[
    {
        "title": "Insert Interval",
        "question_content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n&nbsp;\nConstraints:\n\n\t0 <= intervals.length <= 104\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 105\n\tintervals is sorted by starti in ascending order.\n\tnewInterval.length == 2\n\t0 <= start <= end <= 105",
        "solutions": [
            {
                "id": 21602,
                "title": "short-and-straight-forward-java-solution",
                "content": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 21622,
                "title": "7-lines-3-easy-solutions",
                "content": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "codeTag": "Python3"
            },
            {
                "id": 1327206,
                "title": "99-16-faster-proper-explaination-c-solution-o-n",
                "content": "Here 3 cases will arive:\\n1) ***Non Overlapping intervals before given newInterval*** -> push into the ans vector \\n2) **Overlapping of intervals and newInterval** update new interval \\n   starting point of newInterval will be min of the interval starting point \\n   or starting point of newInterval\\n   Ending point will be the max of interval ending point or newInterval          end point.\\n3) **Non overlapping intervals after the newintervals have been merged** ->    push ito ans vector   \\n   \\n**Time complexity - O(N)** \\n**space complexity - O(1)**\\n\\nAlso, please do not use sorting algo here because we have already provided with sorted list.\\n\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote and comment if have doubt**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21600,
                "title": "short-java-code",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21809,
                "title": "python-o-n-and-o-nlgn-solutions",
                "content": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 959756,
                "title": "java-1ms-easy-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21599,
                "title": "elegant-c-stl-solution-using-equal-range-to-find-overlapped-intervals",
                "content": "    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; };\\n            auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);\\n            auto itr1 = range.first, itr2 = range.second;\\n            if (itr1 == itr2) {\\n                intervals.insert(itr1, newInterval);\\n            } else {\\n                itr2--;\\n                itr2->start = min(newInterval.start, itr1->start);\\n                itr2->end = max(newInterval.end, itr2->end);\\n                intervals.erase(itr1, itr2);\\n            }\\n            return intervals;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; }",
                "codeTag": "Java"
            },
            {
                "id": 477856,
                "title": "beat-99-consice-java-solution",
                "content": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844494,
                "title": "python-o-n-solution-explained",
                "content": "I am not sure, why this problem is marked as hard, because we do not use any smart ideas to solve it: just do what is asked: traverse our intervals and merge them. Let us consider the case: `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]` and go through our code:\\n\\n1. Interval `[1,2]` is before `[4,8]`, that is `y < I[0]`, so we just add it to our `res`.\\n2. Interval `[3,5]` is not before `[4,8]` but not after also, so it is the third case and we need to update `I`: `I = [3,8]` now.\\n3. Interval `[6,7]`: the same logic, update `I = [3,8]` now (it did not change though)\\n4. Interval `[8,10]`: still condition number `3`, so `I = [3,10]` now.\\n5. Interval `[12,16]`: it is after our `I`, so this is condition number `2` and we `break` from our loop: `i = 3` now.\\n6. Outside loop we combine `res = [1,2]`, `I = [3,10]` and `intervals[4:] = [12,16]`.\\n\\nWhy we use `i -= 1` inside our loop, before `break`? It can happen, that we did not visit this part and it means, that our suffix `intervals[i+1:]` should be empty.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(n)` as well and additional space complexity (if we do not count our output) is `O(1)`.\\n\\n**Note**: that intstead of traversing our intervals with linear search, we can use binary search, however it will not reduce the overall complexity of algorithm, our result will have in average `O(n)` elements.\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844523,
                "title": "c-super-clean-clear-short-simple-solution-o-n-time-o-1-space",
                "content": "the main idea is that when iterating over the intervals there are three cases: \\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844549,
                "title": "python-super-short-simple-clean-solution-99-faster",
                "content": "the main idea is that when iterating over the intervals there are three cases:\\n\\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556269,
                "title": "simple-concise-js-solution-w-comments",
                "content": "use ES6 destructuring assignment to make code much more concise and readable.\\n\\n```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844394,
                "title": "python-js-go-c-o-n-by-boundary-checking-w-comment",
                "content": "Python O( n ) by boundary checking\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n\\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955134,
                "title": "java-solution-with-explanation-and-comments",
                "content": "# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code defines a class Solution that contains a method insert which takes in two parameters: an array of intervals represented by a 2D array, and a new interval represented by a 1D array. The method returns a new 2D array containing the merged intervals.\\n\\n2. The approach of this code is to add the intervals that come before the new interval to the answer arraylist, then check if the new interval should be merged with the last interval in the answer arraylist, and finally, add the remaining intervals from the input array to the answer arraylist.\\n\\n3. The code first initializes an empty ArrayList called ans. The variable idx is initialized to 0, and the while loop iterates through the input intervals array. The loop compares the starting value of the current interval with the starting value of the new interval, and if the current interval\\'s starting value is less than the new interval\\'s starting value, it is added to the ans arraylist. If the starting value of the current interval is greater than or equal to the new interval\\'s starting value, the loop breaks. This ensures that the intervals in the ans arraylist will be in the same order as they were in the input array, but with the new interval inserted in the correct position.\\n\\n4. Next, the code checks if the ans arraylist is empty or if the new interval\\'s starting value is greater than the last interval\\'s ending value in the ans arraylist. If either of these conditions is true, the new interval is added to the ans arraylist. Otherwise, the last interval in the ans arraylist is merged with the new interval by updating the last interval\\'s ending value to be the maximum of the last interval\\'s ending value and the new interval\\'s ending value.\\n\\n5. Finally, the while loop iterates through the remaining intervals in the input array. The loop compares the ending value of the last interval in the ans arraylist with the starting value of the current interval. If the last interval\\'s ending value is greater than or equal to the current interval\\'s starting value, it means the two intervals overlap and should be merged. The last interval\\'s ending value is updated to be the maximum of the last interval\\'s ending value and the current interval\\'s ending value. If the last interval\\'s ending value is less than the current interval\\'s starting value, it means the two intervals do not overlap and the current interval is added to the ans arraylist.\\n\\n6. After the while loop, the ans arraylist is converted to a 2D array and returned as the final output.\\n```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21659,
                "title": "my-binary-search-approach-implementation-2ms",
                "content": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3056665,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 21753,
                "title": "o-n-python-solution",
                "content": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 3056559,
                "title": "super-easy-explanation-c-o-n-simple-solution",
                "content": "# **Consider \\uD83D\\uDC4D**\\n```\\n                    Please Upvote If You Find It Helpful.\\n```\\n# Approach\\nThere are 3 cases:\\n1. **Non overlapping intervals before given new interval** push into the res vector.\\n2. In this case check for **overlapping intervals and new interval** and merge then as\\n    Starting point if new interval will be minimun of starting point of intervals or new interval(given)\\n    Ending point of new interval will be the max of ending point of interval or new interval(given)\\n3. **Non overlapping intervals after the new interval** is merged is pushed into the res vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```\\n                                 Give a \\uD83D\\uDC4D\\n```\\nLet\\'s connect on [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n```\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n                                 Give a \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056954,
                "title": "c-java-python-short-crisp-approach",
                "content": "**Approach:**\\n* The approach used is to `first` iterate through the given intervals, and keeping track of the index of the interval where the new `interval` should be inserted such that the intervals remain `sorted`. Then it will `merge` any overlapping intervals with the new interval and update its `start` and `end` times. `Finally`, it will insert the new interval into the correct position in the intervals and `return` the modified intervals.\\n* The `key` idea behind this approach is to maintain the `sorted` order of the intervals, and to `merge` any overlapping intervals with the new interval. \\n* By iterating through the intervals and keeping track of the index where the new interval should be `inserted`, we can ensure that the intervals `remain` sorted, and by merging any `overlapping` intervals with the new interval, we can ensure that the final `output` has no `overlapping` intervals.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\\n**Python:**\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```\\n\\n----\\nThe **Time complexity** is **O(n)** \\nThe **Space complexity** is **O(n)** .\\n\\n----\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21632,
                "title": "very-short-and-easy-to-understand-c-solution",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "solutionTags": [],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "codeTag": "Unknown"
            },
            {
                "id": 21815,
                "title": "two-easy-o-n-c-solutions-with-explanations",
                "content": "By far the best solution I have seen is of `O(n)` time (some solutions claim to be of `O(logn)` turns out to be `O(n)`). One of the simplest ideas is to compare each interval in `intervals` (`intervals[i]`) with `newInterval` and then perform respective operations according to their relationships.\\n\\n 1. If they overlap, merge them to `newInterval`;\\n 2. If `intervals[i]` is to the left of `newInterval`, push `intervals[i]` to the result vector;\\n 3. If `newInterval` is to the left of `intervals[i]`, push `newInterval` and all the remaining intervals (`intervals[i]`, ..., `intervals[n - 1]`) to the result vector.\\n\\nThe code is as follows. \\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }\\n                else newInterval = merge(intervals[i], newInterval);\\n            }\\n            res.push_back(newInterval);\\n            return res;\\n        }\\n    private:\\n        Interval merge(Interval& interval1, Interval& interval2) {\\n            int start = min(interval1.start, interval2.start);\\n            int end = max(interval1.end, interval2.end);\\n            return Interval(start, end);\\n        }\\n    };\\n\\nAnother idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge `newInterval` with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained in` newInterval`.\\n\\nLet's do the example in the problem statement: `intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16]` and `newInterval = [4, 9]`. We first find the rightmost interval with `start` smaller than that of `newInterval`, which is `[3, 5]`. Then we find the leftmost interval with `end` larger than that of `newInterval`, which is `[8, 10]`. Then all the intervals between them will be contained within `newInterval` (you may check this to convince yourself) and so can be safely ignored. We only need to check whether `newInterval` overlaps with the two intervals on the two ends and merge them if necessary.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            int n = intervals.size(), leftEnd, rightEnd, l, r;\\n            vector<Interval> res;\\n            // Find the rightmost interval with start smaller than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].start > newInterval.start)\\n                    r = mid - 1;\\n                else l = mid + 1;\\n            } \\n            leftEnd = r;\\n            // Find the leftmost interval with end larger than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].end < newInterval.end)\\n                    l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            rightEnd = l;\\n            // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary\\n            if (leftEnd >= 0 && intervals[leftEnd].end >= newInterval.start)\\n                newInterval.start = intervals[leftEnd--].start;\\n            if (rightEnd < n && intervals[rightEnd].start <= newInterval.end)\\n                newInterval.end = intervals[rightEnd++].end;\\n            // Save the intervals sequentially\\n            for (int i = 0; i <= leftEnd; i++)\\n                res.push_back(intervals[i]);\\n            res.push_back(newInterval);\\n            for (int i = rightEnd; i < n; i++)\\n                res.push_back(intervals[i]);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3056524,
                "title": "python3-merge-interval-solution-explained-space-complexity-o-n-o-1",
                "content": "**Intuition**\\n\\nThis problem is almost the same as [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) if we first insert ```newInterval``` into ```intervals``` such that ```intervals``` is still sorted by the start time, and then merge overlapped intervals.\\n\\n - use binary search to find the index where ```newInterval``` should be instered into ```intervals```. O(logN)\\n - Insert the ```newInterval```. O(N)\\n - merge overlapped intervals if there are any.\\n    - We can interately build a stack, and merge a new interval with the last interval in the stack if they overlap.\\n    - To check if a new interval is overlap with the last interval in stack, we simply check if the last end is greater than or equal to the new start. If it is, we merge the two intervals by using the last start as the start, and the max(lastEnd, newEnd) as the end.\\n    - If there is no overlap between the new interval and the last interval in stack, we simply add the new interval to the stack.\\n\\n**Solution 1** using stack\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\\n\\nWe don\\'t really need to use a stack, but using the list slicing in Python to merge the overlapped intervals.\\n\\n**Solution 2** inplace merge\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n",
                "solutionTags": [],
                "code": "```newInterval```\n```intervals```\n```intervals```\n```newInterval```\n```intervals```\n```newInterval```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902628,
                "title": "c-optimized-solution-9-lines-beats-95-time",
                "content": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342029,
                "title": "javascript-solution-beats-99-79",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313612,
                "title": "python3-faster-than-99-58-36ms-14-9mb",
                "content": "Python3 - Faster than 99.58% - 36ms & 14.9MB\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298982,
                "title": "javascript-solution-95-fast",
                "content": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845073,
                "title": "python-3-sweep-line-heap-explanations",
                "content": "### Explanation\\n- Typical `Sweep Line` question, use `heap` for help\\n- Mark every start as `-1`, every end as `1`\\n- Sort all start & end points\\n- Close interval only when counter `cur` equals to `0`\\n- Check out below comments for more detail\\n### Implementation\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844719,
                "title": "golang-idiomatic-solution",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2429511,
                "title": "java-explained-solution",
                "content": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388642,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464497,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "Ported to C# from [Java solution](https://leetcode.com/problems/insert-interval/discuss/463417/My-concise-Java-solution-(single-pass-O(n)-3-steps))\\n\\n```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250459,
                "title": "very-simple-javascript-o-n-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221925,
                "title": "java-solution-with-comments-o-n",
                "content": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 685007,
                "title": "python-very-simple-solution-based-on-merge-intervals",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056535,
                "title": "python3-79-ms-faster-than-93-12-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1430986,
                "title": "binary-search-solution",
                "content": "First looking where to insert elements from new interval using binary search (to left of the interval or into the interval itself) - O(log N). Second composing two lists left and right to the new interval. Third merging if start or end falls in between of any interval. Overall worst case still O(N) but binary search helps in cases like new interval consumes all intervals.\\n\\n**Python**\\n```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\\n\\n**Javascript**\\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\\n\\n**Rust**\\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463417,
                "title": "my-concise-java-solution-single-pass-o-n-3-steps-with-explanation",
                "content": "The idea is simple. Since the intervals are already sorted by start time, all we need is one pass from left to right. \\n**3 steps:**\\n1. Add any intervals that finish before the new interval starts.\\n2. Update the new interval by merging it will all overlapping intervals. Add the updated newInterval to result.\\n3. Add remaining intervals to result, and voila!\\n\\nHere\\'s the code\\n```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056859,
                "title": "c-easy-intutive-solution-in-o-nlogn-time-complexity",
                "content": "# Intuition\\nIt is similar to the question [Merge Intervals](https://leetcode.com/problems/merge-intervals/) must try before doing this problem.\\n\\n# Approach\\nInsert the new interval in and then the question becomes same as merge intervals.\\n\\n# Complexity\\n- Time complexity:O(NLogN)\\n\\n- Space complexity:O(2*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*I just did this solution for doing it some other way and i know there exist a O(N) solution too*\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912542,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444764,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 792436,
                "title": "c-one-pass-o-n-solution",
                "content": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056498,
                "title": "c-short-easy-code-with-explanation",
                "content": "# Intuition\\nThe main idea of solving this problem is that when iterate over the intervals, there are three cases:\\n\\n1) the new interval\\'s range is before the range of current interval.\\nExample new interval= {3,4} and current interval= {6,9}\\n\\n2) the new interval is after the range of current interval.\\nExample new interval= {5,7} and current interval= {2,3}\\n3) the new interval range overlaps with the range of current interval.\\nExample interval= {5,9} and new interval= {6,11}\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple iterate through intervals.\\n- If case 1 occurs,ie. The new interval\\'s range is before the current interval, so we can insert the new interval into answer and update new interval to the current interval.\\n- If case 2 occurs,ie. The new interval is after the range of current interval, so we can simply insert the current interval into answer.\\n- If case 3 occurs,ie. The new interval overlaps with current interval, so we update the first element of new interval to the minimum of current interval and new interval and update the second element of new interval to the maximum of current interval and new interval.\\nExample interval= {5,9} and new interval= {6,11}. Then update new interval = {min(5,6),max(9,11)}={5,11}\\n- At the end of iterations simply insert new interval to the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738782,
                "title": "solution-swift-insert-interval-test-cases",
                "content": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844503,
                "title": "c-simple-explained-solution-o-n-time-o-1-space-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21698,
                "title": "java-2ms-o-log-n-o-1-binary-search-solution-beats-97-7-with-clear-explaination",
                "content": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 844481,
                "title": "c-clean-and-commented-with-example-explained-o-n-time",
                "content": "****Explaination****\\n- **1st While loop** to put all intervals that are to the left of the inserted interval. \\n-  **2nd While loop to** merge all intervals that intersect with the inserted interval.\\n-  **3rd While loop** put all intervals that are to the right of the inserted interval.\\n\\n****Example****\\nGiven [1,2],[3,5],[6,7],[8,10],[12,14], insert and merge [4,9] in as [1,2],[3,10],[12,14]\\n![image](https://assets.leetcode.com/users/images/58677d7a-175e-4f97-ab36-44d01d3195e5_1599985042.67296.png)\\n\\n****Code****\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```\\n****Complexity****\\nO(n)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844417,
                "title": "python-simple-explained-solution-o-n-time-o-1-space-faster-than-99",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134823,
                "title": "python-6-lines-easy-to-understand-60-ms-beats-96",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21828,
                "title": "my-ac-java-in-place-solution",
                "content": "    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }\\n            \\n            int start = newInterval.start;\\n            int end = newInterval.end;\\n            ListIterator<Interval> li = intervals.listIterator();\\n            boolean inserted = false;\\n            while(li.hasNext()){\\n                Interval itv = li.next();\\n                if(start <= itv.end){\\n                    if(end < itv.start){ //newInterval does not overlap with current itv, time to insert\\n                        li.remove();\\n                        li.add(new Interval(start, end));\\n                        li.add(itv);\\n                        inserted = true;\\n                        break;\\n                    }\\n                    \\n                    // still some overlap so compare start & end\\n                    start = Math.min(start, itv.start);\\n                    end = Math.max(end, itv.end);\\n                    li.remove();\\n                }\\n            }\\n            \\n            if(!inserted){\\n                intervals.add(new Interval(start, end));\\n            }\\n            \\n            return intervals;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3057760,
                "title": "java-99th-percentile-one-pass-explained-article",
                "content": "![image.png](https://assets.leetcode.com/users/images/79f9f39a-f625-4707-9c7b-dcbb13533e2b_1673854957.9331577.png)\\n\\n\\n# Intuition\\nWe are given a non-overlapping, sorted intervals array. These properties are essential because we can utilize them to solve the problem in one pass.\\n\\nLet\\'s visualize a few possibilities that we may have. Imagine these given intervals:\\n```\\n    [     ] [ ] [  ]\\n```\\nImagine them on an x-axis line.\\n\\nWe may need to insert the following intervals:\\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\\n\\nThese are three situations where we may need to insert a new interval.\\n\\nThe first one overlaps multiple given intervals, the second one doesn\\'t overlap and should be inserted in the beginning, and the last is non-overlapping and should be inserted in the end.\\n\\nWe either need to *merge* the interval with one of the given intervals (or multiple), or insert it.\\n\\n*If we merge an interval, we don\\'t impact the intervals previously added*, because they are sorted. `nextIntervalEnd > previousStart`, which is always true because of non-overlapping sorted property.\\n\\nTherefore we need to merge intervals *until* we find an interval that started after the merged interval.\\n\\nIf the given interval doesn\\'t overlap with the merged interval, we simply add it to the result array.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    [     ] [ ] [  ]\\n```\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643451,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n# Approach\\nThe solution follows the logic of iterating through the intervals to find the correct position to insert the new interval while maintaining the sorted order. After insertion, it iterates over the modified array to merge any overlapping intervals by updating the end time of the previous interval if necessary. Finally, it returns the modified array with the new interval inserted and any overlapping intervals merged.\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056720,
                "title": "java-short-beats-99-26-priorityqueue",
                "content": "# One Pass (Beats 99.26%) : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n# PriorityQueue : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038557,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804462,
                "title": "java-99-solution-one-pass-o-n-with-comments",
                "content": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 703958,
                "title": "javascript-explanation",
                "content": "* append new interval to list of intervals\\n* sort by beg time\\n* then do merge intervals \\n\\n(I know sorting will raise time to O(nlogn) and there are some solutions out there that yield O(n))\\n\\n```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21813,
                "title": "short-simple-o-n-in-place-java-solution-with-explanation",
                "content": "The idea is to look at each interval in the list. If it intersects with newInterval then merge it to newInterval and delete it. In the end add newInterval back to its corresponding place.\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }\\n                if (in.start <= newInterval.end && newInterval.start <= in.end) {\\n                    newInterval.start = Math.min(newInterval.start, in.start);\\n                    newInterval.end = Math.max(newInterval.end, in.end);\\n                    i.previous();\\n                    i.remove();\\n                }\\n            }\\n            i.add(newInterval);\\n            return intervals;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3992539,
                "title": "best-solution-in-c-100-easily-understandable",
                "content": "# Approach\\nExplained in the code using comments\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```\\n\\n![pleaseupvotye.jpeg](https://assets.leetcode.com/users/images/e1cd0d4f-0255-4afa-8f6e-b5fff843647b_1693664013.5913265.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057457,
                "title": "simple-c-beats-99-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all if we think of approach so we can do this by using linear search or Binary search . So we know  Bianry search has logn timpecomplexity but through binary search we find where to insert in logn but we have to merge with others and insert also that will take O(n) so there is no need of binary search we can do a linear serach as well beacuse both will be O(n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nComing to Approach first we can think of many conditions but We only need to check three conditions that are :\\n- Insert those intervals who are not overlapping and are less than our new Interval \\n- Now check if our new Interval is overalpping wiht any other interval(s) so either insert if not overlapping or merge if overallping with others\\n- Now insert those who are left i.e those intervals which are greater than new Interval\\n*These condtions can easily be checked using a while loop*\\nFor second condition when the inertvals are overlapping we can do that by :\\n` (a,b)  and (c,d) the  new interval: [min(a,c),max(b,d)]`\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```\\n**Please upVote If Found HelpFull \\uD83D\\uDD3C**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681746,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581680,
                "title": "python-easy-solution-two-approaches",
                "content": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1506902,
                "title": "java-easy-to-understand-o-n-code-with-comments",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261009,
                "title": "zero-bullshit-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 844384,
                "title": "java-greedily-absorb-overlapping-intervals-o-n-time-o-1-extra-space-explained",
                "content": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 530137,
                "title": "hard-problem-c-easy-solution",
                "content": "Not sure why this problem is marked as Hard, it\\'s on the \\'easy\\' side of Easy.\\n```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395709,
                "title": "beautiful-rust-solution-o-n-0-ms",
                "content": "As straightforward as possible.\\nAvoided most of heap memory allocation in method.\\n\\n```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289422,
                "title": "simple-java-solution-with-new-signature-1ms",
                "content": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21595,
                "title": "c-clean-code",
                "content": "**Steps**\\n1. add all intervals smaller than newitv to the new array\\n2. merge all intervals overlap with newitv, then add the merged interval to the new array;\\n3. add all intervals that is leftover (no overlap) into the new array;\\n```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21776,
                "title": "my-18ms-c-code-with-explanation",
                "content": "        class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        };\\n    \\n        auto less = std::lower_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n    \\n        auto greater = std::upper_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n        //printf(\"The index position: %d %d\\\\n\", less - intervals.begin(), greater - intervals.begin());\\n        std::vector<Interval> answer; \\n    \\n        answer.insert(answer.end(), intervals.begin(), less);\\n        answer.push_back(mergeEqual(less, greater, newInterval));\\n        answer.insert(answer.end(), greater, intervals.end());\\n        return answer;\\n      }\\n    \\n    private:\\n    \\n      // Merge the new interval with an array of intervals, all intervals in the \\n      // array equal with the new interval in terms of the partial order we \\n      // defined.\\n      // In other words all of them are overlapped with the new interval.\\n    \\n      Interval mergeEqual(const std::vector<Interval>::iterator & first, const std::vector<Interval>::iterator & last, const Interval &target){\\n    \\n        Interval answer(target);\\n        if(first < last){\\n          answer = merge(answer, *first);\\n          answer = merge(answer, *(last-1));\\n        }\\n        return answer;\\n      }\\n      // Merge two overlapped intervals.\\n      Interval merge(const Interval & a, const Interval & b) {\\n        return Interval(std::min(a.start, b.start), std::max(a.end, b.end));\\n      }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21844,
                "title": "concise-solution-using-stl",
                "content": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "solutionTags": [],
                "code": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3734438,
                "title": "11-lines-of-clean-and-optimized-code-step-by-step-approach",
                "content": "# Approach:\\nMy approach to solving the problem is as follows:\\n\\n- Initialize an empty array for the left side of the intervals and another empty array for the right side.\\n- Iterate through each interval in the given intervals.\\n- Check if the current interval is completely before the new interval. If so, add it to the left array.\\n- Check if the current interval is completely after the new interval. If so, add it to the right array.\\n- If the current interval overlaps with the new interval, update the new interval\\'s start and end values to cover both intervals.\\n- Finally, combine the left array, the new interval, and the right array to get the result.\\n# Complexity:\\n- Time complexity: The time complexity of this approach is O(n), where n is the number of intervals.\\n- Space complexity: The space complexity is also O(n), where n is the number of intervals.\\n\\n# Code\\n```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467746,
                "title": "awesome-logic-python3",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n````\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248191,
                "title": "easy-java-solution-3ms-solved-using-a-single-loop",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057348,
                "title": "c-same-logic-of-merge-intervals-2-pointers-comments-added",
                "content": "### Merge Interval Problem\\n### https://leetcode.com/problems/merge-intervals/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057029,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ (not considering answer array)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056927,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056577,
                "title": "python-o-n-beats-90-easy",
                "content": "**if you like the solution -- Please vote this code**\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733979,
                "title": "javascript-solution-based-on-merge-intervals",
                "content": "This solution is written based on the solution to **Merge Intervals** https://leetcode.com/problems/merge-intervals/\\n\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319389,
                "title": "python3-1-pass-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096028,
                "title": "python-easy-solution-with-complete-explanation",
                "content": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "codeTag": "Python3"
            },
            {
                "id": 741146,
                "title": "swift-simple-steps-o-n-complexity",
                "content": "Time: O(n), Space: O(n)\\n```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502484,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463679,
                "title": "java-10-lines-o-n-1ms",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689977,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "# Intution & Approach\\n# Use three loops.\\n1.) Insert all the intervals which are strictly lesser than the new Interval.\\n2.)(When the new interval is overlaping) In second loop maintain a start and end variable and find the start point and end point of interval and insert that interval in resultant vector.\\n3.)When the intervals values are strictly greater than the new interval insert all the intervals till end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057287,
                "title": "c-easy-to-understand-beats-75",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057001,
                "title": "c-easy-solution-using-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n**Please Upvote it really Motivates me**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056444,
                "title": "daily-leetcoding-challenge-january-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Linear Search\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2489404,
                "title": "c-easy-and-concise",
                "content": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2435713,
                "title": "c-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271812,
                "title": "python-simplest-solution-with-explanation-beg-to-adv-interval",
                "content": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159738,
                "title": "kotlin-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105125,
                "title": "east-to-understand-c-solution-very-intuitive",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075054,
                "title": "c-easy-o-n",
                "content": "\\n\\n```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680989,
                "title": "easy-faster-than-91-72-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877685,
                "title": "java-solution-with-figures-diagrams-easy-3-step-process-update-with-new-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864312,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602609,
                "title": "simple-python-o-n-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562487,
                "title": "extremely-easy-understanding-java",
                "content": "All the intervals can be classified into three groups:\\n\\n1. non-overlapping interval ends before the `newInterval`\\n2. overlapping intervals\\n2. non-overlapping interval starts after the `newInterval`\\n\\nFor intervals in the first and third group, we don\\'t need to do anything rather than adding them to the result set.\\nFor the second group, we just merge their `startTime` and `endTime`, with our `newInterval`, and add the final merged interval to the result.\\n\\n```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499881,
                "title": "python-two-different-solutions",
                "content": "1. Using two pointers\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\\n\\n2. Use previous solution\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436879,
                "title": "javascript-solution-o-n",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 309024,
                "title": "c-98-beat-o-n-single-pass-looper-lew-pah-luu-purrrrr",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\n$ Dolla Dolla Plz $$ TY",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304135,
                "title": "go-8ms-6-2mb",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279899,
                "title": "java-iteration-new-method-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```\\n\\nintervals[i][0] <= newInterval[1] is the key to create newInterval recursively.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180320,
                "title": "python-easy-solution-beat-100-36ms",
                "content": "I extract all the start time points from intervals to a list, all the end time points to another list. Then make use of binary search to check the position of the newInterval. Once I found out the position ( the overlapping duration), then I replace them with the new interval.\\n```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21676,
                "title": "clean-and-short-java-solution-with-explanation",
                "content": "There are three cases with inserting an interval: \\n\\n 1. the start value of the newInterval < the old interval end:  insert the old interval and increment the index as we will know where this newInterval should be inserted.\\n 2.  the start value of the old interval > newInterval end:  we simply insert the old interval as there is no effect on where the newInterval should be inserted.\\n 3.  Otherwise, we need to merge the interval, simply be getting the min of start and max of end value.\\n\\nIn the end, we insert the newInterval based on the index we get on the fly.\\n\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                } else if(intervals.get(i).start > newInterval.end) {\\n                    res.add(intervals.get(i));\\n                } else {\\n                    newInterval.start = Math.min(intervals.get(i).start, newInterval.start);\\n                    newInterval.end = Math.max(intervals.get(i).end, newInterval.end);\\n                }\\n            }\\n            res.add(index, newInterval);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4077652,
                "title": "optimal-solution-o-n-line-by-line-commented-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929854,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057652,
                "title": "simple-easy-to-understand",
                "content": "# Complexity\n- Time complexity: **O(N)**\n\n- Space complexity: **O(1)** #if we ignore answer list\n\n# Code\n```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```\nIf you have any **doubt** ask me in comments and UpVote, if you like it **:)**",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057584,
                "title": "fastest-python-solution-explained",
                "content": "# Intuition\\nThe intuition is simple we just need to expand the values which come under same component i.e. connected\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the starting index from where potential connection can occur so if ending value of any given interval is greater than equal to newInterval starting value then they can be connected.\\n\\nSimilarly, if ending index of newInterval is greater than equal to starting value of any given interval then they can be also in potential conection. so change index of end pointer to current index\\n\\nFinally if starting pointer(intially st=-1) has not changed at that means newIntwrval is greatest of all. Similarly if end pointer(initially end=-1) has never changed that means it is before the interval pointed by starting pointer(st) \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057502,
                "title": "live-coding-0-ms-and-beats-99-with-video-explanation-in-english-and-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMy approach in ENGLISH\\n\\nhttps://youtu.be/qTTqgwvfBZs\\n\\nIN HINDI\\n\\nhttps://youtu.be/rDGgpi1HUXk\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057466,
                "title": "c-begineer-friendly-easy-understanding-union-find-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BCBBfE0HV_0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sort",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057150,
                "title": "python-solution-using-binary-search-and-simple-merge-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition was to first iterate through the `intervals` and find correct index to insert `newInterval`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this approach I first found the correct index to insert the given interval, and then the key to this question is understanding how to merge the intervals, Thus following are the steps involved in the question:\\n1) find the position where new interval should be inserted based on the end time of the intervals given. (used binary search to optimize time)\\n2) for merging intervals take minimum of ( `intervals[k][0]` and `newInterval[0]` ) and maximum of ( `intervals[k][0]` and `newInterval[0]` )    \\nNote: here `k` is the index found using binary search\\n3) simply store it in new result list and return it.\\n\\nThis approach is quite fast:\\n![asdasd.PNG](https://assets.leetcode.com/users/images/91b1baa7-3f3b-40a4-9895-ea2e219b3134_1673846919.1683147.png)\\n\\n\\nHope it Helps!!\\n\\n# Code\\n```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845908,
                "title": "java-solution-with-simple-explanation",
                "content": "### Simulation\\n\\nIdea: We just need to deal with the insert interval, the intervals outside the range of insert interval, we just put it in the list. For those intervals within the range of insert interval, we need to merge them together.\\n\\n```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```\\n\\nComplexity Analysis:\\n\\n- Time Complexity: $O(n)$. $n$ is the length of intervals.\\n- Space Complexity: $O(1)$. We only use extra space for variables.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710112,
                "title": "java-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for result array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587472,
                "title": "c-clean-and-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/25238441-3aa0-4ea3-a549-39e8e6ae2ad3_1663422186.4353445.png)\\n\\n\\nThis solution is very easy and begginer friendly.\\n\\nExplanation :\\n\\nI have used two for loops one for inserting the newInterval and the second loop for merging intervals.\\n\\nI have also added 2 edge cases(it is self explanatory)\\n\\nThis is my Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\nIt takes only 1 sec to Upvote!!!\\nThanks in advance.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576902,
                "title": "c-easiest-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563315,
                "title": "python-2-different-solutions-with-explanation",
                "content": "# Approach 1: O(nlogn)\\nThis is exactly the same thing as the problem **[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)**, except at the beginning of the we append the new interval into the list.\\n\\nIn the for loop, we check if the intervals are overlapping or not (whether the last interval in the resultant list\\'s end time is greater than the start time of the new interval). If they overlap, we merge them by setting the last interval in the resultant list\\'s end time to be the maximum of the 2 intervals.\\n```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\\n\\n# Approach 2: O(n)\\nWe cover the 3 basic scenarios:\\n1. The current interval is before the interval we want to add (we just add the current interval)\\n2. The current interval is after the one we want to add (we add the new interval, and update the new interval since it\\'s now added already)\\n3. The intervals overlap (we merge them, and update the new interval. NO ADDING YET)\\n\\n\\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058154,
                "title": "java-simple-solution-with-explanation",
                "content": "Check below solution with explanation\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval};\\n\\n\\t\\t\\t// define start and end\\n\\t\\t\\tint start  = newInterval[0];\\n\\t\\t\\tint end  = newInterval[1];\\n\\n\\t\\t\\tList<int[]> output = new ArrayList<>();\\n\\n\\t\\t\\t// to insert any interval in sorted array we need to find the place where it needs to be added\\n\\t\\t\\t// to do that we will first add all intervals in output list which has end less than new interval\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < intervals.length && intervals[i][1] < start){\\n\\t\\t\\t\\toutput.add(new int[]{intervals[i][0],intervals[i][1]});\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// once we found the place where new interval should be added using above while loop we will use same logic as merge interval\\n\\t\\t\\t// we will compare new interval and current interval. If merging needed we will merge and add it in the list. \\n\\t\\t\\twhile(i < intervals.length){\\n\\t\\t\\t\\tif(intervals[i][0] <= end){\\n\\t\\t\\t\\t\\tstart = Math.min(start, intervals[i][0]);\\n\\t\\t\\t\\t\\tend = Math.max(end, intervals[i][1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\toutput.add(new int[]{start,end});\\n\\t\\t\\t\\t\\tstart = intervals[i][0];\\n\\t\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add last remaining interval\\n\\t\\t\\toutput.add(new int[]{start, end});\\n\\n\\t\\t\\t// convert list to 2d array\\n\\t\\t\\tint[][] insertInterval = output.toArray(new int[output.size()][]);\\n\\n\\t\\t\\t// return\\n\\t\\t\\treturn insertInterval;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval}",
                "codeTag": "Java"
            },
            {
                "id": 1742085,
                "title": "c-easy-and-convivence",
                "content": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721591,
                "title": "c-visualized-explanation-and-analytics-99-faster-and-clean",
                "content": "**Method 1: Straightforward**\\n\\n```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\\n\\n\\nThere are 8 possible relationships between interval and newInterval.\\n\\n**Goal: \\n1 and 8 are easy, so we have to focus on overlapping (2-7)!**\\n\\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\\n\\nThe algorithm will fail if the newInterval is non-overlapping and last interval,\\nso if `index` is default value (-1), we push back newInterval.\\n\\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\nTime Complexity: O(n), where n is the size of intervals\\nSpace Complexity: O(n)\\nRuntime: 7 ms, faster than 99.17% of C++ online submissions for Insert Interval.\\nMemory Usage: 17.2 MB, less than 40.83% of C++ online submissions for Insert Interval.\\n\\n\\n**Method 2: Clean Version**\\nby reusing the newInterval but more runtime\\n\\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```\\nRuntime: 8 ms, faster than 98.95% of C++ online submissions for Insert Interval.\\nMemory Usage: 16.9 MB, less than 99.47% of C++ online submissions for Insert Interval.\\n\\n**If you have any suggestion or advice, feel free to contact me!**\\n",
                "solutionTags": [],
                "code": "```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515974,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451390,
                "title": "interval-simple-solution-o-n-time-c",
                "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        while(i <n && intervals[i][0]<=ni[1])\\n        {\\n            ni[0]=Math.min(intervals[i][0],ni[0]);\\n            ni[1]=Math.max(intervals[i][1],ni[1]);\\n            i++;\\n        }\\n        \\n        res.add(ni);\\n        \\n        while(i<n)\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1441307,
                "title": "python3-o-n-concise-solution-99-9-binary-search-merge-intervals",
                "content": "**Explanation**\\nSince the given intervals is already in sorted order, we can use binary search to find the insertion point. Then, merge the interval if necessary.\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347799,
                "title": "java-solution-easy-to-understand",
                "content": "**Runtime: 1 ms\\nMemory Usage: 41.4 MB**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295056,
                "title": "javascript-very-easy-to-understand",
                "content": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239530,
                "title": "first-attempt-efficient-solution",
                "content": "First Attempt, which is O(n)\\n```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nThis can be solved in one single pass\\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166865,
                "title": "python-easy-o-n",
                "content": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "solutionTags": [],
                "code": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140661,
                "title": "java-1ms-99-faster",
                "content": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947241,
                "title": "python3-simple-easy-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844488,
                "title": "python-3-o-n-insert-intervals-easy-math-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 790477,
                "title": "python-binary-search-o-n-time-o-1-space",
                "content": "Hello,\\n\\nHere are my two solutions. The analysis follows. \\n\\t- Solution 1: `\\u0398(n)`time and `O(1)` space\\n\\t- Solution 2: `O(logn)`best time,`O(n)`worst time and`O(n)`space: see Complexity Analsysis below.\\n\\n- **Intuition**:\\n\\t\\t\\t\\n\\t\\t\\t- Binary Search : find the intervals new_interval overlap with : insert_start=i, insert_end=j :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                     |--------------|\\n\\t\\t\\t\\n\\t\\t\\t- Update new_interval :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                  |----------------------|\\n\\t\\t\\t\\n\\t\\t\\t- Return [0 : i[ + new_interval + ]j : n] :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |---0---| ... |--i-1--||----------------------||--j+1--|  ... |---n---| \\n\\n- **Implementation**:\\n\\n```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\\n\\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```\\n\\n- **Complexity Analysis**:\\n\\t- Let\\'s `n` be the length of the input list `intervals`\\n\\t- Let\\'s `m` be the length of the output list\\n\\t- Solution 1:\\n\\t\\t- The input is modified and returned\\n\\t\\t- Space Complexity: `O(1)` \\n\\t\\t- Time Complexity: `O(n)`\\n\\t\\t- It requires to delete from`intervals`all overlapping intervals\\n\\t- Solution 2:\\n\\t\\t- A new list is returned\\n\\t\\t- Space Complexity:`O(m)` \\n\\t\\t- Time Complexity:`\\u0398(max(logn, m)) = O(n)`(here `n` is an upper-bound only)\\n\\t\\t- The worst case time complexity is`O(n)`: happens for example when`new_interval`doesn\\'t overlap with`intervals`\\n\\t\\t- The best case time complexity is`O(logn)`: happens for example when`new_interval`overlaps whith the majority of`intervals`, more than`n - logn`\\n\\t\\t- In practice, this solution is faster than solution 1\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 637718,
                "title": "java-o-n-clean-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442034,
                "title": "clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369471,
                "title": "easy-python-solution-insert-and-merge-in-place",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 304030,
                "title": "1ms-simple-java-solution-explained",
                "content": "The principle of this solution is to merge overlapping intervals inside the new one (if needed).\\nThen, the new interval is inserted inside the list only once at the right place.\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t} else if (interval[0] > newInterval[1]) { // Non-overlapping to the right\\n\\t\\t\\t\\t\\tif (!added) {                          // Add the new interval only once\\n\\t\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tresult.add(interval);\\n\\t\\t\\t\\t} else {                                   // Overlapping, update the new interval\\n\\t\\t\\t\\t\\tnewInterval[0] = Math.min(newInterval[0], interval[0]);\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!added) { // Only happens if newInterval is last\\n\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t}\\n\\t\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 245084,
                "title": "super-simple-golang-solution-8ms-beats-100",
                "content": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21613,
                "title": "my-java-solution-pretty-simple-with-one-treemap",
                "content": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21733,
                "title": "a-very-short-c-solution-with-o-logn-search-is-it-clear-enough",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "codeTag": "Unknown"
            },
            {
                "id": 21793,
                "title": "easy-java-solution",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21702,
                "title": "c-code-use-binary-search",
                "content": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21810,
                "title": "in-place-solution-ask-for-suggestion",
                "content": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [],
                "code": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4018688,
                "title": "insert-interval-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795785,
                "title": "very-easy-brute-force-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781818,
                "title": "simple-python-solution-using-insort",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766731,
                "title": "simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492665,
                "title": "simplest-solution-easy-to-understand-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbreak a problem into parts\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nvector processing\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434453,
                "title": "absolutely-clear-and-simple-python-solution-o-n-beats-over-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need modify intervals when an old interval intersect with new interval, that say in this 2 situations:\\n1. left value of old interval <= right value of new interval\\n2. right value of old interval >= left value of new interval\\n\\nBesides upon 2 situation, we just put old intervals into solutions.\\nHowever, in other cases, we would expand new interval.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nA little thing we sholud pay attention, is whether we met the intersection or not. So I use a variable \\'meet\\' to record it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```\\n\\nIt\\'s my first post, UPVOTE this if you like :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429077,
                "title": "java-solution-beats-100-o-n",
                "content": "\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142437,
                "title": "easy-python-solution-with-linear-time-complexity-100-working",
                "content": "\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060958,
                "title": "linear-explained-python3-beats-92-javascript-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intervals are sorted.\\nThere are intervals coming strictly before, after, and intersecting the new interval\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Partition the input intervals into three categories:\\n   - preceeding the new interval\\n   - intersecting the new interval, thus merged into one interval\\n   - following the new interval\\n2. Return these joined interval categories\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$, the space for the resulting intervals is not counted\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Python 3\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\\n## JavaScript\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060893,
                "title": "c-solution-easy-and-simple-explanation-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere Three cases we have to consider \\nCase 1. Insert all the intervals that are non overlapping with the gievn newinterval.\\nCase 2. On finding the overlapping interval merge all the overlappig intervals.\\nCase 3. Insert all the remaining intervals after the overlapping intervals. \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760727,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1868788,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1762258,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1574365,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1948131,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1761687,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 2062287,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760761,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760076,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1568879,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1944081,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760929,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760840,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760409,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759971,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759916,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759732,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759731,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1571142,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760371,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 2069722,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2067271,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2051636,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2045374,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2042915,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2039965,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2033587,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2028140,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2011437,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1963552,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1957718,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1954453,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1947263,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1944702,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1941307,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1935767,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1933469,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1921887,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1919335,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1906710,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1905777,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1904235,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1863143,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1832801,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1820519,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1804316,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1801891,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1792060,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1778869,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1766824,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1761800,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761074,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761047,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761039,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760766,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760764,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760746,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760741,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760739,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760738,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760706,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760696,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760675,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760640,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760615,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760579,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760572,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760503,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760476,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760462,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760439,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760396,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760374,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760368,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760298,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760264,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760221,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760218,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760194,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760172,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760159,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760145,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760138,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760100,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760049,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759898,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759890,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759840,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759803,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759802,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            }
        ]
    },
    {
        "title": "Read N Characters Given Read4",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566981,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1570390,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1711494,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1568437,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1781628,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1567532,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1778199,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1773425,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1566981,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1570390,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1711494,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1568437,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1781628,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1567532,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1778199,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            },
            {
                "id": 1773425,
                "content": [
                    {
                        "username": "skooter_go_fast",
                        "content": "I just want to explain the question so that people can try this on their own.\\n\\nQuestion: read4 reads 4 characters from file and copies them to the buffer that is passed to it. you need to store n number of characters from the file into the buffer that is passed to you in the function read. If n is greater than the file characters size then store only the file characters size. If n is lesser than or equal then store the n characters and not the entire file size."
                    },
                    {
                        "username": "buzzzed",
                        "content": "How ever you implement the solution, the interviewer will most likely have you prove that each of these scenarios is handled.\\nI have seen this question in 2 FAANG interviews.\\n\\nCases:\\n1.   We read more bytes than we need\\n2.   Read4 returns less than 4 indicating end of file\\n2b. Read4 returns less than 4 indicating end of file but it is more than we need\\n3.   We read 4 and we need more"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Garbage description, buggy implementation. In python at least, it is VERY poorly explained how one calls the read4 method/API. Simply assuming \"its out there somewhere\" and using read4(buf4) crashes the debugger. Hints tell you that read4 is undefined. But RUN the code and it works fine... somehow. Its awful. \n\nAs shown, it should not function. Where is read4 defined and how are we accessing it? \"Just trust its there and use it as if it makes sense\" is a garbage way to go about asking this question. Also, the python definition gives you args for your read method with no explanation. Why is it passing me a buffer? Im not even supposed to bother reading the chars into anywhere useful. Literally doesnt matter whats being read where, we only care about the returned number of chars read\n\nIts not even clear what its asking for: \"return the number of chars read\". Well if we fall short of n, then we simply return the sum of the numbers returned when calling read4. What about when n is less than a multiple of 4? What counts as reading a char? read4 will pass back 4 so long as there are enough characters, if n = 9 we will need to call read4 3 times. Now for the answer, did we \"read\" 9 or did we \"read\" 12?\n\nThe problem itself is simple. The given code is crap. This should be rewritten or removed"
                    },
                    {
                        "username": "analystsattu",
                        "content": "Where and how are supposed to access the file?\\nThe inputs to the function are -> an empty destination buffer and an integer \\'n\\', where is the is input file and how to access it?\\n\\nThanks"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This question makes absolutely no sense. I should not have to look at the solution to understand the problem. Please Leetcode, fix your descriptions"
                    },
                    {
                        "username": "MaanavS",
                        "content": "on jahseh"
                    },
                    {
                        "username": "kartavyakothari",
                        "content": "HI everyone!\\n\\nI am one of the people who is maintaining his daily challenge streak since the month it first began. First of all it has improved my coding skills a lot and I love leet code specefically as it goes straight to the problem without unnecessesary  strories. This helps begginers.\\n\\nNow about a general trend I saw. This month\\'s challenges have gotten tougher right from day 1. This was inevitable as leetcode cant reuse probelms from previous months and now tougher problems have to come as easier ones were asked already in previsous challenges. This has one disadvantage that it is no longer a begginer friendly challenge. \\n\\nTherefore, to all the people who are joining the challenge series from this month, I would request you to go solve the previous month\\'s challenges to gain confidence and learn the skills improtant to perform in this one.\\n\\nAll the best people!"
                    },
                    {
                        "username": "hrhxs",
                        "content": "This is the first question I try in the \"LeetCode Curated Algo 170\". The question is very poorly written and confuses me. Besides, in a real interview, how can a question contain such detailed explanation including graphs and test cases? And you don't expect C++ programmer to deal with C string. This is just poor quality."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Most of the solutions are incorrect. Even the official solution is incorrect. I uploaded my solution which seems to be correct. Note that we need to use at the next read when there are remaining chracters in buf4. https://leetcode.com/problems/read-n-characters-given-read4/solutions/3096112/python-accepted-multiple-reads/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Paths",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5]\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [&quot;1&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 68258,
                "title": "accepted-java-simple-solution-in-8-lines",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> answer = new ArrayList<String>();\\n        if (root != null) searchBT(root, \"\", answer);\\n        return answer;\\n    }\\n    private void searchBT(TreeNode root, String path, List<String> answer) {\\n        if (root.left == null && root.right == null) answer.add(path + root.val);\\n        if (root.left != null) searchBT(root.left, path + root.val + \"->\", answer);\\n        if (root.right != null) searchBT(root.right, path + root.val + \"->\", answer);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> answer = new ArrayList<String>();\\n        if (root != null) searchBT(root, \"\", answer);\\n        return answer;\\n    }\\n    private void searchBT(TreeNode root, String path, List<String> answer) {\\n        if (root.left == null && root.right == null) answer.add(path + root.val);\\n        if (root.left != null) searchBT(root.left, path + root.val + \"->\", answer);\\n        if (root.right != null) searchBT(root.right, path + root.val + \"->\", answer);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68270,
                "title": "c-simple-4ms-recursive-solution",
                "content": "    void binaryTreePaths(vector<string>& result, TreeNode* root, string t) {\\n        if(!root->left && !root->right) {\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        if(root->left) binaryTreePaths(result, root->left, t + \"->\" + to_string(root->left->val));\\n        if(root->right) binaryTreePaths(result, root->right, t + \"->\" + to_string(root->right->val));\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        if(!root) return result;\\n        \\n        binaryTreePaths(result, root, to_string(root->val));\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    void binaryTreePaths(vector<string>& result, TreeNode* root, string t) {\\n        if(!root->left && !root->right) {\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        if(root->left) binaryTreePaths(result, root->left, t + \"->\" + to_string(root->left->val));\\n        if(root->right) binaryTreePaths(result, root->right, t + \"->\" + to_string(root->right->val));\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        if(!root) return result;\\n        \\n        binaryTreePaths(result, root, to_string(root->val));\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68272,
                "title": "python-solutions-dfs-stack-bfs-queue-dfs-recursively",
                "content": "```\\n        \\n    # dfs + stack\\n    def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # bfs + queue\\n    def binaryTreePaths2(self, root):\\n        if not root:\\n            return []\\n        res, queue = [], collections.deque([(root, \"\")])\\n        while queue:\\n            node, ls = queue.popleft()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.left:\\n                queue.append((node.left, ls+str(node.val)+\"->\"))\\n            if node.right:\\n                queue.append((node.right, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # dfs recursively\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, root, ls, res):\\n        if not root.left and not root.right:\\n            res.append(ls+str(root.val))\\n        if root.left:\\n            self.dfs(root.left, ls+str(root.val)+\"->\", res)\\n        if root.right:\\n            self.dfs(root.right, ls+str(root.val)+\"->\", res)\\n\\t\\t\\t\\n    def binaryTreePaths1(self, root):\\n        return self.dfs(root, \"\")\\n    \\n    def dfs(self, root, path):\\n        if not root:\\n            return []\\n        path += str(root.val)\\n        if not root.left and not root.right:\\n            return [path]\\n        path += \"->\"\\n        return self.dfs(root.left, path) + self.dfs(root.right, path)\\n    \\n    def binaryTreePaths(self, root): # inorder\\n        stack, ret = [(root, \"\")], []\\n        while stack:\\n            node, path = stack.pop()\\n            if node:\\n                if not node.left and not node.right:\\n                    ret.append(path+str(node.val))\\n                s = path + str(node.val) + \"->\"\\n                stack.append((node.right, s))\\n                stack.append((node.left, s))    \\n        return ret\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n        \\n    # dfs + stack\\n    def binaryTreePaths1(self, root):\\n        if not root:\\n            return []\\n        res, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.right:\\n                stack.append((node.right, ls+str(node.val)+\"->\"))\\n            if node.left:\\n                stack.append((node.left, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # bfs + queue\\n    def binaryTreePaths2(self, root):\\n        if not root:\\n            return []\\n        res, queue = [], collections.deque([(root, \"\")])\\n        while queue:\\n            node, ls = queue.popleft()\\n            if not node.left and not node.right:\\n                res.append(ls+str(node.val))\\n            if node.left:\\n                queue.append((node.left, ls+str(node.val)+\"->\"))\\n            if node.right:\\n                queue.append((node.right, ls+str(node.val)+\"->\"))\\n        return res\\n        \\n    # dfs recursively\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, root, ls, res):\\n        if not root.left and not root.right:\\n            res.append(ls+str(root.val))\\n        if root.left:\\n            self.dfs(root.left, ls+str(root.val)+\"->\", res)\\n        if root.right:\\n            self.dfs(root.right, ls+str(root.val)+\"->\", res)\\n\\t\\t\\t\\n    def binaryTreePaths1(self, root):\\n        return self.dfs(root, \"\")\\n    \\n    def dfs(self, root, path):\\n        if not root:\\n            return []\\n        path += str(root.val)\\n        if not root.left and not root.right:\\n            return [path]\\n        path += \"->\"\\n        return self.dfs(root.left, path) + self.dfs(root.right, path)\\n    \\n    def binaryTreePaths(self, root): # inorder\\n        stack, ret = [(root, \"\")], []\\n        while stack:\\n            node, path = stack.pop()\\n            if node:\\n                if not node.left and not node.right:\\n                    ret.append(path+str(node.val))\\n                s = path + str(node.val) + \"->\"\\n                stack.append((node.right, s))\\n                stack.append((node.left, s))    \\n        return ret\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 68278,
                "title": "my-java-solution-in-dfs-bfs-recursion",
                "content": "recursion:\\n\\n    public class Solution {\\n    //Recursion\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> sList=new LinkedList<String>();\\n        //String s=new String();\\n        if (root==null) return sList;\\n        if (root.left==null && root.right==null) {\\n            sList.add(Integer.toString(root.val));\\n            return sList;\\n        }\\n        \\n        for (String s: binaryTreePaths(root.left)) {\\n            sList.add(Integer.toString(root.val)+\"->\"+s);\\n        }\\n        for (String s: binaryTreePaths(root.right)) {\\n            sList.add(Integer.toString(root.val)+\"->\"+s);\\n        }\\n        return sList;\\n    }\\n}\\n\\nBFS  - queue\\n\\n    public class Solution {\\n    //BFS - Queue\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list=new ArrayList<String>();\\n        Queue<TreeNode> qNode=new LinkedList<TreeNode>();\\n        Queue<String> qStr=new LinkedList<String>();\\n        \\n        if (root==null) return list;\\n        qNode.add(root);\\n        qStr.add(\"\");\\n        while(!qNode.isEmpty()) {\\n            TreeNode curNode=qNode.remove();\\n            String curStr=qStr.remove();\\n            \\n            if (curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);\\n            if (curNode.left!=null) {\\n                qNode.add(curNode.left);\\n                qStr.add(curStr+curNode.val+\"->\");\\n            }\\n            if (curNode.right!=null) {\\n                qNode.add(curNode.right);\\n                qStr.add(curStr+curNode.val+\"->\");\\n            }\\n        }\\n        return list;\\n    }\\n    \\nDFS - stack\\n\\n    public class Solution {\\n    //DFS - Stack\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list=new ArrayList<String>();\\n        Stack<TreeNode> sNode=new Stack<TreeNode>();\\n        Stack<String> sStr=new Stack<String>();\\n        \\n        if(root==null) return list;\\n        sNode.push(root);\\n        sStr.push(\"\");\\n        while(!sNode.isEmpty()) {\\n            TreeNode curNode=sNode.pop();\\n            String curStr=sStr.pop();\\n            \\n            if(curNode.left==null && curNode.right==null) list.add(curStr+curNode.val);\\n            if(curNode.left!=null) {\\n                sNode.push(curNode.left);\\n                sStr.push(curStr+curNode.val+\"->\");\\n            }\\n            if(curNode.right!=null) {\\n                sNode.push(curNode.right);\\n                sStr.push(curStr+curNode.val+\"->\");\\n            }\\n        }\\n        return list;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    //Recursion\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> sList=new LinkedList<String>();\\n        //String s=new String();\\n        if (root==null) return sList;\\n        if (root.left==null && root.right==null) {\\n            sList.add(Integer.toString(root.val));\\n            return sList;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68282,
                "title": "clean-java-solution-accepted-without-any-helper-recursive-function",
                "content": "Lot of recursive solutions on this forum involves creating a helper recursive function with added parameters. The added parameter which usually is of the type List<String> , carries the supplementary path information. However, the approach below doesn't use such a helper function.\\n\\n\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n            \\n            List<String> paths = new LinkedList<>();\\n    \\n            if(root == null) return paths;\\n            \\n            if(root.left == null && root.right == null){\\n                paths.add(root.val+\"\");\\n                return paths;\\n            }\\n    \\n             for (String path : binaryTreePaths(root.left)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             for (String path : binaryTreePaths(root.right)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             return paths;\\n            \\n        }",
                "solutionTags": [],
                "code": "Lot of recursive solutions on this forum involves creating a helper recursive function with added parameters. The added parameter which usually is of the type List<String> , carries the supplementary path information. However, the approach below doesn't use such a helper function.\\n\\n\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n            \\n            List<String> paths = new LinkedList<>();\\n    \\n            if(root == null) return paths;\\n            \\n            if(root.left == null && root.right == null){\\n                paths.add(root.val+\"\");\\n                return paths;\\n            }\\n    \\n             for (String path : binaryTreePaths(root.left)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             for (String path : binaryTreePaths(root.right)) {\\n                 paths.add(root.val + \"->\" + path);\\n             }\\n    \\n             return paths;\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 671194,
                "title": "c-using-recursion-short-and-easy-to-understand",
                "content": "***Pls upvote if you find this helpful  :)***\\nThe basic idea is to traverse the tree keeping the path in the string **curr** and when you find a leaf then substituting curr in the answer.We need vector **answer** to be same in all the calls in the call stack, therefore we use address operator while we need separate curr for each step,hence not using address operator.\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<string>& answer,string curr){\\n        if(!root)return;\\n        if(root->left||root->right)curr+=(to_string(root->val)+\"->\");\\n        else{\\n            curr+=(to_string(root->val));\\n            answer.push_back(curr);\\n        }\\n        helper(root->left,answer,curr);\\n        helper(root->right,answer,curr);  \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> answer;\\n        string curr=\"\";\\n        helper(root,answer,curr);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,vector<string>& answer,string curr){\\n        if(!root)return;\\n        if(root->left||root->right)curr+=(to_string(root->val)+\"->\");\\n        else{\\n            curr+=(to_string(root->val));\\n            answer.push_back(curr);\\n        }\\n        helper(root->left,answer,curr);\\n        helper(root->right,answer,curr);  \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> answer;\\n        string curr=\"\";\\n        helper(root,answer,curr);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68287,
                "title": "5-lines-recursive-python",
                "content": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        return [str(root.val) + '->' + path\\n                for kid in (root.left, root.right) if kid\\n                for path in self.binaryTreePaths(kid)] or [str(root.val)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        return [str(root.val) + '->' + path\\n                for kid in (root.left, root.right) if kid\\n                for path in self.binaryTreePaths(kid)] or [str(root.val)]",
                "codeTag": "Python3"
            },
            {
                "id": 68265,
                "title": "java-solution-using-stringbuilder-instead-of-string-manipulation",
                "content": "\\n\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rst = new ArrayList<String>();\\n            if(root == null) return rst;\\n            StringBuilder sb = new StringBuilder();\\n            helper(rst, sb, root);\\n            return rst;\\n        }\\n        \\n        public void helper(List<String> rst, StringBuilder sb, TreeNode root){\\n            if(root == null) return;\\n            int tmp = sb.length();\\n            if(root.left == null && root.right == null){\\n                sb.append(root.val);\\n                rst.add(sb.toString());\\n                sb.delete(tmp , sb.length());\\n                return;\\n            }\\n            sb.append(root.val + \"->\");\\n            helper(rst, sb, root.left);\\n            helper(rst, sb, root.right);\\n            sb.delete(tmp , sb.length());\\n            return;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rst = new ArrayList<String>();\\n            if(root == null) return rst;\\n            StringBuilder sb = new StringBuilder();\\n            helper(rst, sb, root);\\n            return rst;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68279,
                "title": "c-non-recursive-version-and-recursive-version",
                "content": "    /*\\n    follow up: non-recursive version\\n    */\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            stack<TreeNode*> s;\\n            stack<string> pathStack;\\n            s.push(root);\\n            pathStack.push(to_string(root->val));\\n            \\n            while (!s.empty()) {\\n                TreeNode * curNode = s.top(); s.pop();\\n                string tmpPath = pathStack.top(); pathStack.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(tmpPath); continue;\\n                }\\n                \\n                if (curNode->left != NULL) {\\n                    s.push(curNode->left);\\n                    pathStack.push(tmpPath + \"->\" + to_string(curNode->left->val));\\n                }\\n                \\n                if (curNode->right != NULL) {\\n                    s.push(curNode->right);\\n                    pathStack.push(tmpPath + \"->\" + to_string(curNode->right->val));\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };\\n    \\n    //recursive version\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            dfs(root, to_string(root->val), res);\\n            return res;\\n        }\\n        \\n        void dfs(TreeNode* root, string path, vector<string>& res) {\\n            if (root->left == NULL && root->right == NULL) {\\n                res.push_back(path);\\n            }\\n            \\n            if (root->left != NULL)\\n                dfs(root->left, path + \"->\" + to_string(root->left->val), res);\\n            \\n            if (root->right != NULL)\\n                dfs(root->right, path + \"->\" + to_string(root->right->val), res);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            stack<TreeNode*> s;\\n            stack<string> pathStack;\\n            s.push(root);\\n            pathStack.push(to_string(root->val));\\n            \\n            while (!s.empty()) {\\n                TreeNode * curNode = s.top(); s.pop();\\n                string tmpPath = pathStack.top(); pathStack.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(tmpPath); continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 68507,
                "title": "8-lines-in-python-48ms",
                "content": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n        treepaths = [str(root.val)+'->'+path for path in self.binaryTreePaths(root.left)]\\n        treepaths += [str(root.val)+'->'+path for path in self.binaryTreePaths(root.right)]\\n        return treepaths",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n        treepaths = [str(root.val)+'->'+path for path in self.binaryTreePaths(root.left)]\\n        treepaths += [str(root.val)+'->'+path for path in self.binaryTreePaths(root.right)]\\n        return treepaths",
                "codeTag": "Python3"
            },
            {
                "id": 68477,
                "title": "my-concise-java-dfs-solution",
                "content": "**Explanation**\\n\\nThis is just a classic problem to use depth first search algorithm.\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<String> res = new ArrayList<String>();        \\n        DFS(root, \"\", res);\\n        return res;        \\n    }\\n    \\t\\n    public void DFS(TreeNode root, String solution, ArrayList<String> res) {\\n    \\tif (root == null) return;    \\t\\n    \\tif (root.left==null && root.right==null) res.add(solution + root.val);\\n    \\tDFS(root.left, solution + root.val + \"->\", res);    \\t\\n    \\tDFS(root.right, solution + root.val + \"->\", res);    \\t    \\t\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThis is just a classic problem to use depth first search algorithm.\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<String> res = new ArrayList<String>();        \\n        DFS(root, \"\", res);\\n        return res;        \\n    }\\n    \\t\\n    public void DFS(TreeNode root, String solution, ArrayList<String> res) {\\n    \\tif (root == null) return;    \\t\\n    \\tif (root.left==null && root.right==null) res.add(solution + root.val);\\n    \\tDFS(root.left, solution + root.val + \"->\", res);    \\t\\n    \\tDFS(root.right, solution + root.val + \"->\", res);    \\t    \\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 68424,
                "title": "java-2ms-solution-using-stringbuilder",
                "content": "The time complexity for the problem should be O(n), since we are basically visiting each node in the tree. Yet an interviewer might ask you for further optimization when he or she saw a string concatenation. A string concatenation is just too costly. A StringBuilder can be used although a bit tricky since it is not immutable like string is.\\n\\nWhen using StringBuilder, We can just keep track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back. Another trick is when to append the \"->\", since we don't need the last arrow at the end of the string, we only append it before recurse to the next level of the tree. Hope the solution helps!\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        helper(res, root, sb);\\n        return res;\\n    }\\n\\n    private void helper(List<String> res, TreeNode root, StringBuilder sb) {\\n        if(root == null) {\\n            return;\\n        }\\n        int len = sb.length();\\n        sb.append(root.val);\\n        if(root.left == null && root.right == null) {\\n            res.add(sb.toString());\\n        } else {\\n            sb.append(\"->\");\\n            helper(res, root.left, sb);\\n            helper(res, root.right, sb);\\n        }\\n        sb.setLength(len);\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "The time complexity for the problem should be O(n), since we are basically visiting each node in the tree. Yet an interviewer might ask you for further optimization when he or she saw a string concatenation. A string concatenation is just too costly. A StringBuilder can be used although a bit tricky since it is not immutable like string is.\\n\\nWhen using StringBuilder, We can just keep track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back. Another trick is when to append the \"->\", since we don't need the last arrow at the end of the string, we only append it before recurse to the next level of the tree. Hope the solution helps!\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        helper(res, root, sb);\\n        return res;\\n    }\\n\\n    private void helper(List<String> res, TreeNode root, StringBuilder sb) {\\n        if(root == null) {\\n            return;\\n        }\\n        int len = sb.length();\\n        sb.append(root.val);\\n        if(root.left == null && root.right == null) {\\n            res.add(sb.toString());\\n        } else {\\n            sb.append(\"->\");\\n            helper(res, root.left, sb);\\n            helper(res, root.right, sb);\\n        }\\n        sb.setLength(len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 328264,
                "title": "simple-javascript-solution-with-explanation",
                "content": "This code does not pass around data within function parameters and is recursive with no helper functions.\\n\\n```\\nvar binaryTreePaths = function(root) {\\n\\t// If null return an empty array\\n    if (root === null) return [];\\n\\t// If no children return the nodes value itself as a string within an array\\n    else if (root.left === null && root.right === null) return [`${root.val}`];\\n    else {\\n\\t\\t// For all child paths add the root to their head one by one.\\n        let left = binaryTreePaths(root.left).map(x => root.val + \\'->\\' + x);\\n        let right = binaryTreePaths(root.right).map(x => root.val + \\'->\\' + x);\\n\\t\\t\\n\\t\\t// return the array with the root value attached\\n        return [...left, ...right];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n\\t// If null return an empty array\\n    if (root === null) return [];\\n\\t// If no children return the nodes value itself as a string within an array\\n    else if (root.left === null && root.right === null) return [`${root.val}`];\\n    else {\\n\\t\\t// For all child paths add the root to their head one by one.\\n        let left = binaryTreePaths(root.left).map(x => root.val + \\'->\\' + x);\\n        let right = binaryTreePaths(root.right).map(x => root.val + \\'->\\' + x);\\n\\t\\t\\n\\t\\t// return the array with the root value attached\\n        return [...left, ...right];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68443,
                "title": "my-java-and-c-solution-c-4ms",
                "content": " this is a simple dfs+tree question,using preorder to visit tree will be fine.\\n \\nc++:\\n\\n     class Solution {\\n        public:\\n        \\n                vector<string> binaryTreePaths(TreeNode* root) {\\n                    vector<string> v;\\n                    if(root)\\n                        preorder(v,root,\"\");\\n                    return v;\\n                }\\n                void preorder(vector<string>& v,TreeNode* r,string t){\\n                    if(!r)\\n                        return;\\n                    if(!t.empty())\\n                        t+=(\"->\"+to_string(r->val));\\n                    else t+=to_string(r->val);\\n                    if(r->left||r->right){\\n                        preorder(v,r->left,t);\\n                        preorder(v,r->right,t);\\n                    }else{\\n                        v.push_back(t);\\n                    }\\n                }\\n            };\\n\\nmy java:\\n\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> l=new ArrayList<>();\\n            if(root!=null)\\n                pre(l,root,\"\");\\n            return l;\\n        }\\n         void pre(List<String> l,TreeNode r,String s){\\n             if(r==null)return;\\n             if(s.isEmpty())\\n                s+=r.val;\\n            else s+=(\"->\"+r.val);\\n            if(r.left!=null||r.right!=null){\\n                pre(l,r.left,s);\\n                pre(l,r.right,s);\\n            }else\\n                l.add(s);\\n         }\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "class Solution {\\n        public:\\n        \\n                vector<string> binaryTreePaths(TreeNode* root) {\\n                    vector<string> v;\\n                    if(root)\\n                        preorder(v,root,\"\");\\n                    return v;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 928068,
                "title": "dfs-js-solution",
                "content": "```\\nUsing String:\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n    \\n    function dfsTraversal(root, cur) {\\n        if (!root) return;\\n        if (!root.left && !root.right) {\\n            paths.push(cur + root.val);\\n            return;\\n        }\\n        dfsTraversal(root.left, cur + root.val + \"->\");\\n        dfsTraversal(root.right, cur + root.val + \"->\");\\n    }\\n    \\n    dfsTraversal(root, \"\");\\n    return paths;\\n    // Time Complexity: O(N), we always visit all nodes\\n    // Space Complexity: O(H) or O(N), height can be at most N (in case of a skewed tree)\\n};\\n```\\n\\n```\\nUsing Array:\\nconst binaryTreePaths = (root) => {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (root === null) {\\n      return;\\n    }\\n    if (root.left === null && root.right === null) {\\n      paths.push([...curPath, root.val]);\\n      return;\\n    }\\n    dfsTraversal([...curPath, root.val], root.left);\\n    dfsTraversal([...curPath, root.val], root.right);\\n  }\\n  dfsTraversal([], root);\\n  return paths.map(path => path.join(\"->\"));\\n};\\n```\\n```\\nUsing only one array:\\nvar binaryTreePaths = function(root) {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (!root) return;\\n    curPath.push(root.val);\\n    if (root.left === null && root.right === null) {\\n      paths.push(curPath.join(\"->\"));\\n    }\\n    dfsTraversal(curPath, root.left);\\n    dfsTraversal(curPath, root.right);\\n    curPath.pop();\\n  }\\n  dfsTraversal([], root);\\n  return paths;\\n  // T.C: O(N)\\n  // S.C: O(H)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nUsing String:\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n    \\n    function dfsTraversal(root, cur) {\\n        if (!root) return;\\n        if (!root.left && !root.right) {\\n            paths.push(cur + root.val);\\n            return;\\n        }\\n        dfsTraversal(root.left, cur + root.val + \"->\");\\n        dfsTraversal(root.right, cur + root.val + \"->\");\\n    }\\n    \\n    dfsTraversal(root, \"\");\\n    return paths;\\n    // Time Complexity: O(N), we always visit all nodes\\n    // Space Complexity: O(H) or O(N), height can be at most N (in case of a skewed tree)\\n};\\n```\n```\\nUsing Array:\\nconst binaryTreePaths = (root) => {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (root === null) {\\n      return;\\n    }\\n    if (root.left === null && root.right === null) {\\n      paths.push([...curPath, root.val]);\\n      return;\\n    }\\n    dfsTraversal([...curPath, root.val], root.left);\\n    dfsTraversal([...curPath, root.val], root.right);\\n  }\\n  dfsTraversal([], root);\\n  return paths.map(path => path.join(\"->\"));\\n};\\n```\n```\\nUsing only one array:\\nvar binaryTreePaths = function(root) {\\n  let paths = [];\\n  function dfsTraversal(curPath, root) {\\n    if (!root) return;\\n    curPath.push(root.val);\\n    if (root.left === null && root.right === null) {\\n      paths.push(curPath.join(\"->\"));\\n    }\\n    dfsTraversal(curPath, root.left);\\n    dfsTraversal(curPath, root.right);\\n    curPath.pop();\\n  }\\n  dfsTraversal([], root);\\n  return paths;\\n  // T.C: O(N)\\n  // S.C: O(H)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68536,
                "title": "three-4ms-c-solutions-given-recursion-dfs-stack-based-bfs-queue-based",
                "content": "(1)Recursion, if root is empty, return, if root is a leaf, then return cur+root->val, if root has childrens, then do recursion on each child, with cur updated to cur + root->val +\"->\"\\n\\n    class Solution {\\n        void dfs(vector<string> &res, TreeNode *root, string cur)\\n        {\\n            if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n            else\\n            {\\n                if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n                if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n            }\\n        }\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            if(root)  dfs(res, root, \"\");\\n            return res;\\n        }\\n    };\\n\\n(2) DFS Version using a stack\\nUsing a stack (the element is a pair of the current node pointer and the string recording the path from root to the current node). The logic is the same as (1)\\n\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> res;\\n            TreeNode *curNode;\\n            string curPath;\\n            stack<pair<TreeNode*, string>> liveNodes;\\n            if(root) liveNodes.push(make_pair(root, \"\"));\\n            while(!liveNodes.empty())\\n            {\\n                curNode = liveNodes.top().first;\\n                curPath    = liveNodes.top().second;\\n                liveNodes.pop();\\n                if(!curNode->left && !curNode->right)\\n                {\\n                    res.push_back(curPath + std::to_string(curNode->val));\\n                }\\n                else\\n                {\\n                    if(curNode->left)  liveNodes.push(make_pair(curNode->left, curPath + std::to_string(curNode->val)+ \"->\"));\\n                    if(curNode->right) liveNodes.push(make_pair(curNode->right, curPath + std::to_string(curNode->val)+ \"->\"));\\n                }\\n            }\\n            return res;\\n        }\\n    };\\n\\n(3) BFS queue based solution.\\nIt prints all the paths in an ascending order of the path length\\n\\n    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            queue<pair<TreeNode*, string>> liveNodes[2];\\n            int cur=0, next=1;\\n            TreeNode* curNode;\\n            string curPath;\\n            vector<string> res;\\n            \\n            if(root) liveNodes[cur].push(make_pair(root, \"\"));\\n            while(!liveNodes[cur].empty())\\n            {\\n                curNode = liveNodes[cur].front().first;\\n                curPath = liveNodes[cur].front().second;\\n                liveNodes[cur].pop();\\n                if(!curNode->left && !curNode->right) res.push_back(curPath + std::to_string(curNode->val));\\n                else{\\n                    if(curNode->left)  liveNodes[next].push(make_pair(curNode->left,  curPath + std::to_string(curNode->val) + \"->\"));\\n                    if(curNode->right) liveNodes[next].push(make_pair(curNode->right, curPath + std::to_string(curNode->val) + \"->\"));\\n                }\\n                if(liveNodes[cur].empty()) swap(cur, next);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        void dfs(vector<string> &res, TreeNode *root, string cur)\\n        {\\n            if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n            else\\n            {\\n                if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n                if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 68364,
                "title": "4-lines-python-dfs",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        result= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.left)]\\n        result+= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.right)]\\n        return result or [str(root.val)]  # if empty return leaf itself\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        result= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.left)]\\n        result+= [ str(root.val)+\"->\" + path for path in self.binaryTreePaths(root.right)]\\n        return result or [str(root.val)]  # if empty return leaf itself\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 827629,
                "title": "python-o-n-2-by-dfs-w-comment",
                "content": "Python O(n^2) by DFS \\n\\n---\\n\\n**Implementation**:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        \\n        result = []\\n        \\n        # ----------------------------------------\\n        def helper(node, cur):\\n            \\n            if not node:\\n                # base case\\n                return\\n            \\n            \\n            if not node.left and not node.right:\\n                # stop condition\\n                result.append( cur + [str(node.val)] )\\n                \\n            else:\\n                # general case\\n                helper(node.left, cur + [str(node.val)] )\\n                helper(node.right, cur + [str(node.val)] )\\n            \\n            \\n        # ----------------------------------------\\n        \\n        helper(node=root, cur=[])\\n        return [ *map(\\'->\\'.join, result) ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        \\n        result = []\\n        \\n        # ----------------------------------------\\n        def helper(node, cur):\\n            \\n            if not node:\\n                # base case\\n                return\\n            \\n            \\n            if not node.left and not node.right:\\n                # stop condition\\n                result.append( cur + [str(node.val)] )\\n                \\n            else:\\n                # general case\\n                helper(node.left, cur + [str(node.val)] )\\n                helper(node.right, cur + [str(node.val)] )\\n            \\n            \\n        # ----------------------------------------\\n        \\n        helper(node=root, cur=[])\\n        return [ *map(\\'->\\'.join, result) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68410,
                "title": "short-and-clear-c-dfs-solution",
                "content": "    vector<string> binaryTreePaths(TreeNode* root) {\\n    \\tvector<string> res;\\n    \\thelp(res, root, \"\");\\n    \\treturn res;\\n    }\\n    void help(vector<string>& res, TreeNode* root, string pre) {\\n    \\tif (!root)\\n    \\t\\treturn;\\n    \\tif (!root->left && !root->right) {\\n    \\t\\tres.push_back(pre + to_string(root->val));\\n    \\t\\treturn;\\n    \\t}\\n    \\thelp(res, root->left, pre + to_string(root->val) + \"->\");\\n    \\thelp(res, root->right, pre + to_string(root->val) + \"->\");\\n    }",
                "solutionTags": [],
                "code": "    vector<string> binaryTreePaths(TreeNode* root) {\\n    \\tvector<string> res;\\n    \\thelp(res, root, \"\");\\n    \\treturn res;\\n    }\\n    void help(vector<string>& res, TreeNode* root, string pre) {\\n    \\tif (!root)\\n    \\t\\treturn;\\n    \\tif (!root->left && !root->right) {\\n    \\t\\tres.push_back(pre + to_string(root->val));\\n    \\t\\treturn;\\n    \\t}\\n    \\thelp(res, root->left, pre + to_string(root->val) + \"->\");\\n    \\thelp(res, root->right, pre + to_string(root->val) + \"->\");\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3164442,
                "title": "python-simple-recursive-solution-beats-100",
                "content": "## Upvote if it helps !\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We iterate through left and right nodes until we get to a leaf.\\n    - We construct the string in the recursion. \\n    - During the recursion, we add ```->``` before the value of the node **only if it\\'s not the root**.\\n    - We add the string to the result only when we get to a leaf.  \\n\\n# Code\\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        res = []\\n        \\n        def dfs(node, s):\\n            if s != \"\":\\n                s += \"->\"\\n            s += str(node.val)\\n            if not node.left and not node.right: res.append(s)\\n            if node.left: dfs(node.left, s)\\n            if node.right: dfs(node.right, s)\\n        dfs(root, \"\") \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```->```\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        res = []\\n        \\n        def dfs(node, s):\\n            if s != \"\":\\n                s += \"->\"\\n            s += str(node.val)\\n            if not node.left and not node.right: res.append(s)\\n            if node.left: dfs(node.left, s)\\n            if node.right: dfs(node.right, s)\\n        dfs(root, \"\") \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799051,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234676,
                "title": "c-easy-100-faster",
                "content": "```\\n\\tclass Solution {\\npublic:\\n    vector<string>ans1;\\n    \\n   void recurs(TreeNode* root,string ans)\\n    {\\n       if(root==NULL)\\n       {\\n           return ;\\n       }\\n    \\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=to_string(root->val);\\n            ans1.push_back(ans);\\n            return ;\\n        }\\n\\n            ans+=to_string(root->val)+\"->\";\\n       \\n        recurs(root->left,ans);\\n        recurs(root->right,ans);\\n    }\\n    \\n    \\n    \\n    \\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        recurs(root,\"\");\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    vector<string>ans1;\\n    \\n   void recurs(TreeNode* root,string ans)\\n    {\\n       if(root==NULL)\\n       {\\n           return ;\\n       }\\n    \\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=to_string(root->val);\\n            ans1.push_back(ans);\\n            return ;\\n        }\\n\\n            ans+=to_string(root->val)+\"->\";\\n       \\n        recurs(root->left,ans);\\n        recurs(root->right,ans);\\n    }\\n    \\n    \\n    \\n    \\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        recurs(root,\"\");\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602321,
                "title": "time-o-n-h-beats-99-43-space-o-h-beats-99-39-python-simple-explanation",
                "content": "**Time Complexity Explanation:** For every path - in the worst case we have (n/2 + 1) paths which happens when the tree is perfect - we iterate through each node in the path once in order to stringify the path. At worst, we will have h nodes in the path - where h is the height of the tree, and n is the total number of nodes in the tree. Therefore we get a time complexity of O((n/2 + 1) * h) = O(n * h).\\n\\n**Space Complexity Explanation:** This is trivial, we are using Depth-First Search, and an extra list which can contain at most h nodes - where h is the height of the tree. Therefore we get a space complexity of O(h).\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def _dfs(self, root: Optional[TreeNode], cur, res) -> None:\\n        \\n        # Base Case\\n        if not root:\\n            return\\n        \\n        # Append node to path\\n        cur.append(str(root.val))\\n        \\n        # If root is a leaf, append path to result\\n        if not root.left and not root.right:\\n            res.append(\\'->\\'.join(cur))\\n            \\n        # Recursive Step\\n        self._dfs(root.left, cur, res)\\n        self._dfs(root.right, cur, res)\\n        \\n        # Backtracking / Post-processing / pop node from path\\n        cur.pop()\\n        \\n        \\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        res = []\\n        self._dfs(root, [], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def _dfs(self, root: Optional[TreeNode], cur, res) -> None:\\n        \\n        # Base Case\\n        if not root:\\n            return\\n        \\n        # Append node to path\\n        cur.append(str(root.val))\\n        \\n        # If root is a leaf, append path to result\\n        if not root.left and not root.right:\\n            res.append(\\'->\\'.join(cur))\\n            \\n        # Recursive Step\\n        self._dfs(root.left, cur, res)\\n        self._dfs(root.right, cur, res)\\n        \\n        # Backtracking / Post-processing / pop node from path\\n        cur.pop()\\n        \\n        \\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        res = []\\n        self._dfs(root, [], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111611,
                "title": "javascript-dfs-solution",
                "content": "```\\nvar binaryTreePaths = function(root) {\\n    if(!root) return [];\\n    var result = [];\\n    function path(root, str){\\n        if(!root.left && !root.right) result.push(str + root.val);\\n        if(root.left) path(root.left, str + root.val + \"->\");\\n        if(root.right) path(root.right, str + root.val + \"->\");\\n    }\\n    path(root, \"\");\\n    return result;\\n};",
                "solutionTags": [],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n    if(!root) return [];\\n    var result = [];\\n    function path(root, str){\\n        if(!root.left && !root.right) result.push(str + root.val);\\n        if(root.left) path(root.left, str + root.val + \"->\");\\n        if(root.right) path(root.right, str + root.val + \"->\");\\n    }\\n    path(root, \"\");\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 68441,
                "title": "python-easy-dfs-recursive-iterative-solution",
                "content": "Recursive:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, node, path, res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path, node.val))\\n        self.dfs(node.left, \"{}{}->\".format(path, node.val), res)\\n        self.dfs(node.right, \"{}{}->\".format(path, node.val), res)\\n\\nIterative:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, \"\")]\\n        while stack:\\n            node, path = stack.pop()\\n            if not node:\\n                continue\\n            if not node.left and not node.right:\\n                res.append(\"{}{}\".format(path,node.val))\\n            stack.append((node.left, \"{}{}->\".format(path,node.val)))\\n            stack.append((node.right, \"{}{}->\".format(path,node.val)))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "Recursive:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        self.dfs(root, \"\", res)\\n        return res\\n    \\n    def dfs(self, node, path, res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path, node.val))\\n        self.dfs(node.left, \"{}{}->\".format(path, node.val), res)\\n        self.dfs(node.right, \"{}{}->\".format(path, node.val), res)\\n\\nIterative:\\n\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n        res = []\\n        stack = [(root, \"\")]\\n        while stack:\\n            node, path = stack.pop()\\n            if not node:\\n                continue\\n            if not node.left and not node.right:\\n                res.append(\"{}{}\".format(path,node.val))\\n            stack.append((node.left, \"{}{}->\".format(path,node.val)))\\n            stack.append((node.right, \"{}{}->\".format(path,node.val)))\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3476527,
                "title": "easy-o-n-c-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Inbuilt Stack for Recursive calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<string>v;\\n    \\n    void solve(TreeNode* root,string s){\\n        if(!root){\\n            if(s!=\"\")\\n            return;\\n            else\\n            v.push_back(s);\\n            return;\\n        }\\n\\n        s=s+to_string(root->val)+\"->\";\\n        if(!root->left and !root->right){\\n            s=s.substr(0,s.size()-2);\\n            v.push_back(s);\\n        }\\n        if(root->left)\\n        solve(root->left,s);\\n        if(root->right)\\n        solve(root->right,s);\\n        \\n       \\n        \\n}\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        solve(root,s);\\n        return v;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<string>v;\\n    \\n    void solve(TreeNode* root,string s){\\n        if(!root){\\n            if(s!=\"\")\\n            return;\\n            else\\n            v.push_back(s);\\n            return;\\n        }\\n\\n        s=s+to_string(root->val)+\"->\";\\n        if(!root->left and !root->right){\\n            s=s.substr(0,s.size()-2);\\n            v.push_back(s);\\n        }\\n        if(root->left)\\n        solve(root->left,s);\\n        if(root->right)\\n        solve(root->right,s);\\n        \\n       \\n        \\n}\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        solve(root,s);\\n        return v;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247162,
                "title": "c-recursive-backtracking-iterative",
                "content": "The recursive idea is to get the paths of the `left` and `right` subtrees and append the `root` to them.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths, left, right;\\n        left = binaryTreePaths(root -> left);\\n        right = binaryTreePaths(root -> right);\\n        for (string l : left) {\\n            paths.push_back(to_string(root -> val) + (l.empty() ? \"\" : \"->\" + l));\\n        }\\n        for (string r : right) {\\n            paths.push_back(to_string(root -> val) + (r.empty() ? \"\" : \"->\" + r));\\n        }\\n        if (paths.empty()) {\\n            paths.push_back(to_string(root -> val));\\n        }\\n        return paths;\\n    }\\n};\\n```\\n\\nBacktracking can also be applied, which is basically a template solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> paths;\\n        string path;\\n        binaryTreePaths(root, path, paths);\\n        return paths;\\n    }\\nprivate:\\n    void binaryTreePaths(TreeNode* root, string path, vector<string>& paths) {\\n        if (!root) {\\n            return;\\n        }\\n        path += (path.empty() ? \"\" : \"->\") + to_string(root -> val);\\n        if (!root -> left && !root -> right) {\\n            paths.push_back(path);\\n        } else {\\n            binaryTreePaths(root -> left, path, paths);\\n            binaryTreePaths(root -> right, path, paths);\\n        }\\n    }\\n};\\n```\\n\\nOr we may solve it iteratively by storing each node and the path to it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths;\\n        queue<pair<TreeNode*, string>> todo;\\n        todo.push({root, to_string(root -> val)});\\n        while (!todo.empty()) {\\n            pair<TreeNode*, string> p = todo.front();\\n            todo.pop();\\n            TreeNode* node = p.first;\\n            string path = p.second;\\n            if (!node -> left && !node -> right) {\\n                paths.push_back(path);\\n            } else {\\n                if (node -> left) {\\n                    todo.push({node -> left, path + \"->\" + to_string(node -> left -> val)});\\n                }\\n                if (node -> right) {\\n                    todo.push({node -> right, path + \"->\" + to_string(node -> right -> val)});\\n                }\\n            }\\n        }\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths, left, right;\\n        left = binaryTreePaths(root -> left);\\n        right = binaryTreePaths(root -> right);\\n        for (string l : left) {\\n            paths.push_back(to_string(root -> val) + (l.empty() ? \"\" : \"->\" + l));\\n        }\\n        for (string r : right) {\\n            paths.push_back(to_string(root -> val) + (r.empty() ? \"\" : \"->\" + r));\\n        }\\n        if (paths.empty()) {\\n            paths.push_back(to_string(root -> val));\\n        }\\n        return paths;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> paths;\\n        string path;\\n        binaryTreePaths(root, path, paths);\\n        return paths;\\n    }\\nprivate:\\n    void binaryTreePaths(TreeNode* root, string path, vector<string>& paths) {\\n        if (!root) {\\n            return;\\n        }\\n        path += (path.empty() ? \"\" : \"->\") + to_string(root -> val);\\n        if (!root -> left && !root -> right) {\\n            paths.push_back(path);\\n        } else {\\n            binaryTreePaths(root -> left, path, paths);\\n            binaryTreePaths(root -> right, path, paths);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        vector<string> paths;\\n        queue<pair<TreeNode*, string>> todo;\\n        todo.push({root, to_string(root -> val)});\\n        while (!todo.empty()) {\\n            pair<TreeNode*, string> p = todo.front();\\n            todo.pop();\\n            TreeNode* node = p.first;\\n            string path = p.second;\\n            if (!node -> left && !node -> right) {\\n                paths.push_back(path);\\n            } else {\\n                if (node -> left) {\\n                    todo.push({node -> left, path + \"->\" + to_string(node -> left -> val)});\\n                }\\n                if (node -> right) {\\n                    todo.push({node -> right, path + \"->\" + to_string(node -> right -> val)});\\n                }\\n            }\\n        }\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68453,
                "title": "my-java-non-recursion-solution-using-stack-and-wrapper",
                "content": "    private class Wrapper {\\n    \\t\\tprivate TreeNode node;\\n    \\t\\tprivate String path;\\n    \\n    \\t\\tpublic Wrapper(TreeNode node, String path) {\\n    \\t\\t\\tthis.node = node;\\n    \\t\\t\\tthis.path = path;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t// non-recursion-version\\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new LinkedList<>();\\n    \\t\\tif (root == null) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tStack<Wrapper> stack = new Stack<>();\\n    \\t\\tstack.add(new Wrapper(root, \"\"+root.val));\\n    \\t\\twhile(!stack.isEmpty()){\\n    \\t\\t\\tWrapper wrapper = stack.pop();\\n    \\t\\t\\tif (wrapper.node.left == null && wrapper.node.right == null) {\\n    \\t\\t\\t\\tres.add(wrapper.path);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.left != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.left, wrapper.path + \"->\" + wrapper.node.left.val));\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.right != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.right, wrapper.path + \"->\" + wrapper.node.right.val));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\n    \\t}",
                "solutionTags": [],
                "code": "    private class Wrapper {\\n    \\t\\tprivate TreeNode node;\\n    \\t\\tprivate String path;\\n    \\n    \\t\\tpublic Wrapper(TreeNode node, String path) {\\n    \\t\\t\\tthis.node = node;\\n    \\t\\t\\tthis.path = path;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\t// non-recursion-version\\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new LinkedList<>();\\n    \\t\\tif (root == null) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tStack<Wrapper> stack = new Stack<>();\\n    \\t\\tstack.add(new Wrapper(root, \"\"+root.val));\\n    \\t\\twhile(!stack.isEmpty()){\\n    \\t\\t\\tWrapper wrapper = stack.pop();\\n    \\t\\t\\tif (wrapper.node.left == null && wrapper.node.right == null) {\\n    \\t\\t\\t\\tres.add(wrapper.path);\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.left != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.left, wrapper.path + \"->\" + wrapper.node.left.val));\\n    \\t\\t\\t}\\n    \\t\\t\\tif (wrapper.node.right != null) {\\n    \\t\\t\\t\\tstack.add(new Wrapper(wrapper.node.right, wrapper.path + \"->\" + wrapper.node.right.val));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1066377,
                "title": "c-simple-0ms-recursive-solution",
                "content": "#### **Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\n#### Memory Usage: 13.1 MB, less than 67.34% of C++ online submissions for Binary Tree Paths.**\\n\\n```\\nclass Solution {\\npublic:\\n    void binaryTreePaths(TreeNode* root,vector<string>& res,string str){\\n        if(!root->left && !root->right){\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(root->left)\\n            binaryTreePaths(root->left,res,str + \"->\" + to_string(root->left->val));\\n        if(root->right)\\n            binaryTreePaths(root->right,res,str + \"->\" + to_string(root->right->val));\\n        \\n    } \\n        \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if (!root) return res;\\n        \\n        binaryTreePaths(root,res,to_string(root->val));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void binaryTreePaths(TreeNode* root,vector<string>& res,string str){\\n        if(!root->left && !root->right){\\n            res.push_back(str);\\n            return;\\n        }\\n        \\n        if(root->left)\\n            binaryTreePaths(root->left,res,str + \"->\" + to_string(root->left->val));\\n        if(root->right)\\n            binaryTreePaths(root->right,res,str + \"->\" + to_string(root->right->val));\\n        \\n    } \\n        \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if (!root) return res;\\n        \\n        binaryTreePaths(root,res,to_string(root->val));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68420,
                "title": "simple-python-solution-using-dfs-recursion",
                "content": "this solution does not require defining a new helper function. \\n\\n    class Solution:\\n        def binaryTreePaths(self, root):\\n            if not root:\\n                return []\\n            \\n            if not root.left and not root.right:\\n                return [str(root.val)]\\n    \\n            leftPathToLeaf = self.binaryTreePaths(root.left) \\n            rightPathToLeaf = self.binaryTreePaths(root.right)\\n            \\n            left = [str(root.val)+ (\"->\"+lpath ) for lpath in leftPathToLeaf]\\n            right = [str(root.val)+ (\"->\"+rpath) for rpath in rightPathToLeaf]\\n            return left+right",
                "solutionTags": [
                    "Python"
                ],
                "code": "this solution does not require defining a new helper function. \\n\\n    class Solution:\\n        def binaryTreePaths(self, root):\\n            if not root:\\n                return []\\n            \\n            if not root.left and not root.right:\\n                return [str(root.val)]\\n    \\n            leftPathToLeaf = self.binaryTreePaths(root.left) \\n            rightPathToLeaf = self.binaryTreePaths(root.right)\\n            \\n            left = [str(root.val)+ (\"->\"+lpath ) for lpath in leftPathToLeaf]\\n            right = [str(root.val)+ (\"->\"+rpath) for rpath in rightPathToLeaf]\\n            return left+right",
                "codeTag": "Java"
            },
            {
                "id": 701765,
                "title": "c-simple-classic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string ans;\\n        printNodes(root, ans, result);\\n        return result;\\n    }\\n    void printNodes(TreeNode* root, string ans, vector<string>& result)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        ans += to_string(root->val) + \"->\";\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            ans.erase(ans.length()-2, 2);\\n            result.push_back(ans);\\n        }\\n        printNodes(root->left, ans, result);\\n        printNodes(root->right, ans, result);\\n    }\\n};\\n```\\nUpvotes are encouraging!!\\nThank you :D",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string ans;\\n        printNodes(root, ans, result);\\n        return result;\\n    }\\n    void printNodes(TreeNode* root, string ans, vector<string>& result)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        ans += to_string(root->val) + \"->\";\\n        if(root->left == NULL && root->right ==NULL)\\n        {\\n            ans.erase(ans.length()-2, 2);\\n            result.push_back(ans);\\n        }\\n        printNodes(root->left, ans, result);\\n        printNodes(root->right, ans, result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68427,
                "title": "accepted-0ms-c-solution",
                "content": "    int pathsNum (struct TreeNode* root);\\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex);\\n    char* stringAdd (char* s, int val);\\n    \\n    char** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n      int index = 0;\\n      if (root == NULL)  return NULL;\\n      int paths = *returnSize = pathsNum(root);\\n      char** pathsArray = (char**) calloc (paths, sizeof (char*));\\n      Traverse (root, pathsArray, \"\", &index);\\n      return pathsArray;\\n    }\\n    \\n    int pathsNum (struct TreeNode* root)\\n    {\\n      if (root == NULL)\\n        return 0;\\n      if (root->left == NULL && root->right == NULL)\\n        return 1;\\n      return pathsNum(root->left) + pathsNum(root->right);\\n    }\\n    \\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex)\\n    {\\n      char* s;\\n      if (root->left == NULL && root->right == NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        array[(*pindex)++] = s;\\n      }\\n      if (root->left != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->left, array, s, pindex);\\n        free (s);\\n      }\\n      if (root->right != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->right, array, s, pindex);\\n        free (s);\\n      }\\n    }\\n    \\n    char* stringAdd (char* s, int val)\\n    {\\n      char temp[10];\\n      if (s == \"\")\\n        sprintf (temp,\"%d\", val);\\n      else\\n        sprintf (temp, \"->%d\", val);\\n      char* snew = (char*) calloc (strlen (s) + strlen (temp) + 1, sizeof (char));\\n      strcpy (snew, s);\\n      strcat (snew, temp);\\n      return snew;\\n    }",
                "solutionTags": [],
                "code": "    int pathsNum (struct TreeNode* root);\\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex);\\n    char* stringAdd (char* s, int val);\\n    \\n    char** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n      int index = 0;\\n      if (root == NULL)  return NULL;\\n      int paths = *returnSize = pathsNum(root);\\n      char** pathsArray = (char**) calloc (paths, sizeof (char*));\\n      Traverse (root, pathsArray, \"\", &index);\\n      return pathsArray;\\n    }\\n    \\n    int pathsNum (struct TreeNode* root)\\n    {\\n      if (root == NULL)\\n        return 0;\\n      if (root->left == NULL && root->right == NULL)\\n        return 1;\\n      return pathsNum(root->left) + pathsNum(root->right);\\n    }\\n    \\n    void Traverse (struct TreeNode* root, char** array, char* spre, int* pindex)\\n    {\\n      char* s;\\n      if (root->left == NULL && root->right == NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        array[(*pindex)++] = s;\\n      }\\n      if (root->left != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->left, array, s, pindex);\\n        free (s);\\n      }\\n      if (root->right != NULL)\\n      {\\n        s = stringAdd (spre, root->val);\\n        Traverse (root->right, array, s, pindex);\\n        free (s);\\n      }\\n    }\\n    \\n    char* stringAdd (char* s, int val)\\n    {\\n      char temp[10];\\n      if (s == \"\")\\n        sprintf (temp,\"%d\", val);\\n      else\\n        sprintf (temp, \"->%d\", val);\\n      char* snew = (char*) calloc (strlen (s) + strlen (temp) + 1, sizeof (char));\\n      strcpy (snew, s);\\n      strcat (snew, temp);\\n      return snew;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68485,
                "title": "bfs-with-two-queue-java-solution",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<String> path = new LinkedList<>();\\n        path.offer(root.val + \"\");\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            String item = path.poll();\\n            if (cur.left == null && cur.right == null) {\\n                res.add(item);\\n            }\\n            if (cur.left != null) {\\n                queue.offer(cur.left);\\n                path.offer(item + \"->\" + cur.left.val + \"\");\\n            }\\n            if (cur.right != null) {\\n                queue.offer(cur.right);\\n                path.offer(item + \"->\" + cur.right.val + \"\");\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Queue<String> path = new LinkedList<>();\\n        path.offer(root.val + \"\");\\n        queue.offer(root);\\n        while (!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            String item = path.poll();\\n            if (cur.left == null && cur.right == null) {\\n                res.add(item);\\n            }\\n            if (cur.left != null) {\\n                queue.offer(cur.left);\\n                path.offer(item + \"->\" + cur.left.val + \"\");\\n            }\\n            if (cur.right != null) {\\n                queue.offer(cur.right);\\n                path.offer(item + \"->\" + cur.right.val + \"\");\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68461,
                "title": "simple-to-understand-python-solution",
                "content": "    class Solution(object):\\n        def binaryTreePaths(self, root):\\n            if root == None:\\n                return []\\n            return self.constructPaths(root, str(root.val), [])\\n\\n        def constructPaths(self, root, p, paths):\\n            if root.left == None and root.right == None:\\n                paths.append(p)\\n            if root.left:\\n                paths = self.constructPaths(root.left, p + \"->\" + str(root.left.val), paths)\\n            if root.right:\\n                paths = self.constructPaths(root.right, p + \"->\" + str(root.right.val), paths)\\n            return paths",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def binaryTreePaths(self, root):\\n            if root == None:\\n                return []\\n            return self.constructPaths(root, str(root.val), [])\\n\\n        def constructPaths(self, root, p, paths):\\n            if root.left == None and root.right == None:\\n                paths.append(p)\\n            if root.left:\\n                paths = self.constructPaths(root.left, p + \"->\" + str(root.left.val), paths)\\n            if root.right:\\n                paths = self.constructPaths(root.right, p + \"->\" + str(root.right.val), paths)\\n            return paths",
                "codeTag": "Java"
            },
            {
                "id": 68471,
                "title": "java-easy-to-understand-solution-3-line-dfs",
                "content": "Code in Java:\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>(); // stores the final output\\n        if(root==null) return res;\\n        helper(root, \"\", res);\\n        return res;\\n    }\\n    // DFS\\n    private void helper(TreeNode root, String str, List<String> res) {\\n        if(root.left==null && root.right==null) res.add(str + root.val); // reach a leaf node, completes a path\\n        if(root.left!=null)                     helper(root.left, str+root.val+\"->\", res); // recursively checks its left child\\n        if(root.right!=null)                    helper(root.right, str+root.val+\"->\", res); // recursively checks its right child\\n    }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "Code in Java:\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>(); // stores the final output\\n        if(root==null) return res;\\n        helper(root, \"\", res);\\n        return res;\\n    }\\n    // DFS\\n    private void helper(TreeNode root, String str, List<String> res) {\\n        if(root.left==null && root.right==null) res.add(str + root.val); // reach a leaf node, completes a path\\n        if(root.left!=null)                     helper(root.left, str+root.val+\"->\", res); // recursively checks its left child\\n        if(root.right!=null)                    helper(root.right, str+root.val+\"->\", res); // recursively checks its right child\\n    }\\n\\nIf you are interested in my other posts, please feel free to check my Github page here: [https://github.com/F-L-A-G/Algorithms-in-Java][1]\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java",
                "codeTag": "Unknown"
            },
            {
                "id": 3640686,
                "title": "simple-dfs-in-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find all the root-to-leaf paths, we can use a depth-first search (DFS) algorithm. We\\'ll implement a recursive helper function `solve()` that takes two parameters: the current node and the current path string. The `solve()` function will traverse the tree in a depth-first manner and append the root-to-leaf paths to the `ans` list.\\n\\nIn the `solve()` function:\\n1. Append the string representation of the current node\\'s value to the path string (`s += str(root.val)`).\\n2. Check if the current node is a leaf node (i.e., it has no left or right child). If so, it means we have reached the end of a root-to-leaf path. In this case, append the current path string to the `ans` list and return.\\n3. If the current node has a right child, recursively call `solve()` with the right child and the updated path string (`solve(root.right, s + \"->\")`).\\n4. If the current node has a left child, recursively call `solve()` with the left child and the updated path string (`solve(root.left, s + \"->\")`).\\n\\nAfter defining the `solve()` function, we initialize an empty `ans` list. Then, we call `solve()` with the `root` node and an empty path string (`\"\"`). Finally, we return the `ans` list, which contains all the root-to-leaf paths.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n        def solve(root, s):\\n            s += str(root.val)\\n            if not root.right and not root.left:\\n                ans.append(s)\\n                return\\n            if root.right:\\n                solve(root.right, s+\"->\")\\n            if root.left:\\n                solve(root.left, s+\"->\")\\n        solve(root, \"\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n        def solve(root, s):\\n            s += str(root.val)\\n            if not root.right and not root.left:\\n                ans.append(s)\\n                return\\n            if root.right:\\n                solve(root.right, s+\"->\")\\n            if root.left:\\n                solve(root.left, s+\"->\")\\n        solve(root, \"\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323006,
                "title": "simple-c-4ms-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void abc(vector<string>& ans,string s,TreeNode* root){\\n        s+=to_string(root->val);\\n        if(root->left==NULL && root->right==NULL){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(root->left){\\n            abc(ans,s+\"->\",root->left);\\n        }\\n        if(root->right){\\n            // s+=\"->\";\\n            abc(ans,s+\"->\",root->right);\\n        }\\n        return;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string s=\"\";\\n        abc(ans,s,root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void abc(vector<string>& ans,string s,TreeNode* root){\\n        s+=to_string(root->val);\\n        if(root->left==NULL && root->right==NULL){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(root->left){\\n            abc(ans,s+\"->\",root->left);\\n        }\\n        if(root->right){\\n            // s+=\"->\";\\n            abc(ans,s+\"->\",root->right);\\n        }\\n        return;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string s=\"\";\\n        abc(ans,s,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059553,
                "title": "java-recursive-dfs-explained",
                "content": "# Intuition\\nWe will begin by **Adding values in String ans** (Sublist).And If our LeafNode Condition hits that means **add current SubList In Main** and continue the procedure of Traversing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<String> list=new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String ans=\"\";\\n        path(root,ans);\\n        return list;\\n    }\\n    void path(TreeNode root, String ans) {\\n        if(root==null) return;\\n        ans=ans+root.val;\\n        if(root.left==null && root.right==null){\\n            list.add(ans);\\n            return;\\n        }\\n        ans=ans+\"->\";\\n        path(root.left,ans);\\n        path(root.right,ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<String> list=new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String ans=\"\";\\n        path(root,ans);\\n        return list;\\n    }\\n    void path(TreeNode root, String ans) {\\n        if(root==null) return;\\n        ans=ans+root.val;\\n        if(root.left==null && root.right==null){\\n            list.add(ans);\\n            return;\\n        }\\n        ans=ans+\"->\";\\n        path(root.left,ans);\\n        path(root.right,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484118,
                "title": "python-3-beats-100-nine-lines-dfs",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, R: TreeNode) -> List[str]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None): A.append(\\'->\\'.join(map(str,P)))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, R: TreeNode) -> List[str]:\\n        A, P = [], []\\n        def dfs(N):\\n            if N == None: return\\n            P.append(N.val)\\n            if (N.left,N.right) == (None,None): A.append(\\'->\\'.join(map(str,P)))\\n            else: dfs(N.left), dfs(N.right)\\n            P.pop()\\n        dfs(R)\\n        return A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 433961,
                "title": "python-solution-dfs-path",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        self.res = []\\n        self.dfs(root, str(root.val))\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if not root.left and not root.right:\\n            self.res.append(path)\\n        if root.left:\\n            self.dfs(root.left, path + \"->\" + str(root.left.val))\\n        if root.right:\\n            self.dfs(root.right, path + \"->\" + str(root.right.val))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        self.res = []\\n        self.dfs(root, str(root.val))\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if not root.left and not root.right:\\n            self.res.append(path)\\n        if root.left:\\n            self.dfs(root.left, path + \"->\" + str(root.left.val))\\n        if root.right:\\n            self.dfs(root.right, path + \"->\" + str(root.right.val))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68423,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // import javafx.util.Pair;\\n    // dfs recursively \\n    public List<String> binaryTreePaths1(TreeNode root) {\\n        List<String> ret = new LinkedList<>();\\n        dfs(new Pair(root, \"\"), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(Pair<TreeNode, String> p, List<String> ret) {\\n        TreeNode n = p.getKey();\\n        String str = p.getValue();\\n        if (n != null) {\\n            if (n.left == null && n.right == null) {\\n                str += n.val;\\n                ret.add(str);\\n                //return;\\n            } \\n            dfs(new Pair(n.left, str+n.val+\"->\"), ret);\\n            dfs(new Pair(n.right, str+n.val+\"->\"), ret);\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<String> binaryTreePaths2(TreeNode root) {\\n        Stack<Pair<TreeNode, String>> stack = new Stack<>();\\n        stack.push(new Pair(root, \"\"));\\n        List<String> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, String> p = stack.pop();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += Integer.toString(n.val);\\n                    ret.add(str);\\n                }\\n                stack.push(new Pair(n.right, str+n.val+\"->\"));\\n                stack.push(new Pair(n.left, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        Queue<Pair<TreeNode, String>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, \"\"));\\n        List<String> ret = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, String> p = queue.poll();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += n.val;\\n                    ret.add(str);\\n                    //continue;\\n                }\\n                queue.add(new Pair(n.left, str+n.val+\"->\"));\\n                queue.add(new Pair(n.right, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // import javafx.util.Pair;\\n    // dfs recursively \\n    public List<String> binaryTreePaths1(TreeNode root) {\\n        List<String> ret = new LinkedList<>();\\n        dfs(new Pair(root, \"\"), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(Pair<TreeNode, String> p, List<String> ret) {\\n        TreeNode n = p.getKey();\\n        String str = p.getValue();\\n        if (n != null) {\\n            if (n.left == null && n.right == null) {\\n                str += n.val;\\n                ret.add(str);\\n                //return;\\n            } \\n            dfs(new Pair(n.left, str+n.val+\"->\"), ret);\\n            dfs(new Pair(n.right, str+n.val+\"->\"), ret);\\n        }\\n    }\\n    \\n    // dfs iteratively\\n    public List<String> binaryTreePaths2(TreeNode root) {\\n        Stack<Pair<TreeNode, String>> stack = new Stack<>();\\n        stack.push(new Pair(root, \"\"));\\n        List<String> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, String> p = stack.pop();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += Integer.toString(n.val);\\n                    ret.add(str);\\n                }\\n                stack.push(new Pair(n.right, str+n.val+\"->\"));\\n                stack.push(new Pair(n.left, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        Queue<Pair<TreeNode, String>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, \"\"));\\n        List<String> ret = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, String> p = queue.poll();\\n            TreeNode n = p.getKey();\\n            String str = p.getValue();\\n            if (n != null) {\\n                if (n.left == null && n.right == null) {\\n                    str += n.val;\\n                    ret.add(str);\\n                    //continue;\\n                }\\n                queue.add(new Pair(n.left, str+n.val+\"->\"));\\n                queue.add(new Pair(n.right, str+n.val+\"->\"));\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3448270,
                "title": "python-3-bfs-getting-list-of-all-paths-and-then-return-in-needed-format",
                "content": "# Code\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        paths = []\\n        def dfs(node, path):\\n            if not node: return\\n            path = path + [node.val]\\n            if not (node.left or node.right):\\n                return paths.append(path)\\n            dfs(node.left, path)\\n            dfs(node.right, path)\\n        dfs(root, [])\\n\\n        return [\\'->\\'.join(map(str, path)) for path in paths]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        paths = []\\n        def dfs(node, path):\\n            if not node: return\\n            path = path + [node.val]\\n            if not (node.left or node.right):\\n                return paths.append(path)\\n            dfs(node.left, path)\\n            dfs(node.right, path)\\n        dfs(root, [])\\n\\n        return [\\'->\\'.join(map(str, path)) for path in paths]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231860,
                "title": "257-time-96-78-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Here\\'s a step-by-step explanation:\\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n```\\nThe solution defines a class Solution with a method binaryTreePaths. It takes in the root node of a binary tree, represented as a TreeNode object, and returns a list of strings representing all possible paths from root to leaf nodes.\\n\\nThe variable ans is initialized as an empty list, which will store the answer.\\n\\n```\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n```\\nA depth-first search (DFS) helper function dfs is defined, which takes in a node root and a path represented as a list of strings. If the node root is None, the function returns and does nothing.\\n```\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n```\\nIf root is a leaf node (i.e. has no left or right child), the function appends the current path joined by -> and the value of the leaf node to ans. Then, the function returns and does nothing.\\n\\n```   path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n```\\nIf root is not a leaf node, the function appends the current node value followed by -> to the path. It then recursively calls dfs on the left and right children of the node. After these recursive calls are complete, the current node value is popped from the path.\\n\\n```\\n    dfs(root, [])\\n    return ans\\n```\\n\\nFinally, the dfs function is called on the root node with an empty path list, and ans is returned as the answer to the problem.\\n\\n# Complexity\\n- Time complexity:\\n96.78%\\n\\n- Space complexity:\\n63.68%\\n\\n# Code\\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n\\n      path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n\\n    dfs(root, [])\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n```\n```\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n```\n```\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n```\n```   path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n```\n```\\n    dfs(root, [])\\n    return ans\\n```\n```\\nclass Solution:\\n  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n    ans = []\\n\\n    def dfs(root: Optional[TreeNode], path: List[str]) -> None:\\n      if not root:\\n        return\\n      if not root.left and not root.right:\\n        ans.append(\\'\\'.join(path) + str(root.val))\\n        return\\n\\n      path.append(str(root.val) + \\'->\\')\\n      dfs(root.left, path)\\n      dfs(root.right, path)\\n      path.pop()\\n\\n    dfs(root, [])\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051305,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string path) {\\n        if(node->left == NULL and node->right == NULL) ans.push_back(path + to_string(node->val));\\n        if(node->left) dfs(node->left, path + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, path + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string path) {\\n        if(node->left == NULL and node->right == NULL) ans.push_back(path + to_string(node->val));\\n        if(node->left) dfs(node->left, path + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, path + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783039,
                "title": "java-backtracking-solution",
                "content": "```\\nRuntime: 5 ms, faster than 70.04% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 43 MB, less than 25.59% of Java online submissions for Binary Tree Paths.\\n```\\n\\n        \\n        public List<String> binaryTreePaths(TreeNode root) {\\n\\t\\t List<String> ans = new ArrayList<>();\\n        List<String> path = new ArrayList<>();\\n        \\n        reserve(root, ans, path);\\n        return ans;\\n    }\\n    \\n    public void reserve(TreeNode root, List<String> ans , List<String> path){\\n        if(root == null) return;\\n        \\n        path.add(root.val + \"\");\\n        if(root.left == null && root.right == null){\\n            ans.add(String.join(\"->\",path));\\n        }\\n        reserve(root.left, ans, path);\\n        reserve(root.right, ans, path);\\n        \\n        path.remove(path.size()-1);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nRuntime: 5 ms, faster than 70.04% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 43 MB, less than 25.59% of Java online submissions for Binary Tree Paths.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438679,
                "title": "99-80-faster-easy-solution",
                "content": "if you found the solution easy, please **Upvote**\\n\\n\\tclass Solution {\\n    List<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) \\n    {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    \\n    \\n    void helper(TreeNode node, StringBuilder slate)\\n    {\\n        if(node==null) return;\\n        \\n        int length = slate.length();\\n        slate.append(node.val);\\n        \\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        \\n        else\\n        {\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    List<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) \\n    {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1188771,
                "title": "c-simple-dfs-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>V;\\n    \\n    void dfs(TreeNode* root, string s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left == NULL and root->right==NULL)\\n        {\\n            V.push_back(s+to_string(root->val));\\n        }\\n        dfs(root->left, s+to_string(root->val)+\"->\");\\n        \\n        dfs(root->right, s+to_string(root->val)+\"->\");\\n        \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n     \\n        dfs(root, \"\");\\n        return V;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>V;\\n    \\n    void dfs(TreeNode* root, string s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left == NULL and root->right==NULL)\\n        {\\n            V.push_back(s+to_string(root->val));\\n        }\\n        dfs(root->left, s+to_string(root->val)+\"->\");\\n        \\n        dfs(root->right, s+to_string(root->val)+\"->\");\\n        \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n     \\n        dfs(root, \"\");\\n        return V;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760438,
                "title": "time-complexity-analysis-string-vs-stringbuilder",
                "content": "Time Complexity: number of paths * time complexity for each path.\\n\\n**Using Strings:**\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,\"\");\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, String str){\\n        str+= (str.length()==0) ? String.valueOf(root.val): \"->\"+String.valueOf(root.val);\\n        if(root.left==null && root.right==null) res.add(str);\\n        if(root.left!=null) binaryTreePaths(root.left,str);\\n        if(root.right!=null) binaryTreePaths(root.right,str);\\n    }\\n    \\n}\\n```\\n\\nWell balanced tree Case:\\n\\nThere will N/2 leaf nodes and max path length would be O(logn).\\nIn every path we traverse, we are adding a char to string, in every such operation a string is allocated (and copied, due to String immutability) for each node in this path, not just the leaves.\\nHence the complexity for a single path would be 1+ 2+ .....+ logn = O((logN)^2).\\nTotal complexity is O(N/2)*O(logN)^2) =  **O(N x (logN)^2).**\\n\\nNodes in Straight Line Case:\\n\\nHere there would be a single leaf path, which is of length N.\\nHence time complexity for this path: 1+2+3+..n = O(N^2).\\nSince we have a single path here, Total Complexity is =  **O(N^2).**\\n\\n**Using String Builder:**\\n\\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,new StringBuilder());\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, StringBuilder sb){        \\n        if(root==null) return;\\n        \\n        int len = sb.length();\\n        sb.append(root.val);\\n        \\n        if(root.left==null && root.right==null) \\n            res.add(sb.toString());\\n        else{\\n            sb.append(\"->\");\\n            binaryTreePaths(root.left,sb);\\n            binaryTreePaths(root.right,sb);\\n        }\\n       sb.setLength(len);\\n    }\\n}\\n```\\n\\nIn this above approach using stringBuilder i\\'m reusing the char array and unlike with string approach, the whole string will not be copied at each node. \\n\\nWell balanced tree Case:\\n\\nThere will N/2 leaf nodes and max path length would be O(logn).\\nIn a single path at every node we would only take O(1) time, so time complexity for a single path would be: O(logn)\\nHence total complexity is O(N/2)*O(logN)) = **O(N x (logN)).**\\n\\nNodes in Straight Line Case:\\n\\nSo here there would be a single leaf path, which is of length N.\\nSo time complexity for this path: O(N)\\nSince we have a single path here, total complexity = **O(N).**\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,\"\");\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, String str){\\n        str+= (str.length()==0) ? String.valueOf(root.val): \"->\"+String.valueOf(root.val);\\n        if(root.left==null && root.right==null) res.add(str);\\n        if(root.left!=null) binaryTreePaths(root.left,str);\\n        if(root.right!=null) binaryTreePaths(root.right,str);\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    List<String> res = new ArrayList();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null)\\n            return res;\\n        binaryTreePaths(root,new StringBuilder());\\n        return res;\\n    }\\n    \\n    public void binaryTreePaths(TreeNode root, StringBuilder sb){        \\n        if(root==null) return;\\n        \\n        int len = sb.length();\\n        sb.append(root.val);\\n        \\n        if(root.left==null && root.right==null) \\n            res.add(sb.toString());\\n        else{\\n            sb.append(\"->\");\\n            binaryTreePaths(root.left,sb);\\n            binaryTreePaths(root.right,sb);\\n        }\\n       sb.setLength(len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589072,
                "title": "clear-and-simple-c-solution-100-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        insertPaths(root, \"\", &result);\\n        return result;\\n    }\\nprivate:\\n\\t// simple recursive pre-order traversal\\n    void insertPaths(TreeNode* node, string str, vector<string>* res) {\\n        if (!node) return;  // base-case\\n        \\n        str += to_string(node->val);\\n        if (!node->left && !node->right) {\\n\\t\\t\\t// if the current node is a leaf, add string to result\\n            res->emplace_back(str);\\n        }\\n        \\n        insertPaths(node->left, str + \"->\", res);\\n        insertPaths(node->right, str + \"->\", res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        insertPaths(root, \"\", &result);\\n        return result;\\n    }\\nprivate:\\n\\t// simple recursive pre-order traversal\\n    void insertPaths(TreeNode* node, string str, vector<string>* res) {\\n        if (!node) return;  // base-case\\n        \\n        str += to_string(node->val);\\n        if (!node->left && !node->right) {\\n\\t\\t\\t// if the current node is a leaf, add string to result\\n            res->emplace_back(str);\\n        }\\n        \\n        insertPaths(node->left, str + \"->\", res);\\n        insertPaths(node->right, str + \"->\", res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556028,
                "title": "go-recursion-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Binary Tree Paths.\\nMemory Usage: 2.3 MB, less than 100.00% of Go online submissions for Binary Tree Paths.\\n```\\nvar arrow string = \"->\"\\n\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    ans := make([]string, 0)\\n    \\n    paths(root, \"\", &ans)\\n    \\n    return ans\\n}\\n\\nfunc paths(root *TreeNode, prefix string, ans *[]string) {\\n    if root == nil {\\n        return\\n    }\\n    \\n    if len(prefix) == 0 {\\n        prefix += strconv.Itoa(root.Val)\\n    } else {\\n        prefix += \"->\" + strconv.Itoa(root.Val)\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        *ans = append(*ans, prefix)\\n        return\\n    }\\n    \\n    paths(root.Left, prefix, ans)\\n    paths(root.Right, prefix, ans)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nvar arrow string = \"->\"\\n\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    ans := make([]string, 0)\\n    \\n    paths(root, \"\", &ans)\\n    \\n    return ans\\n}\\n\\nfunc paths(root *TreeNode, prefix string, ans *[]string) {\\n    if root == nil {\\n        return\\n    }\\n    \\n    if len(prefix) == 0 {\\n        prefix += strconv.Itoa(root.Val)\\n    } else {\\n        prefix += \"->\" + strconv.Itoa(root.Val)\\n    }\\n    \\n    if root.Left == nil && root.Right == nil {\\n        *ans = append(*ans, prefix)\\n        return\\n    }\\n    \\n    paths(root.Left, prefix, ans)\\n    paths(root.Right, prefix, ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68378,
                "title": "4ms-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n\\n        if(!root) return res;\\n        else if(!root->left && !root->right) res.push_back(to_string(root->val));\\n        \\n        string head = to_string(root->val) + \"->\";\\n        \\n        for(auto item: binaryTreePaths(root->left)) res.push_back(head + item);\\n        for(auto item: binaryTreePaths(root->right)) res.push_back(head + item);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n\\n        if(!root) return res;\\n        else if(!root->left && !root->right) res.push_back(to_string(root->val));\\n        \\n        string head = to_string(root->val) + \"->\";\\n        \\n        for(auto item: binaryTreePaths(root->left)) res.push_back(head + item);\\n        for(auto item: binaryTreePaths(root->right)) res.push_back(head + item);\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68499,
                "title": "c-a-clean-one-function-approach",
                "content": "    vector<string> binaryTreePaths(TreeNode* root) {\\n      if (root == nullptr)\\n        return {};\\n      if (root->left == nullptr && root->right == nullptr)\\n        return {to_string(root->val)};\\n    \\n      vector<string> left  = binaryTreePaths(root->left);\\n      vector<string> right = binaryTreePaths(root->right);\\n      left.insert(left.end(), begin(right), end(right));\\n      for (auto &e : left)\\n        e = to_string(root->val) + \"->\" + e;\\n      return left;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> binaryTreePaths(TreeNode* root) {\\n      if (root == nullptr)\\n        return {};\\n      if (root->left == nullptr && root->right == nullptr)\\n        return {to_string(root->val)};\\n    \\n      vector<string> left  = binaryTreePaths(root->left);\\n      vector<string> right = binaryTreePaths(root->right);\\n      left.insert(left.end(), begin(right), end(right));\\n      for (auto &e : left)\\n        e = to_string(root->val) + \"->\" + e;\\n      return left;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68526,
                "title": "c-recursive-and-iterative-solutions-with-detailed-comments",
                "content": "The recursive solution is trivial.\\n\\n    class Solution \\n    {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }\\n            \\n            // Get the path vector starting from the left child.\\n            vector<string> leftPaths = binaryTreePaths(root->left);\\n            // Concatenate root with the left paths to generate \\n            // the paths starting from root.\\n            for (auto& lp : leftPaths)\\n            {\\n                paths.push_back(to_string(root->val) + \"->\" + lp);\\n            }\\n            \\n            // Get the path vector starting from the right child.\\n            vector<string> rightPaths = binaryTreePaths(root->right);\\n            // Concatenate root with the right paths to generate \\n            // the paths starting from root.\\n            for (auto& rp : rightPaths)\\n            {\\n                paths.push_back(to_string(root->val) + \"->\" + rp);\\n            }\\n            \\n            // In case that both leftPaths and rightPaths are empty, \\n            // i.e., root is a leaf, root itself is a path.\\n            if (paths.empty())\\n            {\\n                paths.push_back(to_string(root->val));\\n            }\\n            \\n            return paths;\\n        }\\n    };\\n\\nThe iterative solution essentially uses the depth-first search to find all the paths from root to leaves. Compared with the breadth-first search approach, this approach doesn't need to have a vector of vectors to keep the paths from root to the nodes at the current level. Besides the result vector of strings, this approach just needs one vector which keeps one path from root to the current node and one unordered set which keeps all the nodes that have been visited during the depth-first search. Thus, with respect the space complexity, the depth-first search is more efficient than the breadth-first search.\\n\\n    class Solution \\n    {\\n        // Generate the path string from the TreeNode val vector.\\n        string GetPathStringFromNums(vector<int> &pathVal)\\n        {\\n            int n = pathVal.size();\\n            string res;\\n            // For the nodes except the last node, we need to \\n            // append \"->\" to the node values.\\n            for (int i = 0; i < n - 1; i++)\\n            {\\n                res += (to_string(pathVal[i]) + \"->\");\\n            }\\n            \\n            if (n > 0)\\n            {\\n                res += to_string(pathVal[n - 1]);\\n            }\\n            \\n            return res;\\n        }\\n        \\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector immediately.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }\\n            \\n            // pathVal is a vector of TreeNode values along a path \\n            // starting from root.\\n            vector<int> pathVal({root->val});\\n            \\n            // st is the stack used for the depth-first search.\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            \\n            // visitedNodes keeps all the nodes which have been visited \\n            // during the depth-first search. In other words, it keeps \\n            // all the nodes which have ever been pushed into the stack.\\n            unordered_set<TreeNode*> visitedNodes({root});\\n            \\n            // Do the depth-first search until the stack is empty.\\n            while (!st.empty())\\n            {\\n                TreeNode *curr = st.top();\\n    \\n                if ((curr->left == nullptr) && (curr->right == nullptr))\\n                {\\n                    // curr is a leaf, so the current path is a path from \\n                    // root to a leaf and add it to paths.\\n                    paths.push_back(GetPathStringFromNums(pathVal));\\n                    \\n                    // Remove the leaf node from pathVal which will end at \\n                    // the parent node of curr.\\n                    pathVal.pop_back();\\n                    \\n                    st.pop();\\n                }\\n                else \\n                {\\n                    // curr is not leaf, so we need to go down at least one \\n                    // level.\\n                    \\n                    // First we try pushing the left child if it hasn't \\n                    // been visited.\\n                    if (curr->left != nullptr)\\n                    {\\n                        auto itLeft = visitedNodes.find(curr->left);\\n                        if (itLeft == visitedNodes.end())\\n                        {\\n                            st.push(curr->left);\\n                            pathVal.push_back(curr->left->val);\\n                            \\n                            visitedNodes.insert(curr->left);\\n                            continue;\\n                        }\\n                    }\\n                    \\n                    // We reach here because either the left child doesn't \\n                    // exist or the left child has been visited. Then we try \\n                    // pushing the right child if it hasn't been visited.\\n                    if (curr->right != nullptr)\\n                    {\\n                        auto itRight = visitedNodes.find(curr->right);\\n                        if (itRight == visitedNodes.end())\\n                        {\\n                            st.push(curr->right);\\n                            pathVal.push_back(curr->right->val);\\n                            \\n                            visitedNodes.insert(curr->right);\\n                            continue;\\n                        }\\n                    }\\n                    \\n                    // The nodes in the subtree below curr have all been \\n                    // visited, so remove curr from pathVal which will end \\n                    // at the parent node of curr.\\n                    pathVal.pop_back();\\n                    st.pop();\\n                }\\n            }\\n            \\n            return paths;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution \\n    {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) \\n        {\\n            vector<string> paths;\\n            // If root is NULL, return an empty path vector.\\n            if (root == nullptr)\\n            {\\n                return paths;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2781823,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def backtrack(node, path, rst):\\n            children = (node.left, node.right)\\n            \\n            path.append(str(node.val))\\n\\n            if not any(children): # leaf\\n                rst.append(\\'->\\'.join(path))\\n                \\n            for child in filter(None, children):\\n                backtrack(child, path, rst)\\n                \\n            path.pop()\\n                    \\n            return rst\\n        \\n        return backtrack(root, [], [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        def backtrack(node, path, rst):\\n            children = (node.left, node.right)\\n            \\n            path.append(str(node.val))\\n\\n            if not any(children): # leaf\\n                rst.append(\\'->\\'.join(path))\\n                \\n            for child in filter(None, children):\\n                backtrack(child, path, rst)\\n                \\n            path.pop()\\n                    \\n            return rst\\n        \\n        return backtrack(root, [], [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509320,
                "title": "java-recursive-solution-dfs",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        List<String>res = new ArrayList<>();\\n        fillPaths(root,\"\",res);\\n        return res;\\n    }\\n    \\n    \\n   public void fillPaths(TreeNode node,String str,List<String> res)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        if(node.left == null && node.right == null)\\n        {\\n            res.add(str+node.val); \\n            return;\\n        }\\n          fillPaths(node.left, str+node.val+\"->\", res); \\n          fillPaths(node.right, str+node.val+\"->\", res); \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        List<String>res = new ArrayList<>();\\n        fillPaths(root,\"\",res);\\n        return res;\\n    }\\n    \\n    \\n   public void fillPaths(TreeNode node,String str,List<String> res)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        if(node.left == null && node.right == null)\\n        {\\n            res.add(str+node.val); \\n            return;\\n        }\\n          fillPaths(node.left, str+node.val+\"->\", res); \\n          fillPaths(node.right, str+node.val+\"->\", res); \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583284,
                "title": "javascript-solution",
                "content": "```\\n\\nvar binaryTreePaths = function(root) {\\n    let result = [];\\n    traverse(root, \"\");\\n    \\n    function traverse(node, path) {\\n        if (!node) \\n            return;\\n \\n        if (!node.left  && !node.right) {\\n            result.push(path + node.val);\\n            return;\\n        }\\n        traverse(node.left, path + node.val + \"->\");\\n        traverse(node.right, path + node.val + \"->\");\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nvar binaryTreePaths = function(root) {\\n    let result = [];\\n    traverse(root, \"\");\\n    \\n    function traverse(node, path) {\\n        if (!node) \\n            return;\\n \\n        if (!node.left  && !node.right) {\\n            result.push(path + node.val);\\n            return;\\n        }\\n        traverse(node.left, path + node.val + \"->\");\\n        traverse(node.right, path + node.val + \"->\");\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237550,
                "title": "python-solution",
                "content": "Time complexity: `O(n + h*m)`, where `n` = # of nodes in the tree, `h` = height of the tree, and `m` = # of leaf nodes of the tree. In worse case, this is `O(n log n)`. Space complexity: `O(h*m)`. In worst case, this is `O(n log n)`.  \\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: \\'TreeNode\\') -> \\'List[str]\\':\\n        def dfs(root):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                tmp.append(str(root.val))\\n                res.append(\"->\".join(tmp))\\n                tmp.pop()\\n                return\\n            tmp.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n            tmp.pop()\\n        tmp = []\\n        res = []\\n        dfs(root)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: \\'TreeNode\\') -> \\'List[str]\\':\\n        def dfs(root):\\n            if not root:\\n                return\\n            if not root.left and not root.right:\\n                tmp.append(str(root.val))\\n                res.append(\"->\".join(tmp))\\n                tmp.pop()\\n                return\\n            tmp.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n            tmp.pop()\\n        tmp = []\\n        res = []\\n        dfs(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68463,
                "title": "2ms-java-recursive-solution-with-explaination",
                "content": "The idea is to perform a dfs, for every node we visit the path up till that node is path + currentNode.val and when we see that a node has no children we know this is one of the valid path.\\n\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> result = new ArrayList<String>();\\n        helper(root, result, \"\");\\n        return result;\\n    }\\n    public void helper(TreeNode root, List<String> result, String path){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left == null && root.right == null){\\n            result.add(path+root.val);\\n            return;\\n        }\\n        \\n        helper(root.left, result, path+root.val+\"->\");\\n        helper(root.right, result, path+root.val+\"->\");\\n        return;\\n    }",
                "solutionTags": [],
                "code": "The idea is to perform a dfs, for every node we visit the path up till that node is path + currentNode.val and when we see that a node has no children we know this is one of the valid path.\\n\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> result = new ArrayList<String>();\\n        helper(root, result, \"\");\\n        return result;\\n    }\\n    public void helper(TreeNode root, List<String> result, String path){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left == null && root.right == null){\\n            result.add(path+root.val);\\n            return;\\n        }\\n        \\n        helper(root.left, result, path+root.val+\"->\");\\n        helper(root.right, result, path+root.val+\"->\");\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68260,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null){\\n            return new ArrayList<>();\\n        }\\n        List<String> returnList = new ArrayList<>();\\n        getBinaryTreePaths(returnList,root,\"\");\\n        return returnList;\\n\\n    }\\n\\n    private void getBinaryTreePaths(List<String> returnList, TreeNode node,String base) {\\n        String current = base.length()==0?node.val+\"\":base+\"->\"+node.val;\\n        if(node.left == null && node.right == null){\\n            returnList.add(current);\\n        }\\n        if (node.left != null){\\n            getBinaryTreePaths(returnList,node.left,current);\\n        }\\n        if (node.right != null){\\n            getBinaryTreePaths(returnList,node.right,current);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     public List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null){\\n            return new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3447521,
                "title": "c-accepted-using-recursion-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryPaths(TreeNode* root) {\\n      vector<string> ans;\\n     // base condition   \\n      if(root==NULL){\\n       return ans;\\n      }\\n        if(root->left ==NULL && root->right ==NULL){\\n          ans.push_back(to_string(root->val));\\n       return ans;\\n      }\\n// recursion for triversing on all node\\n     vector<string> leftt =  binaryPaths(root->left); \\n     vector<string> rightt =  binaryPaths(root->right); \\n //to add root data and -> on all solution under that node    \\n     for(int i=0;i<leftt.size();i++){\\n      ans.push_back (to_string(root->val)+\"->\"+leftt[i]);\\n     }\\n     for(int j=0;j<rightt.size();j++){\\n      ans.push_back (to_string(root->val)+\"->\"+rightt[j]);\\n     }\\n   \\n     return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n    vector<string> ans;   \\n    ans = binaryPaths(root) ;\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryPaths(TreeNode* root) {\\n      vector<string> ans;\\n     // base condition   \\n      if(root==NULL){\\n       return ans;\\n      }\\n        if(root->left ==NULL && root->right ==NULL){\\n          ans.push_back(to_string(root->val));\\n       return ans;\\n      }\\n// recursion for triversing on all node\\n     vector<string> leftt =  binaryPaths(root->left); \\n     vector<string> rightt =  binaryPaths(root->right); \\n //to add root data and -> on all solution under that node    \\n     for(int i=0;i<leftt.size();i++){\\n      ans.push_back (to_string(root->val)+\"->\"+leftt[i]);\\n     }\\n     for(int j=0;j<rightt.size();j++){\\n      ans.push_back (to_string(root->val)+\"->\"+rightt[j]);\\n     }\\n   \\n     return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n    vector<string> ans;   \\n    ans = binaryPaths(root) ;\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072837,
                "title": "back-tracking-4ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void BackTrack(TreeNode* root,string s,vector<string> &v)\\n    {\\n        if(root->left==NULL && root->right==NULL)\\n            s=s+to_string(root->val);\\n            v.push_back(s);\\n            return ;\\n        s=s+to_string(root->val)+\"->\";\\n        if(root->left!=NULL)\\n            BackTrack(root->left,s,v);\\n        if(root->right!=NULL)\\n            BackTrack(root->right,s,v);\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        BackTrack(root,\"\",v);\\n        return v;\\n    }\\n};// UPVOTE PLEASE\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void BackTrack(TreeNode* root,string s,vector<string> &v)\\n    {\\n        if(root->left==NULL && root->right==NULL)\\n            s=s+to_string(root->val);\\n            v.push_back(s);\\n            return ;\\n        s=s+to_string(root->val)+\"->\";\\n        if(root->left!=NULL)\\n            BackTrack(root->left,s,v);\\n        if(root->right!=NULL)\\n            BackTrack(root->right,s,v);\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        BackTrack(root,\"\",v);\\n        return v;\\n    }\\n};// UPVOTE PLEASE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597790,
                "title": "c-dfs-easy-commented-and-readable",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        void solve(TreeNode *root, vector<string> &ans, string s)\\n        {\\n           \\t// if the current node is not having either a left or a right then we are \\n           \\t// done with one root to leaf path so we push it into the answer\\n            if (!root->left && !root->right)\\n            {\\n                ans.push_back(s);\\n                return;\\n            }\\n\\n           \\t// we move towards either left of the root or right of the root, whichever\\n           \\t// suitable adding the current node\\'s value to the string and moving ahead\\n           \\t// this addition to our string goes on until we find our base condition break\\n            if (root->left) solve(root->left, ans, s + \"->\" + to_string(root->left->val));\\n            if (root->right) solve(root->right, ans, s + \"->\" + to_string(root->right->val));\\n        }\\n\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> ans;\\n        if (!root) return ans;\\n       \\t// we make the value of our root node as a string\\n        string s = to_string(root->val);\\n        solve(root, ans, to_string(root->val));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        void solve(TreeNode *root, vector<string> &ans, string s)\\n        {\\n           \\t// if the current node is not having either a left or a right then we are \\n           \\t// done with one root to leaf path so we push it into the answer\\n            if (!root->left && !root->right)\\n            {\\n                ans.push_back(s);\\n                return;\\n            }\\n\\n           \\t// we move towards either left of the root or right of the root, whichever\\n           \\t// suitable adding the current node\\'s value to the string and moving ahead\\n           \\t// this addition to our string goes on until we find our base condition break\\n            if (root->left) solve(root->left, ans, s + \"->\" + to_string(root->left->val));\\n            if (root->right) solve(root->right, ans, s + \"->\" + to_string(root->right->val));\\n        }\\n\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> ans;\\n        if (!root) return ans;\\n       \\t// we make the value of our root node as a string\\n        string s = to_string(root->val);\\n        solve(root, ans, to_string(root->val));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981927,
                "title": "simple-python-recursive-solution-using-preorder-traversal-with-explanation",
                "content": "**VOTE  UP  IF  YOU  LIKE  AND  UNDERSTAND  THE  SOLUTION**\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans=[]           # resultant list containing all paths.\\n        def preorder(root,s):\\n            if not root.left and not root.right:        # If leaf node occurs then path ends here so append the string in \\'ans\\'.\\n                ans.append(s+str(root.val))\\n                return\\n            s+=str(root.val)        # concatenate value of root in the path \\n            if root.left:                # If there is any node in left to traverse\\n                preorder(root.left,s+\"->\")\\n            if root.right:             # If there is any node in right to traverse\\n                preorder(root.right,s+\"->\")\\n            return\\n\\t\\t\\t\\n        preorder(root,\"\")         # main calling of preOrder with empty string\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/9143281d-9a54-419f-84a4-f00740fd4567_1650906957.1431794.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans=[]           # resultant list containing all paths.\\n        def preorder(root,s):\\n            if not root.left and not root.right:        # If leaf node occurs then path ends here so append the string in \\'ans\\'.\\n                ans.append(s+str(root.val))\\n                return\\n            s+=str(root.val)        # concatenate value of root in the path \\n            if root.left:                # If there is any node in left to traverse\\n                preorder(root.left,s+\"->\")\\n            if root.right:             # If there is any node in right to traverse\\n                preorder(root.right,s+\"->\")\\n            return\\n\\t\\t\\t\\n        preorder(root,\"\")         # main calling of preOrder with empty string\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706552,
                "title": "c-simple-using-preorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void preorder(TreeNode* root, string str){\\n        \\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> right == NULL and root -> left  == NULL){\\n            string x = to_string(root -> val);\\n            str.append(x);\\n            ans.push_back(str);\\n        }\\n        string x = to_string(root -> val);\\n        str.append(x);\\n        str.append(\"->\");\\n        preorder(root-> left, str);\\n        preorder(root -> right, str);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void preorder(TreeNode* root, string str){\\n        \\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> right == NULL and root -> left  == NULL){\\n            string x = to_string(root -> val);\\n            str.append(x);\\n            ans.push_back(str);\\n        }\\n        string x = to_string(root -> val);\\n        str.append(x);\\n        str.append(\"->\");\\n        preorder(root-> left, str);\\n        preorder(root -> right, str);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157075,
                "title": "java-clean-code-backtracking-1ms-99-86-38-7mb-96-85",
                "content": "With `List<Integer> tmp`:\\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new ArrayList<>(), new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, List<Integer> tmp, StringBuilder sb) {\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tfor (int val : tmp) {\\n\\t\\t\\tsb.append(val).append(\"->\");\\n\\t\\t}\\n\\t\\tsb.append(node.val);\\n\\t\\tcollector.add(sb.toString());\\n\\t\\tsb.setLength(0);\\n\\t\\treturn;\\n\\t}\\n\\ttmp.add(node.val);\\n\\tif (node.left != null) backTracking(node.left, collector, tmp, sb);\\n\\tif (node.right != null) backTracking(node.right, collector, tmp, sb);\\n\\ttmp.remove(tmp.size()-1);\\n}\\n```\\n\\n\\n---\\nWithout `List<Integer> tmp`:\\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, StringBuilder sb) {\\n\\tint len = sb.length();\\n\\tsb.append(node.val);\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tcollector.add(sb.toString());\\n\\t} else {\\n\\t\\tsb.append(\"->\");\\n\\t\\tif (node.left != null) backTracking(node.left, collector, sb);\\n\\t\\tif (node.right != null) backTracking(node.right, collector, sb);\\n\\t}\\n\\tsb.setLength(len);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new ArrayList<>(), new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, List<Integer> tmp, StringBuilder sb) {\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tfor (int val : tmp) {\\n\\t\\t\\tsb.append(val).append(\"->\");\\n\\t\\t}\\n\\t\\tsb.append(node.val);\\n\\t\\tcollector.add(sb.toString());\\n\\t\\tsb.setLength(0);\\n\\t\\treturn;\\n\\t}\\n\\ttmp.add(node.val);\\n\\tif (node.left != null) backTracking(node.left, collector, tmp, sb);\\n\\tif (node.right != null) backTracking(node.right, collector, tmp, sb);\\n\\ttmp.remove(tmp.size()-1);\\n}\\n```\n```\\npublic List<String> binaryTreePaths(TreeNode root) {\\n\\tList<String> res = new LinkedList<>();\\n\\tbackTracking(root, res, new StringBuilder());\\n\\treturn res;\\n}\\nprivate void backTracking(TreeNode node, List<String> collector, StringBuilder sb) {\\n\\tint len = sb.length();\\n\\tsb.append(node.val);\\n\\tif (node.left == null && node.right == null) {\\n\\t\\tcollector.add(sb.toString());\\n\\t} else {\\n\\t\\tsb.append(\"->\");\\n\\t\\tif (node.left != null) backTracking(node.left, collector, sb);\\n\\t\\tif (node.right != null) backTracking(node.right, collector, sb);\\n\\t}\\n\\tsb.setLength(len);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520487,
                "title": "c-faster-than-97-10-less-than-16-67-mem-o-n",
                "content": "Runtime: 236 ms\\nMemory Usage: 31.6 MB\\n\\n```\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        IList<string> result = new List<string>();\\n        StringBuilder st = new StringBuilder();\\n        BuildPath(root, st, result);\\n        return result;\\n    }\\n    \\n    private void BuildPath(TreeNode root, StringBuilder st, IList<string> result)\\n    {\\n        if (root == null) { return; }\\n        \\n        int len = st.Length; \\n        \\n        st.Append(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            result.Add(st.ToString());\\n        }\\n        else\\n        {\\n            st.Append(\"->\");\\n            BuildPath(root.left, st, result);\\n            BuildPath(root.right, st, result);\\n        }\\n        \\n        st.Length = len;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Runtime: 236 ms\\nMemory Usage: 31.6 MB\\n\\n```\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        IList<string> result = new List<string>();\\n        StringBuilder st = new StringBuilder();\\n        BuildPath(root, st, result);\\n        return result;\\n    }\\n    \\n    private void BuildPath(TreeNode root, StringBuilder st, IList<string> result)\\n    {\\n        if (root == null) { return; }\\n        \\n        int len = st.Length; \\n        \\n        st.Append(root.val);\\n        \\n        if (root.left == null && root.right == null) {\\n            result.Add(st.ToString());\\n        }\\n        else\\n        {\\n            st.Append(\"->\");\\n            BuildPath(root.left, st, result);\\n            BuildPath(root.right, st, result);\\n        }\\n        \\n        st.Length = len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68437,
                "title": "my-java-solution-with-stringbuilder-may-help-u",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public void help(List<String> list, TreeNode node, StringBuilder sb) {\\n    \\t\\tif (node == null)\\n    \\t\\t\\treturn;\\n    \\t\\tint len=sb.length();\\n    \\t\\tsb.append(node.val);\\n    \\t\\tif (node.left == null && node.right == null) {\\t\\t\\t\\t\\n    \\t\\t\\tlist.add(sb.toString());\\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tsb.append(\"->\");\\n    \\t\\thelp(list, node.left, sb);\\n    \\t\\thelp(list, node.right, sb);\\n    \\t\\tsb.setLength(len);\\n    \\t}\\n    \\n    \\tpublic List<String> binaryTreePaths(TreeNode root) {\\n    \\t\\tList<String> res = new ArrayList<String>();\\n    \\t\\thelp(res, root, new StringBuilder());\\n    \\t\\treturn res;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void help(List<String> list, TreeNode node, StringBuilder sb) {\\n    \\t\\tif (node == null)\\n    \\t\\t\\treturn;\\n    \\t\\tint len=sb.length();\\n    \\t\\tsb.append(node.val);\\n    \\t\\tif (node.left == null && node.right == null) {\\t\\t\\t\\t\\n    \\t\\t\\tlist.add(sb.toString());\\n    \\t\\t\\tsb.setLength(len);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 68489,
                "title": "my-recursive-javascript-solution",
                "content": "     /**\\n     * Definition for a binary tree node.\\n     * function TreeNode(val) {\\n     *     this.val = val;\\n     *     this.left = this.right = null;\\n     * }\\n     */\\n    /**\\n     * @param {TreeNode} root\\n     * @return {string[]}\\n     */\\n    var binaryTreePaths = function(root) {\\n        var result = [];\\n    \\n        var findPath = function(node, path) {\\n            if(!node) {\\n                return;\\n            } else {\\n                path += node.val;\\n            }\\n            \\n            if(!node.left && !node.right) {\\n                return result.push(path);\\n            } else {\\n                path += \"->\";\\n            }\\n            \\n            if(node.left) {\\n                findPath(node.left, path);\\n            }\\n            \\n            if(node.right) {\\n                findPath(node.right, path);\\n            }\\n        }\\n        \\n        findPath(root, \"\");\\n        return result;\\n    };",
                "solutionTags": [],
                "code": "     /**\\n     * Definition for a binary tree node.\\n     * function TreeNode(val) {\\n     *     this.val = val;\\n     *     this.left = this.right = null;\\n     * }\\n     */\\n    /**\\n     * @param {TreeNode} root\\n     * @return {string[]}\\n     */\\n    var binaryTreePaths = function(root) {\\n        var result = [];\\n    \\n        var findPath = function(node, path) {\\n            if(!node) {\\n                return;\\n            } else {\\n                path += node.val;\\n            }\\n            \\n            if(!node.left && !node.right) {\\n                return result.push(path);\\n            } else {\\n                path += \"->\";\\n            }\\n            \\n            if(node.left) {\\n                findPath(node.left, path);\\n            }\\n            \\n            if(node.right) {\\n                findPath(node.right, path);\\n            }\\n        }\\n        \\n        findPath(root, \"\");\\n        return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 68520,
                "title": "myjavaeasysolution",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<String>();\\n        if(root != null){\\n            res.addAll(binaryTreePaths(root.left));\\n            res.addAll(binaryTreePaths(root.right));\\n            for(int i=0; i < res.size();i++){\\n                String path = root.val+\"->\"+res.get(i);\\n                res.set(i,path);\\n            }\\n            \\n            if(res.size()==0) res.add(String.valueOf(root.val));\\n        }\\n        return res;\\n         \\n    }",
                "solutionTags": [],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<String>();\\n        if(root != null){\\n            res.addAll(binaryTreePaths(root.left));\\n            res.addAll(binaryTreePaths(root.right));\\n            for(int i=0; i < res.size();i++){\\n                String path = root.val+\"->\"+res.get(i);\\n                res.set(i,path);\\n            }\\n            \\n            if(res.size()==0) res.add(String.valueOf(root.val));\\n        }\\n        return res;\\n         \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3654265,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<string> &res, TreeNode *root, string cur)\\n    {\\n        if(!root->left && !root->right) res.push_back(cur  + std::to_string(root->val));\\n        else\\n        {\\n            if(root->left) dfs(res, root->left,  cur  + std::to_string(root->val)+\"->\");\\n            if(root->right) dfs(res, root->right, cur  + std::to_string(root->val)+\"->\");\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> res;\\n        if(root)  dfs(res, root, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520019,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode * root, vector<string>&ans, string s)\\n    {\\n        if(!root)return;\\n        if(!root->left && !root->right)\\n        {\\n            s += to_string(root->val);\\n            ans.push_back(s);\\n        }\\n        s += to_string(root->val);\\n        solve(root->left, ans, s+\"->\");\\n        solve(root->right, ans, s+\"->\");\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string s = \"\";\\n        vector<string>ans;\\n        solve(root, ans, s);    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode * root, vector<string>&ans, string s)\\n    {\\n        if(!root)return;\\n        if(!root->left && !root->right)\\n        {\\n            s += to_string(root->val);\\n            ans.push_back(s);\\n        }\\n        s += to_string(root->val);\\n        solve(root->left, ans, s+\"->\");\\n        solve(root->right, ans, s+\"->\");\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string s = \"\";\\n        vector<string>ans;\\n        solve(root, ans, s);    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168127,
                "title": "binary-tree-path-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPre-order traversal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0. Do the pre-order traversal.\\n1. Kepp collecting the node values in an array.\\n2. As soon as get the leaf child, push the current collection of nodes in the answer array.\\n3. At end just convert all the paths as per output requirement\\n4. Return you final collection of paths\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(no. of nodes in widest level)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {string[]}\\n */\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n\\n    function preOrder(node,currPath){\\n        if(node){\\n            currPath.push(node.val);\\n            if(node.left==null && node.right==null){\\n                paths.push([...currPath]);\\n            }\\n            preOrder(node.left,[...currPath]);\\n            preOrder(node.right,[...currPath]);\\n        }\\n    }\\n    preOrder(root,[]);\\n    let ans = paths.map(path => path.join(\"->\"))\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {string[]}\\n */\\nvar binaryTreePaths = function(root) {\\n    let paths = [];\\n\\n    function preOrder(node,currPath){\\n        if(node){\\n            currPath.push(node.val);\\n            if(node.left==null && node.right==null){\\n                paths.push([...currPath]);\\n            }\\n            preOrder(node.left,[...currPath]);\\n            preOrder(node.right,[...currPath]);\\n        }\\n    }\\n    preOrder(root,[]);\\n    let ans = paths.map(path => path.join(\"->\"))\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642914,
                "title": "python-recursive-approach-easy-to-understand",
                "content": "**Approach 1:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        result = []\\n        def dfs(temp, root):\\n            if root:\\n                temp = temp + str(root.val) + \\'->\\'\\n                if not root.left and not root.right:\\n                    result.append(temp[:-2])\\n                dfs(temp, root.left)\\n                dfs(temp, root.right)\\n        dfs(\\'\\', root)\\n        return result\\n```\\n**Approach 2:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return []\\n        result, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.right and not node.left:\\n                result.append(ls+str(node.val))\\n            if node.right:\\n                stack.append([node.right, ls + str(node.val) + \\'->\\'])\\n            if node.left:\\n                stack.append([node.left, ls + str(node.val) + \\'->\\'])\\n        return result\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        result = []\\n        def dfs(temp, root):\\n            if root:\\n                temp = temp + str(root.val) + \\'->\\'\\n                if not root.left and not root.right:\\n                    result.append(temp[:-2])\\n                dfs(temp, root.left)\\n                dfs(temp, root.right)\\n        dfs(\\'\\', root)\\n        return result\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return []\\n        result, stack = [], [(root, \"\")]\\n        while stack:\\n            node, ls = stack.pop()\\n            if not node.right and not node.left:\\n                result.append(ls+str(node.val))\\n            if node.right:\\n                stack.append([node.right, ls + str(node.val) + \\'->\\'])\\n            if node.left:\\n                stack.append([node.left, ls + str(node.val) + \\'->\\'])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584597,
                "title": "java-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> list = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        dfs(root,s);\\n        return list;\\n    }\\n    public void dfs(TreeNode root, String s){\\n        if(root!=null){\\n            if(root.left==null && root.right==null){\\n                list.add(s+root.val);\\n            }\\n            dfs(root.left,s+root.val+\"->\");\\n            dfs(root.right,s+root.val+\"->\");\\n        }\\n    }\\n}\\n```\\n# upvote if u found it useful",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> list = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        dfs(root,s);\\n        return list;\\n    }\\n    public void dfs(TreeNode root, String s){\\n        if(root!=null){\\n            if(root.left==null && root.right==null){\\n                list.add(s+root.val);\\n            }\\n            dfs(root.left,s+root.val+\"->\");\\n            dfs(root.right,s+root.val+\"->\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523403,
                "title": "python-solutions-using-dfs-and-bfs",
                "content": "## DFS with Recursion\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n    \\n        res = []\\n        def paths(root, path):\\n            if not any([root.left, root.right]):\\n                res.append(path)\\n                \\n            paths(root.left, path + \\'->\\' + str(root.left.val)) if root.left else None\\n            paths(root.right, path + \\'->\\' + str(root.right.val)) if root.right else None\\n        \\n        paths(root, str(root.val))\\n        return res\\n```\\n\\n## BFS Iterative Solution\\n\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n        \\n        q=[(root, str(root.val))]\\n        res = []\\n        \\n        while q:\\n            \\n            node, path_upto_node = q.pop()\\n            \\n            if not any([node.left, node.right]):\\n                res.append(path_upto_node)\\n            \\n            else:\\n                q.append((node.left, path_upto_node + \\'->\\' + str(node.left.val))) if node.left else None\\n                q.append((node.right, path_upto_node + \\'->\\' + str(node.right.val))) if node.right else None\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n    \\n        res = []\\n        def paths(root, path):\\n            if not any([root.left, root.right]):\\n                res.append(path)\\n                \\n            paths(root.left, path + \\'->\\' + str(root.left.val)) if root.left else None\\n            paths(root.right, path + \\'->\\' + str(root.right.val)) if root.right else None\\n        \\n        paths(root, str(root.val))\\n        return res\\n```\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root: return None\\n        \\n        q=[(root, str(root.val))]\\n        res = []\\n        \\n        while q:\\n            \\n            node, path_upto_node = q.pop()\\n            \\n            if not any([node.left, node.right]):\\n                res.append(path_upto_node)\\n            \\n            else:\\n                q.append((node.left, path_upto_node + \\'->\\' + str(node.left.val))) if node.left else None\\n                q.append((node.right, path_upto_node + \\'->\\' + str(node.right.val))) if node.right else None\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335365,
                "title": "c-easy-beats-100",
                "content": "\\n    vector<string> ans; \\n    \\n    void treePath(TreeNode* root, string s){\\n        if(!root) return; // Base case\\n        s += to_string(root->val); // Adding the current node\\'s value to string\\n\\t\\t\\n\\t\\t// if root has any of the the child present then only add \"->\" to current string\\n        if(root->left || root->right){ \\n            s += \"->\";\\n        }\\n\\t\\t\\n\\t\\t// if current node has no children then push the current string to ans vector\\n        if(!root->left && !root->right){\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t// recursive call\\n        treePath(root->left,s);\\n        treePath(root->right,s);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        treePath(root,\"\");\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "\\n    vector<string> ans; \\n    \\n    void treePath(TreeNode* root, string s){\\n        if(!root) return; // Base case\\n        s += to_string(root->val); // Adding the current node\\'s value to string\\n\\t\\t\\n\\t\\t// if root has any of the the child present then only add \"->\" to current string\\n        if(root->left || root->right){ \\n            s += \"->\";\\n        }\\n\\t\\t\\n\\t\\t// if current node has no children then push the current string to ans vector\\n        if(!root->left && !root->right){\\n            ans.push_back(s);\\n            return;\\n        }\\n\\t\\t// recursive call\\n        treePath(root->left,s);\\n        treePath(root->right,s);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        treePath(root,\"\");\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1650763,
                "title": "java-dfs-short-simple-100-faster",
                "content": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new LinkedList<>();\\n        paths(root,\"\");\\n        return ans;\\n    }\\n    void paths(TreeNode root, String s){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left==null && root.right==null){\\n            ans.add(s.concat(String.valueOf(root.val)));\\n        }\\n        paths(root.left, s.concat(String.valueOf(root.val).concat(\"->\")));\\n        paths(root.right, s.concat(String.valueOf(root.val).concat(\"->\")));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new LinkedList<>();\\n        paths(root,\"\");\\n        return ans;\\n    }\\n    void paths(TreeNode root, String s){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left==null && root.right==null){\\n            ans.add(s.concat(String.valueOf(root.val)));\\n        }\\n        paths(root.left, s.concat(String.valueOf(root.val).concat(\"->\")));\\n        paths(root.right, s.concat(String.valueOf(root.val).concat(\"->\")));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625427,
                "title": "c-understanble-recursion",
                "content": "**_Upvote if you found solution useful_**\\n\\n---\\n```C++\\nclass Solution\\n{\\npublic:\\n    void solve(TreeNode *root, vector<string> &res, string curr)\\n    {\\n        if (root->left == NULL and root->right == NULL)\\n        {\\n            curr += to_string(root->val);\\n            res.push_back(curr);\\n            return;\\n        }\\n        string s = to_string(root->val) + \"->\";\\n        if (root->left and !root->right)\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n        }\\n        else if (root->right and !root->left)\\n        {\\n            curr += s;\\n            solve(root->right, res, curr);\\n        }\\n        else\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n            solve(root->right, res, curr);\\n        }\\n    }\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> res;\\n        solve(root, res, \"\");\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    void solve(TreeNode *root, vector<string> &res, string curr)\\n    {\\n        if (root->left == NULL and root->right == NULL)\\n        {\\n            curr += to_string(root->val);\\n            res.push_back(curr);\\n            return;\\n        }\\n        string s = to_string(root->val) + \"->\";\\n        if (root->left and !root->right)\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n        }\\n        else if (root->right and !root->left)\\n        {\\n            curr += s;\\n            solve(root->right, res, curr);\\n        }\\n        else\\n        {\\n            curr += s;\\n            solve(root->left, res, curr);\\n            solve(root->right, res, curr);\\n        }\\n    }\\n    vector<string> binaryTreePaths(TreeNode *root)\\n    {\\n        vector<string> res;\\n        solve(root, res, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590704,
                "title": "simple-c-soln-using-preorder-traversal",
                "content": "Please upvote if found useful! :))\\nNew suggestions are welcome!\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void preorder(TreeNode *root,string temp){       \\n        if(!root)\\n            return;\\n        //add the current node value\\n        if(temp == \"\") temp += to_string(root->val);\\n        else temp += \"->\"+to_string(root->val);\\n        //if the current node is leaf, then add it to the answer array\\n        if(root->left==NULL && root->right==NULL)\\n            ans.push_back(temp);\\n        //perform preorder traversal\\n        preorder(root->left,temp);\\n        preorder(root->right,temp);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(!root) return ans;\\n        preorder(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void preorder(TreeNode *root,string temp){       \\n        if(!root)\\n            return;\\n        //add the current node value\\n        if(temp == \"\") temp += to_string(root->val);\\n        else temp += \"->\"+to_string(root->val);\\n        //if the current node is leaf, then add it to the answer array\\n        if(root->left==NULL && root->right==NULL)\\n            ans.push_back(temp);\\n        //perform preorder traversal\\n        preorder(root->left,temp);\\n        preorder(root->right,temp);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(!root) return ans;\\n        preorder(root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470608,
                "title": "c-0ms-100-beats",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void fun(TreeNode* root,string s)\\n    {\\n        if(!root->left && !root->right) ans.push_back(s);\\n        if(root->left) fun(root->left,s+\"->\"+to_string(root->left->val));\\n        if(root->right) fun(root->right,s+\"->\"+to_string(root->right->val));\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        s+=to_string(root->val);\\n        fun(root,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void fun(TreeNode* root,string s)\\n    {\\n        if(!root->left && !root->right) ans.push_back(s);\\n        if(root->left) fun(root->left,s+\"->\"+to_string(root->left->val));\\n        if(root->right) fun(root->right,s+\"->\"+to_string(root->right->val));\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        string s=\"\";\\n        s+=to_string(root->val);\\n        fun(root,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367748,
                "title": "java-stringbuilder-recursion-preorder-easy-1ms-solution",
                "content": "Create a String or StringBuilder(mutable) traverse the tree in preOrder, add node Values until you find a null & at leaf add the node and return.\\n```\\n List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new ArrayList<>();\\n        solve(root, new StringBuilder());\\n        return ans;\\n    }\\n    public void solve(TreeNode root, StringBuilder res){\\n        if(root == null)\\n            return;\\n        \\n        int len = res.length();\\n        res.append(root.val);\\n        if(root.left == null && root.right == null){\\n            ans.add(res.toString());\\n        }\\n        else{\\n            res.append(\"->\");\\n            if(root.left != null)\\n                solve(root.left, res);\\n            if(root.right != null)\\n                solve(root.right, res);\\n        }\\n        res.setLength(len);\\n    }\\n```\\nTime Complexity : `O(N)`\\nN number of nodes\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n List<String> ans;\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ans = new ArrayList<>();\\n        solve(root, new StringBuilder());\\n        return ans;\\n    }\\n    public void solve(TreeNode root, StringBuilder res){\\n        if(root == null)\\n            return;\\n        \\n        int len = res.length();\\n        res.append(root.val);\\n        if(root.left == null && root.right == null){\\n            ans.add(res.toString());\\n        }\\n        else{\\n            res.append(\"->\");\\n            if(root.left != null)\\n                solve(root.left, res);\\n            if(root.right != null)\\n                solve(root.right, res);\\n        }\\n        res.setLength(len);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574735,
                "title": "java-dfs-recursive-easy-to-understand-with-explaination",
                "content": "The template function is quite straightforward.\\nIn the recursive function, we first check if the root is null, then it will return without doing anything (this covers the original test case of root being null, as the empty res will be returned). Now, we add the value of the root to the current path string value.\\nbecause we need the path with arrows, pass the string with arrows in the dfs recursion calls.\\nNo need to check for empty root.left or root.right, because it is taken care of at the start of the recursive function.\\nAt the end, check if both children are null. If so, add the current string to the res list.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        writePaths(root, res, \"\");\\n        return res;\\n    }\\n    public void writePaths(TreeNode root, List<String> res, String curr){\\n        if(root == null) return;\\n        curr += root.val;\\n        writePaths(root.left, res, curr+\"->\");\\n        writePaths(root.right, res, curr+\"->\");\\n        if(root.left == null && root.right == null) res.add(curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res = new ArrayList<>();\\n        writePaths(root, res, \"\");\\n        return res;\\n    }\\n    public void writePaths(TreeNode root, List<String> res, String curr){\\n        if(root == null) return;\\n        curr += root.val;\\n        writePaths(root.left, res, curr+\"->\");\\n        writePaths(root.right, res, curr+\"->\");\\n        if(root.left == null && root.right == null) res.add(curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299070,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        var result = new List<string>();\\n        DFS(root, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, IList<string> oneResult, IList<string> result) {\\n        if (root == null) return;\\n        oneResult.Add($\"{root.val}\");\\n        if (root.left == null && root.right == null) {\\n            // leaf\\n            result.Add(string.Join(\"->\", oneResult));\\n        } else {\\n            DFS(root.left, oneResult, result);\\n            DFS(root.right, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        var result = new List<string>();\\n        DFS(root, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(TreeNode root, IList<string> oneResult, IList<string> result) {\\n        if (root == null) return;\\n        oneResult.Add($\"{root.val}\");\\n        if (root.left == null && root.right == null) {\\n            // leaf\\n            result.Add(string.Join(\"->\", oneResult));\\n        } else {\\n            DFS(root.left, oneResult, result);\\n            DFS(root.right, oneResult, result);\\n        }\\n        oneResult.RemoveAt(oneResult.Count - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131174,
                "title": "7-lines-in-kotlin-easy-to-understand",
                "content": "```\\nfun binaryTreePaths(root: TreeNode?): List<String> {\\n        if (root == null)\\n            return emptyList()\\n\\n        if (root.left == null && root.right == null)\\n            return listOf(root.`val`.toString())\\n\\n        val left = binaryTreePaths(root.left)\\n        val right = binaryTreePaths(root.right)\\n\\n        return (left + right).map { root.`val`.toString() + \"->\" + it }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun binaryTreePaths(root: TreeNode?): List<String> {\\n        if (root == null)\\n            return emptyList()\\n\\n        if (root.left == null && root.right == null)\\n            return listOf(root.`val`.toString())\\n\\n        val left = binaryTreePaths(root.left)\\n        val right = binaryTreePaths(root.right)\\n\\n        return (left + right).map { root.`val`.toString() + \"->\" + it }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68333,
                "title": "c-solution-0ms-using-asprintf-to-dynamically-grow-the-path-buffer",
                "content": "```\\nvoid binaryTreePathsHelper(struct TreeNode *node, char ***result, int *resultSize, char *path) {\\n    if (!node) return;\\n    char *newPath = NULL;\\n    if (node->left == NULL && node->right == NULL) {\\n        asprintf(&newPath, \"%s%d\", path, node->val);\\n        *result = realloc(*result, ++(*resultSize) * sizeof(char **));\\n        (*result)[*resultSize - 1] = newPath;\\n        return;   \\n    }\\n    asprintf(&newPath, \"%s%d->\", path, node->val);\\n    binaryTreePathsHelper(node->left, result, resultSize, newPath);\\n    binaryTreePathsHelper(node->right, result, resultSize, newPath);\\n    free(newPath);\\n}\\n\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    if (!root) return NULL;\\n    char **result = NULL;\\n    binaryTreePathsHelper(root, &result, returnSize, \"\");\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid binaryTreePathsHelper(struct TreeNode *node, char ***result, int *resultSize, char *path) {\\n    if (!node) return;\\n    char *newPath = NULL;\\n    if (node->left == NULL && node->right == NULL) {\\n        asprintf(&newPath, \"%s%d\", path, node->val);\\n        *result = realloc(*result, ++(*resultSize) * sizeof(char **));\\n        (*result)[*resultSize - 1] = newPath;\\n        return;   \\n    }\\n    asprintf(&newPath, \"%s%d->\", path, node->val);\\n    binaryTreePathsHelper(node->left, result, resultSize, newPath);\\n    binaryTreePathsHelper(node->right, result, resultSize, newPath);\\n    free(newPath);\\n}\\n\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    if (!root) return NULL;\\n    char **result = NULL;\\n    binaryTreePathsHelper(root, &result, returnSize, \"\");\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68466,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> vecRet;\\n            if (root == NULL) return vecRet;\\n            string s = \"\";\\n            getTreePaths(vecRet, s, root);\\n            \\n            return vecRet;\\n        }\\n        void getTreePaths(vector<string> &vecRet, string s, TreeNode *root) {\\n            if (root == NULL) return;\\n            \\n            s += to_string(root->val);\\n            if (root->left == NULL && root->right == NULL)//the current node is leaf,then put s into vecRet\\n                vecRet.push_back(s);\\n            else\\n                s += \"->\";\\n    \\n            getTreePaths(vecRet, s, root->left);//recur in left subtree\\n            getTreePaths(vecRet, s, root->right);//recur in right subtree\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> vecRet;\\n            if (root == NULL) return vecRet;\\n            string s = \"\";\\n            getTreePaths(vecRet, s, root);\\n            \\n            return vecRet;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68398,
                "title": "binary-tree-paths-dfs-java-solution",
                "content": "\\npublic class Solution {\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n\\n        List<String> ret = new ArrayList<String>();\\n        \\n        if(root == null){\\n            return ret;\\n        }\\n        \\n        dfs(root, new StringBuilder(), ret);\\n        \\n        return ret;\\n    }\\n    \\n    public void dfs(TreeNode root, StringBuilder sb, List<String> ret){\\n\\n       if(root.left == null && root.right == null){\\n           sb.append(root.val);\\n           ret.add(sb.toString());\\n           return;\\n       }\\n        \\n       sb.append(root.val);\\n       sb.append(\"->\");\\n       \\n       if(root.left != null){\\n           dfs(root.left, new StringBuilder(sb), ret);\\n       }\\n       \\n       if(root.right != null){\\n           dfs(root.right, new StringBuilder(sb), ret);\\n       }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n\\n        List<String> ret = new ArrayList<String>();\\n        \\n        if(root == null){\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3832627,
                "title": "java-short-easy-recursive-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) stack space in memory\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n      List<String> ans = new ArrayList<>();\\n      if(root != null) dfs(root, \"\", ans);\\n      return ans;   \\n    }\\n    public void dfs(TreeNode root, String path, List<String> ans) {\\n        if(root.left == null && root.right == null) ans.add(path + root.val);\\n        if(root.left != null) dfs(root.left, path + root.val + \"->\", ans);\\n        if(root.right != null) dfs(root.right, path + root.val + \"->\", ans);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n      List<String> ans = new ArrayList<>();\\n      if(root != null) dfs(root, \"\", ans);\\n      return ans;   \\n    }\\n    public void dfs(TreeNode root, String path, List<String> ans) {\\n        if(root.left == null && root.right == null) ans.add(path + root.val);\\n        if(root.left != null) dfs(root.left, path + root.val + \"->\", ans);\\n        if(root.right != null) dfs(root.right, path + root.val + \"->\", ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619326,
                "title": "java-program-to-get-all-possible-path-of-tree",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `binaryTreePath` method takes three parameters: `root` (the current node in the binary tree), `path` (a string representing the path from the root to the current node), and `list` (a list to store all the paths).\\n   \\n2. The first condition checks if the `root` is null, which means we have reached the end of a path. In this case, it simply returns the `list` as it is.\\n\\n3. The second condition checks if the current node is a leaf node (i.e., it doesn\\'t have any left or right child). If it is a leaf node, it means we have reached the end of a path, so we add the current path (`path + root.val`) to the `list` and return the updated `list`.\\n\\n4. If the above conditions are not met, it means we are still traversing the tree. We recursively call the `binaryTreePath` method for the left child of the current node, passing the updated `path` (including the current node value and an arrow \"->\") and the same `list`.\\n\\n5. Similarly, we recursively call the `binaryTreePath` method for the right child of the current node, passing the updated `path` and the same `list`.\\n\\n6. Finally, after traversing all the paths, we return the `list` containing all the paths.\\n\\n7. The `binaryTreePaths` method is the public interface for this functionality. It initializes an empty list (`list`) and calls the `binaryTreePath` method with the `root` of the binary tree, an empty string as the initial path, and the `list`.\\n\\n8. It returns the `list` containing all the paths from the root to the leaf nodes in the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePath(TreeNode root,String path,List<String> list){\\n        if(root == null){\\n            return list;\\n        }\\n        if(root.left == null && root.right == null){\\n            list.add(path + root.val);\\n            return list;\\n        }\\n        binaryTreePath(root.left,(path + root.val + \"->\"),list);\\n        binaryTreePath(root.right,(path + root.val + \"->\"),list);\\n        return list;\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        binaryTreePath(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePath(TreeNode root,String path,List<String> list){\\n        if(root == null){\\n            return list;\\n        }\\n        if(root.left == null && root.right == null){\\n            list.add(path + root.val);\\n            return list;\\n        }\\n        binaryTreePath(root.left,(path + root.val + \"->\"),list);\\n        binaryTreePath(root.right,(path + root.val + \"->\"),list);\\n        return list;\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        binaryTreePath(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432756,
                "title": "binbin-s-another-brilliant-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if root.left is None and root.right is None:\\n            return [str(root.val)]\\n        def findpath(node,l,L):\\n            if node.left is None and node.right is None:\\n                l += str(node.val)\\n                L.append(l)\\n            if node.left is not None:\\n                findpath(node.left,l+str(node.val)+\"->\",L)\\n            if node.right is not None:\\n                findpath(node.right,l+str(node.val)+\"->\",L)\\n            return L      \\n       \\n        return findpath(root,\"\",[])\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if root.left is None and root.right is None:\\n            return [str(root.val)]\\n        def findpath(node,l,L):\\n            if node.left is None and node.right is None:\\n                l += str(node.val)\\n                L.append(l)\\n            if node.left is not None:\\n                findpath(node.left,l+str(node.val)+\"->\",L)\\n            if node.right is not None:\\n                findpath(node.right,l+str(node.val)+\"->\",L)\\n            return L      \\n       \\n        return findpath(root,\"\",[])\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338140,
                "title": "most-simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        List l=new ArrayList<>();\\n        return solve(root,l,s);\\n    }\\n    public List<String> solve(TreeNode root,List l, String s){\\n        if(root==null) return l;\\n        if(root.left==null && root.right==null){    //if it is a leaf node\\n            l.add(s+root.val);\\n            return l;\\n        }\\n        s= s+root.val+\"->\";\\n        solve(root.left, l, s);\\n        solve(root.right, l, s);\\n        return l;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        String s=\"\";\\n        List l=new ArrayList<>();\\n        return solve(root,l,s);\\n    }\\n    public List<String> solve(TreeNode root,List l, String s){\\n        if(root==null) return l;\\n        if(root.left==null && root.right==null){    //if it is a leaf node\\n            l.add(s+root.val);\\n            return l;\\n        }\\n        s= s+root.val+\"->\";\\n        solve(root.left, l, s);\\n        solve(root.right, l, s);\\n        return l;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296439,
                "title": "java-recursive-solution",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    List<String> li = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        helper(root, \"\");\\n        for(int i=0;i<li.size();i++)\\n        li.set(i, li.get(i).substring(2));\\n        return li;\\n    }\\n    void helper(TreeNode root , String curr)\\n    {\\n        if(root == null)\\n        return;\\n\\n        if(root.left == null && root.right == null)\\n        li.add(curr + \"->\" + root.val );\\n        \\n        helper(root.left, curr + \"->\" + root.val);\\n        helper(root.right, curr + \"->\" + root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<String> li = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        \\n        helper(root, \"\");\\n        for(int i=0;i<li.size();i++)\\n        li.set(i, li.get(i).substring(2));\\n        return li;\\n    }\\n    void helper(TreeNode root , String curr)\\n    {\\n        if(root == null)\\n        return;\\n\\n        if(root.left == null && root.right == null)\\n        li.add(curr + \"->\" + root.val );\\n        \\n        helper(root.left, curr + \"->\" + root.val);\\n        helper(root.right, curr + \"->\" + root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042190,
                "title": "c-easy-and-fast-solution-recursion",
                "content": "TC:O(N)\\nSC: Auxilairy Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<string> solve(TreeNode* &root){\\n        //base case\\n        if(root==NULL)return {};\\n        \\n        vector<string>ans;\\n        string root_val = to_string(root->val);\\n        vector<string>left  = solve(root->left);\\n        vector<string>right = solve(root->right);\\n        for(auto it:left)ans.push_back(root_val + \"->\" + it);\\n        for(auto it:right)ans.push_back(root_val + \"->\" + it);\\n        \\n        if(ans.size()==0)return{root_val};\\n        return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> solve(TreeNode* &root){\\n        //base case\\n        if(root==NULL)return {};\\n        \\n        vector<string>ans;\\n        string root_val = to_string(root->val);\\n        vector<string>left  = solve(root->left);\\n        vector<string>right = solve(root->right);\\n        for(auto it:left)ans.push_back(root_val + \"->\" + it);\\n        for(auto it:right)ans.push_back(root_val + \"->\" + it);\\n        \\n        if(ans.size()==0)return{root_val};\\n        return ans;\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042042,
                "title": "java-simple-easy-and-fast-solution",
                "content": "\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        DFS(root,\"\",list);\\n        return list ;\\n    }\\n    \\n    public void DFS(TreeNode root , String ans , List<String> list){\\n        if(root == null){\\n            return ;\\n        }\\n        if(root.left==null && root.right==null){\\n            list.add(ans+root.val);\\n            return ;\\n        }\\n        \\n        DFS(root.left,ans+root.val+\"->\",list);\\n        DFS(root.right,ans+root.val+\"->\",list);\\n    }\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        DFS(root,\"\",list);\\n        return list ;\\n    }\\n    \\n    public void DFS(TreeNode root , String ans , List<String> list){\\n        if(root == null){\\n            return ;\\n        }\\n        if(root.left==null && root.right==null){\\n            list.add(ans+root.val);\\n            return ;\\n        }\\n        \\n        DFS(root.left,ans+root.val+\"->\",list);\\n        DFS(root.right,ans+root.val+\"->\",list);\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3013848,
                "title": "using-reccursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n         List<string> paths = new List<string>();\\n        string s = \"\";\\n        FindPath(root, s);\\n        void FindPath(TreeNode root,string s1)\\n        {\\n            if (root != null)\\n            {\\n                if (root.left == null && root.right == null)\\n                {\\n                    s1 = s1 + root.val;\\n                    paths.Add(s1);\\n                }\\n                else\\n                {\\n                    s1 = s1 + root.val + \"->\";\\n                    FindPath(root.left, s1);\\n                    FindPath(root.right, s1);\\n\\n                }\\n            }\\n        }\\n        return paths;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n         List<string> paths = new List<string>();\\n        string s = \"\";\\n        FindPath(root, s);\\n        void FindPath(TreeNode root,string s1)\\n        {\\n            if (root != null)\\n            {\\n                if (root.left == null && root.right == null)\\n                {\\n                    s1 = s1 + root.val;\\n                    paths.Add(s1);\\n                }\\n                else\\n                {\\n                    s1 = s1 + root.val + \"->\";\\n                    FindPath(root.left, s1);\\n                    FindPath(root.right, s1);\\n\\n                }\\n            }\\n        }\\n        return paths;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680229,
                "title": "python-dfs-easy-to-understand-faster-than-81",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        \\n        res = []\\n        \\n        def dfs(root,s):\\n            \\n            if not root.left and not root.right:\\n                s = s + str(root.val)\\n                res.append(s)\\n                \\n            s = s+ str(root.val)+\"->\"    \\n            \\n            if root.left:\\n                left = dfs(root.left,s)\\n            \\n            if root.right:\\n                right = dfs(root.right,s)\\n            \\n            \\n        dfs(root,\"\")\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        \\n        res = []\\n        \\n        def dfs(root,s):\\n            \\n            if not root.left and not root.right:\\n                s = s + str(root.val)\\n                res.append(s)\\n                \\n            s = s+ str(root.val)+\"->\"    \\n            \\n            if root.left:\\n                left = dfs(root.left,s)\\n            \\n            if root.right:\\n                right = dfs(root.right,s)\\n            \\n            \\n        dfs(root,\"\")\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662822,
                "title": "java-easy-recursive-solution",
                "content": "```\\nclass Solution {\\n    void traverse(TreeNode root,String str,List<String> list ){\\n        if(root!=null){\\n            str+= (root.val+\"\");\\n            if(root.left==null && root.right==null){\\n                list.add(str);\\n            }\\n            str+=\"->\";\\n            traverse(root.left,str,list);\\n            traverse(root.right,str,list);\\n        }\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        String str = \"\";\\n        traverse(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode root,String str,List<String> list ){\\n        if(root!=null){\\n            str+= (root.val+\"\");\\n            if(root.left==null && root.right==null){\\n                list.add(str);\\n            }\\n            str+=\"->\";\\n            traverse(root.left,str,list);\\n            traverse(root.right,str,list);\\n        }\\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        String str = \"\";\\n        traverse(root,\"\",list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581377,
                "title": "super-simple-dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        if (!root->left && !root->right)\\n            return {to_string(root->val)};\\n\\n        vector<string> output;\\n        for (auto node : binaryTreePaths(root->left))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n        for (auto node : binaryTreePaths(root->right))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if (!root)\\n            return {};\\n        if (!root->left && !root->right)\\n            return {to_string(root->val)};\\n\\n        vector<string> output;\\n        for (auto node : binaryTreePaths(root->left))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n        for (auto node : binaryTreePaths(root->right))\\n            output.push_back(to_string(root->val) + \"->\" + node);\\n\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455753,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        dfs(root, \"\", ans);\\n        return ans;\\n    }\\n\\n    private void dfs(TreeNode root, String s, List<String> ans){\\n        \\n        if (root == null) return;\\n\\n        if (root.left == null && root.right == null){\\n            s += root.val;\\n            ans.add(s);\\n        }\\n\\n        s += \"\" + root.val + \"->\";\\n\\n        dfs(root.left, s, ans);\\n        dfs(root.right, s,ans);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2449587,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q257. Binary Tree Paths***\\nGiven the `root` of a binary tree, return all root-to-leaf paths in **any order.**\\n\\nA **leaf**  is a node with no children.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return\\n        res =[]\\n        self.preorder(root,\"\",res)\\n        return res\\n    def preorder(self,node,path,res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path,node.val))\\n        self.preorder(node.left,\"{}{}->\".format(path,node.val),res)\\n        self.preorder(node.right,\"{}{}->\".format(path,node.val),res)\\n        \\n```\\n**Runtime:**  54 ms\\t\\n**Memory Usage:**  13.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> v=new ArrayList<>();\\n        if(root!=null)\\n            preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode r,List<String> v,String s)\\n    {\\n        if(r==null)\\n            return;\\n        if(s.isEmpty())\\n            s+=r.val;\\n        else s+=(\"->\"+r.val);\\n        if(r.left!=null||r.right!=null)\\n        {\\n            preorder(r.left,v,s);\\n            preorder(r.right,v,s);\\n        }\\n        else\\n            v.add(s);\\n    }\\n}\\n```\\n**Runtime:**  12 ms\\t4\\n**Memory Usage:**  43.3 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nlass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        if(root)\\n         preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode* r,vector<string>&v,string s)\\n    {\\n        if (!r)\\n            return ;\\n        if(!s.empty())\\n            s+=(\"->\"+to_string(r->val));\\n        else s+=to_string(r->val);\\n        if(r->left||r->right)\\n        {\\n            preorder(r->left,v,s);\\n            preorder(r->right,v,s);\\n        }\\n        else\\n            v.push_back(s);\\n        \\n    }\\n};\\n```\\n**Runtime:** 3 ms\\t\\t\\n**Memory Usage:**  13.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        if not root:\\n            return\\n        res =[]\\n        self.preorder(root,\"\",res)\\n        return res\\n    def preorder(self,node,path,res):\\n        if not node:\\n            return\\n        if not node.left and not node.right:\\n            res.append(\"{}{}\".format(path,node.val))\\n        self.preorder(node.left,\"{}{}->\".format(path,node.val),res)\\n        self.preorder(node.right,\"{}{}->\".format(path,node.val),res)\\n        \\n```\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> v=new ArrayList<>();\\n        if(root!=null)\\n            preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode r,List<String> v,String s)\\n    {\\n        if(r==null)\\n            return;\\n        if(s.isEmpty())\\n            s+=r.val;\\n        else s+=(\"->\"+r.val);\\n        if(r.left!=null||r.right!=null)\\n        {\\n            preorder(r.left,v,s);\\n            preorder(r.right,v,s);\\n        }\\n        else\\n            v.add(s);\\n    }\\n}\\n```\n```\\nlass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> v;\\n        if(root)\\n         preorder(root,v,\"\");\\n        return v;\\n    }\\n    void preorder(TreeNode* r,vector<string>&v,string s)\\n    {\\n        if (!r)\\n            return ;\\n        if(!s.empty())\\n            s+=(\"->\"+to_string(r->val));\\n        else s+=to_string(r->val);\\n        if(r->left||r->right)\\n        {\\n            preorder(r->left,v,s);\\n            preorder(r->right,v,s);\\n        }\\n        else\\n            v.push_back(s);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253948,
                "title": "java-100-faster-solution-1ms-easy",
                "content": "# Please Upvote Bro \\uD83E\\uDD7A\\n\\n```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 42.2 MB, less than 96.55% of Java online submissions for Binary Tree Paths.\\n```\\n\\n```\\nList<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    void helper(TreeNode node, StringBuilder slate){\\n        if(node==null) return;\\n        int length = slate.length();\\n        slate.append(node.val);\\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        else{\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Binary Tree Paths.\\nMemory Usage: 42.2 MB, less than 96.55% of Java online submissions for Binary Tree Paths.\\n```\n```\\nList<String> result = new ArrayList<String>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        helper(root, new StringBuilder());\\n        return result;\\n    }\\n    void helper(TreeNode node, StringBuilder slate){\\n        if(node==null) return;\\n        int length = slate.length();\\n        slate.append(node.val);\\n        if(node.left == null && node.right == null)\\n            result.add(slate.toString()); \\n        else{\\n           slate.append(\"->\");\\n           helper(node.left, slate);\\n           helper(node.right, slate);\\n        }\\n        slate.setLength(length);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192255,
                "title": "c-dfs-recursion-100-faster-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,string s,vector<string>&ans)\\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans.push_back(s);\\n            return ;\\n        }\\n        s+=\"->\";\\n        dfs(root->left,s,ans);\\n        dfs(root->right,s,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string>ans;\\n        dfs(root,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,string s,vector<string>&ans)\\n    {\\n        if(!root)\\n            return;\\n        s+=to_string(root->val);\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans.push_back(s);\\n            return ;\\n        }\\n        s+=\"->\";\\n        dfs(root->left,s,ans);\\n        dfs(root->right,s,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string>ans;\\n        dfs(root,\"\",ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138269,
                "title": "c-easy-to-understand-3ms-solution-recursion-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void TreePaths(TreeNode* root, string path, vector<string> &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            path += to_string(root->val);\\n            ans.push_back(path);\\n            return;\\n            \\n        }\\n        path += (to_string(root->val)) + \"->\";\\n        TreePaths(root->left,path,ans);\\n        TreePaths(root->right,path,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        vector<string> ans;\\n        TreePaths(root,\"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void TreePaths(TreeNode* root, string path, vector<string> &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            path += to_string(root->val);\\n            ans.push_back(path);\\n            return;\\n            \\n        }\\n        path += (to_string(root->val)) + \"->\";\\n        TreePaths(root->left,path,ans);\\n        TreePaths(root->right,path,ans);\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        \\n        vector<string> ans;\\n        TreePaths(root,\"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778386,
                "title": "c-backtracking",
                "content": "My answer for this problem.\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<string> vs; \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root == nullptr) return vs;\\n        string rootStr = to_string(root->val); \\n        btp(root, rootStr);\\n        return vs;\\n    }\\n    void btp(TreeNode* root, string &str) {\\n        if(root->left == nullptr && root->right == nullptr) { \\n            vs.push_back(str);\\n        }\\n        if(root->left != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->left->val);\\n            btp(root->left, newstr);\\n        } \\n        if(root->right != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->right->val);\\n            btp(root->right, newstr);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<string> vs; \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root == nullptr) return vs;\\n        string rootStr = to_string(root->val); \\n        btp(root, rootStr);\\n        return vs;\\n    }\\n    void btp(TreeNode* root, string &str) {\\n        if(root->left == nullptr && root->right == nullptr) { \\n            vs.push_back(str);\\n        }\\n        if(root->left != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->left->val);\\n            btp(root->left, newstr);\\n        } \\n        if(root->right != nullptr) {\\n            string newstr=str + \"->\" + to_string(root->right->val);\\n            btp(root->right, newstr);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630587,
                "title": "82-runtime-99-92-memory-a-simple-way-to-improve-the-memory-usage",
                "content": "C formatting functions (`printf`, `snprintf`, `fprintf`) are still widely used in production codes over the C++ streams. In anycase, the idea below generalizes to any programming language. \\n\\n- Allocate a static character buffer\\n- Keep a variable to track the number of characters written to the buffer during tree-traversal\\n\\n```\\nstatic char buffer[1000];\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\n        \\nclass Solution {\\npublic:\\n    \\n    vector<string> ret;        \\n    void iter(TreeNode* root, int len) {\\n        if(!root) { return; }\\n        if(root && !root->left && !root->right) {\\n            snprintf(&buffer[len], sizeof(buffer)-len, \"%d\", root->val);\\n            ret.emplace_back(buffer);\\n            return;\\n        }\\n\\n        int n = snprintf(&buffer[len], sizeof(buffer)-len, \"%d->\", root->val);\\n        iter(root->left, len+n);\\n        iter(root->right, len+n);            \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {        \\n        iter(root, 0);        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic char buffer[1000];\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\n        \\nclass Solution {\\npublic:\\n    \\n    vector<string> ret;        \\n    void iter(TreeNode* root, int len) {\\n        if(!root) { return; }\\n        if(root && !root->left && !root->right) {\\n            snprintf(&buffer[len], sizeof(buffer)-len, \"%d\", root->val);\\n            ret.emplace_back(buffer);\\n            return;\\n        }\\n\\n        int n = snprintf(&buffer[len], sizeof(buffer)-len, \"%d->\", root->val);\\n        iter(root->left, len+n);\\n        iter(root->right, len+n);            \\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {        \\n        iter(root, 0);        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560520,
                "title": "c-100-faster-solution-binary-tree-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n         if(root == nullptr){\\n            vector<string> v;    return v;\\n        } else if(root->left == nullptr && root->right == nullptr){\\n            vector<string> v;\\n            v.push_back(to_string(root->val));        return v;\\n        }\\n        \\n        vector<string> left = binaryTreePaths(root->left);\\n        for(int i = 0; i < left.size(); ++i){\\n            left[i] = to_string(root->val) + \"->\" + left[i];\\n        }\\n        \\n        vector<string> right = binaryTreePaths(root->right);\\n        for(int i = 0; i < right.size(); ++i){\\n            right[i] = to_string(root->val) + \"->\" + right[i];  \\n        }\\n        \\n        vector<string> res;\\n        for(auto x: left)       res.push_back(x);\\n        for(auto x: right)       res.push_back(x);\\n        return res;\\n    }\\n};\\n```\\n\\n**Result-**\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\nMemory Usage: 13.8 MB, less than 17.49% of C++ online submissions for Binary Tree Paths.\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n         if(root == nullptr){\\n            vector<string> v;    return v;\\n        } else if(root->left == nullptr && root->right == nullptr){\\n            vector<string> v;\\n            v.push_back(to_string(root->val));        return v;\\n        }\\n        \\n        vector<string> left = binaryTreePaths(root->left);\\n        for(int i = 0; i < left.size(); ++i){\\n            left[i] = to_string(root->val) + \"->\" + left[i];\\n        }\\n        \\n        vector<string> right = binaryTreePaths(root->right);\\n        for(int i = 0; i < right.size(); ++i){\\n            right[i] = to_string(root->val) + \"->\" + right[i];  \\n        }\\n        \\n        vector<string> res;\\n        for(auto x: left)       res.push_back(x);\\n        for(auto x: right)       res.push_back(x);\\n        return res;\\n    }\\n};\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Paths.\\nMemory Usage: 13.8 MB, less than 17.49% of C++ online submissions for Binary Tree Paths.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528336,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        if(root != null)    path(root,\"\",list);\\n        return list;\\n    }\\n    private void path(TreeNode root, String pth, List<String> list){\\n        if(root.left == null && root.right == null)     list.add(pth+root.val);\\n        if(root.left != null)   path(root.left, pth+root.val+\"->\", list);\\n        if(root.right != null)   path(root.right, pth+root.val+\"->\", list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> list = new ArrayList<>();\\n        if(root != null)    path(root,\"\",list);\\n        return list;\\n    }\\n    private void path(TreeNode root, String pth, List<String> list){\\n        if(root.left == null && root.right == null)     list.add(pth+root.val);\\n        if(root.left != null)   path(root.left, pth+root.val+\"->\", list);\\n        if(root.right != null)   path(root.right, pth+root.val+\"->\", list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516595,
                "title": "javascript-100-simple-dfs-backtracking-solution",
                "content": "```\\nconst binaryTreePaths = (root, paths = [], path = []) => {\\n  path.push(root.val);\\n  if (!root.right && !root.left) paths.push(path.join(\\'->\\'));\\n  root.left && binaryTreePaths(root.left, paths, path);\\n  root.right && binaryTreePaths(root.right, paths, path);\\n  path.pop();\\n  return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst binaryTreePaths = (root, paths = [], path = []) => {\\n  path.push(root.val);\\n  if (!root.right && !root.left) paths.push(path.join(\\'->\\'));\\n  root.left && binaryTreePaths(root.left, paths, path);\\n  root.right && binaryTreePaths(root.right, paths, path);\\n  path.pop();\\n  return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277191,
                "title": "c-easy-solution-recursive",
                "content": "``` \\n void helper(TreeNode* root ,string c,vector<string> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else if(!root->left&&!root->right){\\n            c+=to_string(root->val);\\n            v.push_back(c);\\n            return;\\n        }\\n        c+=to_string(root->val);\\n        c+=\"->\";\\n        helper(root->left,c,v);\\n        helper(root->right,c,v);\\n       \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n       vector<string> v;\\n        \\n        helper(root,\"\",v);\\n        \\n        return v;\\n    }\\n\\t\\n\\t``` \\n\\n",
                "solutionTags": [],
                "code": "``` \\n void helper(TreeNode* root ,string c,vector<string> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else if(!root->left&&!root->right){\\n            c+=to_string(root->val);\\n            v.push_back(c);\\n            return;\\n        }\\n        c+=to_string(root->val);\\n        c+=\"->\";\\n        helper(root->left,c,v);\\n        helper(root->right,c,v);\\n       \\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n       vector<string> v;\\n        \\n        helper(root,\"\",v);\\n        \\n        return v;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167548,
                "title": "javascript-recursion-stack-easy-understand",
                "content": "Recursion\\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var travel = function(node, path) {\\n        if(!node.left && !node.right) result.push(path.join(\\'->\\')); //reach leaf\\n        if(node.left) travel(node.left, [...path, node.left.val]); // left child exists, keep going\\n        if(node.right) travel(node.right, [...path, node.right.val]); //right child exists, keep going\\n    }\\n    travel(root, [root.val]);\\n    return result;\\n};\\n```\\n\\nStack\\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var stack = [[root, [root.val]]];\\n    while(stack.length) {\\n        var element = stack.pop();\\n        var node = element[0];\\n        if(!node.left && !node.right) result.push(element[1].join(\\'->\\'));\\n        if(node.left) stack.push([node.left, [...element[1], node.left.val]]);\\n        if(node.right) stack.push([node.right, [...element[1], node.right.val]]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var travel = function(node, path) {\\n        if(!node.left && !node.right) result.push(path.join(\\'->\\')); //reach leaf\\n        if(node.left) travel(node.left, [...path, node.left.val]); // left child exists, keep going\\n        if(node.right) travel(node.right, [...path, node.right.val]); //right child exists, keep going\\n    }\\n    travel(root, [root.val]);\\n    return result;\\n};\\n```\n```\\nvar binaryTreePaths = function(root) {\\n    var result = [];\\n    var stack = [[root, [root.val]]];\\n    while(stack.length) {\\n        var element = stack.pop();\\n        var node = element[0];\\n        if(!node.left && !node.right) result.push(element[1].join(\\'->\\'));\\n        if(node.left) stack.push([node.left, [...element[1], node.left.val]]);\\n        if(node.right) stack.push([node.right, [...element[1], node.right.val]]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114192,
                "title": "python-solutions-dfs-recursive-and-iterative",
                "content": "dfs recursive:\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs recursive\\n        res = []\\n        def dfs(root,string):\\n            if not root: return\\n            if not (root.left or root.right):\\n                res.append(string+str(root.val))\\n            if root.left:\\n                dfs(root.left,string+str(root.val)+\"->\")\\n            if root.right:\\n                dfs(root.right,string+str(root.val)+\"->\")\\n        dfs(root,\"\")\\n        return res\\n```\\n\\ndfs iterative:\\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs iterative\\n        stack,res = [(root,\"\")],[]\\n        while stack:\\n            node,path = stack.pop()\\n            if not (node.left or node.right):\\n                res.append(path+str(node.val))\\n            if node.left:\\n                stack.append((node.left,path+str(node.val)+\"->\"))\\n            if node.right:\\n                stack.append((node.right,path+str(node.val)+\"->\"))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs recursive\\n        res = []\\n        def dfs(root,string):\\n            if not root: return\\n            if not (root.left or root.right):\\n                res.append(string+str(root.val))\\n            if root.left:\\n                dfs(root.left,string+str(root.val)+\"->\")\\n            if root.right:\\n                dfs(root.right,string+str(root.val)+\"->\")\\n        dfs(root,\"\")\\n        return res\\n```\n```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #\\n        ## dfs iterative\\n        stack,res = [(root,\"\")],[]\\n        while stack:\\n            node,path = stack.pop()\\n            if not (node.left or node.right):\\n                res.append(path+str(node.val))\\n            if node.left:\\n                stack.append((node.left,path+str(node.val)+\"->\"))\\n            if node.right:\\n                stack.append((node.right,path+str(node.val)+\"->\"))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931366,
                "title": "backtrack-beat-99-58-and-100",
                "content": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #backtracking\\n        path,values = [], []\\n        if not root:\\n            return path\\n        self.backtracking(root, values, path)\\n        return path\\n    \\n    def isLeaf(self, node):    #determine if leaf node\\n        return not node.left and not node.right\\n    \\n    def buildPath(self, values):\\n        string = \\'\\'\\n        for i in range(len(values)):\\n            string += str(values[i])\\n            if i != len(values)-1:\\n                string += \\'->\\'    #add -> beteween 2 numbers\\n        return string\\n    \\n    def backtracking(self, node, values, path):\\n        if not node:\\n            return \\n        values.append(node.val)\\n        if self.isLeaf(node):\\n            path.append(self.buildPath(values))     #find a path, add it to the answer\\n        else:\\n            self.backtracking(node.left, values, path)    #goto left  leaf\\n            self.backtracking(node.right, values, path)  #goto right leaf\\n        values.pop()    #backtrack to the origin to find another solution\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        #backtracking\\n        path,values = [], []\\n        if not root:\\n            return path\\n        self.backtracking(root, values, path)\\n        return path\\n    \\n    def isLeaf(self, node):    #determine if leaf node\\n        return not node.left and not node.right\\n    \\n    def buildPath(self, values):\\n        string = \\'\\'\\n        for i in range(len(values)):\\n            string += str(values[i])\\n            if i != len(values)-1:\\n                string += \\'->\\'    #add -> beteween 2 numbers\\n        return string\\n    \\n    def backtracking(self, node, values, path):\\n        if not node:\\n            return \\n        values.append(node.val)\\n        if self.isLeaf(node):\\n            path.append(self.buildPath(values))     #find a path, add it to the answer\\n        else:\\n            self.backtracking(node.left, values, path)    #goto left  leaf\\n            self.backtracking(node.right, values, path)  #goto right leaf\\n        values.pop()    #backtrack to the origin to find another solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900188,
                "title": "best-easiest-solution-for-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if root is None:return \\n        paths = []\\n        \\n        if root.left is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.left)]\\n        \\n        if root.right is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.right)]\\n    \\n        \\n        return paths if paths != [] else [str(root.val)]\\n        \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if root is None:return \\n        paths = []\\n        \\n        if root.left is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.left)]\\n        \\n        if root.right is not None:\\n            paths += [f\"{root.val}->{i}\" for i in self.binaryTreePaths(root.right)]\\n    \\n        \\n        return paths if paths != [] else [str(root.val)]\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 887855,
                "title": "rust-0ms-100",
                "content": "```rust\\n/*\\nlearn a lot from\\nhttps://leetcode.com/problems/binary-tree-paths/discuss/733347/Rust-cheapest-and-best\\n */\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn binary_tree_paths(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<String> {\\n        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if let Some(node) = root {\\n                let node = node.borrow();\\n                let (left, right) = (&node.left, &node.right);\\n                if left.is_none() && right.is_none() {\\n                    ans.push(vec![node.val]);\\n                } else {\\n                    [left, right].iter().for_each(|&branch| {\\n                        ans.extend(dfs(branch).into_iter().map(|mut p| {\\n                            p.push(node.val);\\n                            p\\n                        }))\\n                    });\\n                }\\n            }\\n            ans\\n        }\\n\\n        dfs(&root)\\n            .iter()\\n            .map(|v| {\\n                v.iter()\\n                    .rev()\\n                    .map(|i| i.to_string())\\n                    .collect::<Vec<String>>()\\n                    .join(\"->\")\\n            })\\n            .collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_binary_tree_paths() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: Some(Rc::new(RefCell::new(TreeNode::new(5)))),\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(\\n            Solution::binary_tree_paths(root),\\n            vec![\"1->2->5\".to_owned(), \"1->3\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n/*\\nlearn a lot from\\nhttps://leetcode.com/problems/binary-tree-paths/discuss/733347/Rust-cheapest-and-best\\n */\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn binary_tree_paths(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<String> {\\n        fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\\n            let mut ans = vec![];\\n            if let Some(node) = root {\\n                let node = node.borrow();\\n                let (left, right) = (&node.left, &node.right);\\n                if left.is_none() && right.is_none() {\\n                    ans.push(vec![node.val]);\\n                } else {\\n                    [left, right].iter().for_each(|&branch| {\\n                        ans.extend(dfs(branch).into_iter().map(|mut p| {\\n                            p.push(node.val);\\n                            p\\n                        }))\\n                    });\\n                }\\n            }\\n            ans\\n        }\\n\\n        dfs(&root)\\n            .iter()\\n            .map(|v| {\\n                v.iter()\\n                    .rev()\\n                    .map(|i| i.to_string())\\n                    .collect::<Vec<String>>()\\n                    .join(\"->\")\\n            })\\n            .collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_binary_tree_paths() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: Some(Rc::new(RefCell::new(TreeNode::new(5)))),\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(\\n            Solution::binary_tree_paths(root),\\n            vec![\"1->2->5\".to_owned(), \"1->3\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765151,
                "title": "c-faster-than-100-preorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    void preorder(TreeNode* root, string add)\\n    {\\n        if(!root)\\n            return;\\n        if(add.size() != 0)\\n            add += \"->\";\\n        add += to_string(root -> val);\\n        if(root -> left == nullptr and root -> right == nullptr)\\n            ans.push_back(add);\\n        preorder(root -> left, add);\\n        preorder(root -> right, add);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        preorder(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<string> ans;\\n    \\n    void preorder(TreeNode* root, string add)\\n    {\\n        if(!root)\\n            return;\\n        if(add.size() != 0)\\n            add += \"->\";\\n        add += to_string(root -> val);\\n        if(root -> left == nullptr and root -> right == nullptr)\\n            ans.push_back(add);\\n        preorder(root -> left, add);\\n        preorder(root -> right, add);\\n    }\\n    \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        preorder(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677005,
                "title": "java-recursion-2ms-top-99-94-memory-solution-based-on-strignbuilder",
                "content": "```\\n\\tpublic List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<String> result = new ArrayList<>();\\n        binaryTreePathsRec(root, new StringBuilder(), result);\\n        return result;\\n    }\\n    \\n    private void binaryTreePathsRec(TreeNode root, StringBuilder currentPath, List<String> output) {\\n        if (root.left == null && root.right == null) {\\n            output.add(new StringBuilder(currentPath).append(root.val).toString());\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            binaryTreePathsRec(root.left, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n        \\n        if (root.right != null) {\\n            binaryTreePathsRec(root.right, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic List<String> binaryTreePaths(TreeNode root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<String> result = new ArrayList<>();\\n        binaryTreePathsRec(root, new StringBuilder(), result);\\n        return result;\\n    }\\n    \\n    private void binaryTreePathsRec(TreeNode root, StringBuilder currentPath, List<String> output) {\\n        if (root.left == null && root.right == null) {\\n            output.add(new StringBuilder(currentPath).append(root.val).toString());\\n            return;\\n        }\\n        \\n        if (root.left != null) {\\n            binaryTreePathsRec(root.left, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n        \\n        if (root.right != null) {\\n            binaryTreePathsRec(root.right, new StringBuilder(currentPath).append(root.val).append(\"->\"), output);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566039,
                "title": "python-dfs-recursive-and-bfs-queue",
                "content": "DFS Recursive \\n\\n```\\n   def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        self.paths = []\\n        \\n        def dfs(root, path):\\n            path += str(root.val)\\n            if not root.left and not root.right:\\n                self.paths.append(path)\\n            \\n            if root.left:\\n                dfs(root.left, path + \\'->\\')\\n            if root.right:\\n                dfs(root.right, path + \\'->\\')\\n            return\\n        \\n        if root:\\n            dfs(root, \\'\\')\\n        return self.paths\\n\\n```\\n\\nBFS + Queue\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        \\n        paths, start = [str(root.val)], 0\\n        layer = [root]  # queue\\n        \\n        while layer:\\n            root = layer.pop(0)\\n            if root.left:\\n                paths.append(paths[start] + \\'->\\' + str(root.left.val))\\n                layer.append(root.left)\\n            if root.right:\\n                paths.append(paths[start] + \\'->\\' +  str(root.right.val))\\n                layer.append(root.right)\\n            if not root.left and not root.right:\\n                start += 1\\n            else:\\n                paths.pop(start)\\n        \\n        return paths\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        self.paths = []\\n        \\n        def dfs(root, path):\\n            path += str(root.val)\\n            if not root.left and not root.right:\\n                self.paths.append(path)\\n            \\n            if root.left:\\n                dfs(root.left, path + \\'->\\')\\n            if root.right:\\n                dfs(root.right, path + \\'->\\')\\n            return\\n        \\n        if root:\\n            dfs(root, \\'\\')\\n        return self.paths\\n\\n```\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        if not root:\\n            return []\\n        \\n        paths, start = [str(root.val)], 0\\n        layer = [root]  # queue\\n        \\n        while layer:\\n            root = layer.pop(0)\\n            if root.left:\\n                paths.append(paths[start] + \\'->\\' + str(root.left.val))\\n                layer.append(root.left)\\n            if root.right:\\n                paths.append(paths[start] + \\'->\\' +  str(root.right.val))\\n                layer.append(root.right)\\n            if not root.left and not root.right:\\n                start += 1\\n            else:\\n                paths.pop(start)\\n        \\n        return paths\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 550969,
                "title": "go",
                "content": "```\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    if root == nil {\\n        return nil\\n    }\\n    result := []string{}\\n    helper(root, strconv.Itoa(root.Val), &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, str string, result *[]string) {\\n    if root.Left == nil && root.Right == nil {\\n        *result = append(*result, str)\\n        return\\n    }\\n    if root.Left != nil {\\n        helper(root.Left, str +\"->\" + strconv.Itoa(root.Left.Val), result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, str +\"->\" + strconv.Itoa(root.Right.Val), result)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc binaryTreePaths(root *TreeNode) []string {\\n    if root == nil {\\n        return nil\\n    }\\n    result := []string{}\\n    helper(root, strconv.Itoa(root.Val), &result)\\n    return result\\n}\\n\\nfunc helper(root *TreeNode, str string, result *[]string) {\\n    if root.Left == nil && root.Right == nil {\\n        *result = append(*result, str)\\n        return\\n    }\\n    if root.Left != nil {\\n        helper(root.Left, str +\"->\" + strconv.Itoa(root.Left.Val), result)\\n    }\\n    if root.Right != nil {\\n        helper(root.Right, str +\"->\" + strconv.Itoa(root.Right.Val), result)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535561,
                "title": "simple-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<String>();\\n        helper(root, \"\", ans);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, String temp, List<String> ans) {\\n        if(root == null) return;\\n        else if(root.left == null && root.right == null) {\\n            ans.add(temp + root.val);\\n            return;\\n        } else {\\n            helper(root.left, temp + root.val + \"->\", ans);\\n            helper(root.right, temp + root.val + \"->\", ans);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<String>();\\n        helper(root, \"\", ans);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, String temp, List<String> ans) {\\n        if(root == null) return;\\n        else if(root.left == null && root.right == null) {\\n            ans.add(temp + root.val);\\n            return;\\n        } else {\\n            helper(root.left, temp + root.val + \"->\", ans);\\n            helper(root.right, temp + root.val + \"->\", ans);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432674,
                "title": "very-simple-and-easy-ruby-solution-using-stack-beats-100",
                "content": "```\\ndef binary_tree_paths(root)\\n  @stack = []\\n  @result = []\\n  preorder(root)\\n  @result\\nend\\n\\ndef preorder(node)\\n  return if node.nil?\\n  @stack.push(node.val)\\n  preorder(node.left)\\n  preorder(node.right)\\n  @result << @stack.join(\"->\") if !node.left && !node.right\\n  @stack.pop\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\ndef binary_tree_paths(root)\\n  @stack = []\\n  @result = []\\n  preorder(root)\\n  @result\\nend\\n\\ndef preorder(node)\\n  return if node.nil?\\n  @stack.push(node.val)\\n  preorder(node.left)\\n  preorder(node.right)\\n  @result << @stack.join(\"->\") if !node.left && !node.right\\n  @stack.pop\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 426760,
                "title": "simple-dfs-javascript-readable-code-for-humans-both-recursive-iterative",
                "content": "simpler recursive code\\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```\\nIterative\\n```js\\n// iterative\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    let stack = [root]\\n    let pathStack = [\"\"]\\n    while(stack.length !== 0) {\\n        let node = stack.pop()\\n        let path = pathStack.pop()\\n        path += node.val\\n        if(!node.left && !node.right) {\\n            paths.push(path)            \\n        }\\n        path += \\'->\\'\\n        if(node.left) {\\n            stack.push(node.left) \\n            pathStack.push(path)\\n        }\\n        if(node.right) {\\n            stack.push(node.right) \\n            pathStack.push(path)\\n        }\\n    }\\n    return paths\\n};\\n```\\nless simple recursive\\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```\n```js\\n// iterative\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    let stack = [root]\\n    let pathStack = [\"\"]\\n    while(stack.length !== 0) {\\n        let node = stack.pop()\\n        let path = pathStack.pop()\\n        path += node.val\\n        if(!node.left && !node.right) {\\n            paths.push(path)            \\n        }\\n        path += \\'->\\'\\n        if(node.left) {\\n            stack.push(node.left) \\n            pathStack.push(path)\\n        }\\n        if(node.right) {\\n            stack.push(node.right) \\n            pathStack.push(path)\\n        }\\n    }\\n    return paths\\n};\\n```\n```js\\nvar binaryTreePaths = function(root) {\\n    if(!root) { return []}\\n    let paths = []\\n    function recurse(root, path) {\\n        path += root.val\\n        if(!root.left && !root.right) { \\n            paths.push(path) \\n            return \\n        }        \\n        path += \\'->\\'\\n        root.left && recurse(root.left, path)\\n        root.right && recurse(root.right, path)\\n    }\\n    recurse(root, \"\")\\n    return paths\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158022,
                "title": "python-dfs",
                "content": "### 257. Binary Tree Paths\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386 | \\u5206\\u5236\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS\\u904D\\u5386\\n\\n\\u8FD9\\u91CC\\u5229\\u7528str\\u662Fimmutable\\u7684\\u7279\\u6027\\uFF0C\\u4E0D\\u9700\\u8981\\u8003\\u8651\\u6BCF\\u6B21backtrack\\u65F6\\u5019\\u5BF9temp\\u6570\\u7EC4\\u7684\\u66F4\\u6539\\u3002\\n\\u9012\\u5F52\\u601D\\u8DEF\\u4E09\\u79CD\\uFF1A\\n1. \\u5982\\u679C\\u6CA1\\u6709\\u5DE6\\u53F3\\u5B69\\u5B50\\uFF1A\\u5C06`temp`\\u5B58\\u5165\\u8FD4\\u56DE\\u6570\\u7EC4`res`\\n2/3: \\u5982\\u679C\\u6709\\u5DE6\\u6216\\u8005\\u53F3\\uFF0C\\u9012\\u5F52\\u5E76\\u4E14\\u66F4\\u65B0`temp`\\n\\n```python\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        self.dfs(root, res, \\'\\')\\n        return res\\n    \\n    def dfs(self, root, res, temp):\\n        temp += str(root.val)\\n        if not root.left and not root.right:\\n            res.append(temp)\\n        if root.left:\\n            self.dfs(root.left, res, temp + \\'->\\')\\n        if root.right:\\n            self.dfs(root.right, res, temp + \\'->\\')\\n```\\n\\n#### DFS\\u5206\\u5236\\n\\n\\u8FD9\\u91CC\\u6BD4\\u8F83Tricky\\uFF0C\\u5148\\u904D\\u5386\\u5230\\u6700\\u4E0B\\u7AEF\\uFF0C\\u6BCF\\u6B21\\u5F80\\u4E0A\\u8FD4\\u56DE\\u7684\\u662F\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u6570\\u7EC4\\u91CC\\u9762\\u5305\\u542B\\u4E86\\u6240\\u6709\\u5DE6\\u8FB9\\u6216\\u8005\\u53F3\\u8FB9\\u4F20\\u4E0A\\u53BB\\u7684\\u5404\\u79CD`path`\\uFF0C\\u5728\\u4E0A\\u4F20\\u5230parent\\u8282\\u70B9\\u7684\\u65F6\\u5019\\uFF0Cparent\\u5728\\u6240\\u6709\\u7684`path`\\u91CC\\u9762\\u8FED\\u4EE3\\u4E00\\u6B21\\uFF0C\\u53CD\\u5411\\u52A0\\u4E0A\\u5F53\\u524D`root.val`\\uFF0C\\u7136\\u540E\\u7EE7\\u7EED\\u5F80\\u4E0A\\u53CD\\u3002\\u56E0\\u4E3A\\u8FD9\\u91CC\\u6CA1\\u6709\\u7528\\u5168\\u5C40\\u7684return value\\uFF0C\\u6BCF\\u6B21\\u5728\\u5411\\u4E0A\\u4F20\\u9012\\u7684\\u65F6\\u5019\\uFF0C\\u8981\\u91CD\\u65B0\\u518D\\u5BF9return value\\u8FDB\\u884Cappend\\u3002\\n\\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        left_path = self.binaryTreePaths(root.left)\\n        right_path = self.binaryTreePaths(root.right)\\n        \\n        if not root.left and not root.right:\\n            res.append(str(root.val))\\n        \\n        if root.left:\\n            for path in left_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        if root.right:\\n            for path in right_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386 | \\u5206\\u5236\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        self.dfs(root, res, \\'\\')\\n        return res\\n    \\n    def dfs(self, root, res, temp):\\n        temp += str(root.val)\\n        if not root.left and not root.right:\\n            res.append(temp)\\n        if root.left:\\n            self.dfs(root.left, res, temp + \\'->\\')\\n        if root.right:\\n            self.dfs(root.right, res, temp + \\'->\\')\\n```\n```\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        if not root: return []\\n        res = []\\n        left_path = self.binaryTreePaths(root.left)\\n        right_path = self.binaryTreePaths(root.right)\\n        \\n        if not root.left and not root.right:\\n            res.append(str(root.val))\\n        \\n        if root.left:\\n            for path in left_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        if root.right:\\n            for path in right_path:\\n                path = str(root.val) + \\'->\\' + path \\n                res.append(path)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 68261,
                "title": "accepted-javascript-stack-solution",
                "content": "#### Approach Vertical Tree Walk\\n\\n**Intuition**\\n\\nTo avoid stack overflow problems on big datasets we will use stack data structure for saving state and walking through a tree.\\n\\n**Algorithm**\\n\\n* Initialize stack with *root* node and empty *path*;\\n* Iterate while *stack* has at least one element;\\n* Take last element from *stack*;\\n* Ensure element is not null;\\n* Initialize *children* with non-null right and left nodes;\\n* Concatenate stack item *path* and current node *path* and put it to *path*;\\n* Add result row if *children* is empty;\\n* Add each *child* with *path* to the *stack*.\\n\\n**Javascript**\\n\\n```javascript\\nvar binaryTreePaths = function(root) {\\n    let result = [];    \\n    let stack = [{node: root, path: []}];\\n    \\n    while (stack.length > 0) {\\n        let item = stack.pop();\\n        if (item.node === null) {\\n            continue;\\n        }\\n        \\n        let children = [item.node.right, item.node.left].filter(child => child !== null);\\n        let path = item.path.concat([item.node.val]);\\n\\n        if (children.length === 0) {\\n            result.push(path.join(\"->\"));\\n        }\\n\\n        children.forEach(child => stack.push({node: child, path: path}));\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity : *O(n)*.\\n\\nTo find all necessary paths we need to visit each node only once.\\n\\n* Space complexity : *O(m * 2)*\\n\\nWe need *O(m * 2)* space in worst case, where *m* is the depth of the tree.",
                "solutionTags": [],
                "code": "```javascript\\nvar binaryTreePaths = function(root) {\\n    let result = [];    \\n    let stack = [{node: root, path: []}];\\n    \\n    while (stack.length > 0) {\\n        let item = stack.pop();\\n        if (item.node === null) {\\n            continue;\\n        }\\n        \\n        let children = [item.node.right, item.node.left].filter(child => child !== null);\\n        let path = item.path.concat([item.node.val]);\\n\\n        if (children.length === 0) {\\n            result.push(path.join(\"->\"));\\n        }\\n\\n        children.forEach(child => stack.push({node: child, path: path}));\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68263,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nvoid copy(int *a,char *b,int temp)\\n{\\n    int j=0;\\n    for(int i=0;i<temp;i++)\\n    {j+=sprintf(b+j,\"%d->\",a[i]);}\\n    b[j-2]='\\\\0';\\n}\\nvoid order(struct TreeNode* root,int* returnSize,char** result,int *a,int *temp)\\n{\\n    if(root==NULL)\\n    {return ;}\\n    a[(*temp)++]=root->val;  \\n    if(root->left==NULL&&root->right==NULL)\\n    {\\n        result[*returnSize]=(char*)malloc(sizeof(char)*100);\\n        copy(a,result[*returnSize],*temp);\\n        (*returnSize)++;   \\n        (*temp)--;\\n        return;\\n    }\\n    order(root->left,returnSize,result,a,temp);\\n    order(root->right,returnSize,result,a,temp);\\n    (*temp)--;\\n}\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    int *temp=(int*)malloc(sizeof(int));\\n    *temp=0;\\n    int *a=(int*)malloc(sizeof(int)*100);\\n    char** result=(char**)malloc(sizeof(char*)*100);\\n    *returnSize=0;\\n    if(root==NULL)\\n    {return NULL;}\\n    order(root,returnSize,result,a,temp);  \\n    return result;   \\n}\\n````",
                "solutionTags": [],
                "code": "```\\nvoid copy(int *a,char *b,int temp)\\n{\\n    int j=0;\\n    for(int i=0;i<temp;i++)\\n    {j+=sprintf(b+j,\"%d->\",a[i]);}\\n    b[j-2]='\\\\0';\\n}\\nvoid order(struct TreeNode* root,int* returnSize,char** result,int *a,int *temp)\\n{\\n    if(root==NULL)\\n    {return ;}\\n    a[(*temp)++]=root->val;  \\n    if(root->left==NULL&&root->right==NULL)\\n    {\\n        result[*returnSize]=(char*)malloc(sizeof(char)*100);\\n        copy(a,result[*returnSize],*temp);\\n        (*returnSize)++;   \\n        (*temp)--;\\n        return;\\n    }\\n    order(root->left,returnSize,result,a,temp);\\n    order(root->right,returnSize,result,a,temp);\\n    (*temp)--;\\n}\\nchar** binaryTreePaths(struct TreeNode* root, int* returnSize) {\\n    int *temp=(int*)malloc(sizeof(int));\\n    *temp=0;\\n    int *a=(int*)malloc(sizeof(int)*100);\\n    char** result=(char**)malloc(sizeof(char*)*100);\\n    *returnSize=0;\\n    if(root==NULL)\\n    {return NULL;}\\n    order(root,returnSize,result,a,temp);  \\n    return result;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 68407,
                "title": "java-solution-with-recursive-easy-to-understand",
                "content": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res=new ArrayList<String>();\\n        if(root==null)  return res;\\n        String s=root.val+\"\";\\n        getPaths(res,root,s);\\n        return res;\\n    }\\n    private void getPaths(List<String> res,TreeNode root,String s){\\n        if(root.left==null&&root.right==null){\\n               res.add(s);\\n               return;\\n        }\\n        if(root.left!=null)\\n            getPaths(res,root.left,s+\"->\"+root.left.val);\\n        if(root.right!=null)\\n            getPaths(res,root.right,s+\"->\"+root.right.val);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> res=new ArrayList<String>();\\n        if(root==null)  return res;\\n        String s=root.val+\"\";\\n        getPaths(res,root,s);\\n        return res;\\n    }\\n    private void getPaths(List<String> res,TreeNode root,String s){\\n        if(root.left==null&&root.right==null){\\n               res.add(s);\\n               return;\\n        }\\n        if(root.left!=null)\\n            getPaths(res,root.left,s+\"->\"+root.left.val);\\n        if(root.right!=null)\\n            getPaths(res,root.right,s+\"->\"+root.right.val);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 68415,
                "title": "dfs-python-solution-very-easy-to-understand",
                "content": "    class Solution:\\n    # @param {TreeNode} root\\n    # @return {string[]}\\n    def binaryTreePaths(self, root):\\n        if not root:return []\\n        stack,res=[(root,[str(root.val)])],[]\\n        while stack:\\n            temp,val=stack.pop()\\n            if not temp.left and not temp.right:\\n                res.append('->'.join(val))\\n            if temp.left:\\n                stack.append((temp.left,val+[str(temp.left.val)]))\\n            if temp.right:\\n                stack.append((temp.right,val+[str(temp.right.val)]))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 68369,
                "title": "binary-tree-paths-bfs-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            // Write your code here\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            queue<pair<string, TreeNode*>> Q;\\n            Q.push({to_string(root->val), root});\\n            \\n            while (!Q.empty()) {\\n                string curStr = Q.front().first;\\n                TreeNode* curNode = Q.front().second;\\n                Q.pop();\\n                \\n                if (curNode->left == NULL && curNode->right == NULL) {\\n                    res.push_back(curStr);\\n                } else {\\n                    if (curNode->left != NULL)\\n                        Q.push({curStr + \"->\" + to_string(curNode->left->val), curNode->left});\\n                    if (curNode->right != NULL)\\n                        Q.push({curStr + \"->\" + to_string(curNode->right->val), curNode->right});\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            // Write your code here\\n            vector<string> res;\\n            if (root == NULL) return res;\\n            queue<pair<string, TreeNode*>> Q;\\n            Q.push({to_string(root->val), root}",
                "codeTag": "Java"
            },
            {
                "id": 68465,
                "title": "share-my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> ret;\\n            if(root) dfs(ret, \"\", root);\\n            return ret;\\n        }\\n        \\n        void dfs(vector<string> &ret, string path, TreeNode* root){\\n            path += to_string(root->val);\\n            if(!root->left && !root->right){\\n                ret.push_back(path);\\n            }else{\\n                if(root->left) dfs(ret, path + \"->\", root->left);\\n                if(root->right) dfs(ret, path + \"->\", root->right);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            vector<string> ret;\\n            if(root) dfs(ret, \"\", root);\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68474,
                "title": "my-concise-c-solution-neat-and-short",
                "content": "    \\n\\n    class Solution {\\n            void treeHelper(vector<string>& result, string temp, TreeNode* root){\\n                if(!root) return;\\n                if(!root -> left && !root -> right){\\n                    temp += to_string(root -> val);\\n                    result.push_back(temp);\\n                    return ;\\n                }\\n                temp += to_string(root -> val);\\n                treeHelper(result, temp + \"->\", root -> left);\\n                treeHelper(result, temp + \"->\", root -> right);\\n            }\\n        public:\\n            vector<string> binaryTreePaths(TreeNode* root) {\\n                vector<string> result;\\n                string temp = \"\";\\n                treeHelper(result, temp, root);\\n                return result;\\n            }\\n        };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n            void treeHelper(vector<string>& result, string temp, TreeNode* root){\\n                if(!root) return;\\n                if(!root -> left && !root -> right){\\n                    temp += to_string(root -> val);\\n                    result.push_back(temp);\\n                    return ;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 68500,
                "title": "java-solution-dfs",
                "content": "\\n    public class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rootLeafPath = new ArrayList<String>();\\n            if (root == null) return rootLeafPath;\\n            \\n            List<TreeNode> path = new LinkedList<TreeNode>();\\n            DFS(root, path , rootLeafPath);\\n            return rootLeafPath;\\n        }\\n        \\n        private void DFS(TreeNode root, List<TreeNode> path,   List<String> rootLeafPath){\\n            path.add(root);\\n            if (root.left != null) DFS(root.left, path, rootLeafPath);\\n            if (root.right != null) DFS(root.right, path, rootLeafPath);\\n            if (root.left == null && root.right == null) {\\n                StringBuilder sb = new StringBuilder();\\n                // print all value in current path\\n                for (int i = 0; i < path.size(); i++){\\n                    sb.append(path.get(i).val);\\n                    if (i != path.size()-1) sb.append(\"->\");\\n                }\\n                rootLeafPath.add(sb.toString());\\n            }\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> binaryTreePaths(TreeNode root) {\\n            List<String> rootLeafPath = new ArrayList<String>();\\n            if (root == null) return rootLeafPath;\\n            \\n            List<TreeNode> path = new LinkedList<TreeNode>();\\n            DFS(root, path , rootLeafPath);\\n            return rootLeafPath;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 68530,
                "title": "simple-binary-tree-paths-solution",
                "content": "    class Solution {\\n    public:\\n    \\n        using Elem = pair<TreeNode*, string>;\\n        using Stack = stack<Elem>;\\n    \\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            \\n            vector<string> paths;\\n            \\n            if(root)\\n            {\\n                Stack pool;\\n                pool.push(Elem(root, to_string(root->val)));\\n                \\n                while(!pool.empty())\\n                {\\n                    auto p = pool.top();\\n                    pool.pop();\\n                    \\n                    if(!p.first->left && !p.first->right)\\n                        paths.push_back(p.second);\\n                    \\n                    if(p.first->left)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->left->val);\\n                        pool.push(Elem(p.first->left, nstring));\\n                    }\\n                    \\n                    if(p.first->right)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->right->val);\\n                        pool.push(Elem(p.first->right, nstring));\\n                    }\\n                }\\n            }\\n            \\n            return paths;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        using Elem = pair<TreeNode*, string>;\\n        using Stack = stack<Elem>;\\n    \\n        vector<string> binaryTreePaths(TreeNode* root) {\\n            \\n            vector<string> paths;\\n            \\n            if(root)\\n            {\\n                Stack pool;\\n                pool.push(Elem(root, to_string(root->val)));\\n                \\n                while(!pool.empty())\\n                {\\n                    auto p = pool.top();\\n                    pool.pop();\\n                    \\n                    if(!p.first->left && !p.first->right)\\n                        paths.push_back(p.second);\\n                    \\n                    if(p.first->left)\\n                    {\\n                        string nstring = p.second + \"->\" + to_string(p.first->left->val);\\n                        pool.push(Elem(p.first->left, nstring));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3941880,
                "title": "c-clean-and-modular-code-using-backtracking-detailed-comments",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) due to path string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector <string> res; //store result\\n\\n    void addToPath(int val, string &path){\\n        path += \"->\" + to_string(val);\\n    }\\n\\n    void removeFromPath(int val, string &path){\\n        int len = to_string(val).length() + 2; // +2 due to \"->\"\\n        while(len--) path.pop_back(); \\n    }\\n\\n    void traverse(TreeNode* root, string &path){\\n        if(!root) return;\\n        if(!root->left && !root->right){ //reached leaf node\\n            addToPath(root->val, path); //do\\n            res.push_back(path); //add path \\n            removeFromPath(root->val, path); //undo\\n            return;\\n        }\\n\\n        addToPath(root->val, path); //do\\n        traverse(root->left, path); //recurse\\n        traverse(root->right, path);\\n        removeFromPath(root->val, path); //undo \\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        res.clear(); // clear result first\\n        string path = to_string(root->val); initialise path with root\\n        if(!root->left && !root->right) return {path};\\n        //check wether head itself is not a root if yes then return head value as only path\\n\\n        traverse(root->left, path); //recurse left subtree\\n        traverse(root->right, path); //recurse right subtree\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector <string> res; //store result\\n\\n    void addToPath(int val, string &path){\\n        path += \"->\" + to_string(val);\\n    }\\n\\n    void removeFromPath(int val, string &path){\\n        int len = to_string(val).length() + 2; // +2 due to \"->\"\\n        while(len--) path.pop_back(); \\n    }\\n\\n    void traverse(TreeNode* root, string &path){\\n        if(!root) return;\\n        if(!root->left && !root->right){ //reached leaf node\\n            addToPath(root->val, path); //do\\n            res.push_back(path); //add path \\n            removeFromPath(root->val, path); //undo\\n            return;\\n        }\\n\\n        addToPath(root->val, path); //do\\n        traverse(root->left, path); //recurse\\n        traverse(root->right, path);\\n        removeFromPath(root->val, path); //undo \\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        res.clear(); // clear result first\\n        string path = to_string(root->val); initialise path with root\\n        if(!root->left && !root->right) return {path};\\n        //check wether head itself is not a root if yes then return head value as only path\\n\\n        traverse(root->left, path); //recurse left subtree\\n        traverse(root->right, path); //recurse right subtree\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917896,
                "title": "python-easy-solution-100-recursion-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        arr=\\'\\'\\n        if not root:\\n            return []\\n        self.checkSm(root, arr)\\n        return self.res\\n    \\n    def checkSm(self, node, arr):\\n        newarr=arr+str(node.val)\\n        if not node.left and not node.right:\\n            self.res.append(newarr)\\n            return\\n        else:\\n            newarr=newarr+\\'->\\'\\n            if node.left:\\n                self.checkSm(node.left, newarr)\\n            if node.right:\\n                self.checkSm(node.right, newarr)\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def __init__(self):\\n        self.res=[]\\n\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        arr=\\'\\'\\n        if not root:\\n            return []\\n        self.checkSm(root, arr)\\n        return self.res\\n    \\n    def checkSm(self, node, arr):\\n        newarr=arr+str(node.val)\\n        if not node.left and not node.right:\\n            self.res.append(newarr)\\n            return\\n        else:\\n            newarr=newarr+\\'->\\'\\n            if node.left:\\n                self.checkSm(node.left, newarr)\\n            if node.right:\\n                self.checkSm(node.right, newarr)\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879045,
                "title": "accepted-java-simple-solution-recursive-dfs",
                "content": "# Intuition\\n\\n# Approach\\nWe simply create a helper function and simply perform inorder traversal while adding the values to a string and add the string to the arraylist as soon as we encounter a leaf node and empty the string for the next path.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> s=new ArrayList<>();\\n     String ss=\"\";\\n     helper(root,s,ss);\\n    return s;\\n    }\\n    public static void helper(TreeNode root , List<String> s,String ss)\\n    {   \\n        if(root==null)\\n        {return ;}\\n        if(root.left==null && root.right==null)\\n        {\\n            ss+=root.val;\\n            s.add(ss);\\n            ss=\"\";\\n            return ;\\n        }\\n        ss+=root.val+\"->\";\\n        helper(root.left,s,ss);\\n        helper(root.right,s,ss);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n     List<String> s=new ArrayList<>();\\n     String ss=\"\";\\n     helper(root,s,ss);\\n    return s;\\n    }\\n    public static void helper(TreeNode root , List<String> s,String ss)\\n    {   \\n        if(root==null)\\n        {return ;}\\n        if(root.left==null && root.right==null)\\n        {\\n            ss+=root.val;\\n            s.add(ss);\\n            ss=\"\";\\n            return ;\\n        }\\n        ss+=root.val+\"->\";\\n        helper(root.left,s,ss);\\n        helper(root.right,s,ss);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863269,
                "title": "preorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        helper(root,\"\",ans);\\n        return ans;\\n        \\n    }\\n    private void helper(TreeNode root,String up,List<String> ans){\\n        if(root == null)\\n         return;\\n\\n        if (root.left == null && root.right == null){\\n            ans.add(up+Integer.toString(root.val));\\n            return;\\n        }\\n\\n        helper(root.left,up + Integer.toString(root.val)+\"->\",ans);\\n        helper(root.right,up +Integer.toString(root.val)+\"->\",ans);\\n\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> ans = new ArrayList<>();\\n        helper(root,\"\",ans);\\n        return ans;\\n        \\n    }\\n    private void helper(TreeNode root,String up,List<String> ans){\\n        if(root == null)\\n         return;\\n\\n        if (root.left == null && root.right == null){\\n            ans.add(up+Integer.toString(root.val));\\n            return;\\n        }\\n\\n        helper(root.left,up + Integer.toString(root.val)+\"->\",ans);\\n        helper(root.right,up +Integer.toString(root.val)+\"->\",ans);\\n\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820624,
                "title": "simple-and-easy-traversal-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        solve(root,arr);\\n        return ans;\\n    }\\n    public Boolean solve(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) {\\n            return false;\\n        }\\n\\n        arr.add(root.val);\\n        Boolean left = solve(root.left,arr);\\n        Boolean right = solve(root.right,arr);\\n        if(left==true || right== true){\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        if(left==false && right==false){\\n            String s = \"\";\\n            for(int i=0;i<arr.size();i++){\\n                s+= arr.get(i)+\"\";\\n                if(i<arr.size()-1){\\n                    s+= \"->\";\\n                }\\n            }\\n            ans.add(s);\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        solve(root,arr);\\n        return ans;\\n    }\\n    public Boolean solve(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) {\\n            return false;\\n        }\\n\\n        arr.add(root.val);\\n        Boolean left = solve(root.left,arr);\\n        Boolean right = solve(root.right,arr);\\n        if(left==true || right== true){\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        if(left==false && right==false){\\n            String s = \"\";\\n            for(int i=0;i<arr.size();i++){\\n                s+= arr.get(i)+\"\";\\n                if(i<arr.size()-1){\\n                    s+= \"->\";\\n                }\\n            }\\n            ans.add(s);\\n            arr.remove(arr.size()-1);\\n            return true;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788869,
                "title": "easiest-way-to-solve-to-solve-binary-tree-path-java",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> lis = new ArrayList<>();\\n        dfs(root, lis, \"\");\\n        for(int i = 0; i < lis.size(); i++)\\n            lis.set(i, lis.get(i).substring(2));\\n        return lis;\\n    }\\n    public void dfs(TreeNode node, List<String> lis, String s){\\n        if(node == null) return;\\n        if(node.left == null && node.right == null)\\n            lis.add(s + \"->\" + node.val);\\n        s += \"->\" + node.val;\\n        dfs(node.left, lis, s);\\n        dfs(node.right, lis, s);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<String> lis = new ArrayList<>();\\n        dfs(root, lis, \"\");\\n        for(int i = 0; i < lis.size(); i++)\\n            lis.set(i, lis.get(i).substring(2));\\n        return lis;\\n    }\\n    public void dfs(TreeNode node, List<String> lis, String s){\\n        if(node == null) return;\\n        if(node.left == null && node.right == null)\\n            lis.add(s + \"->\" + node.val);\\n        s += \"->\" + node.val;\\n        dfs(node.left, lis, s);\\n        dfs(node.right, lis, s);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677320,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root) {\\n        if(!root->left && !root->right) return true;\\n\\n        return false;\\n    }\\n\\n    void getPath(TreeNode* root, vector<int>& temp, vector<string>& ans) {\\n        if(root == NULL) return ;\\n\\n        temp.push_back(root -> val);\\n\\n        if(isLeaf(root)) {\\n            string s = \"\";\\n            for(int i : temp) {\\n                s += to_string(i) + \"->\";\\n            }\\n            s = s.substr(0, s.length()-2);\\n            ans.push_back(s);\\n        }\\n\\n        getPath(root->left, temp, ans);\\n        getPath(root->right, temp, ans);\\n\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        if(root == NULL) return ans;\\n\\n        vector<int> temp;\\n        getPath(root, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode* root) {\\n        if(!root->left && !root->right) return true;\\n\\n        return false;\\n    }\\n\\n    void getPath(TreeNode* root, vector<int>& temp, vector<string>& ans) {\\n        if(root == NULL) return ;\\n\\n        temp.push_back(root -> val);\\n\\n        if(isLeaf(root)) {\\n            string s = \"\";\\n            for(int i : temp) {\\n                s += to_string(i) + \"->\";\\n            }\\n            s = s.substr(0, s.length()-2);\\n            ans.push_back(s);\\n        }\\n\\n        getPath(root->left, temp, ans);\\n        getPath(root->right, temp, ans);\\n\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        if(root == NULL) return ans;\\n\\n        vector<int> temp;\\n        getPath(root, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597335,
                "title": "c-recursive-dfs-beats-100",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string path = \"\";\\n        backtrack(result, path, root); \\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(vector<string>& result, string path, TreeNode*& root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            path += to_string(root->val);\\n            result.emplace_back(path);\\n            return;\\n        }\\n\\n        path += to_string(root->val) + \"->\";\\n        backtrack(result, path, root->left);\\n        backtrack(result, path, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> result;\\n        string path = \"\";\\n        backtrack(result, path, root); \\n        return result;\\n    }\\n\\nprivate:\\n    void backtrack(vector<string>& result, string path, TreeNode*& root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            path += to_string(root->val);\\n            result.emplace_back(path);\\n            return;\\n        }\\n\\n        path += to_string(root->val) + \"->\";\\n        backtrack(result, path, root->left);\\n        backtrack(result, path, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584312,
                "title": "recursive-solution-by-leo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n\\n        paths = []\\n        if root.left:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.left)]\\n        if root.right:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.right)]\\n\\n        return paths\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binaryTreePaths(self, root):\\n        if not root:\\n            return []\\n\\n        if not root.left and not root.right:\\n            return [str(root.val)]\\n\\n        paths = []\\n        if root.left:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.left)]\\n        if root.right:\\n            paths += [str(root.val) + \\'->\\' + path for path in self.binaryTreePaths(root.right)]\\n\\n        return paths\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576001,
                "title": "100-accepted-c-solution-easy-dfs",
                "content": "\\n```\\nclass Solution {\\n    private:\\n    vector<string>ans;\\n    void fun(TreeNode *root,string str)\\n    {\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val)+\"->\";\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            str.pop_back();\\n            str.pop_back();\\n            ans.push_back(str);\\n        }\\n        fun(root->left,str);\\n        fun(root->right,str);\\n        str.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string str =  \"\";\\n        fun(root,str);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    vector<string>ans;\\n    void fun(TreeNode *root,string str)\\n    {\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val)+\"->\";\\n        if(root->left == NULL && root->right == NULL)\\n        {\\n            str.pop_back();\\n            str.pop_back();\\n            ans.push_back(str);\\n        }\\n        fun(root->left,str);\\n        fun(root->right,str);\\n        str.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) \\n    {\\n        string str =  \"\";\\n        fun(root,str);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480135,
                "title": "binary-tree-paths-c-java-recursive-and-iterative-approach",
                "content": "# **Recursive: (faster)**\\nC++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        vector<int> path;\\n        vector<vector<int>> allPaths;\\n        getAllPaths(root,path,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        getAllPaths(root,path,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# **Iterative**\\n\\nc++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\n    void lvlOrder(TreeNode* node,vector<vector<int>> &allPaths){\\n        queue<pair<TreeNode*,vector<int>>>q;\\n        q.push({node,{}});\\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            node=ele.first;\\n            if(node->left==NULL && node->right==NULL){\\n                ele.second.push_back(node->val);\\n                allPaths.push_back(ele.second);\\n            }\\n            ele.second.push_back(node->val);\\n            if(node->left!=NULL) q.push({node->left,ele.second});\\n            if(node->right!=NULL) q.push({node->right,ele.second});\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        // vector<int> path;\\n        vector<vector<int>> allPaths;\\n        lvlOrder(root,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    TreeNode node;\\n    List<Integer> list;\\n    public Pair(TreeNode node,List<Integer> list){\\n        this.node=node;\\n        this.list=list;\\n    }\\n}\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    private void lvlOrder(TreeNode node,List<List<Integer>> allPaths){\\n        Queue<Pair>q= new LinkedList<>();\\n        q.add(new Pair(node,new ArrayList<>()));\\n        while(!q.isEmpty()){\\n            Pair ele=q.peek();\\n            q.remove();\\n            node=ele.node;\\n            if(node.left==null && node.right==null){\\n                ele.list.add(node.val);\\n                allPaths.add(new ArrayList<>(ele.list));\\n            }\\n            ele.list.add(node.val);\\n            if(node.left!=null) q.add(new Pair(node.left,new ArrayList<>(ele.list)));\\n            if(node.right!=null) q.add(new Pair(node.right,new ArrayList<>(ele.list)));\\n        }\\n    }\\n        \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        // List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        lvlOrder(root,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        vector<int> path;\\n        vector<vector<int>> allPaths;\\n        getAllPaths(root,path,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        getAllPaths(root,path,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void getAllPaths(TreeNode* node,vector<int> &path,vector<vector<int>> &allPaths){\\n        if(node->left==NULL && node->right==NULL){\\n            path.push_back(node->val);\\n            allPaths.push_back(path);\\n            path.pop_back();\\n            return;\\n        }\\n        path.push_back(node->val);\\n        if(node->left!=NULL) getAllPaths(node->left,path,allPaths);\\n        if(node->right!=NULL) getAllPaths(node->right,path,allPaths);\\n        path.pop_back();\\n        \\n    }\\n    void lvlOrder(TreeNode* node,vector<vector<int>> &allPaths){\\n        queue<pair<TreeNode*,vector<int>>>q;\\n        q.push({node,{}});\\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            node=ele.first;\\n            if(node->left==NULL && node->right==NULL){\\n                ele.second.push_back(node->val);\\n                allPaths.push_back(ele.second);\\n            }\\n            ele.second.push_back(node->val);\\n            if(node->left!=NULL) q.push({node->left,ele.second});\\n            if(node->right!=NULL) q.push({node->right,ele.second});\\n        }\\n    }\\npublic:\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) return {to_string(root->val)};\\n        // vector<int> path;\\n        vector<vector<int>> allPaths;\\n        lvlOrder(root,allPaths);\\n        vector<string> ans;\\n        for(auto vec:allPaths){\\n            string s=\"\";\\n            int vec_size=vec.size();\\n            for(int i=0;i<vec_size-1;i++){\\n                s.append(to_string(vec[i])+\"->\");\\n            }     \\n            s.append(to_string(vec[vec_size-1]));\\n            ans.push_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Pair{\\n    TreeNode node;\\n    List<Integer> list;\\n    public Pair(TreeNode node,List<Integer> list){\\n        this.node=node;\\n        this.list=list;\\n    }\\n}\\nclass Solution {\\n    private void getAllPaths(TreeNode node,List<Integer> path,List<List<Integer>> allPaths){\\n        if(node.left==null && node.right==null){\\n            path.add(node.val);\\n            allPaths.add(new ArrayList<>(path));\\n            path.remove(path.size()-1);\\n            return;\\n        }\\n        path.add(node.val);\\n        if(node.left!=null) getAllPaths(node.left,path,allPaths);\\n        if(node.right!=null) getAllPaths(node.right,path,allPaths);\\n        path.remove(path.size()-1);\\n        \\n    }\\n    private void lvlOrder(TreeNode node,List<List<Integer>> allPaths){\\n        Queue<Pair>q= new LinkedList<>();\\n        q.add(new Pair(node,new ArrayList<>()));\\n        while(!q.isEmpty()){\\n            Pair ele=q.peek();\\n            q.remove();\\n            node=ele.node;\\n            if(node.left==null && node.right==null){\\n                ele.list.add(node.val);\\n                allPaths.add(new ArrayList<>(ele.list));\\n            }\\n            ele.list.add(node.val);\\n            if(node.left!=null) q.add(new Pair(node.left,new ArrayList<>(ele.list)));\\n            if(node.right!=null) q.add(new Pair(node.right,new ArrayList<>(ele.list)));\\n        }\\n    }\\n        \\n    public List<String> binaryTreePaths(TreeNode root) {\\n        // List<Integer> path = new ArrayList<>();\\n        List<List<Integer>> allPaths= new ArrayList<>();\\n        List<String> ans= new ArrayList<>();\\n        lvlOrder(root,allPaths);\\n        for(List<Integer> arr:allPaths){\\n            StringBuffer str= new StringBuffer();\\n            for(int i=0;i<arr.size()-1;i++){\\n                str.append(String.valueOf(arr.get(i))+\"->\");\\n            }\\n            str.append(String.valueOf(arr.get(arr.size()-1)));\\n            ans.add(str.toString());\\n                       \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432558,
                "title": "this-is-the-shortest-ans-for-the-this-question",
                "content": "# Intuition\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string str) {\\n        if(node->left == NULL &&  node->right == NULL) ans.push_back(str + to_string(node->val));\\n        if(node->left) dfs(node->left, str + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, str + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void dfs(TreeNode* node, string str) {\\n        if(node->left == NULL &&  node->right == NULL) ans.push_back(str + to_string(node->val));\\n        if(node->left) dfs(node->left, str + to_string(node->val) + \"->\");\\n        if(node->right) dfs(node->right, str + to_string(node->val) + \"->\");\\n    }\\n     \\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        dfs(root, \"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393713,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<string>& ans, string temp){\\n        if (root==NULL)return;\\n        string node= to_string(root->val);\\n        temp+= node;\\n        if (root->left==NULL && root->right==NULL){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        else temp+= \"->\";\\n        if (root->left) dfs(root->left,ans,temp);\\n        if (root->right) dfs(root->right,ans,temp);\\n        //temp.pop_back();\\n        //temp.pop_back();\\n        //temp.pop_back();\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        dfs(root,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<string>& ans, string temp){\\n        if (root==NULL)return;\\n        string node= to_string(root->val);\\n        temp+= node;\\n        if (root->left==NULL && root->right==NULL){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        else temp+= \"->\";\\n        if (root->left) dfs(root->left,ans,temp);\\n        if (root->right) dfs(root->right,ans,temp);\\n        //temp.pop_back();\\n        //temp.pop_back();\\n        //temp.pop_back();\\n    }\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<string> ans;\\n        string temp=\"\";\\n        dfs(root,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188529,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root , vector<int> &temp , vector<vector<int> > &ans){\\n        if(root == NULL){\\n            // ans.push_back(s);\\n            return ;\\n        }\\n        if(root -> left == NULL && root -> right == NULL){\\n           temp.push_back(root -> val);\\n           ans.push_back(temp);\\n           temp.pop_back();\\n           return;\\n        }\\n        // cout << root -> val << endl;\\n        temp.push_back(root->val);\\n        helper(root->left, temp,ans);\\n        helper(root->right, temp,ans);\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        helper(root, temp, ans);\\n        vector<string> sol;\\n        for(auto v:ans){\\n            string t = \"\";\\n            for(int i=0;i<v.size()-1;i++){\\n                t += to_string(v[i]);\\n                t += \"->\";\\n            }\\n            t += to_string(v[v.size()-1]);\\n            sol.push_back(t);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root , vector<int> &temp , vector<vector<int> > &ans){\\n        if(root == NULL){\\n            // ans.push_back(s);\\n            return ;\\n        }\\n        if(root -> left == NULL && root -> right == NULL){\\n           temp.push_back(root -> val);\\n           ans.push_back(temp);\\n           temp.pop_back();\\n           return;\\n        }\\n        // cout << root -> val << endl;\\n        temp.push_back(root->val);\\n        helper(root->left, temp,ans);\\n        helper(root->right, temp,ans);\\n        temp.pop_back();\\n    }\\n\\n    vector<string> binaryTreePaths(TreeNode* root) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        helper(root, temp, ans);\\n        vector<string> sol;\\n        for(auto v:ans){\\n            string t = \"\";\\n            for(int i=0;i<v.size()-1;i++){\\n                t += to_string(v[i]);\\n                t += \"->\";\\n            }\\n            t += to_string(v[v.size()-1]);\\n            sol.push_back(t);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3184409,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public List<string> ans;\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        ans=new();\\n        if(root.left==null&&root.right==null){\\n                ans.Add(root.val.ToString());\\n                return ans;\\n            }\\n        StringBuilder sb=new();\\n        dfs(root,sb);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,StringBuilder sb){\\n        if(root!=null){\\n            sb.Append(root.val);\\n            if(root.left==null&&root.right==null){\\n                ans.Add(sb.ToString());\\n            }\\n            else{\\n            sb.Append(\"->\");\\n            }\\n            StringBuilder sbl=new();\\n            StringBuilder sbr=new();\\n            sbl.Append(sb.ToString());\\n            sbr.Append(sb.ToString());\\n            dfs(root.left,sbl);\\n            dfs(root.right,sbr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<string> ans;\\n    public IList<string> BinaryTreePaths(TreeNode root) {\\n        ans=new();\\n        if(root.left==null&&root.right==null){\\n                ans.Add(root.val.ToString());\\n                return ans;\\n            }\\n        StringBuilder sb=new();\\n        dfs(root,sb);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root,StringBuilder sb){\\n        if(root!=null){\\n            sb.Append(root.val);\\n            if(root.left==null&&root.right==null){\\n                ans.Add(sb.ToString());\\n            }\\n            else{\\n            sb.Append(\"->\");\\n            }\\n            StringBuilder sbl=new();\\n            StringBuilder sbr=new();\\n            sbl.Append(sb.ToString());\\n            sbr.Append(sb.ToString());\\n            dfs(root.left,sbl);\\n            dfs(root.right,sbr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823810,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n public List<String> binaryTreePaths(TreeNode root) {\\n  List<String> paths = new ArrayList<>();\\n  if (root == null) return paths;\\n\\n  Stack<TreeNode> stackNode = new Stack<>();\\n  Stack<String> stackInt = new Stack<>();\\n  stackNode.push(root);\\n  stackInt.push(Integer.toString(root.val));\\n\\n  while (!stackNode.empty()) {\\n   TreeNode node = stackNode.pop();\\n   String num = stackInt.pop();\\n\\n   if (node.left == null && node.right == null) {\\n    paths.add(num);\\n   }\\n\\n   if (node.left != null) {\\n    stackNode.push(node.left);\\n    stackInt.push(num + \"->\" + node.left.val);\\n   }\\n\\n   if (node.right != null) {\\n    stackNode.push(node.right);\\n    stackInt.push(num + \"->\" + node.right.val);\\n   }\\n  }\\n\\n  return paths;\\n }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n public List<String> binaryTreePaths(TreeNode root) {\\n  List<String> paths = new ArrayList<>();\\n  if (root == null) return paths;\\n\\n  Stack<TreeNode> stackNode = new Stack<>();\\n  Stack<String> stackInt = new Stack<>();\\n  stackNode.push(root);\\n  stackInt.push(Integer.toString(root.val));\\n\\n  while (!stackNode.empty()) {\\n   TreeNode node = stackNode.pop();\\n   String num = stackInt.pop();\\n\\n   if (node.left == null && node.right == null) {\\n    paths.add(num);\\n   }\\n\\n   if (node.left != null) {\\n    stackNode.push(node.left);\\n    stackInt.push(num + \"->\" + node.left.val);\\n   }\\n\\n   if (node.right != null) {\\n    stackNode.push(node.right);\\n    stackInt.push(num + \"->\" + node.right.val);\\n   }\\n  }\\n\\n  return paths;\\n }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2823001,
                "title": "python3-using-queue-level-order-traversal",
                "content": "```\\nclass Node:\\n    def __init__(self, value):\\n        self.value = value\\n        self.next = None\\n    \\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self.length = 0\\n\\n    def __len__(self):\\n        return self.length\\n\\n    def add(self, value):\\n        node = Node(value)\\n        if self.head:\\n            self.tail.next = node\\n            self.tail = node\\n        else:\\n            self.head = node\\n            self.tail = node\\n        self.length += 1\\n\\n    def remove_first(self):\\n        if self.head:\\n            value = self.head.value\\n            self.head = self.head.next\\n            self.length -= 1\\n            return value\\n\\nclass Queue:\\n    def __init__(self, size = 0):\\n        self.list = LinkedList()\\n        self.size = size\\n\\n    def enqueue(self, value):\\n        self.list.add(value)\\n\\n    def dequeue(self):\\n        return self.list.remove_first()\\n    \\n    def is_empty(self):\\n        return self.list.head == None\\n\\nclass Solution:\\n    def binaryTreePaths(self, rootNode: Optional[TreeNode]) -> List[str]:\\n        if not rootNode:\\n            return\\n        else:\\n            queue = Queue()\\n            queue.enqueue(rootNode)\\n            paths = {\\n                f\"0-{rootNode.val}\": str(rootNode.val)\\n            }\\n            next_counter = 0\\n            current_counter = 0\\n            while not queue.is_empty():\\n                current = queue.dequeue()\\n                current_parent = paths[f\"{current_counter}-{current.val}\"]\\n                if current.left:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.left.val}\\'] = f\\'{current_parent}->{current.left.val}\\'\\n                    queue.enqueue(current.left)\\n                if current.right:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.right.val}\\'] = f\\'{current_parent}->{current.right.val}\\'\\n                    queue.enqueue(current.right)\\n                if current.right or current.left:    \\n                    del paths[f\"{current_counter}-{current.val}\"]\\n                current_counter += 1\\n            return list(paths.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, value):\\n        self.value = value\\n        self.next = None\\n    \\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self.length = 0\\n\\n    def __len__(self):\\n        return self.length\\n\\n    def add(self, value):\\n        node = Node(value)\\n        if self.head:\\n            self.tail.next = node\\n            self.tail = node\\n        else:\\n            self.head = node\\n            self.tail = node\\n        self.length += 1\\n\\n    def remove_first(self):\\n        if self.head:\\n            value = self.head.value\\n            self.head = self.head.next\\n            self.length -= 1\\n            return value\\n\\nclass Queue:\\n    def __init__(self, size = 0):\\n        self.list = LinkedList()\\n        self.size = size\\n\\n    def enqueue(self, value):\\n        self.list.add(value)\\n\\n    def dequeue(self):\\n        return self.list.remove_first()\\n    \\n    def is_empty(self):\\n        return self.list.head == None\\n\\nclass Solution:\\n    def binaryTreePaths(self, rootNode: Optional[TreeNode]) -> List[str]:\\n        if not rootNode:\\n            return\\n        else:\\n            queue = Queue()\\n            queue.enqueue(rootNode)\\n            paths = {\\n                f\"0-{rootNode.val}\": str(rootNode.val)\\n            }\\n            next_counter = 0\\n            current_counter = 0\\n            while not queue.is_empty():\\n                current = queue.dequeue()\\n                current_parent = paths[f\"{current_counter}-{current.val}\"]\\n                if current.left:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.left.val}\\'] = f\\'{current_parent}->{current.left.val}\\'\\n                    queue.enqueue(current.left)\\n                if current.right:\\n                    next_counter += 1\\n                    paths[f\\'{next_counter}-{current.right.val}\\'] = f\\'{current_parent}->{current.right.val}\\'\\n                    queue.enqueue(current.right)\\n                if current.right or current.left:    \\n                    del paths[f\"{current_counter}-{current.val}\"]\\n                current_counter += 1\\n            return list(paths.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816197,
                "title": "java-dfs-solution-in-6-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        goDFS(root, list, result);\\n        StringBuilder sb = new StringBuilder();\\n        List<String> strings = new ArrayList<>();\\n        for (List<Integer> l : result) {\\n            for (int i = 0; i < l.size() - 1; i++) {\\n                sb.append(l.get(i)).append(\"->\");\\n            }\\n            sb.append(l.get(l.size() - 1));\\n            strings.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return strings;\\n    }\\n\\n    private void goDFS(TreeNode node, List<Integer> list, List<List<Integer>> result) {\\n        if (node == null) return;\\n        list.add(node.val);\\n        if (node.left == null && node.right == null) {\\n            result.add(new ArrayList<>(list));\\n        }\\n        goDFS(node.left, list, result);\\n        goDFS(node.right, list, result);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        goDFS(root, list, result);\\n        StringBuilder sb = new StringBuilder();\\n        List<String> strings = new ArrayList<>();\\n        for (List<Integer> l : result) {\\n            for (int i = 0; i < l.size() - 1; i++) {\\n                sb.append(l.get(i)).append(\"->\");\\n            }\\n            sb.append(l.get(l.size() - 1));\\n            strings.add(sb.toString());\\n            sb.setLength(0);\\n        }\\n        return strings;\\n    }\\n\\n    private void goDFS(TreeNode node, List<Integer> list, List<List<Integer>> result) {\\n        if (node == null) return;\\n        list.add(node.val);\\n        if (node.left == null && node.right == null) {\\n            result.add(new ArrayList<>(list));\\n        }\\n        goDFS(node.left, list, result);\\n        goDFS(node.right, list, result);\\n        list.remove(list.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812095,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isleaf(TreeNode* root){\\n\\t\\t\\treturn (!root->left && !root->right);\\n\\t\\t}\\n\\t\\tvoid chk(vector<vector<int>>&v, vector<int>&a, TreeNode* root){\\n\\t\\t\\tif(!root){return;}\\n\\t\\t\\ta.push_back(root->val);\\n\\t\\t\\tif(isleaf(root)){v.push_back(a);}\\n\\t\\t\\tchk(v, a, root->left);\\n\\t\\t\\tchk(v, a, root->right);\\n\\t\\t\\ta.pop_back();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<string> binaryTreePaths(TreeNode* root) {\\n\\t\\t\\tvector<vector<int>>v;\\n\\t\\t\\tvector<int>a;\\n\\t\\t\\tchk(v, a, root);\\n\\t\\t\\t// for(int i=0; i<v.size(); i++){\\n\\t\\t\\t//     for(int j=0; j<v[i].size(); j++){\\n\\t\\t\\t//         cout<<v[i][j]<<\" \";\\n\\t\\t\\t//     }cout<<endl;\\n\\t\\t\\t// }\\n\\t\\t\\tvector<string>ans;\\n\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\tstring x=\"\";\\n\\t\\t\\t\\tfor(int j=0; j<v[i].size(); j++){\\n\\t\\t\\t\\t\\tx+=to_string(v[i][j]);\\n\\t\\t\\t\\t\\tx+=\\'-\\'; x+=\\'>\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx.pop_back();\\n\\t\\t\\t\\tx.pop_back();\\n\\t\\t\\t\\tans.push_back(x);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isleaf(TreeNode* root){\\n\\t\\t\\treturn (!root->left && !root->right);\\n\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1863853,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1738339,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1866733,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1573978,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1950610,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1934897,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1785347,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1728220,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1571497,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 2066813,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1863853,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1738339,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1866733,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1573978,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1950610,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1934897,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1785347,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1728220,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 1571497,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            },
            {
                "id": 2066813,
                "content": [
                    {
                        "username": "sourabhbawage",
                        "content": "Didn\\'t feel Easy to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "If you solve something like Path sum I and II before this one, this is pretty easy "
                    },
                    {
                        "username": "psionl0",
                        "content": "Building a list of lists (or in this case a list of strings - after building up each string) takes some knowledge."
                    },
                    {
                        "username": "piotrkow93",
                        "content": "This is DFS problem. \\nGo recursively through the graph and build path, if left and right are null for the node it means it is a leaf an you can add path to result :) "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 If you make it without going to solution you are ready to  go on medium level."
                    },
                    {
                        "username": "Alien_in_hell",
                        "content": "is this for real I feel dumb af"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s an interesting related problem - Maximum Sum Root to Leaf path\\nhttps://www.techiedelight.com/find-maximum-sum-root-to-leaf-path-binary-tree/"
                    },
                    {
                        "username": "mochiball",
                        "content": "This one and Path sum I and II are all very similar "
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\n# Intuition\\nDFS (Preorder) C++.\\n\\n# Approach\\n\\n1. Declare a function `rec` that takes three parameters: a pointer to a `TreeNode` object named `root`, a reference to a vector of strings named `ans`, and a string named `temp`.\\n2. Inside the `rec` function, check if `root` is `NULL` (i.e., there is no node). If true, return from the function.\\n3. Append the string representation of `root->val` followed by \"->\" to the `temp` string.\\n4. Check if both the left and right child nodes of `root` are `NULL`. If true, it means the current node is a leaf node.\\n5. Remove the last two characters from the `temp` string to eliminate the arrow \"->\" from the leaf node\\'s path.\\n6. Add the `temp` string to the `ans` vector since it represents a complete path from the root to a leaf node.\\n7. Return from the function.\\n8. Call the `rec` function recursively for the left child of `root` and pass the `ans` and `temp` strings as arguments.\\n9. Call the `rec` function recursively for the right child of `root` and pass the `ans` and `temp` strings as arguments.\\n10. Declare a function `binaryTreePaths` that takes a pointer to a `TreeNode` object named `root` as a parameter.\\n11. Inside the `binaryTreePaths` function, check if `root` is `NULL`. If true, return an empty vector since there are no paths in an empty tree.\\n12. Declare a vector of strings named `ans` to store the paths.\\n13. Call the `rec` function, passing `root`, `ans`, and an empty string as arguments to start the recursive traversal.\\n14. Return the `ans` vector containing all the paths from the root to the leaves.\\n------------------------------\\n\\n# Complexity\\n- Time complexity:\\nO(n) n=number of nodes.\\n\\n- Space complexity:\\nO(h) h=maximum height of tree. \\nIn worst case skewed tree height is O(n). \\n--------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/binary-tree-paths/solutions/3700850/dfs-preorder-c/\\n\\n"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "Please don\\'t post solutions here."
                    },
                    {
                        "username": "sumantaraj",
                        "content": "THIS IS A bACKTRACKING PROBLEM \\n\\nSome tips :-\\n> Ths can be solved either by pass by value or pass by refrence\\n>Before backtracking you have to delete the prev stored nodes so better store in a tempfile before \\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "thank you for your tip but case 133 is not working\\n"
                    },
                    {
                        "username": "TatianaO8",
                        "content": "Why does replacing string concatenation with StringBuilder not work?\\n\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> binaryTreePaths(TreeNode root) {\\n        if(root == null) {\\n            return ans;\\n        }\\n\\n        StringBuilder s = new StringBuilder();\\n        addPath(root, new StringBuilder());\\n        \\n        return ans;\\n    }\\n\\n    public void addPath(TreeNode root, StringBuilder s) {\\n        if(root != null) {\\n            if(s.length()>0) {\\n                s.append(\"->\");\\n            }\\n            s.append(Integer.toString(root.val));\\n            if(root.left == null && root.right == null) {\\n                ans.add(s.toString());\\n            } else {\\n                addPath(root.left, s);\\n                addPath(root.right, s);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "wagzap",
                        "content": "<h2>Here's why it doesn't work</h2>\n\nEvery node's representation is added to the `StringBuilder`, and never removed .\nSo it ends up being part of every path built after it, and it shouldn't be .\nWhen you use string concatenation, each path is created from strings that are concatenated (resulting in an independent string each time), so that problem doesn't exist.\n\n<h3>Example</h3>\n\nThe smallest binary tree with this problem: the root has 2 children.\nInput [1,2,3].\nThere are 2 paths: from 1 to 2, as \"1->2\", and from 1 to 3, as \"1->3\".\nBut the code you shared outputs \"1->2\", and \"1->2->3\".\nFor your approach to work, you have to count the number of characters you added, to remove them from the end of the builder at the right time.\n\n<details>\n<summary>A few comments about that solution (click/push to open)</summary>\n\n- No need for the null check in `binaryTreePaths`, `addPath` does that already.\n- The  `StringBuilder s` created in `binaryTreePaths` isn't used, I removed it.\nIt can also be moved as a class member, and used just like `ans`\n- The indentation can be reduced by changing the body of `addPath` from\n```java\n        if (root != null) {\n            // code here\n        }\n```\nto\n```java\n        if (root == null) {\n            return;\n        }\n        // code here\n```\n\nI suggest doing the things above as an exercise.\n- When writing Java code in a comment, please put it between these, for proper formatting:\n\\```java\n// code here\n\\```\n</details>\n\n<h2>You now have the needed info to make it work (please try it before reading the solution below)</h2>\n\n<details>\n<summary>Here's my solution that corrects the version you shared </summary>\n\n```java\nclass Solution {\n    List<String> ans = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        if (root == null) {\n            return ans;\n        }\n        addPath(root, new StringBuilder());\n        return ans;\n    }\n\n    public void addPath(TreeNode root, StringBuilder builder) {\n        if (root != null) {\n            int toDelete = 0;\n            if (builder.length() > 0) {\n                builder.append(\"->\");\n                toDelete += 2;\n            }\n            String valueString = Integer.toString(root.val);\n            builder.append(valueString);\n            toDelete += valueString.length();\n            if(root.left == null && root.right == null) {\n                ans.add(builder.toString());\n            } else {\n                addPath(root.left, builder);\n                addPath(root.right, builder);\n            }\n            int end = builder.length();\n            builder.delete(end-toDelete, end);\n        }\n    }\n}\n```\n\n</details>"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "Brennan-M",
                        "content": "I have written working solution when I am testing assuming the input for root is a TreeNode. However when I run it on this website, it says the input was an array [1,2]. What does that mean? I thought type root was a TreeNode?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "The input is in form of an array , for example [1,2] represents a tree with root node as 1 and having a left child as 2 .\\n"
                    },
                    {
                        "username": "pssanth1",
                        "content": "In this solution, Can Someone tell me why the ans list is empty after the dfs call? If I print `path` at the base case, the path is correct. But why is not adding into the ans?\\n\\n `class Solution:\\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\\n        ans = []\\n\\n        def dfs(root, path):\\n            if not root: return\\n            path.append(root.val)\\n            if not root.left and not root.right:\\n                ans.append(path)\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n            path.pop()     \\n        \\n        dfs(root, [])\\n        return ans`\\n"
                    }
                ]
            }
        ]
    }
]