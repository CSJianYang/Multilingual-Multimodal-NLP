[
    {
        "title": "Find All Numbers Disappeared in an Array",
        "question_content": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\n&nbsp;\nExample 1:\nInput: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\nExample 2:\nInput: nums = [1,1]\nOutput: [2]\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t1 <= n <= 105\n\t1 <= nums[i] <= n\n\n&nbsp;\nFollow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.",
        "solutions": [
            {
                "id": 92955,
                "title": "python-4-lines-with-short-explanation",
                "content": "For each number i in nums,\\nwe mark the number that i points as negative.\\nThen we filter the list, get all the indexes\\nwho points to a positive number.\\nSince those indexes are not visited.\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # For each number i in nums,\\n        # we mark the number that i points as negative.\\n        # Then we filter the list, get all the indexes\\n        # who points to a positive number\\n        for i in xrange(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = - abs(nums[index])\\n\\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # For each number i in nums,\\n        # we mark the number that i points as negative.\\n        # Then we filter the list, get all the indexes\\n        # who points to a positive number\\n        for i in xrange(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = - abs(nums[index])\\n\\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344583,
                "title": "python-o-1-space-solution",
                "content": "The idea is to use the original array to keep track of the numbers visited. Since all the numbers are positive intergers, for every number visited we mark the presence of that number by negating the number at the index equal to the current number. Since Python follows 0-indexing, the index we mark is actually `number - 1`. If the number at that index is already negated we do nothing. In the end, we just return the indices `(index + 1 for the number)` where there are still postive numbers.\\n\\nStill confused?? I hope the following example will make it clearer:\\nLet `nums = [4, 3, 2, 7, 8, 2, 3, 1]`. Now let\\'s iterate through the array `nums`.\\n\\nAt `iter = 0`,\\n`current number: |4|` `(|.| here refers to taking the absolute value)`\\n`number at index = 3 (current number - 1): 7` \\nAfter negation: `nums = [4, 3, 2, -7, 8, 2, 3, 1]`\\n\\nAt `iter = 1`\\n`current number: |3|`\\n`number at index = 2: 2` \\nAfter negation: `nums = [4, 3, -2, -7, 8, 2, 3, 1]`\\n\\nAt `iter = 2`\\n`current number: |-2|`\\n`number at index = 1: 3` \\nAfter negation: `nums = [4, -3, -2, -7, 8, 2, 3, 1]`\\n\\nAt `iter = 3`\\n`current number: |-7|`\\n`number at index = 6: 3` \\nAfter negation: `nums = [4, -3, -2, -7, 8, 2, -3, 1]`\\n\\nAt `iter = 4`\\n`current number: |8|`\\n`number at index = 7: 1` \\nAfter negation: `nums = [4, -3, -2, -7, 8, 2, -3, -1]`\\n\\nAt `iter = 5`\\n`current number: |2|`\\n`number at index = 1: -3` \\nArray stays unchanged: `nums = [4, -3, -2, -7, 8, 2, -3, -1]`\\n\\nAt `iter = 6`\\n`current number: |-3|`\\n`number at index = 2: -2` \\nArray stays unchanged: `nums = [4, -3, -2, -7, 8, 2, -3, -1]`\\n\\nAt `iter = 7`\\n`current number: |-1|`\\n`number at index = 0: 4` \\nAfter negation: `nums = [-4, -3, -2, -7, 8, 2, -3, -1]`\\t\\t\\t\\t \\n\\nNow the indices at which there are still positive numbers are the numbers (index+1) that weren\\'t present in the array.\\n\\n```Python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in range(len(nums)):\\n            temp = abs(nums[i]) - 1\\n            if nums[temp] > 0:\\n                nums[temp] *= -1\\n        \\n        res = []\\n        for i,n in enumerate(nums):\\n            if n > 0:\\n                res.append(i+1)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in range(len(nums)):\\n            temp = abs(nums[i]) - 1\\n            if nums[temp] > 0:\\n                nums[temp] *= -1\\n        \\n        res = []\\n        for i,n in enumerate(nums):\\n            if n > 0:\\n                res.append(i+1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583736,
                "title": "c-python-all-6-solutions-w-explanations-binary-search-hashset-2x-o-1-space-approach",
                "content": "We are given an array `nums` of size `n`. We need to return an array `ans` containing all elements in range `[1, n]` that are not present in `nums`.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nA brute-force way to solve this question is to take each number in range `[1, n]` and push it into `ans` array if it doesn\\'t occur in `nums`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(find(begin(nums), end(nums), i) == end(nums))  // linear search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        return [i for i in range(1, len(nums)+1) if i not in nums]\\n```\\n\\n***Time Complexity :*** **<code>O(n<sup>2</sup>)</code>**, we iterate over the range `[1, n]` which takes `O(n)` and for each iteration, we check if that element occurs in `nums` which takes another `O(n)` giving total time of <code>O(n<sup>2</sup>)</code>\\n***Space Complexity :*** **<code>O(1)</code>**, excluding the space required for the output vector, we only use constant extra space. The output space is generally not included in the space complexity.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Sort & Binary-Search)***\\n\\nInstead of linear-searching if every element in range `[1, n]` is present in `nums` or not, we could instead sort `nums` and then apply binary-search every time. If the element is not found in `nums`, we include it in `ans`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(!binary_search(begin(nums), end(nums), i))   // binary search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        nums.sort()\\n        return [i for i in range(1, len(nums)+1) if nums[bisect_left(nums, i)%len(nums)] != i]\\n```\\n\\n***Time Complexity :*** **<code>O(nlogn)</code>**, we iterate over the range `[1, n]` which takes `O(n)` and for each iteration, we check if that element occurs in `nums` using binary search which takes another `O(logn)` giving a total time of <code>O(nlogn)</code>\\n***Space Complexity :*** **<code>O(sort)</code>**, the only extra space required is the one used in internal sorting algorithm. Ignoring that space, we can say it to be `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (HashSet)***\\n\\nWe can do even better if we just insert every element from `nums` into a hashset and then iterate over the range `[1, n]` and only add those elements to `ans` and are not present in hashset.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_set<int> s(begin(nums), end(nums));   // insert every nums[i] in hashset\\n        vector<int> ans(size(nums) - size(s));\\n        for(int i = 1, j = 0; i <= size(nums); i++)  \\n            if(!s.count(i)) ans[j++] = i;               // add all elements not found in hashset to ans\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        s = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in s]\\n```\\n\\n***Time Complexity :*** **<code>O(n)</code>**, we require `O(n)` time to insert all elements into hashset and another `O(n)` time to iterate over range and insert elements not present in hashset into `ans`, thus giving a total time of `O(n)`.\\n***Space Complexity :*** **<code>O(n)</code>**, required to maintain the hashset.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Boolean array)***\\n\\nWe can slightly optimize previous approach by using an boolean array of size `n` instead of hashset, since the range is known to be `[1, n]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<bool> seen(size(nums)+1);\\n        vector<int> ans;\\n        for(auto c : nums) seen[c] = true;\\n        for(int i = 1; i <= size(nums); i++)\\n            if(!seen[i]) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        ans, seen = [], [False]*(len(nums)+1)\\n        for c in nums: seen[c] = True\\n        for i in range(1, len(nums)+1):\\n            if not seen[i]:\\n                ans.append(i)\\n        return ans\\n```\\n\\n***Time Complexity :*** **<code>O(n)</code>**\\n***Space Complexity :*** **<code>O(n)</code>**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Placing Elements at Correct Index - Space Optimized)***\\n\\nThis solution involves placing all possible elements at their right index place. By that, I mean every possible index `i` should be occupied by correct element `i+1`, i.e, `num[i] = i+1`. This allows us to check if a number `j` from range `[1, n]` exists in `nums` or not. \\n* The numbers `j` will be present in `nums` only if the number `j` itself is present at `nums[j-1]` which is its correct index place. \\n* The numbers `j\\'` that are not present in `nums` wont have correct element (which is `j\\'` itself) at its correct index place `nums[j\\'-1]`.\\n\\nThe numbers `j` that are not in `nums` wont have correct element  at their right index place (`nums[i-1]`) and that index place would be occupied by some other element.\\n\\n**Now, Can we do this linearly using constant space? Yes!**\\n1. We will iterate over each element of `nums`.\\n2. For each element `c`, if the correct index place of `c`, i.e, `nums[c-1]` is not occupied by `c`, then we place `c` at its correct index place. But we dont want to lose number which was already present at `nums[c-1]`. So we swap it instead so the number at `nums[c-1]` occupies current element `c` & vice-versa.\\n3. We placed original current element `c` at its correct place but now we have another element as `c` for which we need to place it at its correct place. So, repeat above step till `c` is at its correct place in `nums`.\\n4. The steps 2 & 3 are repeated for all elements of `nums` so that we ensure every possible index is occupied by correct element. At last, the index not occupied by correct element are once which dont occur in `nums`.\\n\\n```python\\nLet nums = [4,3,2,7,8,2,3,1]. The steps take place as -\\n\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n\\nIndex 4 & 5 are not occupied by their correct elements meaning the elements corresponding to those indices are missing\\n```\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto& c : nums) \\n            while(nums[c-1] != c) \\n\\t\\t\\t\\tswap(c, nums[c-1]);               // swap till correct index place of c is not occupied by c itself\\n        for(int i = 1; i <= size(nums); i++)\\n            if(i != nums[i-1]) ans.push_back(i);  // correct index place of i is not occupied by i itself\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        for i in range(len(nums)):\\n            while nums[nums[i]-1] != nums[i]: \\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n        return [i for i in range(1, len(nums)+1) if i != nums[i-1]]\\n```\\n\\n**Is Infinite loop possible in while statement?**\\nNo. This is because each time we take an element and swap it with element at its right index. Each element will be placed at its right index only once. So, the while loop is bound to terminate within `O(n)`\\n\\n***Time Complexity :*** **`O(n)`**, the first loop places each possible element at its correct index place only once. Thus the for loop and its inner while loop run for atmost `O(n)`.\\n***Space Complexity :*** **`O(1)`**, only constant extra space is being used except for the output `ans`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VI (Mark as seen by Negation - Space Optimized)***\\n\\nThere\\'s another way that we can compute `ans` without using any extra space (except the output `ans`). We know that **`nums` is of size is `n`** and it contains **only elements from `[1, n]`.** We can map each element of the range `[1, n]` to the indices of `nums` from `[0, n-1]`.\\n\\nThus, the above property can be used to mark if an element from range `[1, n]` is present in `nums` or not. \\n\\n**How?**\\nWe can iterate over `nums` and for each element, we know it can be mapped to index `nums[i]-1`. We can therefore **mark the element `nums[i]` as present in `nums` by making the element at index `nums[i]-1` negative**. Thus after iterating the array, we have -\\n\\n* `nums[i] < 0` or `nums[i]` is  negative only if the element `i+1` is present in the array.\\n* `nums[i] > 0` or `nums[i]` is positive only if the element `i+1` is not present in the array\\n\\nFor eg. Consider the following example -\\n```python\\nnums = [4,3,2,7,8,2,3,1]\\n1. \\'4\\' is present in nums. Mark as present by negating nums[4-1] = nums[3].  Thus, nums[3] = -7\\n   => nums = [4,3,2,-7,8,2,3,1]\\n\\t\\n2. \\'3\\' is present in nums. Mark as present by negating nums[3-1] = nums[2].  Thus, nums[2] = -2\\n   => nums = [4,3,-2,-7,8,2,3,1]\\n\\n3. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,3,1]\\n   \\n4. \\'7\\' is present in nums. Thus, nums[6] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,1]\\n\\n5. \\'8\\' is present in nums. Thus, nums[7] = -1\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]\\n   \\n6. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n  \\n7. \\'3\\' is present in nums. Thus, nums[2] = -2\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n\\n7. \\'1\\' is present in nums. Thus, nums[0] = -4\\n   => nums = [-4,-3,-2,-7,8,2,-3,-1]   \\n\\nNow, the only elements nums[i] which are positive are those where \\'i+1\\' is not found in nums\\nThese are => nums[4] and nums[5].\\nThat means 5 and 6 an not present in the initial nums array\\n```\\n\\nWe need to take care that some elements may already be negated. Thus, to avoid negative indexing or converting a negative element back to positive,  we use `abs()` to get the absolute value of elements.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto c : nums)\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1]);   // mark c is present by negating nums[c-1]\\n        for(int i = 0; i < size(nums); i++) \\n            if(nums[i] > 0) ans.push_back(i+1);      // nums[i] > 0 means i+1 isnt present in nums\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ans = []\\n        for c in nums:\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1])\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```\\n\\n***Time Complexity :*** **`O(n)`**, we only iterate `nums` twice each taking `O(n)` time atmost.\\n***Space Complexity :*** **`O(1)`**, only constant extra space is being used except for the output `ans`.\\n\\n\\uD83D\\uDCA1**Note :** \\n1. If input modification is not allowed, we can even restore the `nums` back to its original form before returning. We just need to convert every negative number back to positive again.\\n2. The above solution works for all `nums` of length `n` consisting of elements in range `[k, k+n]`, where `k > 0`.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(find(begin(nums), end(nums), i) == end(nums))  // linear search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        return [i for i in range(1, len(nums)+1) if i not in nums]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 1; i <= size(nums); i++) \\n            if(!binary_search(begin(nums), end(nums), i))   // binary search in nums for each i\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        nums.sort()\\n        return [i for i in range(1, len(nums)+1) if nums[bisect_left(nums, i)%len(nums)] != i]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_set<int> s(begin(nums), end(nums));   // insert every nums[i] in hashset\\n        vector<int> ans(size(nums) - size(s));\\n        for(int i = 1, j = 0; i <= size(nums); i++)  \\n            if(!s.count(i)) ans[j++] = i;               // add all elements not found in hashset to ans\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        s = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in s]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<bool> seen(size(nums)+1);\\n        vector<int> ans;\\n        for(auto c : nums) seen[c] = true;\\n        for(int i = 1; i <= size(nums); i++)\\n            if(!seen[i]) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        ans, seen = [], [False]*(len(nums)+1)\\n        for c in nums: seen[c] = True\\n        for i in range(1, len(nums)+1):\\n            if not seen[i]:\\n                ans.append(i)\\n        return ans\\n```\n```python\\nLet nums = [4,3,2,7,8,2,3,1]. The steps take place as -\\n\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n\\nIndex 4 & 5 are not occupied by their correct elements meaning the elements corresponding to those indices are missing\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto& c : nums) \\n            while(nums[c-1] != c) \\n\\t\\t\\t\\tswap(c, nums[c-1]);               // swap till correct index place of c is not occupied by c itself\\n        for(int i = 1; i <= size(nums); i++)\\n            if(i != nums[i-1]) ans.push_back(i);  // correct index place of i is not occupied by i itself\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):        \\n        for i in range(len(nums)):\\n            while nums[nums[i]-1] != nums[i]: \\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n        return [i for i in range(1, len(nums)+1) if i != nums[i-1]]\\n```\n```python\\nnums = [4,3,2,7,8,2,3,1]\\n1. \\'4\\' is present in nums. Mark as present by negating nums[4-1] = nums[3].  Thus, nums[3] = -7\\n   => nums = [4,3,2,-7,8,2,3,1]\\n\\t\\n2. \\'3\\' is present in nums. Mark as present by negating nums[3-1] = nums[2].  Thus, nums[2] = -2\\n   => nums = [4,3,-2,-7,8,2,3,1]\\n\\n3. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,3,1]\\n   \\n4. \\'7\\' is present in nums. Thus, nums[6] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,1]\\n\\n5. \\'8\\' is present in nums. Thus, nums[7] = -1\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]\\n   \\n6. \\'2\\' is present in nums. Thus, nums[1] = -3\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n  \\n7. \\'3\\' is present in nums. Thus, nums[2] = -2\\n   => nums = [4,-3,-2,-7,8,2,-3,-1]   \\n\\n7. \\'1\\' is present in nums. Thus, nums[0] = -4\\n   => nums = [-4,-3,-2,-7,8,2,-3,-1]   \\n\\nNow, the only elements nums[i] which are positive are those where \\'i+1\\' is not found in nums\\nThese are => nums[4] and nums[5].\\nThat means 5 and 6 an not present in the initial nums array\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto c : nums)\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1]);   // mark c is present by negating nums[c-1]\\n        for(int i = 0; i < size(nums); i++) \\n            if(nums[i] > 0) ans.push_back(i+1);      // nums[i] > 0 means i+1 isnt present in nums\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ans = []\\n        for c in nums:\\n            nums[abs(c)-1] = -abs(nums[abs(c)-1])\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92958,
                "title": "c-solution-o-1-space",
                "content": "The idea is very similar to problem 442. Find All Duplicates in an Array: https://leetcode.com/problems/find-all-duplicates-in-an-array/.\\n\\nFirst iteration to negate values at position whose equal to values appear in array. Second iteration to collect all position whose value is positive, which are the missing values. Complexity is O(n) Time and O(1) space.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int len = nums.size();\\n        for(int i=0; i<len; i++) {\\n            int m = abs(nums[i])-1; // index start from 0\\n            nums[m] = nums[m]>0 ? -nums[m] : nums[m];\\n        }\\n        vector<int> res;\\n        for(int i = 0; i<len; i++) {\\n            if(nums[i] > 0) res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int len = nums.size();\\n        for(int i=0; i<len; i++) {\\n            int m = abs(nums[i])-1; // index start from 0\\n            nums[m] = nums[m]>0 ? -nums[m] : nums[m];\\n        }\\n        vector<int> res;\\n        for(int i = 0; i<len; i++) {\\n            if(nums[i] > 0) res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583741,
                "title": "time-o-n-space-o-1",
                "content": "For each value in the array mark its presence by making the number negative at that place in array \\neg. if you hae array [3,1,4,1] for 3, i will go to index 2 and make its value negative ie. now nums[2] becomes -4. present array: [3,1,-4,1]\\nfor 1, i will go to index 0 and make its value negative ie. now nums[0] becomes -3. present array: [-3,1,-4,1]\\nfor 4, (take abs value), i will go to index 3 and make its value negative ie. now nums[3] becomes -1. present array: [-3,1,-4,-1]\\nfor 1 take abs value), i will go to index 0 as it is already -ve do nothing. present array: [-3,1,-4,-1]\\nAt last I will have [-3,1,-4,-1]. now i will iterate over the array, whichever idx has positive value that number will not be in the array so as we have nums[1]>0 so 2 is not in the list.\\n\\n**PLEASE UPVOTE** if you liked the solution, comment for any queries\\n\\n```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                idx = nums[i]*-1-1;\\n            }else{\\n                idx = nums[i]-1;\\n            }\\n            \\n            if(nums[idx]>0){\\n                nums[idx] = -nums[idx];\\n            }\\n            \\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > 0){\\n                list.add(i+1);\\n            };\\n            \\n        }\\n        \\n        return list;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        int idx = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                idx = nums[i]*-1-1;\\n            }else{\\n                idx = nums[i]-1;\\n            }\\n            \\n            if(nums[idx]>0){\\n                nums[idx] = -nums[idx];\\n            }\\n            \\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > 0){\\n                list.add(i+1);\\n            };\\n            \\n        }\\n        \\n        return list;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 93007,
                "title": "simple-java-in-place-sort-solution",
                "content": "The idea is simple, if nums[i] != i + 1 and nums[i] != nums[nums[i] - 1], then we swap nums[i] with nums[nums[i] - 1], for example, nums[0] = 4 and nums[3] = 7, then we swap nums[0] with nums[3]. So In the end the array will be sorted and if nums[i] != i + 1, then i + 1 is missing.\\nThe example run as follows\\n```\\n[4,3,2,7,8,2,3,1]\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n```\\n\\nSince every swap we put at least one number to its correct position, the time is O(n)\\n\\n```java\\npublic class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) {\\n                int tmp = nums[i];\\n                nums[i] = nums[tmp - 1];\\n                nums[tmp - 1] = tmp;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[4,3,2,7,8,2,3,1]\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n```\n```java\\npublic class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 && nums[i] != nums[nums[i] - 1]) {\\n                int tmp = nums[i];\\n                nums[i] = nums[tmp - 1];\\n                nums[tmp - 1] = tmp;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375581,
                "title": "c-easy-to-understand-comments-negate-seen-elements",
                "content": "1st for loop: for each value x, negate the element at xth position\\n2nd for loop: get all the positions that has a positive element. These are the missing values to return.\\n\\n```\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n\\t\\t\\n        // 1st for loop: nums = [4,3,2,7,8,2,3,1]\\n        for(int i = 0; i < nums.size(); i++)  // each iteration:\\n        {                                     // i = 0              i = 1               i = 2                ... i = 7\\n            int temp = nums[i];               // temp = 4           temp = 3            temp = -2            ... temp = -1\\n            temp = (temp > 0) ? temp : -temp; // temp = 4           temp = 3            temp = 2             ... temp = 1\\n            if(nums[temp-1] > 0)              // nums[3] > 0        nums[2] > 0         nums[1] > 0          ... nums[0] > 0\\n                nums[temp-1] *= -1;           // [4,3,2,-7,8,2,3,1] [4,3,-2,-7,8,2,3,1] [4,-3,-2,-7,8,2,3,1] ... [-4,-3,-2,-7,8,2,-3,-1]\\n        } \\n\\t\\t\\n\\t\\t// 2nd for loop: nums = [-4,-3,-2,-7,8,2,-3,-1]\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] > 0)         // the 4th & 5th indexes are positive\\n                ans.push_back(i+1); // ans = [5,6]\\n\\t\\t\\t\\t\\n        return ans;\\n    }\\n```\\nUpvote if my comments helped. Have fun coding!",
                "solutionTags": [],
                "code": "```\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n\\t\\t\\n        // 1st for loop: nums = [4,3,2,7,8,2,3,1]\\n        for(int i = 0; i < nums.size(); i++)  // each iteration:\\n        {                                     // i = 0              i = 1               i = 2                ... i = 7\\n            int temp = nums[i];               // temp = 4           temp = 3            temp = -2            ... temp = -1\\n            temp = (temp > 0) ? temp : -temp; // temp = 4           temp = 3            temp = 2             ... temp = 1\\n            if(nums[temp-1] > 0)              // nums[3] > 0        nums[2] > 0         nums[1] > 0          ... nums[0] > 0\\n                nums[temp-1] *= -1;           // [4,3,2,-7,8,2,3,1] [4,3,-2,-7,8,2,3,1] [4,-3,-2,-7,8,2,3,1] ... [-4,-3,-2,-7,8,2,-3,-1]\\n        } \\n\\t\\t\\n\\t\\t// 2nd for loop: nums = [-4,-3,-2,-7,8,2,-3,-1]\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] > 0)         // the 4th & 5th indexes are positive\\n                ans.push_back(i+1); // ans = [5,6]\\n\\t\\t\\t\\t\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777978,
                "title": "java-time-o-n-space-o-1",
                "content": "The solution works because `1 \\u2264 a[i] \\u2264 n (n = size of array)`\\nAs we walk through all elements in the array, we can use the current element as an index and flag its value (in place). All numbers are > 0, so we can use a negative number.\\nIn the end, the indexes of all positive numbers in the array are the missing values.\\n\\nThe input: [4, 3, 2, 7, 8, 2, 3, 1]\\nBecomes: [-4, -3, -2, -7, 8, 2, -3, -1]\\n\\nStarting from 1, the missing values are 5 and 6.\\n\\n```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i : nums) {\\n            int index = Math.abs(i);\\n            if (nums[index - 1] > 0) {\\n                nums[index - 1] *= -1;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for (int i : nums) {\\n            int index = Math.abs(i);\\n            if (nums[index - 1] > 0) {\\n                nums[index - 1] *= -1;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92980,
                "title": "5-line-java-easy-understanding",
                "content": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = nums.length;\\n        for (int i = 0; i < nums.length; i ++) nums[(nums[i]-1) % n] += n;\\n        for (int i = 0; i < nums.length; i ++) if (nums[i] <= n) res.add(i+1);\\n        return res;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = nums.length;\\n        for (int i = 0; i < nums.length; i ++) nums[(nums[i]-1) % n] += n;\\n        for (int i = 0; i < nums.length; i ++) if (nums[i] <= n) res.add(i+1);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1583705,
                "title": "c-easy-intuitive-solution-2-approach-frequency-array-negation-technique",
                "content": "Hello everyone, I hope you all are doing great!\\n***Note: Please do upvote if you found this post helpful***\\n\\nSo, we have vector of size `N` which consists of values in the range `[1, N]`. And we need to return the vector consisting of missing elements.\\n\\n**Approach 1: (Frequency Array)**\\n1. First, I\\'ll keep a frequency vector of size `N+1` to directly hash the elements of `nums` vector to the indices of my frequency vector. (This will help us to keep the track of frequency of each element in `nums` vector in the range `[1, N]`).\\n\\n2. Then, we iterate the `nums` vector and compute the frequency of each element.\\n\\n3. Then, we iterate on our frequency vector, and check whose frequency is `0` and add the corresponding element to our result vector since such elements would be our missing elements.\\n\\n**Below is the code for my appraoch:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); // frequency vector\\n\\t\\tvector<int>res{}; // result vec\\n        \\n\\t\\t// Compute frequency\\n        for(auto num: nums){\\n            freq[num]++;\\n        }\\n        \\n\\t\\t// Compute missing elements\\n        for(int i{1}; i<=n; ++i){\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(2N) ~ O(N)***\\n**Space Complexity:** ***O(N)*** because we are using frequency vector.\\n\\n**Approach 2: (Negation Technique)** Now we will optimize the space complexity, and try to remove the frequency array here.\\n\\n**Observation:** Observe that if our array would be like this: `[4, 3, 2, 7, 8, 2, 3,1]`, then our frequency array woulde be like:\\n```\\nfreq:     [1, 2, 2, 1, 0, 0, 1, 1]\\nindex:     0  1  2  3  4  5  6  7\\nelement:   1  2  3  4  5  6  7  8\\nHere 5 and 6 are missing because they have zero frequence.\\n```\\nSo, my idea is instead of having frequency arrays, we can make changes to the original array itself to make it resemble to look like our frequency array (But without storing the frequency).\\n\\nSo, now observe that the frequency array above looks like `[x x x x 0 0 x x]`, so instead we will have changes like freq array in our nums array as below:\\n`[- - - - + + - -]`. (The indexes where numbers are positive, that `(index+1)` (since 0-based indexing) is the elment which is missing).\\nFor example:\\n```\\nnums: [4, 3, 2, 7, 8, 2, 3,1]\\nNow iterate through nums array\\n```\\n\\n**Iteration 1:**\\n```\\nindex: 0  1  2  3  4  5  6  7\\nnums: [4, 3, 2, 7, 8, 2, 3, 1]\\n       \\uD83D\\uDC46\\n```\\nSince we have found `4`, we will mark it as found, we will mark it by negating the value at position `4-1 = 3` (Since 0-based indexing). So we will make `7` to `-7`\\n\\n**Iteration 2:**\\n```\\nindex: 0  1  2   3  4  5  6  7\\nnums: [4, 3, 2, -7, 8, 2, 3, 1]\\n          \\uD83D\\uDC46\\n```\\nNow, we found `3` we will mark it has found by negating the value at position `3 - 1 = 2` (Since, 0 based indexing). So we will make `2` to `-2`.\\n\\n**Iteration 3:**\\n```\\nindex: 0  1   2   3  4  5  6  7\\nnums: [4, 3, -2, -7, 8, 2, 3, 1]\\n             \\uD83D\\uDC46\\n```\\nNow, we have `2` (remember negative is just done to mark indexes found, so we will take the absolute value of element to view them), we will mark `2` has found by negating the value at position `2 - 1 = 1` (Since, 0-based indexing). So we will make `3` to `-3`.\\n\\n**Iteration 4:**\\n```\\nindex: 0   1   2   3  4  5  6  7\\nnums: [4, -3, -2, -7, 8, 2, 3, 1]\\n                  \\uD83D\\uDC46\\n```\\nNow, we found `7` so we mark is as found by negating the value at position `7 - 1 = 6` (Since 0-based indexing). So we will make `3` to `-3` at position `6`\\n\\n**Iteration 5:**\\n```\\nindex: 0   1   2   3  4  5   6  7\\nnums: [4, -3, -2, -7, 8, 2, -3, 1]\\n                     \\uD83D\\uDC46\\n```\\nNow, we have `8` so we mark it as found by negating the value at position `8-1=7`. So we make `1` to `-1`.\\n\\n**Iteration 6:**\\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                         \\uD83D\\uDC46\\n```\\nNow, we have `2` so we mark it as found by negating the value at position `2-1=1` (since 0-based indexing). But the value at position `1` is already negative, that means we have already found the elemetn `2` before, so we leave it as negative and move forward.\\n\\n**Iteration 7**\\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                            \\uD83D\\uDC46\\n```\\nNow, we have `3`, so we will make it found by negating the value at position `3-1=2` (Since 0-based indexing). But the value at position `2` is already negative, that means we have already found the elemetn `3` before, so we leave it as negative and move forward.\\n\\n**Iteration 8:**\\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                                \\uD83D\\uDC46\\n```\\nNow, we have `1` so we will mark it as founf by negating the value at position `1-1=0` (since 0 based indexing). So we make `4` to `-4`.\\n\\n**End of Iterations:**\\n```\\nindex:  0   1   2   3  4  5   6   7\\nnums: [-4, -3, -2, -7, 8, 2, -3, -1]\\n                                    \\uD83D\\uDC46\\n```\\nHere we have only indices `4` and `5` as the positive indices, that measn element `[4+1, 5+1] = [5, 6]` (since 0 based indexing) are the missing element.\\n\\n**Below is the code for the approach mentioned above:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res{};\\n        \\n\\t\\t// Negative elements (Marking foud)\\n        for(int i{}; i<n; ++i){\\n            \\n            int idx = abs(nums[i]) - 1; // since 0-based indexing\\n            nums[idx] = (nums[idx]>0)? -nums[idx]:nums[idx];\\n        }\\n        \\n\\t\\t// Store positive index+1 as missing elements\\n        for(int i{}; i<n; ++i){\\n            if(nums[i] > 0)\\n                res.push_back(i+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(2N) ~ O(N)***\\n**Space Complexity:** ***O(1)***\\n\\n***Note: Please do \\uD83D\\uDD3C Upvote, if you found this post helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); // frequency vector\\n\\t\\tvector<int>res{}; // result vec\\n        \\n\\t\\t// Compute frequency\\n        for(auto num: nums){\\n            freq[num]++;\\n        }\\n        \\n\\t\\t// Compute missing elements\\n        for(int i{1}; i<=n; ++i){\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nfreq:     [1, 2, 2, 1, 0, 0, 1, 1]\\nindex:     0  1  2  3  4  5  6  7\\nelement:   1  2  3  4  5  6  7  8\\nHere 5 and 6 are missing because they have zero frequence.\\n```\n```\\nnums: [4, 3, 2, 7, 8, 2, 3,1]\\nNow iterate through nums array\\n```\n```\\nindex: 0  1  2  3  4  5  6  7\\nnums: [4, 3, 2, 7, 8, 2, 3, 1]\\n       \\uD83D\\uDC46\\n```\n```\\nindex: 0  1  2   3  4  5  6  7\\nnums: [4, 3, 2, -7, 8, 2, 3, 1]\\n          \\uD83D\\uDC46\\n```\n```\\nindex: 0  1   2   3  4  5  6  7\\nnums: [4, 3, -2, -7, 8, 2, 3, 1]\\n             \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5  6  7\\nnums: [4, -3, -2, -7, 8, 2, 3, 1]\\n                  \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6  7\\nnums: [4, -3, -2, -7, 8, 2, -3, 1]\\n                     \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                         \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                            \\uD83D\\uDC46\\n```\n```\\nindex: 0   1   2   3  4  5   6   7\\nnums: [4, -3, -2, -7, 8, 2, -3, -1]\\n                                \\uD83D\\uDC46\\n```\n```\\nindex:  0   1   2   3  4  5   6   7\\nnums: [-4, -3, -2, -7, 8, 2, -3, -1]\\n                                    \\uD83D\\uDC46\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>res{};\\n        \\n\\t\\t// Negative elements (Marking foud)\\n        for(int i{}; i<n; ++i){\\n            \\n            int idx = abs(nums[i]) - 1; // since 0-based indexing\\n            nums[idx] = (nums[idx]>0)? -nums[idx]:nums[idx];\\n        }\\n        \\n\\t\\t// Store positive index+1 as missing elements\\n        for(int i{}; i<n; ++i){\\n            if(nums[i] > 0)\\n                res.push_back(i+1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92957,
                "title": "2ms-o-n-in-space-java",
                "content": "Think we surely have to negate anytime we are given an array with values from 1 to the length of array. If anyone has a better idea, will be happy to hear.\\n\\nThe steps followed in this is:\\n1. Negate each number while traversing\\n2. Run again and find the index that is not negated. \\n\\n``` public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for( int i=0;i< nums.length; i++){\\n            int index = nums[i];\\n            if(nums[Math.abs(index)-1] > 0){\\n                nums[Math.abs(index)-1]= -nums[Math.abs(index)-1];\\n            }\\n        }\\n        \\n        for(int j =1 ;j <= nums.length ; j++){\\n            if(nums[j-1] > 0){\\n                result.add(j);\\n            }\\n        }\\n        return result;\\n        \\n    }",
                "solutionTags": [],
                "code": "Think we surely have to negate anytime we are given an array with values from 1 to the length of array. If anyone has a better idea, will be happy to hear.\\n\\nThe steps followed in this is:\\n1. Negate each number while traversing\\n2. Run again and find the index that is not negated. \\n\\n``` public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for( int i=0;i< nums.length; i++){\\n            int index = nums[i];\\n            if(nums[Math.abs(index)-1] > 0){\\n                nums[Math.abs(index)-1]= -nums[Math.abs(index)-1];\\n            }\\n        }\\n        \\n        for(int j =1 ;j <= nums.length ; j++){\\n            if(nums[j-1] > 0){\\n                result.add(j);\\n            }\\n        }\\n        return result;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1583652,
                "title": "c-short-solution-python-one-liner-explained-no-extra-space",
                "content": "**Solution I:**\\nWe know that all the numbers are in the range [1, n].\\nSo we mark all the indices of the numbers we saw by making the number negative.\\nThen, we iterate through the array again and each number that is positive - we know we never saw that index and we can add it to `res`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) \\n            nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]);\\n        \\n        vector<int> res;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Solutoin II:**\\nONE LINER!\\nWe use simple set subtraction\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return set(range(1, len(nums)+1)) - set(nums)\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) \\n            nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1]);\\n        \\n        vector<int> res;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return set(range(1, len(nums)+1)) - set(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313703,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for n in nums:\\n            a = abs(n) - 1\\n            if nums[a] > 0: nums[a] *= -1\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThank you!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for n in nums:\\n            a = abs(n) - 1\\n            if nums[a] > 0: nums[a] *= -1\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212505,
                "title": "o-n-constant-space-javascript-solution-with-explanation",
                "content": "So the trick here is that the input array is as long as the set of numbers we want to have in there. \\n\\nSo if the input array has a length of 8, we want it to contain the numbers [1,8] (one through eight - including both one and eight). \\n\\nWhen we work with arrays, we technically have two sets of values available: we have the values in the array (in this case, just integers), *and* we can work with the indices of the array itself. \\n\\nSo take a five-element array: `[1, 4, 5, 3, 3]`\\n\\nWe have the numbers `1, 4, 5, 3, 3` in the values itself. But we *also have* the numbers `0, 1, 2, 3, 4` as indices of the array. If you add one to each of those indices, we would have `1, 2, 3, 4, 5`. Those are the numbers we\\'re looking for in an ideal scenario. \\n\\nSo what we can do is use those indices and \"flag\" them in some way to say \"Hey, we saw this index in the values of the array\". To do that, we look at each actual value (1, 4, 5, 3, and 3). Then we subtract one from it to get its corresponding array index. Then we modify the array to flag it. We multiply the value at that index by -1 to make it negative. \\n\\nYou\\'ll see in the code that we have to be careful, if we\\'ve already visited an index, it will be negative, and when we subtract 1 to find the index, we\\'ll have a problem. So we actually take the absolute value. Don\\'t worry if this is hard to follow, there\\'s a comment in the code about it. \\n\\nThen we loop through the array again and build a result. We check each index (again, we don\\'t care about the actual absolute value of the number there, we\\'re just looking for our flag - the negative sign). If it\\'s positive, it means we never visited that index, so we know that\\'s one of the \"disappeared\" numbers.\\n\\n**Solution:**\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    // Loop through each number in nums\\n    nums.forEach(number => {\\n        \\n        // Now we choose an index in the nums array based on the value we\\'re currently looking at.\\n        // We do have to use Math.abs on it first, in case we\\'ve already visited this index and made it negative.\\n        // Then, since arrays are 0 indexed, subtract 1 from it\\n        const indexBasedOnThisValue = Math.abs(number) - 1\\n        \\n        // Then, look at the input array. Multiply it by -1 to mark it negative\\n        // We don\\'t want to do this if we\\'ve already done so, which is why we check that it\\'s greater than 0.\\n        if (nums[indexBasedOnThisValue] > 0) {\\n            nums[indexBasedOnThisValue] = nums[indexBasedOnThisValue] * -1\\n        }\\n    })\\n    \\n    // Now that we\\'ve marked the array with negative numbers, loop through it again.\\n    // This time, we\\'ll be building our result\\n    const result = []\\n    \\n    for (let i=0; i<nums.length; i++) {\\n        // Check if the number at this position is positive or negative.\\n        // It doesn\\'t matter what the number is necessarily, we just want to use the index of this value to check what we visited.\\n        // And again, since arrays are 0-indexed, we\\'ll be off by one, so add 1 when we push to results.\\n        if (nums[i] > 0) {\\n            result.push(i + 1)\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    // Loop through each number in nums\\n    nums.forEach(number => {\\n        \\n        // Now we choose an index in the nums array based on the value we\\'re currently looking at.\\n        // We do have to use Math.abs on it first, in case we\\'ve already visited this index and made it negative.\\n        // Then, since arrays are 0 indexed, subtract 1 from it\\n        const indexBasedOnThisValue = Math.abs(number) - 1\\n        \\n        // Then, look at the input array. Multiply it by -1 to mark it negative\\n        // We don\\'t want to do this if we\\'ve already done so, which is why we check that it\\'s greater than 0.\\n        if (nums[indexBasedOnThisValue] > 0) {\\n            nums[indexBasedOnThisValue] = nums[indexBasedOnThisValue] * -1\\n        }\\n    })\\n    \\n    // Now that we\\'ve marked the array with negative numbers, loop through it again.\\n    // This time, we\\'ll be building our result\\n    const result = []\\n    \\n    for (let i=0; i<nums.length; i++) {\\n        // Check if the number at this position is positive or negative.\\n        // It doesn\\'t matter what the number is necessarily, we just want to use the index of this value to check what we visited.\\n        // And again, since arrays are 0-indexed, we\\'ll be off by one, so add 1 when we push to results.\\n        if (nums[i] > 0) {\\n            result.push(i + 1)\\n        }\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419876,
                "title": "easy-c-with-explanation-o-n-running-time-o-1-space",
                "content": "**Algorithm**\\n\\nWe know that all the values are between 1 and the size of the array, so the idea is to use the indices of the original array to represent the values that are found in the array.\\nWe know that all the values in the array are positive, so we can signal the presence of a value by changing its index (or better still, like in my implementation, the index minus 1, to avoid the \\'special case\\' of values that equal n, which has no vector element) to be negative.\\nWe then loop over the vector, and any positive index indicates that the value (index + 1) does not appear in the vector, so we add it to the list to return.\\n\\n\\n**Complexity**\\n\\nWe loop over the array twice, so the running time is O(2N), which is O(N).\\nWe use the original vector for keeping count of which values appear in the array, so we use O(1) space.\\n\\n\\n**The Code**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> results;\\n        \\n        // Set contents of all indices (minus 1) that appear in the array to be negative\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n\\t\\t\\t// Note that we have to use the absolute value in the next 2 lines, to avoid trying to access a negative index in some cases\\n            if (nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        \\n        // A positive element means that the element (index + 1) does not appear in the array, so save it\\n        for (int i = 0; i < nums.size(); ++i)\\n            if (nums[i] > 0)\\n                results.push_back(i + 1);\\n        \\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> results;\\n        \\n        // Set contents of all indices (minus 1) that appear in the array to be negative\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n\\t\\t\\t// Note that we have to use the absolute value in the next 2 lines, to avoid trying to access a negative index in some cases\\n            if (nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        \\n        // A positive element means that the element (index + 1) does not appear in the array, so save it\\n        for (int i = 0; i < nums.size(); ++i)\\n            if (nums[i] > 0)\\n                results.push_back(i + 1);\\n        \\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108814,
                "title": "java-best-solution-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse HashSet to Remove Duplicates and search whether the it contains all the Elements from 1 to n.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int val : nums) {\\n            set.add(val);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i = 1; i <= nums.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e4f1e2a8-b10b-46db-9ce6-9c2562a1a933_1674945307.2145095.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int val : nums) {\\n            set.add(val);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i = 1; i <= nums.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952453,
                "title": "o-n-o-1-js-solution",
                "content": "```\\nvar findDisappearedNumbers = function(nums) {\\n    let res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let num = Math.abs(nums[i]);\\n        let idx = num-1;\\n        nums[idx] = Math.abs(nums[idx]) * -1;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) res.push(i+1);\\n    }\\n    return res;\\n    // Time Complexity: O(N)\\n    // Space Complexity: O(1)\\n};\\n/*\\nWe will scan through the input array and for every number we will use its value as an index and\\nnegate the number at the index. For example, if we encounter 4, we will negate the number at index 3.\\nThe reason the index is not four is because the array is zero-indexed.\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDisappearedNumbers = function(nums) {\\n    let res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        let num = Math.abs(nums[i]);\\n        let idx = num-1;\\n        nums[idx] = Math.abs(nums[idx]) * -1;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) res.push(i+1);\\n    }\\n    return res;\\n    // Time Complexity: O(N)\\n    // Space Complexity: O(1)\\n};\\n/*\\nWe will scan through the input array and for every number we will use its value as an index and\\nnegate the number at the index. For example, if we encounter 4, we will negate the number at index 3.\\nThe reason the index is not four is because the array is zero-indexed.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584384,
                "title": "java-solution-100",
                "content": "I simply allocated a separate index for each number, then checked which indexes are zero - these are our numbers we are looking for.\\n\\n```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\tint[] res = new int[nums.length + 1];\\n\\n\\tfor (int num : nums) {\\n\\t\\tres[num] = num;\\n\\t}\\n\\n\\tList<Integer> result = new ArrayList<>(res.length);\\n\\tfor (int i = 1; i < res.length; i++) {\\n\\t\\tif (res[i] == 0) {\\n\\t\\t\\tresult.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\tint[] res = new int[nums.length + 1];\\n\\n\\tfor (int num : nums) {\\n\\t\\tres[num] = num;\\n\\t}\\n\\n\\tList<Integer> result = new ArrayList<>(res.length);\\n\\tfor (int i = 1; i < res.length; i++) {\\n\\t\\tif (res[i] == 0) {\\n\\t\\t\\tresult.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93153,
                "title": "step-by-step-detailed-explanation-python-solution",
                "content": "**Solution using Extra Space**\\n* Use a set (hash-map) and add all the numbers in this set. The set consists of all unique values within nums.\\n* Iterate from [1 to N] and add to result list if i is not in the marked set.\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\\n\\n**Solution without using Extra Space**\\n* Can we avoid the set and somehow mark the input array which tells us what numbers are seen and what are not? We have additional information that the numbers are positive and numbers lie between 1 and N.\\n* Approach 1: Iterate the array and mark the position implied by every element as negative. Then in the second iteration, we simply need to report the positive numbers.\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\\n* Approach 2: Iterate the array and add N to the existing number at the position implied by every element. This means that positions implied by the numbers present in the array will be strictly more than N (smallest number is 1 and 1+N > N).  Therefore. in the second iteration, we simply need to report the numbers less than equal to N to return the missing numbers..\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            nums[(nums[i]%N)-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            nums[(nums[i]%N)-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682857,
                "title": "python-3-solutions-o-1-sc-one-line-solution",
                "content": "**Python :**\\n\\n\\nTime complexity : *O(n)*\\nSpace complexity : *O(n)*\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tallNums = [0] * len(nums)\\n\\tfor i in nums:\\n\\t\\tallNums[i - 1] = i\\n\\n\\treturn [i + 1 for i in range(len(allNums)) if allNums[i] == 0]\\n```\\n\\nTime complexity : *O(n)*\\nSpace complexity : *O(1)*\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            nums[abs(i) - 1]  = -abs(nums[abs(i) - 1])\\n            \\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n```\\n\\nTricky one line solution :\\n\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\treturn set(range(1, len(nums) + 1)) - set(nums)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tallNums = [0] * len(nums)\\n\\tfor i in nums:\\n\\t\\tallNums[i - 1] = i\\n\\n\\treturn [i + 1 for i in range(len(allNums)) if allNums[i] == 0]\\n```\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            nums[abs(i) - 1]  = -abs(nums[abs(i) - 1])\\n            \\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]\\n```\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\treturn set(range(1, len(nums) + 1)) - set(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 985924,
                "title": "python3-one-liner-with-step-by-step-explanation",
                "content": "Faster than 91.27% , Memory Usage: 25.3 MB, less than 10.18% \\n\\n**To Find All Numbers Disappeared in an Array**\\n```\\nreturn list(set(range(1,len(nums)+1))-set(nums)))\\n```\\n\\n*Explanation:-*\\n1.  len(nums)+1               -> To get range of list\\n2.  range(1,len(nums)+1) -> range from 1 to n\\n3.  set(range(1,len(nums)+1)) -> set values of range \\n4.  set(nums) -> Given Nums to set \\n5.  set(range(1,len(nums)+1)) - set(nums) -> The missing elements from (1,n)\\n6.  list(set(range(1,len(nums)+1))-set(nums) -> Coversion dict to list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nreturn list(set(range(1,len(nums)+1))-set(nums)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186633,
                "title": "c-o-n-in-place-with-explanation",
                "content": "Since, each element in the array is in range [1,n], it means we can use array elements as index for the same array.\\n\\nSo the idea is to use array element as indexes, and mark those indexes, somehow, so we know, which all indexes are present in the array.\\n\\nIn the end, unmarked indexes will indicate that these elements are missing in the array.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        \\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            int n = abs(nums[i]); \\n            if(nums[n-1] > 0)\\n                nums[n-1] = -nums[n-1]; // marking -ve\\n        }\\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf this helped you, an upvote would be awesome. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        \\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            int n = abs(nums[i]); \\n            if(nums[n-1] > 0)\\n                nums[n-1] = -nums[n-1]; // marking -ve\\n        }\\n        for( int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297895,
                "title": "easy-to-understand-python-3-1-line",
                "content": "*range(1, len(nums) + 1)* is just a list of elements from 1 -> length of the array.\\nBy subtracting set(nums), or the **unique** elements in nums, we get a set of the numbers that were not in our range.\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list((set(range(1, len(nums) + 1))) - (set(nums)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list((set(range(1, len(nums) + 1))) - (set(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545609,
                "title": "c-using-o-1-space-o-n-runtime",
                "content": "```\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.Length; i++) {\\n            int index = Math.Abs(nums[i]) - 1;\\n            if (nums[index] > 0) nums[index] = -nums[index];\\n        }\\n        List<int> result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (nums[i] > 0) result.Add(i+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        for (int i = 0; i < nums.Length; i++) {\\n            int index = Math.Abs(nums[i]) - 1;\\n            if (nums[index] > 0) nums[index] = -nums[index];\\n        }\\n        List<int> result = new List<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (nums[i] > 0) result.Add(i+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121580,
                "title": "java-easy-solution-with-explanation-comments-inlcuded",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        //since we have to find the missing numbers from\\n        //store the  valuses of all array elments in map\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],1);\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        //now check the given array \\n        //nums from 1 to nums.length(incusive) if\\n        //it the i is not in map means it is missing\\n        //add to ans list\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(map.containsKey(i)==false)\\n            {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n\\t\\t//please upvote if you found helpful it will give some motivation\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        //since we have to find the missing numbers from\\n        //store the  valuses of all array elments in map\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],1);\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        //now check the given array \\n        //nums from 1 to nums.length(incusive) if\\n        //it the i is not in map means it is missing\\n        //add to ans list\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(map.containsKey(i)==false)\\n            {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n\\t\\t//please upvote if you found helpful it will give some motivation\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472775,
                "title": "c-o-1-space-o-n-time-easiest-explanation",
                "content": "# LOGIC (When you take extra space)\\n* You can easily solve this problem using the extra space by taking an unordered_map. \\n\\n<iframe src=\"https://leetcode.com/playground/mPLQNXBs/shared\" frameBorder=\"0\" width=\"1000\" height=\"300\"></iframe>\\n\\n---\\n\\n# LOGIC (When you take constant space)\\n* As the values are between 1 and the size of the array, so the idea is to use the indices of the original array to represent the values that are found in the array. As all the values in the array are positive, for every value we will make it\\'s equivalent index position negative. Remember that we will take the (index-1) position to avoid the case when the value of the element is equal to n. \\n* If statement in the first for loop make sure that whenever there are more than one occurrence of the element( it will for sure, [THINK ABOUT IT]) then we don\\'t want to change our signal back to the positive value and that\\'s why we just ignore that case.\\n* We then loop over the vector, and any positive index shows that the value (index + 1) does not appear in the vector, so we add it to the list to return.\\n\\n<iframe src=\"https://leetcode.com/playground/7FwVRQgr/shared\" frameBorder=\"0\" width=\"1000\" height=\"250\"></iframe>\\n\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC3C\\uD83D\\uDCBB If there are any suggestions / questions / mistakes in my post, please do let me know by comments: \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "# LOGIC (When you take extra space)\\n* You can easily solve this problem using the extra space by taking an unordered_map. \\n\\n<iframe src=\"https://leetcode.com/playground/mPLQNXBs/shared\" frameBorder=\"0\" width=\"1000\" height=\"300\"></iframe>\\n\\n---\\n\\n# LOGIC (When you take constant space)\\n* As the values are between 1 and the size of the array, so the idea is to use the indices of the original array to represent the values that are found in the array. As all the values in the array are positive, for every value we will make it\\'s equivalent index position negative. Remember that we will take the (index-1) position to avoid the case when the value of the element is equal to n. \\n* If statement in the first for loop make sure that whenever there are more than one occurrence of the element( it will for sure, [THINK ABOUT IT]) then we don\\'t want to change our signal back to the positive value and that\\'s why we just ignore that case.\\n* We then loop over the vector, and any positive index shows that the value (index + 1) does not appear in the vector, so we add it to the list to return.\\n\\n<iframe src=\"https://leetcode.com/playground/7FwVRQgr/shared\" frameBorder=\"0\" width=\"1000\" height=\"250\"></iframe>\\n\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC3C\\uD83D\\uDCBB If there are any suggestions / questions / mistakes in my post, please do let me know by comments: \\uD83D\\uDC47",
                "codeTag": "Unknown"
            },
            {
                "id": 479225,
                "title": "python-js-java-c-go-o-n-sol-by-sign-flip-visualization",
                "content": "**Visualization**\\n\\n![image](https://assets.leetcode.com/users/images/98f6e027-b824-4527-a095-de93e48a55ac_1665849439.905402.png)\\n\\n---\\n\\n**Implementation**\\n\\nPython O( n ) sol. based on sign flipping.\\n\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\n        for number in nums:\\n\\n            present_indx = abs(number)-1\\n            if nums[present_indx] > 0 :\\n                # use negative number to mark number is presented in array\\n                nums[present_indx] = -nums[present_indx]\\n\\n\\n\\n        # the disappeared numbers are those grids which are still with positive value\\n        return [ i+1 for i, num in enumerate(nums) if num > 0 ]\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    for( let number of nums){\\n        \\n        let presentIndex = Math.abs( number ) - 1;\\n        \\n        if( nums[presentIndex] > 0){\\n            \\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex];\\n        }\\n    }\\n    \\n    \\n    // the disappeared numbers are those grids which are still with positive value\\n    let missingNumber = [];\\n    for( const [idx, number] of nums.entries() ){\\n        \\n        if( number > 0 ){\\n            missingNumber.push( idx+1 );\\n        }\\n    }\\n    \\n    return missingNumber;\\n};\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for( int number : nums){\\n            \\n            int presentIndex = Math.abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        List<Integer> missingNumber = new ArrayList<Integer>();\\n        for( int i = 0 ; i < nums.length ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.add( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        for( int& number : nums){\\n            \\n            int presentIndex = abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        vector<int> missingNumber;\\n        for( size_t i = 0 ; i < nums.size() ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.emplace_back( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc IntegerAbs(x int) int {\\n\\tif x < 0 {\\n\\t\\treturn -x\\n\\t}\\n\\treturn x\\n}\\n\\nfunc findDisappearedNumbers(nums []int) []int {\\n     \\n    for _, number := range nums{\\n\\n        presentIndex := IntegerAbs(number)-1\\n\\n        if( nums[presentIndex] > 0 ){\\n\\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex]\\n        }\\n    }\\n\\n    // the disappeared numbers are those grids which are still with positive value\\n    missingNumber := make( []int, 0)\\n    for i := 0 ; i < len(nums) ; i++ {\\n\\n        if( nums[i] > 0 ){\\n            missingNumber = append(missingNumber, i+1 )\\n        }\\n    }\\n\\n    return missingNumber\\n}\\n```\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #442 Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/)\\n\\n[2] [Leetcode #287 Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\n        for number in nums:\\n\\n            present_indx = abs(number)-1\\n            if nums[present_indx] > 0 :\\n                # use negative number to mark number is presented in array\\n                nums[present_indx] = -nums[present_indx]\\n\\n\\n\\n        # the disappeared numbers are those grids which are still with positive value\\n        return [ i+1 for i, num in enumerate(nums) if num > 0 ]\\n```\n```\\nvar findDisappearedNumbers = function(nums) {\\n    \\n    for( let number of nums){\\n        \\n        let presentIndex = Math.abs( number ) - 1;\\n        \\n        if( nums[presentIndex] > 0){\\n            \\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex];\\n        }\\n    }\\n    \\n    \\n    // the disappeared numbers are those grids which are still with positive value\\n    let missingNumber = [];\\n    for( const [idx, number] of nums.entries() ){\\n        \\n        if( number > 0 ){\\n            missingNumber.push( idx+1 );\\n        }\\n    }\\n    \\n    return missingNumber;\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for( int number : nums){\\n            \\n            int presentIndex = Math.abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        List<Integer> missingNumber = new ArrayList<Integer>();\\n        for( int i = 0 ; i < nums.length ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.add( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        for( int& number : nums){\\n            \\n            int presentIndex = abs(number)-1;\\n            \\n            if( nums[presentIndex] > 0 ){\\n                \\n                // use negative number to mark number is presented in array\\n                nums[presentIndex] = -nums[presentIndex];\\n            }\\n        }\\n        \\n        // the disappeared numbers are those grids which are still with positive value\\n        vector<int> missingNumber;\\n        for( size_t i = 0 ; i < nums.size() ; i++ ){\\n            \\n            if( nums[i] > 0 ){\\n                missingNumber.emplace_back( i+1 );\\n            }\\n        }\\n        \\n        return missingNumber;\\n    }\\n};\\n```\n```\\nfunc IntegerAbs(x int) int {\\n\\tif x < 0 {\\n\\t\\treturn -x\\n\\t}\\n\\treturn x\\n}\\n\\nfunc findDisappearedNumbers(nums []int) []int {\\n     \\n    for _, number := range nums{\\n\\n        presentIndex := IntegerAbs(number)-1\\n\\n        if( nums[presentIndex] > 0 ){\\n\\n            // use negative number to mark number is presented in array\\n            nums[presentIndex] = -nums[presentIndex]\\n        }\\n    }\\n\\n    // the disappeared numbers are those grids which are still with positive value\\n    missingNumber := make( []int, 0)\\n    for i := 0 ; i < len(nums) ; i++ {\\n\\n        if( nums[i] > 0 ){\\n            missingNumber = append(missingNumber, i+1 )\\n        }\\n    }\\n\\n    return missingNumber\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93098,
                "title": "python-solution-without-using-abs",
                "content": "Basically the same idea a lot of previous solutions implement. I was thinking whether we could get rid of the abs operation around the index to make the code faster. I exploited the fact that each repeating elements don't appear more than twice so I set the increment to 0.4 as to maintain the value of the index when being floored.\\n\\nThe funny thing is the code actually ran slower LOL. However just want to share with you guys my idea.\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for v in nums:\\n            index = int(v) - 1\\n            nums[index] += 0.4\\n        return [i+1 for i in xrange(len(nums)) if nums[i] == int(nums[i])]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for v in nums:\\n            index = int(v) - 1\\n            nums[index] += 0.4\\n        return [i+1 for i in xrange(len(nums)) if nums[i] == int(nums[i])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503704,
                "title": "python-easy-solution",
                "content": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]: # nums = [4,3,2,7,8,2,3,1]\\n        full_list = [i for i in range(1,len(nums)+1)] # [1, 2, 3, 4, 5, 6, 7, 8]\\n        return list(set(full_list) - set(nums)) # {1, 2, 3, 4, 5, 6, 7, 8} - {1, 2, 3, 4, 7, 8} = [5,6]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]: # nums = [4,3,2,7,8,2,3,1]\\n        full_list = [i for i in range(1,len(nums)+1)] # [1, 2, 3, 4, 5, 6, 7, 8]\\n        return list(set(full_list) - set(nums)) # {1, 2, 3, 4, 5, 6, 7, 8} - {1, 2, 3, 4, 7, 8} = [5,6]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1584201,
                "title": "python-short-solution-explained",
                "content": "See similar Problems 0041: First Missing positive and 0442: Find All Duplicates in an Array. We an either swap elements, or use trick where we add `n` to all values of already found elements and then return indexes of elements which are `<= n`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, additional space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        n = len(nums)\\n        for num in nums:\\n            nums[(num-1) % n] += n\\n            \\n        return [i+1 for i in range(n) if nums[i] <= n]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        n = len(nums)\\n        for num in nums:\\n            nums[(num-1) % n] += n\\n            \\n        return [i+1 for i in range(n) if nums[i] <= n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261617,
                "title": "java-logic-explained-in-simple-english-o-n-o-1",
                "content": "# This pattern can be used when you have items in the range of 1 - n (where n = elements in array).\\n\\nBasically the idea is to set each element at its correct position while iterating the array.\\n\\n1. Start from the first element. This item is at it correct position if a[i] == i+1\\n\\n 2. If the item is not at its correct position, we will try to put it at the correct position, so now lets look at its correct position i.e. a[a[i] - 1]. ( 4 has to be placed at index 3)\\n\\n3. Now two conditions arise from here, either the item is at a[a[i]-1] is equal to a[i] or it is not equal to a[i]\\n\\n\\ta. If it is equal to a[i], it means the item is duplicated we will leave the item as is and move further. Later we will use this item to find out that item which was supposed to it at this index is missing. \\n\\n\\tb. If it is not equal to a[i], then lets swap it with a[i],** and check again from STEP 2**\\n\\n\\n4. Perform the same thing for each item in the array.\\n\\n\\nAt the end of the loop, Items which are not repeated will be at its correct place, and item which are duplicated, will be at its correct place and other duplicates will be occupying some other places. \\n\\nWe can check the places where item is not at its correct place and add the item to the item, which is supposed to be there.\\n\\n# **Please leave a short comment, if you like the explaination, I will try to write more such posts.**\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        \\n        List<Integer> list = new LinkedList<Integer>();\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            \\n            while(a[i] != i+1 && a[i] != a[a[i] -1]) {\\n                \\n                swap(a, i , a[i]-1);\\n            }\\n        }\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            if(a[i] != i+1) list.add(i+1);\\n        }\\n        \\n        \\n        return list;\\n        \\n    }\\n    \\n    private void swap(int[] a, int i, int j) {\\n        \\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j] = temp;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        \\n        List<Integer> list = new LinkedList<Integer>();\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            \\n            while(a[i] != i+1 && a[i] != a[a[i] -1]) {\\n                \\n                swap(a, i , a[i]-1);\\n            }\\n        }\\n        \\n        for(int i = 0; i < a.length; i++) {\\n            \\n            if(a[i] != i+1) list.add(i+1);\\n        }\\n        \\n        \\n        return list;\\n        \\n    }\\n    \\n    private void swap(int[] a, int i, int j) {\\n        \\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019411,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const map = new Map();\\n  nums.forEach((num, i) => map.set(num, i));\\n\\n  const result = [];\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!map.has(i)) result.push(i);\\n  }\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const map = new Map();\\n  nums.forEach((num, i) => map.set(num, i));\\n\\n  const result = [];\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!map.has(i)) result.push(i);\\n  }\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2666176,
                "title": "easy-solution-java-85-faster",
                "content": "***Please Upvote***\\n\\n...\\n\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] temp=new int[nums.length+1];\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp[nums[i]]=nums[i];\\n        }\\n        \\n        for(int i=1;i<temp.length;i++)\\n        {\\n            if(temp[i]==0)\\n              list.add(i);\\n        }\\n        return list;\\n    }\\n\\n...",
                "solutionTags": [
                    "Java"
                ],
                "code": "***Please Upvote***\\n\\n...\\n\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] temp=new int[nums.length+1];\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp[nums[i]]=nums[i];\\n        }\\n        \\n        for(int i=1;i<temp.length;i++)\\n        {\\n            if(temp[i]==0)\\n              list.add(i);\\n        }\\n        return list;\\n    }\\n\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 790951,
                "title": "golang-solution-beats-99-runtime",
                "content": "```\\nfunc findDisappearedNumbers(nums []int) []int {\\n    length := len(nums)\\n    if length == 0 { return nil }\\n    res := make([]int, length)\\n    for _, v := range nums {\\n        res[v-1] = v\\n    }\\n    j := 0\\n    for i := 0; i < length; i++ {\\n        if res[i] == 0 { \\n            res[j] = i + 1\\n            j++\\n        }\\n    } \\n    return res[:j]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findDisappearedNumbers(nums []int) []int {\\n    length := len(nums)\\n    if length == 0 { return nil }\\n    res := make([]int, length)\\n    for _, v := range nums {\\n        res[v-1] = v\\n    }\\n    j := 0\\n    for i := 0; i < length; i++ {\\n        if res[i] == 0 { \\n            res[j] = i + 1\\n            j++\\n        }\\n    } \\n    return res[:j]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680663,
                "title": "python-without-extra-space-and-in-o-n-runtime",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        lenn = len(nums)\\n        for i in range(lenn):\\n            val = abs(nums[i]) - 1\\n            nums[val] = abs(nums[val]) * -1\\n        res = []\\n        for i in range(lenn):\\n            if nums[i] > 0:\\n                res.append(i+1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        lenn = len(nums)\\n        for i in range(lenn):\\n            val = abs(nums[i]) - 1\\n            nums[val] = abs(nums[val]) * -1\\n        res = []\\n        for i in range(lenn):\\n            if nums[i] > 0:\\n                res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584655,
                "title": "beats-99-45-tc-python-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nBeats 99.45%\\n\\n# Do Upvote if you like it :)\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set_nums = set(nums)\\n        missing = []\\n\\n        for i in range(1,len(nums)+1):\\n            if i not in set_nums:\\n                missing.append(i)\\n\\n        return missing\\n# Do upvote if you like it\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set_nums = set(nums)\\n        missing = []\\n\\n        for i in range(1,len(nums)+1):\\n            if i not in set_nums:\\n                missing.append(i)\\n\\n        return missing\\n# Do upvote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122639,
                "title": "javascript-solution-116ms",
                "content": "Firstly I use the solution whose time complexity is O(n^2). It costs 5756ms, and it only beats 26%.\\n```js\\nvar findDisappearedNumbers = function(nums) {\\n  let arr = Array.from({length:nums.length}, (v, i) => i+1)\\n  let newNum = Array.from(nums.reduce((set, cur) => set.add(cur), new Set()))\\n  return arr.filter( i=> !newNum.includes(i))\\n};\\n```\\n\\nThen I optimize my solution which could be my best solution. Now the time complexity is O(n), and it beats 95%\\n```js\\nvar findDisappearedNumbers = function (nums) {\\n  let length = nums.length\\n  let arr = []\\n  for (let i = 0; i < length; i++) {\\n    arr[i] = i+1\\n  }\\n  for (v of nums) {\\n    arr[v-1] = -1\\n  }\\n  return arr.filter( i => (i > 0) )\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nvar findDisappearedNumbers = function(nums) {\\n  let arr = Array.from({length:nums.length}, (v, i) => i+1)\\n  let newNum = Array.from(nums.reduce((set, cur) => set.add(cur), new Set()))\\n  return arr.filter( i=> !newNum.includes(i))\\n};\\n```\n```js\\nvar findDisappearedNumbers = function (nums) {\\n  let length = nums.length\\n  let arr = []\\n  for (let i = 0; i < length; i++) {\\n    arr[i] = i+1\\n  }\\n  for (v of nums) {\\n    arr[v-1] = -1\\n  }\\n  return arr.filter( i => (i > 0) )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2954066,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=abs(nums[i])-1;\\n            if(nums[j]>0)\\n            nums[j]*=-1;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=abs(nums[i])-1;\\n            if(nums[j]>0)\\n            nums[j]*=-1;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028043,
                "title": "python-3-lines-beats-90-with-comments",
                "content": "* Three passes, O(n)\\n* Constant space if you count the returning array/list as O(1) space as the question mentions\\n\\t* *\"You may assume the returned list does not count as extra space.\"*\\n\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:                        \\n        result = [i for i in range(0, len(nums)+1)] # build an array (0, 1, 2, 3, ..., n)\\n        for i in nums: result[i] = 0 # we index this array, setting \"found\" elements to zero\\n        return [i for i in result if i != 0] # we return results that aren\\'t zero\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:                        \\n        result = [i for i in range(0, len(nums)+1)] # build an array (0, 1, 2, 3, ..., n)\\n        for i in nums: result[i] = 0 # we index this array, setting \"found\" elements to zero\\n        return [i for i in result if i != 0] # we return results that aren\\'t zero\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538304,
                "title": "java-use-negative-to-mark-exisits",
                "content": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            // nums[n - 1] = n;  //can not do this, since you will override the origin node.\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (nums[idx] > 0) nums[idx] = - nums[idx];\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) res.add(i + 1);\\n        }\\n        return res;\\n    }\\n```\\nRef: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92956/Java-accepted-simple-solution\\n",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            // nums[n - 1] = n;  //can not do this, since you will override the origin node.\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (nums[idx] > 0) nums[idx] = - nums[idx];\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) res.add(i + 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144795,
                "title": "python-simple-o-n-no-space-solution",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ret = []\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            if nums[index] > 0:\\n                nums[index] = -nums[index]\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ret.append(i + 1)\\n        return ret",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        ret = []\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            if nums[index] > 0:\\n                nums[index] = -nums[index]\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                ret.append(i + 1)\\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 142717,
                "title": "java-simple-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0 ; i != nums.length ; i++) {\\n            nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]);\\n        }\\n        for (int i = 0 ; i != nums.length; i++) {\\n            if (nums[i] >= 0) res.add(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for (int i = 0 ; i != nums.length ; i++) {\\n            nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]);\\n        }\\n        for (int i = 0 ; i != nums.length; i++) {\\n            if (nums[i] >= 0) res.add(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93054,
                "title": "solution-in-c",
                "content": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int m;\\n    for (int c = 0; c < numsSize; c++) {\\n        m = abs(nums[c]) - 1;\\n        nums[m] = -1 * abs(nums[m]);\\n    }\\n\\n    *returnSize = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            (*returnSize)++;\\n    \\n    int *ret = (int *) calloc (*returnSize, sizeof (int));\\n    int s = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            ret[s++] = c + 1;\\n    \\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int m;\\n    for (int c = 0; c < numsSize; c++) {\\n        m = abs(nums[c]) - 1;\\n        nums[m] = -1 * abs(nums[m]);\\n    }\\n\\n    *returnSize = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            (*returnSize)++;\\n    \\n    int *ret = (int *) calloc (*returnSize, sizeof (int));\\n    int s = 0;\\n    for (int c = 0; c < numsSize; c++)\\n        if (nums[c] > 0)\\n            ret[s++] = c + 1;\\n    \\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868358,
                "title": "python-3",
                "content": "- Runtime: 316 ms, faster than 99.93% of Python3 online submissions for Find All Numbers Disappeared in an Array.\\n- Memory Usage: 25 MB, less than 7.37% of Python3 online submissions for Find All Numbers Disappeared in an Array.\\n\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return None\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return None\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 307741,
                "title": "cyclic-sort-in-o-n",
                "content": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return result;\\n        \\n        int idx = 0;\\n        \\n        while (idx < nums.length) {\\n            if (nums[idx] != nums[nums[idx] - 1]) {\\n                swap(nums, idx, nums[idx] - 1);\\n            } else {\\n                idx++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                result.add(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void swap(int[] nums, int x, int y) {\\n        int temp = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = temp;\\n    }\\n\\t```\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) return result;\\n        \\n        int idx = 0;\\n        \\n        while (idx < nums.length) {\\n            if (nums[idx] != nums[nums[idx] - 1]) {\\n                swap(nums, idx, nums[idx] - 1);\\n            } else {\\n                idx++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                result.add(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void swap(int[] nums, int x, int y) {\\n        int temp = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = temp;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 307041,
                "title": "java-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> missing = new ArrayList<>();\\n        if(nums.length == 0)\\n            return missing;\\n        \\n        /*The index of the current num is num[i]-1\\n          We Math.abs the current num because \\n          we may have made it negative before\\n        */\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = Math.abs(nums[i]) - 1;\\n            if (nums[index] > 0)\\n                nums[index] = -nums[index];\\n        }\\n        /*Now every index value that has a negative number exists\\n          in nums. But the index values with positive numbers do not\\n          exist. We know this is the case because if we saw X, \\n          then we would have made nums[X-1] a negative value. \\n          We can get these missing numbers with index+1.\\n        */\\n        for (int i = 0; i < nums.length; i++) {\\n            //This index i does not exist in nums, since the value is +\\n            if (nums[i] > 0)\\n                missing.add(i+1);\\n        }\\n        \\n        return missing;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> missing = new ArrayList<>();\\n        if(nums.length == 0)\\n            return missing;\\n        \\n        /*The index of the current num is num[i]-1\\n          We Math.abs the current num because \\n          we may have made it negative before\\n        */\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = Math.abs(nums[i]) - 1;\\n            if (nums[index] > 0)\\n                nums[index] = -nums[index];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 160034,
                "title": "o-n-swap",
                "content": "Verry simple solution. Iterate throught the array and put every number in it\\'s \"spot\". I.E. if the number is 1 put it int he 1st spot 2, 2nd etc. This will be done in O(n) because you will perform at most n swaps.\\n\\nAfter, simply check which places are missing their corresponding number and return that list.\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i<nums.length; i++){\\n            while(nums[i] != i + 1 && nums[i] != nums[nums[i]-1]){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] != i + 1){\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i<nums.length; i++){\\n            while(nums[i] != i + 1 && nums[i] != nums[nums[i]-1]){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] != i + 1){\\n                res.add(i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274699,
                "title": "448-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Iterate through the input list nums, and for each element nums[i]:\\na. Calculate the index of nums[i] in the list by taking the absolute value of nums[i] and subtracting 1. This is because the input list contains integers in the range [1, n].\\nb. Update the value at the calculated index to its negative absolute value using nums[index] = -abs(nums[index]). This is because the input list can contain duplicates, so we need to mark the value as visited using its absolute value.\\n3. Iterate through the updated list nums, and for each element nums[i]:\\na. If the value at index i is positive, it means that the number i+1 did not appear in the input list. Append i+1 to the list of missing numbers.\\n3. Return the list of missing numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        # iterate through the input list and mark the values as visited\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = -abs(nums[index])\\n        \\n        # collect the missing values which are still positive\\n        missing = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                missing.append(i+1)\\n        \\n        return missing\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        # iterate through the input list and mark the values as visited\\n        for i in range(len(nums)):\\n            index = abs(nums[i]) - 1\\n            nums[index] = -abs(nums[index])\\n        \\n        # collect the missing values which are still positive\\n        missing = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                missing.append(i+1)\\n        \\n        return missing\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045499,
                "title": "java-2-line-code-100-faster-using-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        Set<Integer> set = new HashSet<>();\\n        ArrayList<Integer> result = new ArrayList<>();\\n\\n        for (int i : a) set.add(i); // removing duplicate elements\\n\\n       for(int i = 1; i <= a.length; i++){\\n           if(!set.contains(i)) result.add(i);\\n       }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] a) {\\n        Set<Integer> set = new HashSet<>();\\n        ArrayList<Integer> result = new ArrayList<>();\\n\\n        for (int i : a) set.add(i); // removing duplicate elements\\n\\n       for(int i = 1; i <= a.length; i++){\\n           if(!set.contains(i)) result.add(i);\\n       }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584684,
                "title": "general-approach-for-the-problems-like-this-with-code-and-detailed-comments",
                "content": "**Please Upvote,it helps a lot**\\n\\n```\\n/* Whenever we get a array Question like this where elements are in a particular Contiguous range like(1 to n) then its best solution always comes from the help of\\narray indices. In all such cases array indices can be used a  marker for these \\nelements. for ex here to mark that element 5 is there in array just make element \\nat 4th index as negative . But Caution because as some elements are missing \\nfrom array some may be repeated too. so if there is already negative element at the marker then don\\'t make it negative.\\n*/\\n\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for(int i = 0;i<nums.length;i++){\\n            int val = Math.abs(nums[i]);\\n            nums[val -1] = nums[val - 1] < 0 ? nums[val - 1] : -1 * nums[val - 1];\\n        }\\n        \\n        List<Integer> list  = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i] > 0) list.add(i + 1);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* Whenever we get a array Question like this where elements are in a particular Contiguous range like(1 to n) then its best solution always comes from the help of\\narray indices. In all such cases array indices can be used a  marker for these \\nelements. for ex here to mark that element 5 is there in array just make element \\nat 4th index as negative . But Caution because as some elements are missing \\nfrom array some may be repeated too. so if there is already negative element at the marker then don\\'t make it negative.\\n*/\\n\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        for(int i = 0;i<nums.length;i++){\\n            int val = Math.abs(nums[i]);\\n            nums[val -1] = nums[val - 1] < 0 ? nums[val - 1] : -1 * nums[val - 1];\\n        }\\n        \\n        List<Integer> list  = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i] > 0) list.add(i + 1);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584006,
                "title": "python-short-and-simple-o-n-time-2-pass-o-1-space-no-hash-needed",
                "content": "Please feel free to ask questions or give suggestions. **Upvote** if you liked the solution.\\n**Idea**: Since numbers are in the range [1, n], we can store whether we\\'ve seen a number at index num-1 (indices are in the range [0, n-1]) by making the value negative eg. For array [3, 1, 4, 2], when I see the first value 3, I flip the number at index 3-1=2 and the array becomes [3, 1, -4, 2] and so on...\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tfor num in nums:\\n\\t\\t# Haven\\'t seen before\\n\\t\\tif nums[abs(num)-1]>0:\\n\\t\\t\\t# Store the fact that it has now been seen\\n\\t\\t\\tnums[abs(num)-1] *= -1\\n\\n\\t# The numbers that weren\\'t seen\\n\\treturn [i+1 for i, num in enumerate(nums) if num>0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\tfor num in nums:\\n\\t\\t# Haven\\'t seen before\\n\\t\\tif nums[abs(num)-1]>0:\\n\\t\\t\\t# Store the fact that it has now been seen\\n\\t\\t\\tnums[abs(num)-1] *= -1\\n\\n\\t# The numbers that weren\\'t seen\\n\\treturn [i+1 for i, num in enumerate(nums) if num>0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 991922,
                "title": "3-liner-in-python-without-extra-space-and-o-n-runtime-easy-to-understand",
                "content": "\\n\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        # 3 liner in Python\\n        # without extra space and O(n) runtime\\n        # 82% Memory Usage\\n\\t\\t#If we go through an array, in the place of the given value, we can change its sign. \\n\\t\\t#With this information, one can find where the index has not changed.\\n        for i in range(len(nums)):\\n            nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1])\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        # 3 liner in Python\\n        # without extra space and O(n) runtime\\n        # 82% Memory Usage\\n\\t\\t#If we go through an array, in the place of the given value, we can change its sign. \\n\\t\\t#With this information, one can find where the index has not changed.\\n        for i in range(len(nums)):\\n            nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1])\\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]",
                "codeTag": "Python3"
            },
            {
                "id": 714196,
                "title": "easy-c-solution-with-time-o-n-and-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int index=abs(nums[i])-1;\\n            if(nums[index]>0) nums[index] = -nums[index];\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]>0) ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int index=abs(nums[i])-1;\\n            if(nums[index]>0) nums[index] = -nums[index];\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]>0) ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93084,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Find All Numbers Disappeared in an Array** https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\n**Solution using Extra Space**\\n* Use a set (hash-map) and add all the numbers in this set. The set consists of all unique values within nums.\\n* Iterate from [1 to N] and add to result list if i is not in the marked set.\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\\n\\n**Solution without using Extra Space**\\n* Can we avoid the set and somehow mark the input array which tells us what numbers are seen and what are not? We have additional information that the numbers are positive and numbers lie between 1 and N.\\n\\n* Approach 1: Iterate the array and mark the position implied by every element as negative. Then in the second iteration, we simply need to report the positive numbers.\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\\n\\n* Approach 2: Iterate the array and add N to the existing number at the position implied by every element. This means that positions implied by the numbers present in the array will be strictly more than N (smallest number is 1 and 1+N > N).  Therefore. in the second iteration, we simply need to report the numbers less than equal to N to return the missing numbers..\\n\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            x = nums[i] % N\\n            nums[x-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        marked = set(nums)\\n        return [i for i in range(1, len(nums)+1) if i not in marked]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i in range(len(nums)):\\n            x = abs(nums[i])\\n            nums[x-1] = -1*abs(nums[x-1])\\n        return [i+1 for i in range(len(nums)) if nums[i]>0]\\n```\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        N = len(nums)\\n        for i in range(len(nums)):\\n            x = nums[i] % N\\n            nums[x-1] += N\\n        return [i+1 for i in range(len(nums)) if nums[i]<=N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583657,
                "title": "c-o-n-solution-using-hash-array",
                "content": "Runtime: 48 ms, faster than 84.87% of C++ online submissions for Find All Numbers Disappeared in an Array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        int n  =nums.size();\\n        vector<int>hash(n+1,0);\\n        \\n        for(int i=0;i<n;i++){\\n            hash[nums[i]]++;\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=1;i<=n;i++)\\n            if(hash[i]==0)\\n                ans.push_back(i);\\n        \\n        return ans;\\n        // Please Upvote if You Liked It.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        int n  =nums.size();\\n        vector<int>hash(n+1,0);\\n        \\n        for(int i=0;i<n;i++){\\n            hash[nums[i]]++;\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=1;i<=n;i++)\\n            if(hash[i]==0)\\n                ans.push_back(i);\\n        \\n        return ans;\\n        // Please Upvote if You Liked It.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505514,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            int index = Math.abs(nums[i]) -1;\\n            if(nums[index]>=0) nums[index] = -nums[index];\\n        }\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]>=0) list.add(i+1);\\n            \\n        }\\n        return list;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            int index = Math.abs(nums[i]) -1;\\n            if(nums[index]>=0) nums[index] = -nums[index];\\n        }\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i]>=0) list.add(i+1);\\n            \\n        }\\n        return list;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990393,
                "title": "set-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& v) {\\n        set<int> s(v.begin(),v.end());        // copying all the values of vector in set\\n        vector<int> c;\\n        for(int i=1;i<=v.size();i++)\\n        {\\n            if(s.count(i)==0)              // to check if the element is already present or not\\n                c.push_back(i);\\n        }\\n        \\n        return c;\\n    }\\n};\\n```             \\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0APlease do UPVOTE if my code helps you \\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& v) {\\n        set<int> s(v.begin(),v.end());        // copying all the values of vector in set\\n        vector<int> c;\\n        for(int i=1;i<=v.size();i++)\\n        {\\n            if(s.count(i)==0)              // to check if the element is already present or not\\n                c.push_back(i);\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523295,
                "title": "python-solution-in-place-in-o-n-time",
                "content": "I see a lot of Python solutions posted here that are ignoring the space complexity.  Clearly in Python it would be easy to use a collection like a Counter, a dictonary, another list, or even a set.  But that is ignoring the whole point of this problem, which is solving it in place.\\n\\nGiven that the list only contains positive values in the same range as the size of the list (1..N vs. 0..N-1), that was a big clue as far as what the solution might be.  You can iterate through the list, and take advantage of these facts.  For each item in the list that you find, you set the value at its index to a negative value.  This will indicate that the index value was found in the list.\\n\\nThis involves two list iterations, plus updating the list by index, which happens in constant time.  So although it is more like 3*N, that still qualifies as O(N).  This uses no extra space, as specified, other than the space for the return list, which is also ok per the specifications.  My simple solution is below.\\n\\n```class Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for x in nums:\\n            y = abs(x)\\n            nums[y - 1] = 0 - abs(nums[y - 1])\\n            \\n        r = []\\n        for i, x in enumerate(nums):\\n            if x > 0:\\n                r.append(i + 1)\\n        return r\\n ```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for x in nums:\\n            y = abs(x)\\n            nums[y - 1] = 0 - abs(nums[y - 1])\\n            \\n        r = []\\n        for i, x in enumerate(nums):\\n            if x > 0:\\n                r.append(i + 1)\\n        return r\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 316499,
                "title": "approaches-to-solve-this-problem-to-discuss-in-an-interview",
                "content": "#### 1st approach : Brute force\\n```\\nFor each i in [1, n]:\\n\\tlinearly search i in nums\\n\\tif not found:\\n\\t\\tresult.add(i)\\n```\\n**Time: O(N^2) - Space: O(1)**\\n_____________________________________________\\n#### 2nd approach : Sort\\n```\\nsort the array in place\\nfor each i in [0, len(array)-1]:\\n\\tif nums[i+1] - nums[i] > 1:\\n\\t\\tresult.add(elements strictly between nums[i] and nums[i+1]\\n```\\n**Time : O(Nlog(N), Space : O(1)**\\n_____________________________________________\\n#### 3rd approach : Use HashSet\\n```\\nstore the array\\'s elements in a set\\nfor each i in [1, n]:\\n\\tif i not in the set:\\n\\t\\tresult.add(i)\\n```\\n**Time : O(N) - Space : O(N)**\\n_____________________________________________\\n#### 4th approach : Use another array to store elements in their correct positions\\n```\\nhelper_array = [False]*n\\nfor element in nums:\\n\\thelper_array[element-1] = True\\n\\nfor i in [1, n]:\\n\\tif helper_array[i-1] == False:\\n\\t\\tresult.add(i)\\n```\\n**Time : O(N) - Space : O(N)**\\n_____________________________________________\\n#### 5th approach : Store elements in their correct positions in place\\nThe idea is to iterate and store each element in its correct position (for example 1 needs to be at the first position). If an element appears twice and its first occurence has been stored in its correct position, ignore it and continue iterating.\\nIterate for a second time, and for each i in [1, len(nums)]:\\n&nbsp;&nbsp;&nbsp;&nbsp;if nums[i] != i+1:\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.add(i+1)\\n**Time : O(N) - Space : O(1)**\\n\\nHere is my code in python :\\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\ti, res = 0, []\\n\\n\\twhile i < len(nums):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tif nums[i]-1 >= len(nums) or nums[nums[i]-1] == nums[i]:   \\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:    \\n\\t\\t\\t\\ttmp = nums[nums[i]-1]\\n\\t\\t\\t\\tnums[nums[i]-1] = nums[i]\\n\\t\\t\\t\\tnums[i] = tmp\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tres.append(i+1)\\n\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\nFor each i in [1, n]:\\n\\tlinearly search i in nums\\n\\tif not found:\\n\\t\\tresult.add(i)\\n```\n```\\nsort the array in place\\nfor each i in [0, len(array)-1]:\\n\\tif nums[i+1] - nums[i] > 1:\\n\\t\\tresult.add(elements strictly between nums[i] and nums[i+1]\\n```\n```\\nstore the array\\'s elements in a set\\nfor each i in [1, n]:\\n\\tif i not in the set:\\n\\t\\tresult.add(i)\\n```\n```\\nhelper_array = [False]*n\\nfor element in nums:\\n\\thelper_array[element-1] = True\\n\\nfor i in [1, n]:\\n\\tif helper_array[i-1] == False:\\n\\t\\tresult.add(i)\\n```\n```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\ti, res = 0, []\\n\\n\\twhile i < len(nums):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tif nums[i]-1 >= len(nums) or nums[nums[i]-1] == nums[i]:   \\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:    \\n\\t\\t\\t\\ttmp = nums[nums[i]-1]\\n\\t\\t\\t\\tnums[nums[i]-1] = nums[i]\\n\\t\\t\\t\\tnums[i] = tmp\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] != i+1:\\n\\t\\t\\tres.append(i+1)\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 271085,
                "title": "javascript-in-place-method",
                "content": "[ 4, 3, 2, 7, 8, 2, 3, 1 ]\\n[ 7, 3, 2, 4, 8, 2, 3, 1 ]\\n[ 3, 3, 2, 4, 8, 2, 7, 1 ]\\n[ 2, 3, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 8, 2, 7, 1 ]\\n[ 3, 2, 3, 4, 1, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n[ 1, 2, 3, 4, 3, 2, 7, 8 ]\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    /**\\n     * swap i and j for nums\\n     * @param i\\n     * @param j\\n     */\\n    var swap = function (i, j) {\\n        const t = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = t;\\n    }\\n    const N = nums.length;\\n    for (let i = 0; i < N;) {\\n        const cur = nums[i] - 1;\\n        // if current value is in the right place,\\n        // or its right place has been set by other same value\\n        // go to next index\\n        if (cur === i || nums[i] === nums[cur]) {\\n            i++;\\n        } else {\\n            // swap current value to the right place it should be\\n            swap(i, cur);\\n        }\\n    }\\n    const res = [];\\n    for (let i = 0; i < N; i++) {\\n        // if current idx don\\'t have correct value,\\n        // push this idx to result array\\n        if (nums[i] - 1 !== i) res.push(i + 1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    /**\\n     * swap i and j for nums\\n     * @param i\\n     * @param j\\n     */\\n    var swap = function (i, j) {\\n        const t = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = t;\\n    }\\n    const N = nums.length;\\n    for (let i = 0; i < N;) {\\n        const cur = nums[i] - 1;\\n        // if current value is in the right place,\\n        // or its right place has been set by other same value\\n        // go to next index\\n        if (cur === i || nums[i] === nums[cur]) {\\n            i++;\\n        } else {\\n            // swap current value to the right place it should be\\n            swap(i, cur);\\n        }\\n    }\\n    const res = [];\\n    for (let i = 0; i < N; i++) {\\n        // if current idx don\\'t have correct value,\\n        // push this idx to result array\\n        if (nums[i] - 1 !== i) res.push(i + 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238213,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Using Set**\\n\\n**Time complexity:** `O(N)`\\n**Space Complexity:** `O(N)`\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();             // List of Missing Elements in [1 .. N]\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            set.add(n);\\n        }\\n\\n        for (int i = 1; i <= A.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\n**Solution 2: Negative Marking**\\n\\n**Intuition:**\\n- Given that, All the elements are in the range `[1, N]`\\n- So, we can make use of the input array itself to somehow `mark visited` numbers and then find the missing numbers.\\n- We will be negating the numbers seen in the array and use the sign of each of the numbers for finding the missing numbers. We will be treating numbers in the array as indices and mark corresponding locations in the array as negative.\\n\\n**Algorithm:**\\n1. For each element `A[i]`, mark the element at the corresponding location as negative if it is not already marked. So i.e. `A[A[i] - 1]` * \\u22121. In this way, all the numbers that we have seen will be marked as `negative`. \\n1. In the second iteration, if a value is not marked as `negative`, it implies we have never seen that `index` before, so it will be added to the return list\\n1. Since the elements in the Array are from `1` to `N`, so subtracting one will be `0` to `N - 1` which are the `indexes` of the array.\\n1. For example, input array `A = [4, 3, 2, 7, 8, 2, 3, 1]` and by subtracting `1` from each element it becomes an array of indexes `[3, 2, 1, 6, 7, 1, 2, 0]`.\\n\\n**For Example:**\\n\\nFor the first iteration\\n```\\nwhen i = 0, array becomes [ 4,  3,  2, -7,  8,  2,  3,  1]    // Marked `A[3]` as negative\\nwhen i = 1, array becomes [ 4,  3, -2, -7,  8,  2,  3,  1]    // Marked `A[2]` as negative\\nwhen i = 2, array becomes [ 4, -3, -2, -7,  8,  2,  3,  1]    // Marked `A[1]` as negative\\nwhen i = 3, array becomes [ 4, -3, -2, -7,  8,  2, -3,  1]    // Marked `A[6]` as negative\\nwhen i = 4, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[7]` as negative\\nwhen i = 5, array becomes [ 4,  3, -2, -7,  8,  2, -3, -1]    // No change since `A[1]` is already marked as negative\\nwhen i = 6, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // No change since `A[2]` is already marked as negative\\nwhen i = 7, array becomes [-4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[3]` as negative\\n```\\n\\nFor the second iteration\\nWe can see, `A[4] = 8` and `A[5] = 2` which are greater than `0`, which means `4` and `5` are not in the indexes array `[3, 2, 1, 6, 7, 1, 2, 0]`. So by adding one, we can say that `5` and `6` are not in the input `[4, 3, 2, 7, 8, 2, 3, 1]`\\n\\n**Time complexity:** `O(N)`\\n**Space Complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = 0; i < A.length; i++) {\\n            int newIndex = Math.abs(A[i]) - 1;\\n\\n            if (A[newIndex] > 0) {\\n                A[newIndex] *= -1;\\n            }\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] > 0) {\\n                list.add(i + 1);                // If A[i] is positive, means i + 1 is missing.\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();             // List of Missing Elements in [1 .. N]\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            set.add(n);\\n        }\\n\\n        for (int i = 1; i <= A.length; i++) {\\n            if (!set.contains(i)) {\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\n```\\nwhen i = 0, array becomes [ 4,  3,  2, -7,  8,  2,  3,  1]    // Marked `A[3]` as negative\\nwhen i = 1, array becomes [ 4,  3, -2, -7,  8,  2,  3,  1]    // Marked `A[2]` as negative\\nwhen i = 2, array becomes [ 4, -3, -2, -7,  8,  2,  3,  1]    // Marked `A[1]` as negative\\nwhen i = 3, array becomes [ 4, -3, -2, -7,  8,  2, -3,  1]    // Marked `A[6]` as negative\\nwhen i = 4, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[7]` as negative\\nwhen i = 5, array becomes [ 4,  3, -2, -7,  8,  2, -3, -1]    // No change since `A[1]` is already marked as negative\\nwhen i = 6, array becomes [ 4, -3, -2, -7,  8,  2, -3, -1]    // No change since `A[2]` is already marked as negative\\nwhen i = 7, array becomes [-4, -3, -2, -7,  8,  2, -3, -1]    // Marked `A[3]` as negative\\n```\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] A) {\\n        List<Integer> list = new ArrayList<>();\\n\\n        for (int i = 0; i < A.length; i++) {\\n            int newIndex = Math.abs(A[i]) - 1;\\n\\n            if (A[newIndex] > 0) {\\n                A[newIndex] *= -1;\\n            }\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] > 0) {\\n                list.add(i + 1);                // If A[i] is positive, means i + 1 is missing.\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190195,
                "title": "java-solution-in-o-n-without-extra-spaces",
                "content": "I call this algorithm Find Your Own Position.\n\nSet each number to its own position, number 1 should go to index 0, 2 should go to index 1 etc.\n\nIf a number's expected position is ocupied with same number, stop. If the positon is ocupied with another number, let that number find its own positon until each number find its positon. As each number will find its own positon only once. The running time will be O(n)\n\n```\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> res=new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n           int val=nums[i];\n            while(val!=nums[val-1]){\n                int tmp=nums[val-1];\n                nums[val-1]=val;\n                val=tmp;\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            if(i+1!=nums[i]){\n                res.add(i+1);\n            }\n        }\n        return res;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> res=new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n           int val=nums[i];\n            while(val!=nums[val-1]){\n                int tmp=nums[val-1];\n                nums[val-1]=val;\n                val=tmp;\n            }\n        }\n        for(int i=0;i<nums.length;i++){\n            if(i+1!=nums[i]){\n                res.add(i+1);\n            }\n        }\n        return res;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432831,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int i = 0;\\n        while (i < nums.length) {\\n            int position = nums[i] - 1;\\n            if (nums[i] != nums[position]) {\\n                int temp = nums[i];\\n                nums[i] = nums[position];\\n                nums[position] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        for (i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                list.add(i + 1);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int i = 0;\\n        while (i < nums.length) {\\n            int position = nums[i] - 1;\\n            if (nums[i] != nums[position]) {\\n                int temp = nums[i];\\n                nums[i] = nums[position];\\n                nums[position] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        for (i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                list.add(i + 1);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723236,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n    List<Integer> result = new ArrayList<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n        int val = Math.abs(nums[i]) - 1;\\n        if (nums[val] > 0)\\n            nums[val] = -nums[val];\\n    }\\n\\n    for (int i = 0; i < nums.length; i++)\\n        if (nums[i] > 0)\\n            result.add(i+1);\\n    return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n    List<Integer> result = new ArrayList<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n        int val = Math.abs(nums[i]) - 1;\\n        if (nums[val] > 0)\\n            nums[val] = -nums[val];\\n    }\\n\\n    for (int i = 0; i < nums.length; i++)\\n        if (nums[i] > 0)\\n            result.add(i+1);\\n    return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468452,
                "title": "javascript-solution-faster-than-90",
                "content": "```\\nconst findDisappearedNumbers = nums => {\\n    const set = new Set(nums);    \\n    const newArr = [];\\n    \\n    for (let i = 0; i < nums.length; i += 1) {\\n\\t\\tif(!set.has(i + 1)){\\n\\t\\t\\tnewArr.push(i + 1);\\n\\t\\t}\\n    }\\n    \\n    return newArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findDisappearedNumbers = nums => {\\n    const set = new Set(nums);    \\n    const newArr = [];\\n    \\n    for (let i = 0; i < nums.length; i += 1) {\\n\\t\\tif(!set.has(i + 1)){\\n\\t\\t\\tnewArr.push(i + 1);\\n\\t\\t}\\n    }\\n    \\n    return newArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584213,
                "title": "tc-o-n-sc-o-1-5ms-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n    \\n        // since all numbers are between [1,n], we go to nums[i]-1 th index and multiply it by -1. \\n\\t\\t// if it is already negative(has previously been visited) we leave it as it is\\n        \\n        // Example, nums = [4,3,2,7,8,2,3,1] becomes\\n        //          nums = [-4,-3,-2,-7,-8,2,3,-1]\\n        for(int i=0; i<nums.length; i++){\\n            int num = Math.abs(nums[i]) - 1;\\n            \\n            nums[num] = nums[num] < 0 ? nums[num] : - nums[num];\\n        }\\n        \\n        // finally we check if there are positive numbers in nums, which indicates that number is \\n\\t\\t// missing(hasn\\'t been multiplied by -1). And then add their index + 1(b/c array is 0 indexed) \\n\\t\\t// to our result list.\\n        for(int i=0; i< nums.length; i++){\\n            if(nums[i] > 0){\\n                result.add(i+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n    \\n        // since all numbers are between [1,n], we go to nums[i]-1 th index and multiply it by -1. \\n\\t\\t// if it is already negative(has previously been visited) we leave it as it is\\n        \\n        // Example, nums = [4,3,2,7,8,2,3,1] becomes\\n        //          nums = [-4,-3,-2,-7,-8,2,3,-1]\\n        for(int i=0; i<nums.length; i++){\\n            int num = Math.abs(nums[i]) - 1;\\n            \\n            nums[num] = nums[num] < 0 ? nums[num] : - nums[num];\\n        }\\n        \\n        // finally we check if there are positive numbers in nums, which indicates that number is \\n\\t\\t// missing(hasn\\'t been multiplied by -1). And then add their index + 1(b/c array is 0 indexed) \\n\\t\\t// to our result list.\\n        for(int i=0; i< nums.length; i++){\\n            if(nums[i] > 0){\\n                result.add(i+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313866,
                "title": "c-solution-2-different-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i = 0; i < n; i++){\\n            int idx = abs(nums[i]); \\n            if(nums[idx-1] > 0) nums[idx-1] = -nums[idx-1]; // marking -ve    \\n        }\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\\n**Using Unordered map**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int>ans;\\n        unordered_map<int, bool>mp;\\n        for(int i = 0; i < n; i++) mp[nums[i]] = true;\\n        \\n        for(int i = 1; i <= n; i++)\\n            if(mp.find(i) == mp.end()) ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        for(int i = 0; i < n; i++){\\n            int idx = abs(nums[i]); \\n            if(nums[idx-1] > 0) nums[idx-1] = -nums[idx-1]; // marking -ve    \\n        }\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) res.push_back(i+1);\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int>ans;\\n        unordered_map<int, bool>mp;\\n        for(int i = 0; i < n; i++) mp[nums[i]] = true;\\n        \\n        for(int i = 1; i <= n; i++)\\n            if(mp.find(i) == mp.end()) ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482313,
                "title": "elegant-swift-solution",
                "content": "It is not optimal and using extra memory, but fun :)\\n\\n```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        if nums.isEmpty {\\n            return nums\\n        }\\n        \\n        return Array(\\n            Set(1...nums.count).subtracting(nums)\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        if nums.isEmpty {\\n            return nums\\n        }\\n        \\n        return Array(\\n            Set(1...nums.count).subtracting(nums)\\n        )\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92976,
                "title": "c-time-o-n-space-o-1",
                "content": "I use in-place change and the index of vector is from 0 -> n-1.\\n\\n    class Solution {\\n    public:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        if(nums.empty()) return res;\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            while(nums[nums[i]-1] != nums[i]){\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] != i+1){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        if(nums.empty()) return res;\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            while(nums[nums[i]-1] != nums[i]){\\n                swap(nums[nums[i]-1], nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3741667,
                "title": "cyclic-sort-be-saving-life-fr-java",
                "content": "\\n### Intuition\\nThe problem aims to find the missing numbers in an array of integers from 1 to n. The intuition behind the solution is to use cyclic sort to arrange the elements in their correct positions. After that, we can iterate through the sorted array and identify the missing numbers.\\n\\n### Approach\\n1. We start by initializing variables `n` as the length of the array `nums`, `i` as 0, and creating an empty ArrayList called `ans` to store the missing numbers.\\n2. We perform a cyclic sort on the `nums` array. The goal is to move each number to its correct index position by swapping elements. If the current number is not equal to the number at its correct index, we perform the swap.\\n3. After the cyclic sort, we iterate through the array again to find the missing numbers. If the number at index `i` is not equal to `i+1`, it means `i+1` is a missing number. We add it to the `ans` ArrayList.\\n4. Finally, we return the `ans` ArrayList, which contains the missing numbers.\\n\\n### Complexity\\n- Time complexity: The time complexity is O(n), where n is the length of the `nums` array. The cyclic sort and the subsequent iteration take linear time.\\n- Space complexity: The space complexity is O(1) since the extra space used is only for the variables `n`, `i`, and the `ans` ArrayList, which are of constant size.\\n\\n### Code\\n```java\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        int n = nums.length;\\n        int i = 0 ; \\n        List<Integer> ans = new ArrayList();\\n\\n        if (n < 2) return new ArrayList<Integer>(1);\\n\\n        while (i < n) {\\n            int correctIndex = nums[i] - 1;\\n\\n            if (nums[i] != nums[correctIndex]) {\\n                if (correctIndex < n) {\\n                    swap(nums, i, correctIndex);\\n                } else {\\n                    i++;\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                ans.add(i + 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\\n\\nI hope this explanation helps you understand the solution. If you have any further questions, feel free to ask!\\n\\n![upvotekaro1.jpeg](https://assets.leetcode.com/users/images/6f3e46a6-ac51-463b-be4b-56fa16ec0075_1688918097.433203.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        int n = nums.length;\\n        int i = 0 ; \\n        List<Integer> ans = new ArrayList();\\n\\n        if (n < 2) return new ArrayList<Integer>(1);\\n\\n        while (i < n) {\\n            int correctIndex = nums[i] - 1;\\n\\n            if (nums[i] != nums[correctIndex]) {\\n                if (correctIndex < n) {\\n                    swap(nums, i, correctIndex);\\n                } else {\\n                    i++;\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                ans.add(i + 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491390,
                "title": "java-cycle-sort-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        int i=0;\\n        while(i<nums.length){\\n            int correct = nums[i]-1;\\n            if(nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else i++;\\n        }\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) ans.add(i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        int i=0;\\n        while(i<nums.length){\\n            int correct = nums[i]-1;\\n            if(nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else i++;\\n        }\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) ans.add(i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871915,
                "title": "simple-and-easy-approach-to-understand-using-vector-and-set-o-nlogn",
                "content": "# Intuition\\nWE need to find all the elements that are not present in array upto n\\nwhich is size of array.\\n\\n# Approach\\nI have taken A set and inserted all the elemnets  which is  given to us.\\nNow i have taken a vector(V) in which  I am pushing all the elements upto n  regardless of their presence in vector  given i.e nums.\\n\\nNOW we will check through loop if the  element present in our vector (V) is present in set or  not if not found then we will push into vector v1    and return it.\\n\\nlike [1,1,2,2] given here value of  n is 4\\nso we will push 1,2,3,4 into vector v\\n```\\nfor(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n```\\nSO V have  v[1,2,3,4]\\nand set have s {1,2}\\nNOW we will check if v[i] is present in set if not then push it into v1 so v1 have [3,4] and  this is our result\\n```\\n    for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n```\\n\\n\\n# Complexity\\n- Time complexy: $O(nlogn)\\n\\n-\\n-  Space complexity:\\n\\n$O(n)\\n#### if any doubt or confusion regarding the code ask in comment section I will try to reply as soon as possible\\n# IF IT\\'S HELPFUL UPVOTE IT\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      int n=nums.size();\\n      int max=*max_element(nums.begin(), nums.end());\\n      vector<int> v,v1;\\n      set<int>s;\\n      for(int i=0; i<n; i++){\\n        s.insert(nums[i]);\\n      }\\n      for(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n       for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n       return v1;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nfor(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n```\n```\\n    for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      int n=nums.size();\\n      int max=*max_element(nums.begin(), nums.end());\\n      vector<int> v,v1;\\n      set<int>s;\\n      for(int i=0; i<n; i++){\\n        s.insert(nums[i]);\\n      }\\n      for(int i=0; i<=n; i++){\\n      v.push_back(i);\\n      }\\n       for(int i=1; i<=n; i++){\\n           if(s.find(v[i])==s.end()){\\n             v1.push_back(v[i]); }\\n          }\\n       return v1;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687300,
                "title": "easy-c-set-method",
                "content": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      \\n\\t  int n = nums.size();\\n        vector<int> ans;\\n        unordered_set<int> temp;\\n        for(auto x:nums) \\n        {   temp.insert(x);\\n        }\\n        for(int i=1;i<=n;i++)\\n            // iterate from 1->n, and find if the number is not present in the set                  and store it in the ans.\\n        {\\n            if(temp.find(i)==temp.end())\\n            {\\n               ans.push_back(i); \\n            }\\n        }\\n        return ans;\\n       \\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n      \\n\\t  int n = nums.size();\\n        vector<int> ans;\\n        unordered_set<int> temp;\\n        for(auto x:nums) \\n        {   temp.insert(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1616425,
                "title": "cyclic-sort-method-time-o-n-and-space-o-1",
                "content": "Disclaimer: This question is very easy if you use simple hashmap, but get\\'s slightly tricky if you have a restriction of O(1) space, and that\\'s where the interviewer strikes :)\\n\\nLet us solve a simpler question:\\ngiven an array of size n and values between 1 and n , how can we sort it in O(n) complexity with O(1) space complexity?\\nAnswer is cyclic sort, read about it [here](https://emre.me/coding-patterns/cyclic-sort/).\\n\\nHere is my implementation of cyclic sort:\\n```\\n    vector<int>A = {4, 3, 1, 2};\\n    int n = A.size();\\n    for(int i=0; i<n; ++i) {\\n        while(i != A[i]-1) {\\n            swap(A[i], A[A[i]-1]);\\n        }\\n    }\\n\\t// A is now sorted\\n```\\n\\nNow once you are done with cyclic sort, this question will be cakewalk, try it yourself, below is my implementation:\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; ++i) {\\n            while(i != (nums[i]-1) && nums[i] != nums[nums[i]-1]) {\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i]-1!=i) {\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    vector<int>A = {4, 3, 1, 2};\\n    int n = A.size();\\n    for(int i=0; i<n; ++i) {\\n        while(i != A[i]-1) {\\n            swap(A[i], A[A[i]-1]);\\n        }\\n    }\\n\\t// A is now sorted\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; ++i) {\\n            while(i != (nums[i]-1) && nums[i] != nums[nums[i]-1]) {\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i]-1!=i) {\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583712,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for v in nums:            \\n            nums[abs(v) - 1] = -abs(nums[abs(v) - 1])\\n                \\n        return [ i + 1 for i, v in enumerate(nums) if v >= 1 ]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for v in nums:            \\n            nums[abs(v) - 1] = -abs(nums[abs(v) - 1])\\n                \\n        return [ i + 1 for i, v in enumerate(nums) if v >= 1 ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759565,
                "title": "javascript-solution-448",
                "content": "```\\nlet findDisappearedNumbers = function(nums1) {\\n    let ans=[];\\n    let diff=0;\\n    let start=0;\\n    nums1.sort(function(a,b){\\n        return (a-b)\\n    });\\n    for (let i=1;i<=nums1.length;i++){\\n        if(!nums1.includes(i)){\\n            ans.push(i);\\n        }\\n    }\\n    return ans;\\n\\n        };\\n```\\n\\n**Runtime: 9068 ms, faster than 5.05% of JavaScript online submissions for Find All Numbers Disappeared in an Array.\\nMemory Usage: 46.5 MB, less than 48.95% of JavaScript online submissions for Find All Numbers Disappeared in an Array.**",
                "solutionTags": [],
                "code": "```\\nlet findDisappearedNumbers = function(nums1) {\\n    let ans=[];\\n    let diff=0;\\n    let start=0;\\n    nums1.sort(function(a,b){\\n        return (a-b)\\n    });\\n    for (let i=1;i<=nums1.length;i++){\\n        if(!nums1.includes(i)){\\n            ans.push(i);\\n        }\\n    }\\n    return ans;\\n\\n        };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656108,
                "title": "swift-solution-optimal-96",
                "content": "This clean swift solution uses O(n) time and O(1) space.\\n\\n**Explanation**\\nTo signify that the number `n` exists with O(1) space, we make `nums[n - 1]` negative. We must be careful to make it negative only once which is why we have the if condition around the assignment. Also, we use `n - 1` instead of `n` to avoid an array index out of bounds error since `n` ranges from `1 ... n`\\n\\n**Be Aware**\\nTechnically this problem cannot be done in O(1) space in Swift since we must create a new array. This could be done in O(1) space only if we had `_ nums: inout [Int]` in the method signature. \\n\\n**Solution**\\n```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        // If the current number is \"n\", then make index \"n-1\" negative to signify \"n\" exists\\n        var nums = nums \\n        for i in 0 ..< nums.count {\\n            let n = abs(nums[i])\\n            if nums[n - 1] >= 0 {\\n                nums[n - 1] = -nums[n - 1]\\n            }\\n        }\\n        \\n        // If the number at index \"i\" is positive, then number \"i+1\" was missing\\n        var missing = [Int]()\\n        for i in 0 ..< nums.count {\\n            if nums[i] >= 0 {\\n                missing.append(i+1)\\n            }\\n        }\\n        return missing\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func findDisappearedNumbers(_ nums: [Int]) -> [Int] {\\n        // If the current number is \"n\", then make index \"n-1\" negative to signify \"n\" exists\\n        var nums = nums \\n        for i in 0 ..< nums.count {\\n            let n = abs(nums[i])\\n            if nums[n - 1] >= 0 {\\n                nums[n - 1] = -nums[n - 1]\\n            }\\n        }\\n        \\n        // If the number at index \"i\" is positive, then number \"i+1\" was missing\\n        var missing = [Int]()\\n        for i in 0 ..< nums.count {\\n            if nums[i] >= 0 {\\n                missing.append(i+1)\\n            }\\n        }\\n        return missing\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585334,
                "title": "c-basic-solution",
                "content": "```\\n  public IList<int> FindDisappearedNumbers(int[] nums)\\n        {\\n            //creating required range.\\n            //for example, nums = new[] { 4, 3, 2, 7, 8, 2, 3, 1 }; in this case range is 1-10. \\n            //by default all arrays start from 0, that is why we need [nums.Length + 1] for getting proper range\\n            bool[] values = new bool[nums.Length + 1];\\n\\n            //By default value if false, if we found value in our required range set value true\\n            foreach (var t in nums)\\n            {\\n                values[t] = true;\\n            }\\n\\n            //collect all values which is not found in required range\\n            var result = new List<int>();\\n            for (int i = 1; i < values.Length; i++)\\n            {\\n                if (values[i] == false)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n  public IList<int> FindDisappearedNumbers(int[] nums)\\n        {\\n            //creating required range.\\n            //for example, nums = new[] { 4, 3, 2, 7, 8, 2, 3, 1 }; in this case range is 1-10. \\n            //by default all arrays start from 0, that is why we need [nums.Length + 1] for getting proper range\\n            bool[] values = new bool[nums.Length + 1];\\n\\n            //By default value if false, if we found value in our required range set value true\\n            foreach (var t in nums)\\n            {\\n                values[t] = true;\\n            }\\n\\n            //collect all values which is not found in required range\\n            var result = new List<int>();\\n            for (int i = 1; i < values.Length; i++)\\n            {\\n                if (values[i] == false)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336437,
                "title": "solution-in-python-3-five-lines-o-n-time-o-1-space",
                "content": "_1) O(n) speed and O(1) space Solution:_\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, n: List[int]) -> List[int]:\\n        i, L = 0, len(n)\\n        while i != L:\\n        \\tif n[i] in [i + 1, n[n[i] - 1]]: i += 1\\n        \\telse: n[n[i] - 1], n[i] = n[i], n[n[i] - 1]\\n        return [i + 1 for i in range(L) if n[i] != i + 1]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\n_2) Fast Solution (beats ~99%):_\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, n: List[int]) -> List[int]:\\n    \\tN = set(n)\\n    \\treturn [i for i in range(1, len(n) + 1) if i not in N]\\n\\n- Python 3\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, n: List[int]) -> List[int]:\\n        i, L = 0, len(n)\\n        while i != L:\\n        \\tif n[i] in [i + 1, n[n[i] - 1]]: i += 1\\n        \\telse: n[n[i] - 1], n[i] = n[i], n[n[i] - 1]\\n        return [i + 1 for i in range(L) if n[i] != i + 1]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324205,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    let res = []\\n    nums.forEach((val, ind, arr) => {\\n        let tmp = Math.abs(arr[ind]) - 1;\\n        if (arr[tmp] > 0)\\n            arr[tmp] *= -1;\\n    })\\n    nums.forEach((val, ind) => {\\n        if (val > 0)\\n            res.push(ind + 1)\\n    })\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    let res = []\\n    nums.forEach((val, ind, arr) => {\\n        let tmp = Math.abs(arr[ind]) - 1;\\n        if (arr[tmp] > 0)\\n            arr[tmp] *= -1;\\n    })\\n    nums.forEach((val, ind) => {\\n        if (val > 0)\\n            res.push(ind + 1)\\n    })\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273792,
                "title": "javascript-solution",
                "content": "```\\nvar findDisappearedNumbers = function(nums) {\\n    var s = {};\\n    for (let i =1; i< nums.length+1; i++) {\\n        s[i] = 1;\\n    }\\n    \\n    nums.forEach(n=> {\\n        delete s[n];\\n    })\\n    \\n   return Object.keys(s)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findDisappearedNumbers = function(nums) {\\n    var s = {};\\n    for (let i =1; i< nums.length+1; i++) {\\n        s[i] = 1;\\n    }\\n    \\n    nums.forEach(n=> {\\n        delete s[n];\\n    })\\n    \\n   return Object.keys(s)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231325,
                "title": "python-solution",
                "content": "Idea: change `nums[n-1]` to `-1` for all `n` in `nums`, meaning that we have seen `n` in `nums`. Then we traverse `nums` once more, and record all indices `idx` such that `nums[idx] != -1`. Each `idx+1` will be a number that disappears in `nums`. \\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n > 0:\\n                while n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = -1\\n                    n = tmp\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] >= 0:\\n                res.append(i+1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n > 0:\\n                while n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = -1\\n                    n = tmp\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] >= 0:\\n                res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209665,
                "title": "short-python-beats-76",
                "content": "```\\ndef findDisappearedNumbers(self, nums):\\n\\tfor num in nums:\\n\\t\\tnum = abs(num)\\n\\t\\tif nums[num-1] >0:\\n\\t\\t\\tnums[num-1] *=-1\\n\\treturn [i+1 for i,x in enumerate(nums) if x>0]",
                "solutionTags": [],
                "code": "```\\ndef findDisappearedNumbers(self, nums):\\n\\tfor num in nums:\\n\\t\\tnum = abs(num)\\n\\t\\tif nums[num-1] >0:\\n\\t\\t\\tnums[num-1] *=-1\\n\\treturn [i+1 for i,x in enumerate(nums) if x>0]",
                "codeTag": "Python3"
            },
            {
                "id": 92959,
                "title": "c-solution-o-n-and-no-additional-space",
                "content": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int* histogram = (int*) malloc(sizeof(int) * (numsSize + 1)); \\n    memset(histogram, 0, sizeof(int) * numsSize);\\n\\n    for (int index = 0; index < numsSize; index++) {\\n        histogram[nums[index]]++;\\n    }\\n\\n    histogram[0] = 1;\\n    for (int index = 1; index <= numsSize; index++) {\\n        if (histogram[index] == 0) {\\n            histogram[histogram[0]] = index;\\n            histogram[0]++;\\n        }\\n    }\\n    *returnSize = histogram[0] - 1;\\n    return &histogram[1];\\n}\\n```\\nKeeping a histogram array, and later traversing the histogram to return elements with 0 values allows us to solve this problem with O(n) complexity. Index 0 of the histogram was used to store the number of missing numbers.",
                "solutionTags": [],
                "code": "```\\nint* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {\\n    int* histogram = (int*) malloc(sizeof(int) * (numsSize + 1)); \\n    memset(histogram, 0, sizeof(int) * numsSize);\\n\\n    for (int index = 0; index < numsSize; index++) {\\n        histogram[nums[index]]++;\\n    }\\n\\n    histogram[0] = 1;\\n    for (int index = 1; index <= numsSize; index++) {\\n        if (histogram[index] == 0) {\\n            histogram[histogram[0]] = index;\\n            histogram[0]++;\\n        }\\n    }\\n    *returnSize = histogram[0] - 1;\\n    return &histogram[1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3393596,
                "title": "find-all-numbers-disappeared-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            m[i+1]++;\\n            m[nums[i]]++;\\n        }\\n        nums.clear();\\n        for( auto it:m)\\n        {\\n            if(it.second==1)\\n            {\\n                nums.push_back(it.first);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            m[i+1]++;\\n            m[nums[i]]++;\\n        }\\n        nums.clear();\\n        for( auto it:m)\\n        {\\n            if(it.second==1)\\n            {\\n                nums.push_back(it.first);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659032,
                "title": "c-solution-simple-and-precise-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> v;\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        for(int i=1;i<=nums.size();i++)\\n        {\\n            if(m[i]==0) v.push_back(i); \\n        }\\n        return v;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> v;\\n        unordered_map<int,int> m;\\n        for(int x: nums) m[x]++;\\n        for(int i=1;i<=nums.size();i++)\\n        {\\n            if(m[i]==0) v.push_back(i); \\n        }\\n        return v;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643134,
                "title": "easy-c-sol-for-beginners-o-n-time-complexity-and-o-1-space-complexity",
                "content": "Basically what we are trying to do is \\n1) Given range 1 to n\\n2) Range of array 0 to n-1\\n3) So we are trying to traverse every element of nums and replace the index nums[i]-1 with negative value (the values can some times already be negative so we are using abs() to make sure it is not changed back to positive value if we encounter the same element again)\\n4) After travesing the nums array we will one again traverse to check which values are +ve (Because +ve values means they are not encountered earlier)\\n5) Finally we will add (index of positive values +1) to vector and return the vector (why +1 -> Remember that the difference between range of values and array index is 1 so we need to add this 1 to cover the difference)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n=nums.size(), loc;\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            loc = abs(nums[i])-1;\\n            nums[loc] = abs(nums[loc])*(-1);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nHope this helps!\\nThank you!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n=nums.size(), loc;\\n        vector<int> res;\\n        for(int i=0; i<n; i++){\\n            loc = abs(nums[i])-1;\\n            nums[loc] = abs(nums[loc])*(-1);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990280,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Check in HashSet**\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        seen = set(nums)\\n        res = []\\n        for num in range(1, n+1):\\n            if num not in seen:\\n                res.append(num)\\n        return res\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reuse index**\\n- Since value are in range `[1..n]`, we can mark number as seen by marking the number at that index as negative.\\n- Finally, iterate `i = [0..n-1]`, if `nums[i] > 0` then `i+1` is missing.\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        for num in nums:\\n            idx = abs(num) - 1\\n            nums[idx] = -abs(nums[idx])\\n            \\n        ans = []\\n        for i in range(n):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        seen = set(nums)\\n        res = []\\n        for num in range(1, n+1):\\n            if num not in seen:\\n                res.append(num)\\n        return res\\n```\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        for num in nums:\\n            idx = abs(num) - 1\\n            nums[idx] = -abs(nums[idx])\\n            \\n        ans = []\\n        for i in range(n):\\n            if nums[i] > 0:\\n                ans.append(i+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849912,
                "title": "python-one-liner-simple-and-elegant",
                "content": "**Solution**:\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        return set(range(1,len(nums)+1)) - set(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        return set(range(1,len(nums)+1)) - set(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584902,
                "title": "java-solution-o-n-time-o-1-space-100-faster",
                "content": "**Complexity Explanation:**\\n* O(N) Time: We pass through the array 2 times\\n* O(1) Space: Constant space used\\n\\n---\\n\\n**Algorithm Explanation:**\\n\\nThis array has the special property of only containing numbers between 1 and the array length\\n\\nThis means that we can easily record in the input array if we have seen that number already\\n\\nWhenever we visit an element, we visit the index of the element, and make the index negative, to show that we visited\\n\\nBy making it negative, we can clearly see that it was changed, without changing it\\'s numerical value\\n\\nAfter the array has been iterated, all indexes that have negative elements will have their indexes as elements in the array themselves.\\n\\nPositive elements mean that the index never appeared in the array, and so we add that index to our output/result.\\n\\n---\\n**Example:**\\n\\n\\nInput Array: [**4**,3,2,7,8,2,3,1]\\n\\nFirst element is 4, we make the 4th index negative\\n\\nNew Array: [4,**3**,2,-7,8,2,3,1]\\n\\nSecond element is 3, we make the 3rd index negative\\n\\nNew Array: [4,3,**-2**,-7,8,2,3,1]\\n\\nThird element is -2, but it\\'s numerical value is 2, so we make the 2nd element negative\\n\\nNew Array: [4,-3,-2,**-7**,8,2,3,1]\\n\\nFourth element is -7, but it\\'s numerical value is 7, so we make the 7th element negative\\n\\nNew Array: [4,-3,-2,-7,**8**,2,-3,1]\\n\\nFifth element, is 8, so we make the 8th element negative\\n\\nNew Array: [4,-3,-2,-7,8,**2**,-3,-1]\\n\\nsixth element is 2, so we make the 2nd element negative\\n\\nSince it is already negative, we make no change\\n\\nNew Array: [4,-3,-2,-7,8,2,**-3**,-1]\\n\\nseventh element is -3, which has a numerical value of 3, so we make the 3rd element negative\\n\\nSince it is already negative, we make no change\\n\\nNew Array: [4,-3,-2,-7,8,2,-3,**-1**]\\n\\neighth element is -1, which has a numerical value of 1, so we make the 1st element negative\\n\\n**Final Array:** [-4,-3,-2,-7,8,2,-3,-1]\\n\\nThe 5th and 6th element is positive, meaning that those indexes were not present in the array\\n\\nWe return 5 and 6 in a List, and finish our code :)\\n\\n---\\n\\n**The Code:**\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[Math.abs(nums[idx])-1]>0){\\n                nums[Math.abs(nums[idx])-1]*=-1;\\n            }\\n        }\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[idx] > 0){\\n                result.add(idx+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nIf you found this solution interesting or useful, please upvote :)\\n\\nIf this explanation is still unclear, please comment so that I may further explain it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[Math.abs(nums[idx])-1]>0){\\n                nums[Math.abs(nums[idx])-1]*=-1;\\n            }\\n        }\\n        for(int idx = 0;idx < nums.length;idx++){\\n            if(nums[idx] > 0){\\n                result.add(idx+1);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377234,
                "title": "easy-java-solution-3-ms-faster-than-100-00-of-java-online",
                "content": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int [] a = new int[nums.length+1];\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i =0; i<nums.length; i++)\\n            a[nums[i]]++;\\n        \\n        for(int i =1; i<nums.length+1; i++)\\n            if(a[i] == 0)\\n                list.add(i);\\n            \\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int [] a = new int[nums.length+1];\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i =0; i<nums.length; i++)\\n            a[nums[i]]++;\\n        \\n        for(int i =1; i<nums.length+1; i++)\\n            if(a[i] == 0)\\n                list.add(i);\\n            \\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1238204,
                "title": "java-o-n-time-and-both-o-1-and-o-n-space",
                "content": "**Solution 1: O(n) space**\\nInitialize a new array `tmp` of the same length as `nums`.  By default all elements are 0. Now iterate over `nums` and for\\nfor each element k in `nums`, increment the element at the corresponding index of tmp by 1. For elements within `1,...,n`that are not present in `nums`, the corresponding 0-indexed element in `tmp` will remain zero, since those numbers are not encountered while iterating over `nums`.\\n\\nNext, iterate over `tmp` and add only those indexes to list, whose value is 0. Note that `l.add(i+1)` is done to account for 0-indexing.\\n\\n**Solution 2: O(1) space**\\nSInce all elements are less than or equal to `n = nums.length`, let us first send all elements one by one to their correct positions. Here correct position means 1 should be at index 0, 2 should be at index 1, k should be at index k-1.\\nLet\\'s see how this is done: \\n\\nWe start at the first element 4. `[4,3,2,7,8,2,3,1]` becomes `[7,3,2,4,8,2,3,1]` as the 1st element 4 is sent to index 3 and replaced with 7, which was on index 3. This is carried out until we have element 1 at index 0, or we find a duplicate element. The process goes like:\\n\\n`[7,3,2,4,8,2,3,1]` - >`[3,3,2,4,8,2,7,1]` - > `[2,3,3,4,8,2,7,1]` - > `[3,2,3,4,8,2,7,1]` where we find a duplicate element. Here we shift to the next element which is 2 and repeat the process, until we reach the end of the array, where we\\'re left with `nums = [1,2,3,4,3,2,7,8]`. We can see that the elements that are not in their correct position are 3 at index  4 and 2 at index 5, where 5 and 6 should have been, respectively.\\n\\nHence we return a list containing the elements 5 and 6.\\n\\n```\\n**Solution 1: O(n) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] tmp = new int[nums.length];\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n            tmp[nums[i] - 1]++;\\n        }\\n        for(int i = 0; i < tmp.length; i++){\\n            if(tmp[i] == 0) l.add(i+1);\\n        }\\n        return l;\\n    }\\n\\n**Solution 2: O(1) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        List<Integer> l = new ArrayList<Integer>();\\n        while(i < nums.length){\\n            if(nums[i] != i+1){\\n                if(nums[i] == nums[nums[i] - 1]) {\\n                    i++;\\n                }else{\\n                    int tmp = nums[i];\\n                    nums[i] = nums[nums[i] - 1];\\n                    nums[tmp - 1] = tmp;\\n                }\\n            } else i++;\\n        }\\n        for(i = 0; i < nums.length; i++){\\n            if(nums[i] != i + 1) l.add(i+1);\\n        }\\n        return l;   \\n    }",
                "solutionTags": [],
                "code": "**Solution 1: O(n) space**\\nInitialize a new array `tmp` of the same length as `nums`.  By default all elements are 0. Now iterate over `nums` and for\\nfor each element k in `nums`, increment the element at the corresponding index of tmp by 1. For elements within `1,...,n`that are not present in `nums`, the corresponding 0-indexed element in `tmp` will remain zero, since those numbers are not encountered while iterating over `nums`.\\n\\nNext, iterate over `tmp` and add only those indexes to list, whose value is 0. Note that `l.add(i+1)` is done to account for 0-indexing.\\n\\n**Solution 2: O(1) space**\\nSInce all elements are less than or equal to `n = nums.length`, let us first send all elements one by one to their correct positions. Here correct position means 1 should be at index 0, 2 should be at index 1, k should be at index k-1.\\nLet\\'s see how this is done: \\n\\nWe start at the first element 4. `[4,3,2,7,8,2,3,1]` becomes `[7,3,2,4,8,2,3,1]` as the 1st element 4 is sent to index 3 and replaced with 7, which was on index 3. This is carried out until we have element 1 at index 0, or we find a duplicate element. The process goes like:\\n\\n`[7,3,2,4,8,2,3,1]` - >`[3,3,2,4,8,2,7,1]` - > `[2,3,3,4,8,2,7,1]` - > `[3,2,3,4,8,2,7,1]` where we find a duplicate element. Here we shift to the next element which is 2 and repeat the process, until we reach the end of the array, where we\\'re left with `nums = [1,2,3,4,3,2,7,8]`. We can see that the elements that are not in their correct position are 3 at index  4 and 2 at index 5, where 5 and 6 should have been, respectively.\\n\\nHence we return a list containing the elements 5 and 6.\\n\\n```\\n**Solution 1: O(n) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int[] tmp = new int[nums.length];\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i = 0; i < nums.length; i++){\\n            tmp[nums[i] - 1]++;\\n        }\\n        for(int i = 0; i < tmp.length; i++){\\n            if(tmp[i] == 0) l.add(i+1);\\n        }\\n        return l;\\n    }\\n\\n**Solution 2: O(1) space**\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        List<Integer> l = new ArrayList<Integer>();\\n        while(i < nums.length){\\n            if(nums[i] != i+1){\\n                if(nums[i] == nums[nums[i] - 1]) {\\n                    i++;\\n                }else{\\n                    int tmp = nums[i];\\n                    nums[i] = nums[nums[i] - 1];\\n                    nums[tmp - 1] = tmp;\\n                }\\n            } else i++;\\n        }\\n        for(i = 0; i < nums.length; i++){\\n            if(nums[i] != i + 1) l.add(i+1);\\n        }\\n        return l;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1195628,
                "title": "two-approaches-java-faster-than-100",
                "content": "**O(n) - Time\\nNo Extra Space**\\n1. Traverse the array,and find out index corresponding to given element.(Since we have 0 based index in arrays, so index = abs(nums[i]-1))\\n2. Make the element at that index negative, to mark its presence.\\n3. Traverse the array again to determine the disappeared numbers.\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int index = Math.abs(nums[i])-1;\\n            if(nums[index] > 0)\\n                nums[index] = -1*nums[index];\\n        }\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            if(nums[i] > 0)\\n                arr.add(i+1);\\n        }\\n        return arr;\\n    }\\n}\\n\\n```\\n\\n**Using O(N) space **\\n\\n1. Traverse the array, and maintain the count/ frequency of each element that is occuring.\\n2. Then traverse the count array, and check the elements whose frequency is still 0, and add it to the ans list.\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int n = nums.length;  \\n        List<Integer>  ans = new ArrayList<>();\\n        int count[] = new int[n+1];\\n        for(int i : nums)\\n        {\\n           count[i]++;\\n        }\\n        \\n        for(int i =1;i<n+1;i++)\\n        {\\n            if(count[i] == 0)\\n              ans.add(i);    \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int index = Math.abs(nums[i])-1;\\n            if(nums[index] > 0)\\n                nums[index] = -1*nums[index];\\n        }\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            if(nums[i] > 0)\\n                arr.add(i+1);\\n        }\\n        return arr;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int n = nums.length;  \\n        List<Integer>  ans = new ArrayList<>();\\n        int count[] = new int[n+1];\\n        for(int i : nums)\\n        {\\n           count[i]++;\\n        }\\n        \\n        for(int i =1;i<n+1;i++)\\n        {\\n            if(count[i] == 0)\\n              ans.add(i);    \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139900,
                "title": "simple-java-linear-time-solution-o-1-space",
                "content": "As numbers are between [1,N], so for each number we can make number at index (num - 1) negative and the numbers which are missing  wouldn\\'t  be able to make their indices negative so we will traverse array again and see positive indices and add them into list \\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(nums.length == 0 || nums == null) return result;\\n        \\n        for(int num : nums){\\n            int index = Math.abs(num);\\n            \\n            if(nums[index - 1] > 0){\\n                nums[index - 1] = -nums[index - 1];\\n            }\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(nums[i - 1] > 0){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(nums.length == 0 || nums == null) return result;\\n        \\n        for(int num : nums){\\n            int index = Math.abs(num);\\n            \\n            if(nums[index - 1] > 0){\\n                nums[index - 1] = -nums[index - 1];\\n            }\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(nums[i - 1] > 0){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741568,
                "title": "java-set-approach",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        //add all unique elements in the set\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        \\n        //iterate through 1 to n and check if it is not present in the set\\n        List<Integer> missing = new ArrayList<>();\\n        for(int i = 1; i <= nums.length; i++)\\n            if(!set.contains(i))\\n                missing.add(i);\\n        \\n        \\n        return missing;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        //add all unique elements in the set\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        \\n        //iterate through 1 to n and check if it is not present in the set\\n        List<Integer> missing = new ArrayList<>();\\n        for(int i = 1; i <= nums.length; i++)\\n            if(!set.contains(i))\\n                missing.add(i);\\n        \\n        \\n        return missing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442512,
                "title": "easy-solution-using-hashset-c",
                "content": "```\\npublic IList<int> FindDisappearedNumbers(int[] nums) {\\n            var set = new HashSet<int>(Enumerable.Range(1, nums.Length));\\n            foreach (var num in nums)\\n                set.Remove(num);\\n\\n            return set.ToList();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<int> FindDisappearedNumbers(int[] nums) {\\n            var set = new HashSet<int>(Enumerable.Range(1, nums.Length));\\n            foreach (var num in nums)\\n                set.Remove(num);\\n\\n            return set.ToList();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313578,
                "title": "easy-python-1-line-using-set-95",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        return list(set(range(1,len(nums)+1))-set(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290039,
                "title": "python-8-lines-in-place-changes-can-be-undone-o-n-runtime-o-1-space",
                "content": "Based on  [this solution](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/discuss/92957/2ms-O(n)-In-Space-Javattp://)\\nKeep track of which numbers have been seen, by numbers at the positions of the original array to be negative. For example if we saw the number 1, we set the 1st element of the original array to be negative.\\n\\nThen just return all the indexes where the numbers are positive\\n```\\n\\tfor i in range(len(nums)):\\n\\t\\tn = abs(nums[i])\\n\\t\\tnums[n-1] = -abs(nums[n-1])\\n\\tans = []\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] > 0 :\\n\\t\\t\\tans.append(i+1)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\n\\tfor i in range(len(nums)):\\n\\t\\tn = abs(nums[i])\\n\\t\\tnums[n-1] = -abs(nums[n-1])\\n\\tans = []\\n\\tfor i in range(len(nums)):\\n\\t\\tif nums[i] > 0 :\\n\\t\\t\\tans.append(i+1)\\n\\treturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223645,
                "title": "o-1-space-and-o-n-time-beats-97-22-cpp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\t\\t\\t\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            int temp = nums[i] ; \\n            temp = (temp > 0) ? temp : -temp ; \\n            \\n            temp-- ; \\n            \\n            if(nums[temp] > 0)\\n            {\\n                nums[temp] *= -1 ; \\n            }\\n        }\\n        \\n        vector<int> res ;\\n        \\n        \\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(nums[i] > 0 )\\n            {\\n                res.push_back(i+1) ;\\n            }\\n        }\\n        \\n        \\n        return res; \\n        \\n        \\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\t\\t\\t\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            int temp = nums[i] ; \\n            temp = (temp > 0) ? temp : -temp ; \\n            \\n            temp-- ; \\n            \\n            if(nums[temp] > 0)\\n            {\\n                nums[temp] *= -1 ; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 92996,
                "title": "python-simple-solution",
                "content": "Obviously, the solution is to take the difference set of two sets\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        l = set(sorted(nums))\\n        u = range(1,len(nums)+1)\\n        if len(l) > 0:\\n            return list(set(u) - l)\\n        else:\\n            return []\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        l = set(sorted(nums))\\n        u = range(1,len(nums)+1)\\n        if len(l) > 0:\\n            return list(set(u) - l)\\n        else:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93031,
                "title": "c-one-liner",
                "content": "```\\nusing System.Linq;\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        return Enumerable.Range(1,nums.Length).Except(nums.Distinct()).ToList();\\n    }\\n}\\n```\\nCan anyone tell me why my solution beats only 37.67% of C# submissions?\\n\\nHow does LINQ work internally?\\n\\nThanks in advance!",
                "solutionTags": [],
                "code": "```\\nusing System.Linq;\\npublic class Solution {\\n    public IList<int> FindDisappearedNumbers(int[] nums) {\\n        return Enumerable.Range(1,nums.Length).Except(nums.Distinct()).ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93008,
                "title": "java-using-counter-to-solve",
                "content": "```\\n List<Integer> result = new ArrayList<Integer>();\\n        int n = nums.length;\\n        int a[] = new int [n + 1];\\n        for(int i =0 ; i <= n; i++)\\n           a[i] = 0;\\n        for( int i =0; i < n;i++)\\n           a[nums[i]]++;\\n        \\n        for( int i=1; i <= n;i++){\\n            if(a[i]==0)\\n               result.add(i);\\n        }\\n        \\n        return result;",
                "solutionTags": [],
                "code": "```\\n List<Integer> result = new ArrayList<Integer>();\\n        int n = nums.length;\\n        int a[] = new int [n + 1];\\n        for(int i =0 ; i <= n; i++)\\n           a[i] = 0;\\n        for( int i =0; i < n;i++)\\n           a[nums[i]]++;\\n        \\n        for( int i=1; i <= n;i++){\\n            if(a[i]==0)\\n               result.add(i);\\n        }\\n        \\n        return result;",
                "codeTag": "Unknown"
            },
            {
                "id": 3960130,
                "title": "easy-hashset-solution-in-java",
                "content": "# Approach\\nFirst, we create a HashSet to store all the unique elements from our **nums** array. Once we\\'ve added the items to this set, we proceed to iterate through all the values in the range of **[1, nums.length]** to determine if they already exist in the set. If a value doesn\\'t exist, we include it in an ArrayList of missing values. Finally, we return this ArrayList containing the missing values.\\n\\n*Please drop an upvote and make me happy!* \\uD83D\\uDC4D\\uD83C\\uDFFF\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83C\\uDFFD\\uD83D\\uDC4D\\uD83C\\uDFFB\\n\\n# Complexity\\n- Time complexity is $$O(n)$$.\\n- Space complexity is also $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> uniqueNumbers = new HashSet<>();\\n        ArrayList<Integer> missingNumbers = new ArrayList<>();\\n\\n        for (int num : nums)\\n        {\\n            uniqueNumbers.add(num);\\n        }\\n\\n        for (int i = 1; i <= nums.length; i++)\\n        {\\n            if (!uniqueNumbers.contains(i))\\n            {\\n                missingNumbers.add(i);\\n            }\\n        }\\n\\n        return missingNumbers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution\\n{\\n    public List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> uniqueNumbers = new HashSet<>();\\n        ArrayList<Integer> missingNumbers = new ArrayList<>();\\n\\n        for (int num : nums)\\n        {\\n            uniqueNumbers.add(num);\\n        }\\n\\n        for (int i = 1; i <= nums.length; i++)\\n        {\\n            if (!uniqueNumbers.contains(i))\\n            {\\n                missingNumbers.add(i);\\n            }\\n        }\\n\\n        return missingNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414251,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{}; \\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        } \\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{}; \\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        } \\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414238,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{};\\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        }\\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>freq(n+1, 0); \\n\\t\\tvector<int>res{};\\n        for(auto num: nums)\\n        {\\n            freq[num]++;\\n        }\\n        for(int i{1}; i<=n; ++i)\\n        {\\n            if(!freq[i])\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788910,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++){\\n            freq[nums[i]]++;\\n        } \\n       for(int i=1;i<=n;i++){\\n           if(freq[i]==0) ans.push_back(i);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        vector<int> freq(n+1,0);\\n        for(int i=0;i<n;i++){\\n            freq[nums[i]]++;\\n        } \\n       for(int i=1;i<=n;i++){\\n           if(freq[i]==0) ans.push_back(i);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701204,
                "title": "python-simple-solution-in-o-n-without-using-extra-space",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        a,n=[],len(nums)\\n        for i in nums:\\n            j=abs(i)-1\\n            nums[j]=-1*abs(nums[j])\\n        for i in range(n):\\n            if nums[i]>0:\\n                a.append(i+1)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        a,n=[],len(nums)\\n        for i in nums:\\n            j=abs(i)-1\\n            nums[j]=-1*abs(nums[j])\\n        for i in range(n):\\n            if nums[i]>0:\\n                a.append(i+1)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039287,
                "title": "just-cyclic-sort-o-n-very-simple-code",
                "content": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        while(i<nums.length)\\n        {\\n            int index = nums[i]-1;\\n            if(nums[i]!=nums[index]){\\n                int temp = nums[i];\\n                nums[i]=nums[index];\\n                nums[index]=temp;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ls = new ArrayList<>();\\n        for(int j = 0 ; j<nums.length ; j++){\\n            if(nums[j]!=j+1){\\n                ls.add(j+1);\\n            }\\n        }\\n        return ls;\\n    }\\n\\t\\n    }\\n\\t\\n# \\tHope you  find it useful. don\\'t forget to press the upvote",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int i = 0;\\n        while(i<nums.length)\\n        {\\n            int index = nums[i]-1;\\n            if(nums[i]!=nums[index]){\\n                int temp = nums[i];\\n                nums[i]=nums[index];\\n                nums[index]=temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1659047,
                "title": "python-1-line-solution-with-set",
                "content": "\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\t\\t\\treturn list(set(range(1, len(nums)+1))-set(nums))\\n\\n\"\"\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n\\t\\t\\treturn list(set(range(1, len(nums)+1))-set(nums))\\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 1584989,
                "title": "c-simple-approach-maps-and-swap-sort",
                "content": "```\\nMethod 1 - Using maps\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int x=1;\\n        unordered_map<int,int>mp;\\n        for(auto s:nums){\\n            mp[s]++;\\n        }\\n        for(auto s:nums){\\n            if(mp[x]==0) ans.push_back(x);\\n            x++;\\n        }\\n         return ans;\\n    }\\n};\\n\\n\\nMethod 2 - using swap sort \\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i] != nums[nums[i]-1])  {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }\\n            else\\n                i++;\\n            }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] != i+1){\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nIf you like it then please upvote it.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nMethod 1 - Using maps\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int x=1;\\n        unordered_map<int,int>mp;\\n        for(auto s:nums){\\n            mp[s]++;\\n        }\\n        for(auto s:nums){\\n            if(mp[x]==0) ans.push_back(x);\\n            x++;\\n        }\\n         return ans;\\n    }\\n};\\n\\n\\nMethod 2 - using swap sort \\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int>ans;\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i] != nums[nums[i]-1])  {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }\\n            else\\n                i++;\\n            }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] != i+1){\\n                ans.push_back(i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nIf you like it then please upvote it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072801,
                "title": "javascript-solution",
                "content": "A solution using Javascript with O(n) time complexity and O(1) space complexity:\\n```\\nvar findDisappearedNumbers = function(nums) {\\n    let result = []\\n    \\n    for(let i=0; i<nums.length; i++) {\\n        let index = Math.abs(nums[i]) -1\\n        if(nums[index] > 0) {\\n            nums[index] *= -1\\n        }\\n    }\\n    \\n    for(let i=1; i<=nums.length; i++) {\\n        if(nums[i-1] > 0) {\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar findDisappearedNumbers = function(nums) {\\n    let result = []\\n    \\n    for(let i=0; i<nums.length; i++) {\\n        let index = Math.abs(nums[i]) -1\\n        if(nums[index] > 0) {\\n            nums[index] *= -1\\n        }\\n    }\\n    \\n    for(let i=1; i<=nums.length; i++) {\\n        if(nums[i-1] > 0) {\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1043291,
                "title": "different-o-1-space-solution",
                "content": "We swap elements whose values aren\\'t equal to their indices until we reach the end of the array, then return elements whose indices and values aren\\'t equal.\\n```python\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l = 0\\n        while l < len(nums):\\n            pos = nums[l]-1\\n            if nums[l] == nums[pos]:\\n                l += 1\\n            else:\\n                nums[l], nums[pos] = nums[pos], nums[l]\\n        return [i+1 for i,e in enumerate(nums) if i+1 != e]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l = 0\\n        while l < len(nums):\\n            pos = nums[l]-1\\n            if nums[l] == nums[pos]:\\n                l += 1\\n            else:\\n                nums[l], nums[pos] = nums[pos], nums[l]\\n        return [i+1 for i,e in enumerate(nums) if i+1 != e]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1014522,
                "title": "using-cyclic-sort-c",
                "content": "If we are at `i` , we should try to place current element in correct position in array.\\nIf its already at correct position, we should increment i.\\n##### Time complexity \\nThe time complexity of the above algorithm is O(n).\\n\\n##### Space complexity\\nIgnoring the space required for the output array, the algorithm runs in constant space O(1).\\n\\n```\\n    void swap(vector<int> &arr, int a, int b) {\\n\\tint temp = arr[a];\\n\\tarr[a] = arr[b];\\n\\tarr[b] = temp;\\n}\\nvector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0;\\n\\twhile (i < n) {\\n\\t\\tif (nums[i] == i + 1) i++; //already correct position so increment i\\n\\t\\telse {\\n\\t\\t\\tint correctPosn = nums[i] - 1;\\n\\t\\t\\tif (nums[correctPosn] == nums[i]) i++; //already present at that position\\n\\t\\t\\telse swap(nums, i, correctPosn); //swap\\n\\t\\t}\\n\\t}\\n\\tvector<int> res;\\n\\tfor (int i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1) res.push_back(i + 1);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    void swap(vector<int> &arr, int a, int b) {\\n\\tint temp = arr[a];\\n\\tarr[a] = arr[b];\\n\\tarr[b] = temp;\\n}\\nvector<int> findDisappearedNumbers(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0;\\n\\twhile (i < n) {\\n\\t\\tif (nums[i] == i + 1) i++; //already correct position so increment i\\n\\t\\telse {\\n\\t\\t\\tint correctPosn = nums[i] - 1;\\n\\t\\t\\tif (nums[correctPosn] == nums[i]) i++; //already present at that position\\n\\t\\t\\telse swap(nums, i, correctPosn); //swap\\n\\t\\t}\\n\\t}\\n\\tvector<int> res;\\n\\tfor (int i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1) res.push_back(i + 1);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 839002,
                "title": "two-solutions-in-python-hash-map-and-set-operation",
                "content": "## Solution 1: Hash Map\\n### Python 3\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        hash_table = {}\\n        result = []\\n        \\n        for num in nums:\\n          hash_table[num] = 1\\n        \\n        for num in range(1, len(nums) + 1):\\n          if num not in hash_table:\\n            result.append(num)\\n        \\n        return result\\n```\\n### Complexity Analysis \\n- Time comlexity: O(N)\\n- Space complexity: O(N)\\n\\n## Solution 2: Set Operation\\n### Python 3\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        nums_set = set(nums)\\n        ideal_set = set(range(1, len(nums) + 1))\\n        result = list(ideal_set - nums_set)\\n        \\n        return result\\n```\\n### Complexity Analysis \\n- Time comlexity: O(N)\\n- Space complexity: O(N)\\n",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \\n        hash_table = {}\\n        result = []\\n        \\n        for num in nums:\\n          hash_table[num] = 1\\n        \\n        for num in range(1, len(nums) + 1):\\n          if num not in hash_table:\\n            result.append(num)\\n        \\n        return result\\n```\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        nums_set = set(nums)\\n        ideal_set = set(range(1, len(nums) + 1))\\n        result = list(ideal_set - nums_set)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789861,
                "title": "c-optimal-solution-85-99",
                "content": "First, the naive solution, using an extra collection, as a hashset:\\n\\n```\\n    var res=new HashSet<int>(Enumerable.Range(1,nums.Length));\\n    foreach (var item in nums)\\n        res.Remove(item);\\n    return res.ToArray()\\n```\\n\\nExplanation:  You create a hashset of numbers 1-n, and then remove numbers already at the original array.  Using hashset instead of list makes runtime faster, as hashsets are the fastest dynamic collection.\\n\\nHowever, the description asked to use the least memory possible. To do so, we must use the original array only, both for processing and as result array. Code gets way uglier, tho. The trick here is iterate the array backwards, and swapping each number to its correct position, which is \"nums[i+1]\". Then we scan the array again, and check which number is not present (meaning it was a disappeared number).\\n\\n```\\n    for (int i=nums.Length-1;i>=0;i--)  \\n        {\\n        while (nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]) \\n            (nums[i],nums[nums[i]-1])=(nums[nums[i]-1],nums[i]); \\n        } \\n    int idx=0; \\n    for (int i=0;i<nums.Length;i++) \\n        if (nums[i]!=i+1) nums[idx++]=i+1; \\n    return nums[0..idx]; \\n```\\nExplanation:\\n// Iterates array backwards.\\n// check if number is in correct position\\n// swap number with its correct position, with \"tuple swap\"\\n// now we will move all wrong (missing) numbers to the beginning of the array. \\n// iterate array again \\n// if number is misplaced (disappeared), move it to beginning of the array, increment index\\n// return wrong numbers, using C# 8.0 index range (\"split\") function\\n\\nAbove solution will only use 1 int of extra memory, which is the variable idx. Every operation is done at the original array.",
                "solutionTags": [],
                "code": "```\\n    var res=new HashSet<int>(Enumerable.Range(1,nums.Length));\\n    foreach (var item in nums)\\n        res.Remove(item);\\n    return res.ToArray()\\n```\n```\\n    for (int i=nums.Length-1;i>=0;i--)  \\n        {\\n        while (nums[i]!=i+1 && nums[nums[i]-1]!=nums[i]) \\n            (nums[i],nums[nums[i]-1])=(nums[nums[i]-1],nums[i]); \\n        } \\n    int idx=0; \\n    for (int i=0;i<nums.Length;i++) \\n        if (nums[i]!=i+1) nums[idx++]=i+1; \\n    return nums[0..idx]; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768769,
                "title": "easy-to-understand-python-solution-3-liner-beats-95",
                "content": "```\\n\\t\\tn = len(nums)\\n\\t\\ta = [i + 1 for i in range(n)]\\n        return list(set(a) - set(nums))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tn = len(nums)\\n\\t\\ta = [i + 1 for i in range(n)]\\n        return list(set(a) - set(nums))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 661425,
                "title": "rust-8-ms-2-7-mb-three-lines-functional-programming-iterators-essay-explanation",
                "content": "```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter().for_each(|num| seq[(num-1) as usize] += 1);\\n        seq.into_iter().enumerate().filter(|&(x, y)| y == 0).map(|(x, y)| (x+1) as i32).collect::<Vec<i32>>()\\n    }\\n}\\n```\\nIf you test this code, you\\'ll see that it brings 8 ms and 2.7 MB, which are 100% better than all Rust submissions (as scored).  But, if you format the code properly:\\n\\n```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter()\\n            .for_each(|num|\\n\\t\\t\\t\\tseq[(num - 1) as usize] += 1\\n\\t\\t\\t);\\n        seq.into_iter()\\n            .enumerate()\\n            .filter(|&(index, count)| count == 0)\\n            .map(|(index, _)| (index + 1) as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```\\n... this code will bring you 12 ms and 2.5 MB.\\n\\nAnyway, the idea is to keep an array that works as a sort of HashMap for number sequences.  The index of the array is a number that appears in the sequence; the value at the index is the count of how many times it appears.\\nSince the array\\'s numbers are in the range of its size, we create an array (integer hashmap) that holds the indexes of the numbers we are looking for.\\n\\nWe pass through the array with `for_each(|num| seq[num...] += 1)` to keep a count of nums.  Notice that since arrays are 0-indexed but the sequence is annoyingly 1-indexed, we must subtract 1, and that Rust must use usize to index, so we must cast.  You can use a simple for loop instead of `for_each()`, and indeed, the Rust docs say that it is more idiomatic; but we want to save lines and look cool with a functional style, so we do this.\\n\\nSince we use `into_iter()` instead of `iter()`, we are moving values into iterators, and thus destroying what we don\\'t need; we can also do this because the function passes in arguments by move (rather un-Rust-like).  I don\\'t know if it reduces memory usage at all, but it at least minimizes it - on principle, don\\'t pay for what you don\\'t use.\\n\\n(Note that in general, moving and modifying a vector [temporarily allocates new space](https://users.rust-lang.org/t/into-iter-from-vec-vec-memory-consumption/35778/4) for it.)\\n\\nWe take the hashmap/array and `enumerate()` it to be able to see at what index each value lies.  We `filter()` to find all elements where the count value is 0; then `map()` to acquire the index part of the tuple (destructure the tuple).  We then `collect()` into a vector of i32 and return the vector expression-wise.\\n\\n-==-\\n\\nIn Rust, iterators are lazy (and their implementation is abstracted to the source code), so it becomes challenging to describe the complexity of the program.  At the very least, the time complexity of the solution is O(n).  Each iterator encapsulates a single pass over the collection, so we might conjecture that the complexity is O(2n), with one complete pass over the array `nums` of length `n`, and one worst-case pass over `seq` over `n-1` elements.\\n\\nThe memory usage is also strange, since it\\'s unclear how memory use is calculated.  Does leetcode consider the peak of memory usage in the lifetime of the solution?  Or does it consider the memory still allocated by the very end of the scope?  Or does it average out memory usage over time, or something weird.  No one knows.\\n\\nAt the least, we know that we can allocate one extra array (as described in the problem).  So the space complexity of this problem varies alongside our axioms and knowledge of iterator allocation (which you can find yourself by googling, or looking at the source code, both of which I have done but not accepted):\\n\\nIf we do not count the result vector we allocated, we have O(1); \\nIf we count the result vector, we have O(n); \\nIf we discover that moving a vector into an iterator and collecting again into a vector does consume more memory, we have O(2n), which degrades to O(n);\\nIf we discover that discovery, but not count the result vector, we might claim that the extra allocation caused by `iterator -> collect`  is another vector, thus giving us O(n).\\n\\nOverall, the solution is probably O(n) | O(n), which is embarassing since there are in-place solutions out there.  But  none of them are as flashy or as elegant as just calling a few functions.  Realistically, you\\'d want to get it done quickly, simply (idiomatically/structurally), and readably; well, this is good enough, I suppose.  Plenty of linear algebra libraries use cache-ignorant matrix operations... welp!",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter().for_each(|num| seq[(num-1) as usize] += 1);\\n        seq.into_iter().enumerate().filter(|&(x, y)| y == 0).map(|(x, y)| (x+1) as i32).collect::<Vec<i32>>()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn find_disappeared_numbers(nums: Vec<i32>) -> Vec<i32> {\\n        let mut seq: Vec<i32> = [0].repeat(nums.len());\\n        nums.into_iter()\\n            .for_each(|num|\\n\\t\\t\\t\\tseq[(num - 1) as usize] += 1\\n\\t\\t\\t);\\n        seq.into_iter()\\n            .enumerate()\\n            .filter(|&(index, count)| count == 0)\\n            .map(|(index, _)| (index + 1) as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540609,
                "title": "python-one-liner-better-than-94",
                "content": "``` \\n\\treturn list(set(range(1,len(nums)+1))-set(nums))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\n\\treturn list(set(range(1,len(nums)+1))-set(nums))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500498,
                "title": "easy-java-solution-no-extra-space-11-lines",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {        \\n\\t\\tArrays.sort(nums);\\n        int q=nums.length;\\n        List<Integer> lista = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(0>Arrays.binarySearch(nums, q--))\\n                lista.add(q+1);\\n        }\\n        return lista;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {        \\n\\t\\tArrays.sort(nums);\\n        int q=nums.length;\\n        List<Integer> lista = new ArrayList<>();\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(0>Arrays.binarySearch(nums, q--))\\n                lista.add(q+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 413215,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j= Math.abs(nums[i]) - 1;\\n            nums[j]=-1*Math.abs(nums[j]); //make negative\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n      for(int i=0;i<nums.length;i++)\\n      {\\n          if(nums[i]>0){\\n              res.add(i+1);\\n          }\\n      }\\n        return res;\\n    }\\n}\\n```\\n\\n\\nmaking numbers index negative if that number is present(Mark them visited/present)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j= Math.abs(nums[i]) - 1;\\n            nums[j]=-1*Math.abs(nums[j]); //make negative\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n      for(int i=0;i<nums.length;i++)\\n      {\\n          if(nums[i]>0){\\n              res.add(i+1);\\n          }\\n      }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233405,
                "title": "python-6-line-solution-o-n-time-o-1-memory",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        l, ans, length = 0, [], len(nums)\\n        while l < length:\\n            while nums[nums[l] - 1] != nums[l]:\\n                nums[nums[l] - 1], nums[l] = nums[l], nums[nums[l] - 1]\\n            l += 1\\n        return [i + 1 for i in range(length) if nums[i] != i + 1]\\n```\\n\\nThe main idea of my solution is to try to put each number to the cell with the index = number. For example, having array 4, 1, 2, 7, 3, 5, 6, firstly we will put the first number 4 to the fourth cell, swapping it with 7: 7, 1, 2, 4, 3, 5, 6. Then we do the same thing with 7. When should we stop? We will stop when we\\'ll try to put number to the cell, which already contains the same number. For example, 4, 1, 2, 4, 5, 5: we wouldn\\'t swap 4 with 4 because it will lead to the cycle. In this case we should consider next number (here it\\'s 1) and repeat same things with it. So, we will store a pointer to the current number we are working with (it\\'s l in my solution) and try to change it with the cell which index = number while it\\'s possible and then increment out pointer. At the end we\\'ll have an array in which if the number isn\\'t equal to the index of the cell in which it\\'s situated it will mean that number with the value = this index is missed and we have to add it to the answer. \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        l, ans, length = 0, [], len(nums)\\n        while l < length:\\n            while nums[nums[l] - 1] != nums[l]:\\n                nums[nums[l] - 1], nums[l] = nums[l], nums[nums[l] - 1]\\n            l += 1\\n        return [i + 1 for i in range(length) if nums[i] != i + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161861,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n==0 :return []\\n        for i in range(n):\\n            num = nums[i]\\n            while num != -1:\\n                tmp = nums[num-1]\\n                nums[num-1] = -1\\n                num = tmp\\n        return [i+1 for i in range(n) if nums[i]!=-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n==0 :return []\\n        for i in range(n):\\n            num = nums[i]\\n            while num != -1:\\n                tmp = nums[num-1]\\n                nums[num-1] = -1\\n                num = tmp\\n        return [i+1 for i in range(n) if nums[i]!=-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140737,
                "title": "python-o-n-time-no-extra-space-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for n in nums:\\n            nums[abs(n) - 1] = - abs(nums[abs(n) - 1])\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                output.append(i+1)\\n        return output",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        for n in nums:\\n            nums[abs(n) - 1] = - abs(nums[abs(n) - 1])\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] > 0:\\n                output.append(i+1)\\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 3684183,
                "title": "swap-sort-concept-time-complexity-o-n-space-complexity-o-1",
                "content": "**Swap Sort** can be used in various problems where we have to find the **missing or duplicates values** in array and the array must contain **values in range [1..n]**.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423491,
                "title": "set-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have number 1 to n and find missing numbers in between\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaking a set and after that running a loop 1 to n and checking value have inside of set or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n   let n = nums.length;\\n    let ans = new Set(nums);\\n    let array = [];\\n    for (let i = 1; i <= n; i++) {\\n        if (!ans.has(i)) {\\n           array.push(i);\\n        }\\n    }\\n    return array;\\n}\\n    \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n   let n = nums.length;\\n    let ans = new Set(nums);\\n    let array = [];\\n    for (let i = 1; i <= n; i++) {\\n        if (!ans.has(i)) {\\n           array.push(i);\\n        }\\n    }\\n    return array;\\n}\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3384080,
                "title": "easy-js-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let i=0; i<nums.length; i++) {\\n        const curr = Math.abs(nums[i]);\\n        if(nums[curr-1] >0) {\\n            nums[curr-1] *=-1;\\n        }\\n    }\\n\\n    let idx = 0;\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i] > 0) {\\n            nums[idx] = i+1;\\n            idx++;\\n        }\\n    }\\n    return nums.slice(0,idx);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let i=0; i<nums.length; i++) {\\n        const curr = Math.abs(nums[i]);\\n        if(nums[curr-1] >0) {\\n            nums[curr-1] *=-1;\\n        }\\n    }\\n\\n    let idx = 0;\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i] > 0) {\\n            nums[idx] = i+1;\\n            idx++;\\n        }\\n    }\\n    return nums.slice(0,idx);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3226683,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const uniqueValues = new Set(nums);\\n  const result = [];\\n\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!uniqueValues.has(i)) {\\n      result.push(i);\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function (nums) {\\n  const uniqueValues = new Set(nums);\\n  const result = [];\\n\\n  for (let i = 1; i <= nums.length; i++) {\\n    if (!uniqueValues.has(i)) {\\n      result.push(i);\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095191,
                "title": "java-o-n-time-o-1-space-complete-dry-run-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {      \\n        // sorting when the numbers are from 1 to n \\n\\t\\t// we are checking i+1 as range is from 1 to n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] != i+1 && nums[i] != nums[nums[i] - 1])\\n            {\\n                //swap\\n                int temp =  nums[i];\\n                nums[i] = nums[temp-1];\\n                nums[temp-1] = temp;\\n                // to check the current ith pos\\'n again so that the correct value is here\\n                i--;\\n            }           \\n        }\\n        //the values which are not in their correct posn should be checked here and inserted into the list \\n        List<Integer> list = new ArrayList<>();\\n        for(int i =0;i<nums.length; i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                list.add(i+1);\\n            }\\n        }       \\n        return list; \\n    }\\n}\\n// the following dry run can explain the sorting happening \\n/*\\n[4,3,2,7,8,2,3,1]\\n[7,3,2,4,8,2,3,1]\\n[3,3,2,4,8,2,7,1]\\n[2,3,3,4,8,2,7,1]\\n[3,2,3,4,8,2,7,1]\\n[3,2,3,4,1,2,7,8]\\n[1,2,3,4,3,2,7,8]\\n*/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {      \\n        // sorting when the numbers are from 1 to n \\n\\t\\t// we are checking i+1 as range is from 1 to n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i] != i+1 && nums[i] != nums[nums[i] - 1])\\n            {\\n                //swap\\n                int temp =  nums[i];\\n                nums[i] = nums[temp-1];\\n                nums[temp-1] = temp;\\n                // to check the current ith pos\\'n again so that the correct value is here\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3077181,
                "title": "ts-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findDisappearedNumbers(nums: number[]): number[] {\\n   let set = new Set(nums) , result = []\\n    for (let i = 1; i < nums.length+1; i++) { \\n        if (!set.has(i)){\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findDisappearedNumbers(nums: number[]): number[] {\\n   let set = new Set(nums) , result = []\\n    for (let i = 1; i < nums.length+1; i++) { \\n        if (!set.has(i)){\\n            result.push(i)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3058614,
                "title": "python-set-concept",
                "content": "# Intuition\\ncreate two sets a and b , a with numbers ranged from 1 to n and b with nums, just return the (a-b) with typecasting to list\\n\\n# Approach\\nsubtraction of sets\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        a = set(range(1,len(nums)+1))\\n        b = set(nums)\\n        return list(a-b)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDisappearedNumbers(self, nums):\\n        a = set(range(1,len(nums)+1))\\n        b = set(nums)\\n        return list(a-b)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837907,
                "title": "easy-and-fast-sol-100-beats-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0;i<nums.length;++i){\\n            int n=Math.abs(nums[i]);\\n            if (nums[n-1]>0)nums[n-1]=-1*nums[n-1];\\n        }\\n        for (int i=0;i<nums.length;++i){\\n            if(nums[i]>0) list.add(i+1);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0;i<nums.length;++i){\\n            int n=Math.abs(nums[i]);\\n            if (nums[n-1]>0)nums[n-1]=-1*nums[n-1];\\n        }\\n        for (int i=0;i<nums.length;++i){\\n            if(nums[i]>0) list.add(i+1);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833240,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(auto x: nums) mp[x]++;\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++) {\\n            if(!mp[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(auto x: nums) mp[x]++;\\n        vector<int> ans;\\n        for(int i=1; i<=n; i++) {\\n            if(!mp[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718075,
                "title": "python-easy-code-o-n-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        res = []\\n        for x in nums:\\n            if nums[abs(x)-1] > 0:\\n                nums[abs(x)-1]*=-1\\n        for i, x in enumerate(nums):\\n            if x> 0:\\n                res.append(i+1)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums):\\n        res = []\\n        for x in nums:\\n            if nums[abs(x)-1] > 0:\\n                nums[abs(x)-1]*=-1\\n        for i, x in enumerate(nums):\\n            if x> 0:\\n                res.append(i+1)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2687862,
                "title": "python-simple-solution-in-6-lines-faster-90-32",
                "content": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        arr=set(nums)\\n        a,n=[],len(nums)\\n        for i in range(1,n+1):\\n            if i not in arr:\\n                a.append(i)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        arr=set(nums)\\n        a,n=[],len(nums)\\n        for i in range(1,n+1):\\n            if i not in arr:\\n                a.append(i)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675430,
                "title": "python-with-explanation",
                "content": "```\\n\"\"\"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\"\"\"\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            index=abs(i)-1\\n            nums[index]=-1 * abs(nums[index])\\n        res=[]\\n        for i,n in enumerate(nums):\\n            if n>0:\\n                res.append(i+1)\\n        return res\\n    \\n# EXPLANATION\\n    # First we will iterate through the array and change the element at indexes of present element to negative\\n    # (We will use abs because the value might be negative only once we have changed but we go to that element second time also\\n    # We will map element to their corresponding index here, like if we find 4, we will turn elelment at 3rd index to be negative. If we find 2, we will change element at 1st index to be negative. By doing so, we will change all the indexes corresponding to elements as negative and only absend element\\'s index will be positive)\\n    # We will run another loop and if number in our array is positive, then we will add the element corresponding to its index in the result array\\n    #  ( for example, if element at index 2 is positive, we will add 3 in our result array)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\"\"\"\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        for i in nums:\\n            index=abs(i)-1\\n            nums[index]=-1 * abs(nums[index])\\n        res=[]\\n        for i,n in enumerate(nums):\\n            if n>0:\\n                res.append(i+1)\\n        return res\\n    \\n# EXPLANATION\\n    # First we will iterate through the array and change the element at indexes of present element to negative\\n    # (We will use abs because the value might be negative only once we have changed but we go to that element second time also\\n    # We will map element to their corresponding index here, like if we find 4, we will turn elelment at 3rd index to be negative. If we find 2, we will change element at 1st index to be negative. By doing so, we will change all the indexes corresponding to elements as negative and only absend element\\'s index will be positive)\\n    # We will run another loop and if number in our array is positive, then we will add the element corresponding to its index in the result array\\n    #  ( for example, if element at index 2 is positive, we will add 3 in our result array)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663914,
                "title": "java-solution-using-hashset",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\t\\t\\tList<Integer>list=new ArrayList<>();\\n\\t\\t\\tHashSet<Integer>li=new HashSet<>();\\n\\t\\t\\tfor(int i=1;i<=nums.length;i++)\\n\\t\\t\\t\\tli.add(i);\\n\\t\\t\\tfor(int j=0;j<nums.length;j++)\\n\\t\\t\\t\\tif(li.contains(nums[j]))\\n\\t\\t\\t\\t\\tli.remove(nums[j]);\\n\\t\\t\\tlist.addAll(li);\\n\\t\\t\\treturn list;\\n\\n\\t\\t  }\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n\\t\\t\\tList<Integer>list=new ArrayList<>();\\n\\t\\t\\tHashSet<Integer>li=new HashSet<>();\\n\\t\\t\\tfor(int i=1;i<=nums.length;i++)\\n\\t\\t\\t\\tli.add(i);\\n\\t\\t\\tfor(int j=0;j<nums.length;j++)\\n\\t\\t\\t\\tif(li.contains(nums[j]))\\n\\t\\t\\t\\t\\tli.remove(nums[j]);\\n\\t\\t\\tlist.addAll(li);\\n\\t\\t\\treturn list;\\n\\n\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 2405996,
                "title": "time-o-n-space-o-1-no-extra-space-used-faster-than-97-99-memory-less-than-98-21",
                "content": "1.  Iterating the given array, taking each element(index=abs(element)-1) and changing the sign of that value to neagative at this index for the 1 st time.\\n2.  Iterating again through the array to find the positive numbers. That means the index+1 of that positive number is not present in array.\\n\\n```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i : nums){\\n            int index = Math.abs(i)-1;\\n            if(nums[index]>0){\\n                nums[index]=-nums[index];\\n            }\\n        }\\n        for(int i=0; i<nums.length ; i++){\\n            if(nums[i]>=0){\\n                l.add(i+1);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer>();\\n        for(int i : nums){\\n            int index = Math.abs(i)-1;\\n            if(nums[index]>0){\\n                nums[index]=-nums[index];\\n            }\\n        }\\n        for(int i=0; i<nums.length ; i++){\\n            if(nums[i]>=0){\\n                l.add(i+1);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285662,
                "title": "faster-than-90-c-in-place-solution-tc-o-n",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int t = abs(nums[i]);\\n            if(nums[t-1] > 0) nums[t-1] *= (-1);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]>0) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8c19e752-431b-4322-8ec5-4d843a61e458_1657883756.0280447.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            int t = abs(nums[i]);\\n            if(nums[t-1] > 0) nums[t-1] *= (-1);\\n        }\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]>0) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255749,
                "title": "python-simple-solution-using-logic-with-detailed-explanation",
                "content": "\"\"\"\\nRuntime Complexity:\\nO(n) - because we run a for loop and take the absolute of indices and subract 1 from each element. Because array of length 8 contains\\n8 elements and if you subract 8 with 1, we get 7 which is the last index in our array since it starts from 0 index. We traverse and subract 1 with\\nevery element and go to the particular index and set it to negative. We do this for \\'n\\' elements and we finally run a for loop\\nto check the positive numbers and append it to result array. We then finally return the result.\\nSpace Complexity: O(1) - because the array length is fixed and missing numbers are always less than \\'n\\' so we append only few elements to it. Worst case can be O(N) if all elements are added to result array.\\n\"\"\"\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if len(nums)==0:\\n            return []\\n        n = len(nums)\\n        result = []\\n        for i in range(0,n):\\n            index = abs(nums[i])-1\\n            if nums[index]>0:\\n                nums[index] = nums[index]*-1\\n            else:\\n                continue\\n        print(nums)\\n        for i in range(0,n):\\n            if nums[i]>0:\\n                result.append(i+1)\\n            else:\\n                nums[i] = nums[i] *-1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        if len(nums)==0:\\n            return []\\n        n = len(nums)\\n        result = []\\n        for i in range(0,n):\\n            index = abs(nums[i])-1\\n            if nums[index]>0:\\n                nums[index] = nums[index]*-1\\n            else:\\n                continue\\n        print(nums)\\n        for i in range(0,n):\\n            if nums[i]>0:\\n                result.append(i+1)\\n            else:\\n                nums[i] = nums[i] *-1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153854,
                "title": "easy-c-sol-naive-efficient-approach-time-o-n-aux-space-o-1",
                "content": "```\\n// Naive Solution :: Time : O(N) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        unordered_set<int> s;\\n        vector<int> res;\\n        \\n        int n = nums.size();\\n        \\n        for(int i=1;i<=n;i++){\\n            s.insert(i);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(s.find(nums[i]) != s.end()){\\n                s.erase(nums[i]);\\n            }\\n        }\\n        \\n        for(auto x: s){\\n            res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> res;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[abs(nums[i])-1] > 0){\\n                nums[abs(nums[i])-1]  *= (-1);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i] > 0){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        \\n        unordered_set<int> s;\\n        vector<int> res;\\n        \\n        int n = nums.size();\\n        \\n        for(int i=1;i<=n;i++){\\n            s.insert(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2037235,
                "title": "java-solution-using-hashmap-and-hashset-o-n-time-complexity",
                "content": "**Code using HashMap**\\n```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        List<Integer> arr = new ArrayList();\\n        for(int i=0; i<nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(map.get(i) == null) arr.add(i);\\n        }\\n        \\n        return arr;\\n    }\\n```\\n\\n\\n**Code using HashSet**\\n```\\n\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n         HashSet<Integer> set = new HashSet();\\n         List<Integer> arr = new ArrayList();\\n         for(int i=0; i<nums.length; i++) set.add(nums[i]);\\n         for(int i=1; i<=nums.length; i++){\\n             if(!set.contains(i)) arr.add(i);\\n         }\\n        return arr;\\n    }\\n```\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> findDisappearedNumbers(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        List<Integer> arr = new ArrayList();\\n        for(int i=0; i<nums.length; i++){\\n            map.put(nums[i], i);\\n        }\\n        \\n        for(int i=1; i<=nums.length; i++){\\n            if(map.get(i) == null) arr.add(i);\\n        }\\n        \\n        return arr;\\n    }\\n```\n```\\n\\tpublic List<Integer> findDisappearedNumbers(int[] nums) {\\n         HashSet<Integer> set = new HashSet();\\n         List<Integer> arr = new ArrayList();\\n         for(int i=0; i<nums.length; i++) set.add(nums[i]);\\n         for(int i=1; i<=nums.length; i++){\\n             if(!set.contains(i)) arr.add(i);\\n         }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1983319,
                "title": "c-optimized-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr=abs(nums[i]);          //taking absolute value of the element at index i\\n            nums[curr-1]=-abs(nums[curr-1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0)\\n                ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int curr=abs(nums[i]);          //taking absolute value of the element at index i\\n            nums[curr-1]=-abs(nums[curr-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1952520,
                "title": "java-2-methods-simple",
                "content": "\\n//------------------using Hashset--------------------------------------------------\\n    //--------------time comp: O(n)------------------------------------------\\n    //-------------space comp: O(n)------------------------------------------------------\\n```\\n    public static List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> set=new HashSet<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(!set.contains(i))\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n\\t```\\n\\t//--------------------using Cyclic sort----------------------------------------\\n    //-------------time comp: O(n)------------------------------------\\n    //-------------space comp: O(1)---------------------------------------\\n\\t\\n\\t```\\n\\tpublic static List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            int correctIndex=nums[i]-1;\\n            if(nums[i]!=nums[correctIndex])\\n                swap(nums,i,correctIndex);\\n            else\\n                i++;\\n        }\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=j+1)\\n                list.add(j+1);\\n        }\\n        return list;\\n        \\n    }\\n     public static void swap(int arr[],int j,int m)\\n    {\\n        int temp=arr[j];\\n        arr[j]=arr[m];\\n        arr[m]=temp;\\n    }\\n\\n}\\n```\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n    public static List<Integer> findDisappearedNumbers(int[] nums)\\n    {\\n        HashSet<Integer> set=new HashSet<>();\\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n        for(int i=1;i<=nums.length;i++)\\n        {\\n            if(!set.contains(i))\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n\\t```\n```\\n\\tpublic static List<Integer> findDisappearedNumbers(int[] nums) {\\n        \\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            int correctIndex=nums[i]-1;\\n            if(nums[i]!=nums[correctIndex])\\n                swap(nums,i,correctIndex);\\n            else\\n                i++;\\n        }\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=j+1)\\n                list.add(j+1);\\n        }\\n        return list;\\n        \\n    }\\n     public static void swap(int arr[],int j,int m)\\n    {\\n        int temp=arr[j];\\n        arr[j]=arr[m];\\n        arr[m]=temp;\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894122,
                "title": "python-faster-than-95-o-n",
                "content": "# Please upvote if it helps\\n```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]: \\n        i = 1\\n        res = []\\n        j = len(nums)\\n        nums = set(nums)\\n        \\n        while i<=j:\\n            \\n            if not i in nums:\\n                res.append(i) \\n            \\n            i +=1\\n        \\n        return res\\n        \\n```\\n\\n![image](https://assets.leetcode.com/users/images/0040f25e-3c7e-40a1-8852-001f9b8fd833_1648656721.145055.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]: \\n        i = 1\\n        res = []\\n        j = len(nums)\\n        nums = set(nums)\\n        \\n        while i<=j:\\n            \\n            if not i in nums:\\n                res.append(i) \\n            \\n            i +=1\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758963,
                "title": "o-n-time-and-o-n-space-solution",
                "content": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n   \\n        nums_1 = set(nums)\\n        res = []\\n        for i in range(1,len(nums)+1):\\n            if i not in nums_1:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n   \\n        nums_1 = set(nums)\\n        res = []\\n        for i in range(1,len(nums)+1):\\n            if i not in nums_1:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1746321,
                "title": "simple-cyclic-sort-problem",
                "content": "\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        brute force is to implement cyclic sort\\n        we will start with examples\\n        [4,3,2,7,8,2,3,1]\\n        \\n        n = 8 means array should contain all the values from 1 to 8\\n        means each no is stored on n - 1 idx\\n        [1,2,3,4, , , 7,8]\\n        \\n        our first pointer will graze over array\\n            then we will take val at first ptr\\n            if nums[first ptr] != nums[val at first ptr - 1]\\n                then swap\\n            else \\n                inc first ptr\\n        \\n        firstPtr        valAtFirstPtr           arr\\n        0               4                     [4,3,2,7,8,2,3,1]\\n                                              [7,3,2,4,8,2,3,1]\\n                         7                    [7,3,2,4,8,2,3,1]\\n                                              [1,3,2,4,8,2,3,7]\\n        1                3                    [1,3,2,4,8,2,3,7]\\n                                              [1,2,3,4,8,2,3,7]\\n        2                 3                    [1,2,3,4,8,2,3,7]\\n        3                 4                      [1,2,3,4,8,2,3,7]\\n        4                 8                     [1,2,3,4,7,2,3,8]\\n        4                 7                     [1,2,3,4,3,2,7,8]\\n        4                 3                     [1,2,3,4,3,2,7,8]\\n        5                 2                      [1,2,3,4,3,2,7,8]\\n        6                  7                    [1,2,3,4,3,2,7,8]\\n        7                  8                    [1,2,3,4,3,2,7,8]\\n\\n    now at last check which idx value doesnt match\\n    tc = O(n)\\n    sc = O(1)\\n        \"\"\"\\n        def cyclicSort(nums):\\n            n = len(nums)\\n            firstPtr = 0\\n            while firstPtr < n:\\n                valAtFirstPtr = nums[firstPtr]\\n                if nums[firstPtr] != nums[valAtFirstPtr - 1]:\\n                    nums[firstPtr],nums[valAtFirstPtr - 1] = nums[valAtFirstPtr - 1],nums[firstPtr]\\n                else:\\n                    firstPtr += 1\\n                    \\n        def findMissingNo(nums):\\n            missingNo = []\\n            n = len(nums)\\n            for i in range(n):\\n                if nums[i] != i + 1:\\n                    missingNo.append(i + 1)\\n            return missingNo\\n        \\n        cyclicSort(nums)\\n        return findMissingNo(nums)\\n        \\n                    \\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        brute force is to implement cyclic sort\\n        we will start with examples\\n        [4,3,2,7,8,2,3,1]\\n        \\n        n = 8 means array should contain all the values from 1 to 8\\n        means each no is stored on n - 1 idx\\n        [1,2,3,4, , , 7,8]\\n        \\n        our first pointer will graze over array\\n            then we will take val at first ptr\\n            if nums[first ptr] != nums[val at first ptr - 1]\\n                then swap\\n            else \\n                inc first ptr\\n        \\n        firstPtr        valAtFirstPtr           arr\\n        0               4                     [4,3,2,7,8,2,3,1]\\n                                              [7,3,2,4,8,2,3,1]\\n                         7                    [7,3,2,4,8,2,3,1]\\n                                              [1,3,2,4,8,2,3,7]\\n        1                3                    [1,3,2,4,8,2,3,7]\\n                                              [1,2,3,4,8,2,3,7]\\n        2                 3                    [1,2,3,4,8,2,3,7]\\n        3                 4                      [1,2,3,4,8,2,3,7]\\n        4                 8                     [1,2,3,4,7,2,3,8]\\n        4                 7                     [1,2,3,4,3,2,7,8]\\n        4                 3                     [1,2,3,4,3,2,7,8]\\n        5                 2                      [1,2,3,4,3,2,7,8]\\n        6                  7                    [1,2,3,4,3,2,7,8]\\n        7                  8                    [1,2,3,4,3,2,7,8]\\n\\n    now at last check which idx value doesnt match\\n    tc = O(n)\\n    sc = O(1)\\n        \"\"\"\\n        def cyclicSort(nums):\\n            n = len(nums)\\n            firstPtr = 0\\n            while firstPtr < n:\\n                valAtFirstPtr = nums[firstPtr]\\n                if nums[firstPtr] != nums[valAtFirstPtr - 1]:\\n                    nums[firstPtr],nums[valAtFirstPtr - 1] = nums[valAtFirstPtr - 1],nums[firstPtr]\\n                else:\\n                    firstPtr += 1\\n                    \\n        def findMissingNo(nums):\\n            missingNo = []\\n            n = len(nums)\\n            for i in range(n):\\n                if nums[i] != i + 1:\\n                    missingNo.append(i + 1)\\n            return missingNo\\n        \\n        cyclicSort(nums)\\n        return findMissingNo(nums)\\n        \\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1724267,
                "title": "python-99-55-faster-39-59-better-memory",
                "content": "1. We have to consider the range `[1,n]`, ie infinite series of natural numbers.\\n2. Put all values in a set\\n3. If `l + 1` (remember range `[1,n]`) is not in our set, simply append to our result array, `res`\\n4. Increament counter\\n5. return result array\\n\\n`O(1)` look-up for `if l+1 not in unique`\\n`O(n)` for iteration\\n\\n```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)\\n        res = []\\n        unique = set(nums)\\n\\n        while l < r:\\n            if l+1 not in unique:\\n                res.append(l+1)\\n            l += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)\\n        res = []\\n        unique = set(nums)\\n\\n        while l < r:\\n            if l+1 not in unique:\\n                res.append(l+1)\\n            l += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673641,
                "title": "js-solution-fast-space-efficient",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let n of nums) {\\n        const idx = Math.abs(n) - 1\\n        if (nums[idx] > 0) nums[idx] *= -1\\n    }\\n    let result = []\\n    for(let i=0; i< nums.length; i++) {\\n        if(nums[i] > 0) result.push(i+1)\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findDisappearedNumbers = function(nums) {\\n    for(let n of nums) {\\n        const idx = Math.abs(n) - 1\\n        if (nums[idx] > 0) nums[idx] *= -1\\n    }\\n    let result = []\\n    for(let i=0; i< nums.length; i++) {\\n        if(nums[i] > 0) result.push(i+1)\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1655177,
                "title": "easy-java-100-fast-solution",
                "content": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[nums[i]-1]++;\\n        }\\n        List<Integer> ans=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(arr[i]==0)\\n                ans.add(i+1);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public List<Integer> findDisappearedNumbers(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[nums[i]-1]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1646161,
                "title": "c-o-n-o-1-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        int l = nums.size();\\n        for (int i = 0; i < l; i++) {\\n            int index = abs(nums[i]) - 1;\\n            if (nums[index] > 0) {\\n                nums[index] *= -1;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n           if (nums[i] > 0) {\\n               res.push_back(i + 1);\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        vector<int> res;\\n        int l = nums.size();\\n        for (int i = 0; i < l; i++) {\\n            int index = abs(nums[i]) - 1;\\n            if (nums[index] > 0) {\\n                nums[index] *= -1;\\n            }\\n        }\\n        for (int i = 0; i < l; i++) {\\n           if (nums[i] > 0) {\\n               res.push_back(i + 1);\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564965,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1570677,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1565203,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1569361,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574524,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571974,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571712,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1921352,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1576391,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574446,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1564965,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1570677,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1565203,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1569361,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574524,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571974,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1571712,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1921352,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1576391,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1574446,
                "content": [
                    {
                        "username": "StefanPochmann",
                        "content": "Does anyone have an idea why elements appear only once or twice? At least the common *\"mark by negating\"* solution also works when elements appear more often. Is there a better solution that takes advantage of the fact that elements don't appear more than twice?\\n\\n@yuhaowang001 ?"
                    },
                    {
                        "username": "ajinkode",
                        "content": "This is what overthinking does to you lol"
                    },
                    {
                        "username": "akshatsoni64",
                        "content": "`return set(range(1, len(nums)+1)) - set(nums)`\\n\\n*set(range(1, len(nums)+1)) - set(nums)*: perform minus to get the disappearing elements\\n\\n**set(range(1, len(nums)+1))**: generate set to compare disappearing elements\\n**set(nums)**: Remove duplicates from list\\n\\nClever solution, please upvote is u like this one\\n\\nRegards, Keep Coding"
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "I thought the rules clearly said that solutions should not be posted in the discussion section"
                    },
                    {
                        "username": "prochilles",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Hash Map\n\n  \n**Approach 2:** O(1) Space InPlace Modification Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hhendrycks",
                        "content": "If I understand this problem correctly, we are supposed to return an array of missing numbers. The number 1 and the number 1 have no numbers between then, so why is the expected returned array [2]?"
                    },
                    {
                        "username": "user6359S",
                        "content": "[@sr_ch](/sr_ch) all the integers in the range [1, n] - 2 is not in the range. This is not the first question here, where description is a total smelly garbage."
                    },
                    {
                        "username": "sr_ch",
                        "content": "Because, in question they mentioned your array may contain values from [1,n] where n is length of your array. In [1,1] case ideally it should contain [1,2], but 2 is missing. So the expected answer should be [2]"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "Is it possible to use XOR operations here ?\\n"
                    },
                    {
                        "username": "user1174mw",
                        "content": "No,because by using xor we can solve only one element missing problem,but here more than one element can be missing."
                    },
                    {
                        "username": "ProgrammingWithPalak",
                        "content": "[@ShashidharAngadi](/ShashidharAngadi) why pls tell me"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I think it\\'s not possible..\\n"
                    },
                    {
                        "username": "vegafish",
                        "content": "If we put all the numbers to the place of order.\\n(Put 1 to the 1st place, put 2 to the 2nd place...)\\nE.g. we can make\\n[4,3,2,7,8,2,3,1]\\ninto\\n[1,2,3,4,2,3,7,8]\\n\\nWe can find the 5th and 6th numbers are not 5 and 6, but 2 and 3.\\n[5,6] is the answer of 448.\\n[2,3] is the answer of 442."
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "I tried using this logic but in one test case it is showing wrong ans after passing 28 test cases tho expected and my o/p are same."
                    },
                    {
                        "username": "rockkoca",
                        "content": "\\nFor the test case:\\nThe runtime is 35 ms even I return [5, 6] directly without any loops.\\n\\nI don't think it will have a faster way other than return answer directly.\\n\\nJust cannot believe..."
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "never use list in this type of problems because it will increase the memory instead use a set or a hashmap "
                    },
                    {
                        "username": "shuvocom2014",
                        "content": "\\n![image](https://assets.leetcode.com/users/images/2650b3c5-a89d-452a-8ec7-2f258e553789_1644842277.2351003.png)\\n"
                    },
                    {
                        "username": "0583407",
                        "content": "\\t return list(set(range(1,len(nums)+1)).difference(set(nums)))"
                    }
                ]
            },
            {
                "id": 1572879,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1786431,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1750947,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1720675,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1573272,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1571710,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 2047092,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 2046718,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 2046385,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1957215,
                "content": [
                    {
                        "username": "rapsalands",
                        "content": "As per one of the test cases, input [1,1] should have output of [2]. Why and how? 2 is not missing number I guess."
                    },
                    {
                        "username": "1260",
                        "content": "[@nikhilmourya](/nikhilmourya) range of numbers is from 1 to n, where n is the length of the array. [1, 1] has length = n = 2, so it should be [1, 2], however 2 is missing"
                    },
                    {
                        "username": "nikhilmourya",
                        "content": "[@mishrarohit316x](/mishrarohit316x) can you explain it ? "
                    },
                    {
                        "username": "mishrarohit316x",
                        "content": "the range is given from 1 to n . "
                    },
                    {
                        "username": "MarceloZ",
                        "content": "Test case 30 is out of pocket."
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is wrong?\\n\\n\\nclass Solution:\\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\\n        set=[]\\n        result=[]\\n        for i in range(1,len(nums)+1):\\n            set.append(i)\\n        for i in set:\\n            if i not in nums:\\n              result.append(i)\\n        return result\\n"
                    },
                    {
                        "username": "omar22khaled",
                        "content": "I got time limit exceeded and I don\\'t know where the problem is:\\n\\n `class Solution:`\\n `    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:`\\n `        return [i for i in range(1,len(nums)+1) if i not in nums]`"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "h=len(nums)\\nnums=set(nums)\\n return [i for i in range(1,h+1) if i not in nums]\\nspace complexity is problem"
                    },
                    {
                        "username": "sevenquarkoniums",
                        "content": "Although using the sign of integers does literally use O(1) memory,\\nit is not following the true spirit of using O(1) memory.\\n\\nDisappointed that this problem is not solved by some kind of smart swapping strategy."
                    },
                    {
                        "username": "lh19900702",
                        "content": "Totally same problem."
                    },
                    {
                        "username": "enkil2003",
                        "content": "Leetcode should really REALLY focus their problem descriptions they are so poor."
                    },
                    {
                        "username": "vineetkankerwal",
                        "content": "first sort the array and then see which is not in its correct place."
                    },
                    {
                        "username": "geserx",
                        "content": "It won\\'t be o(n)"
                    },
                    {
                        "username": "geserx",
                        "content": "I think this might be Medium in case of O(n) and no extra space"
                    },
                    {
                        "username": "user1825F",
                        "content": "x=len(nums)\\n        z=[]\\n        for i in range(x+1):\\n            z.append(i)\\n        y=[]\\n        for i in z:\\n            if i not in nums:\\n                y.append(i)\\n        return y[1:]\\nI DID THIS BUT I GOT TIME LIMIT EXCEED ON A TEST CASE CAN ANYONE GIVE ME A HINT ON HOW TO OPTIMIZE MY CODE"
                    }
                ]
            },
            {
                "id": 1920607,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1812339,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1801716,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1781075,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1763628,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1731022,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1729957,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1726469,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1725514,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            },
            {
                "id": 1723963,
                "content": [
                    {
                        "username": "ehernandez07",
                        "content": "<b>TIP:</b> actual input array in test cases during runtime may contain negative numbers."
                    },
                    {
                        "username": "arpitsketchmyweb",
                        "content": " @class Solution {\\n      public List<Integer> findDisappearedNumbers(int[] nums) {\\n\\n        List<Integer> disappearedNumbers = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                if (nums[(-1 * nums[i] - 1)] > 0) {\\n                    nums[-1 * nums[i] - 1] = -1 * nums[-1 * nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            } else {\\n                if (nums[nums[i] - 1] > 0) {\\n                    nums[nums[i] - 1] = -1 * nums[nums[i] - 1];\\n                } else {\\n                    continue;\\n                }\\n\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                disappearedNumbers.add(i + 1);\\n            }\\n        }\\n        return disappearedNumbers;\\n    }\\n\\n}"
                    },
                    {
                        "username": "bm9avan",
                        "content": "could u please explain this code"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "Alternatively to solve this question we can use a boolean array of range 1 to n."
                    },
                    {
                        "username": "iasarexaa",
                        "content": "I wrote two solutions, one with a counter array and one using the input array for in-place array operations. But why does the in-place array solution use more memory than the counter array?\\ncounter array solution = 51ms, 7.3 MB\\nin-place array solution = 48ms, 7.9 MB"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Can we solve this problem inplace??"
                    },
                    {
                        "username": "nomeshpatel",
                        "content": "My Code\\'s output and the expected o/p both are same but it\\'s showing wrong ans in one test case \\nI passed 28/33 testcases.\\nSomeone please help."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/448_%20Disappeared_num.cpp"
                    },
                    {
                        "username": "rahaf_jazar",
                        "content": " public List<Integer> findDisappearedNumbers(int[] nums) {\\n        List <Integer> n=new ArrayList<>();\\n                for (int i=0;i<nums.length;i++){\\n                    if (n.contains(nums[i])){\\n                        continue;\\n                    }\\n                    else\\n                        n.add(nums[i]);\\n                  }\\n                \\n       for (Integer i=1;i<=nums.length;i++){\\n           if (n.contains(i)){\\n               n.remove(i);\\n           }\\n         else\\n               n.add(i);\\n        }\\n        return n;\\n}\\n\\nWhy it gives me (time limit exceeded)\\n"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "Try this out in java:\\nclass Solution {\\n    public List<Integer> findDisappearedNumbers(int[] arr) {\\n        int i = 0;\\n        while(i < arr.length){\\n            int correct = arr[i]-1;\\n            if(arr[i]!=arr[correct]){\\n                swap(arr,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(int index=0; index<arr.length; index++){\\n            if(arr[index] != index+1){\\n                ans.add(index+1);\\n            }\\n        }\\n        return ans;\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first] = arr[second];\\n        arr[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "daymanXnightman",
                        "content": "It\\'s a bit of a jarring learning experience when learning a more basic concept like arrays and then facing a problem where a hash map is the solution."
                    }
                ]
            }
        ]
    },
    {
        "title": "Serialize and Deserialize BST",
        "question_content": "<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>\n\n<p><b>The encoded string should be as compact as possible.</b></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,1,3]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 177617,
                "title": "the-general-solution-for-serialize-and-deserialize-bst-and-serialize-and-deserialize-bt",
                "content": "### BST\\nuse  upper and lower boundaries to check whether we should add `null`\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\",\");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q, int lower, int upper) {\\n        if (q.isEmpty()) return null;\\n        String s = q.peek();\\n        int val = Integer.parseInt(s);\\n        if (val < lower || val > upper) return null;\\n        q.poll();\\n        TreeNode root = new TreeNode(val);\\n        root.left = deserialize(q, lower, val);\\n        root.right = deserialize(q, val, upper);\\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\n\\n### Binary Tree\\nuse `#` whether we should add `null`\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"#\").append(\",\");\\n        } else {\\n            sb.append(root.val).append(\",\");\\n            serialize(root.left, sb);\\n            serialize(root.right, sb);\\n        }\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q) {\\n        String s = q.poll();\\n        if (s.equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(s));\\n        root.left = deserialize(q);\\n        root.right = deserialize(q);\\n        return root;\\n    }\\n    \\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\",\");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q, int lower, int upper) {\\n        if (q.isEmpty()) return null;\\n        String s = q.peek();\\n        int val = Integer.parseInt(s);\\n        if (val < lower || val > upper) return null;\\n        q.poll();\\n        TreeNode root = new TreeNode(val);\\n        root.left = deserialize(q, lower, val);\\n        root.right = deserialize(q, val, upper);\\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"#\").append(\",\");\\n        } else {\\n            sb.append(root.val).append(\",\");\\n            serialize(root.left, sb);\\n            serialize(root.right, sb);\\n        }\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q) {\\n        String s = q.poll();\\n        if (s.equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(s));\\n        root.left = deserialize(q);\\n        root.right = deserialize(q);\\n        return root;\\n    }\\n    \\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93171,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "EDIT: Thanks to @WKVictor , this solution uses 'deque' instead of 'list' as queue. And the performance is O( N )\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return ' '.join(map(str, vals))\\n\\n    # O( N ) since each val run build once\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(float('-infinity'), float('infinity'))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return ' '.join(map(str, vals))\\n\\n    # O( N ) since each val run build once\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(float('-infinity'), float('infinity'))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93175,
                "title": "java-preorder-queue-solution",
                "content": "Hi all, I think my solution is pretty straightforward and easy to understand, not that efficient though. And the serialized tree is compact.\\nPre order traversal of BST will output root node first, then left children, then right.\\n```\\nroot left1 left2 leftX right1 rightX\\n```\\nIf we look at the value of the pre-order traversal we get this:\\n```\\nrootValue (<rootValue) (<rootValue) (<rootValue) |separate line| (>rootValue) (>rootValue)\\n```\\nBecause of BST's property: before the |separate line| all the node values are **less than root value**, all the node values after |separate line| are **greater than root value**. We will utilize this to build left and right tree.\\n\\nPre-order traversal is BST's serialized string. I am doing it iteratively.\\nTo deserialized it, use a queue to recursively get root node, left subtree and right subtree.\\n\\n\\nI think time complexity is O(NlogN).\\nErrr, my bad, as @ray050899 put below, worst case complexity should be O(N^2), when the tree is really unbalanced. \\n\\n\\nMy implementation\\n```\\npublic class Codec {\\n    private static final String SEP = \",\";\\n    private static final String NULL = \"null\";\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return NULL;\\n        //traverse it recursively if you want to, I am doing it iteratively here\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while (!st.empty()) {\\n            root = st.pop();\\n            sb.append(root.val).append(SEP);\\n            if (root.right != null) st.push(root.right);\\n            if (root.left != null) st.push(root.left);\\n        }\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    // pre-order traversal\\n    public TreeNode deserialize(String data) {\\n        if (data.equals(NULL)) return null;\\n        String[] strs = data.split(SEP);\\n        Queue<Integer> q = new LinkedList<>();\\n        for (String e : strs) {\\n            q.offer(Integer.parseInt(e));\\n        }\\n        return getNode(q);\\n    }\\n    \\n    // some notes:\\n    //   5\\n    //  3 6\\n    // 2   7\\n    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7\\n        if (q.isEmpty()) return null;\\n        TreeNode root = new TreeNode(q.poll());//root (5)\\n        Queue<Integer> samllerQueue = new LinkedList<>();\\n        while (!q.isEmpty() && q.peek() < root.val) {\\n            samllerQueue.offer(q.poll());\\n        }\\n        //smallerQueue : 3,2   storing elements smaller than 5 (root)\\n        root.left = getNode(samllerQueue);\\n        //q: 6,7   storing elements bigger than 5 (root)\\n        root.right = getNode(q);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nroot left1 left2 leftX right1 rightX\\n```\n```\\nrootValue (<rootValue) (<rootValue) (<rootValue) |separate line| (>rootValue) (>rootValue)\\n```\n```\\npublic class Codec {\\n    private static final String SEP = \",\";\\n    private static final String NULL = \"null\";\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return NULL;\\n        //traverse it recursively if you want to, I am doing it iteratively here\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while (!st.empty()) {\\n            root = st.pop();\\n            sb.append(root.val).append(SEP);\\n            if (root.right != null) st.push(root.right);\\n            if (root.left != null) st.push(root.left);\\n        }\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    // pre-order traversal\\n    public TreeNode deserialize(String data) {\\n        if (data.equals(NULL)) return null;\\n        String[] strs = data.split(SEP);\\n        Queue<Integer> q = new LinkedList<>();\\n        for (String e : strs) {\\n            q.offer(Integer.parseInt(e));\\n        }\\n        return getNode(q);\\n    }\\n    \\n    // some notes:\\n    //   5\\n    //  3 6\\n    // 2   7\\n    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7\\n        if (q.isEmpty()) return null;\\n        TreeNode root = new TreeNode(q.poll());//root (5)\\n        Queue<Integer> samllerQueue = new LinkedList<>();\\n        while (!q.isEmpty() && q.peek() < root.val) {\\n            samllerQueue.offer(q.poll());\\n        }\\n        //smallerQueue : 3,2   storing elements smaller than 5 (root)\\n        root.left = getNode(samllerQueue);\\n        //q: 6,7   storing elements bigger than 5 (root)\\n        root.right = getNode(q);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93167,
                "title": "concise-c-19ms-solution-beating-99-4",
                "content": "Sharing my solution which doesn't have to parse string for comma at all!\\n\\nThe encoding schema is preorder of BST, and to decode this we can use the same preorder traversal to do it in one pass with recursion in O(n) time.\\n\\nTo minimize the memory, I used binary format instead of ascii format for each integer, just burn those int into 4 chars will save you a lot!!!\\n\\nReally if using ASCII numbers you are paying a lot of penalty memory for integers over 4 digit long and parsing comma is just as painful.\\n\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string order;\\n        inorderDFS(root, order);\\n        return order;\\n    }\\n    \\n    inline void inorderDFS(TreeNode* root, string& order) {\\n        if (!root) return;\\n        char buf[4];\\n        memcpy(buf, &(root->val), sizeof(int)); //burn the int into 4 chars\\n        for (int i=0; i<4; i++) order.push_back(buf[i]);\\n        inorderDFS(root->left, order);\\n        inorderDFS(root->right, order);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return reconstruct(data, pos, INT_MIN, INT_MAX);\\n    }\\n    \\n    inline TreeNode* reconstruct(const string& buffer, int& pos, int minValue, int maxValue) {\\n        if (pos >= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.\\n        \\n        int value;\\n        memcpy(&value, &buffer[pos], sizeof(int));\\n        if (value < minValue || value > maxValue) return NULL;\\n        \\n        TreeNode* node = new TreeNode(value);\\n        pos += sizeof(int);\\n        node->left = reconstruct(buffer, pos, minValue, value);\\n        node->right = reconstruct(buffer, pos, value, maxValue);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string order;\\n        inorderDFS(root, order);\\n        return order;\\n    }\\n    \\n    inline void inorderDFS(TreeNode* root, string& order) {\\n        if (!root) return;\\n        char buf[4];\\n        memcpy(buf, &(root->val), sizeof(int)); //burn the int into 4 chars\\n        for (int i=0; i<4; i++) order.push_back(buf[i]);\\n        inorderDFS(root->left, order);\\n        inorderDFS(root->right, order);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return reconstruct(data, pos, INT_MIN, INT_MAX);\\n    }\\n    \\n    inline TreeNode* reconstruct(const string& buffer, int& pos, int minValue, int maxValue) {\\n        if (pos >= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.\\n        \\n        int value;\\n        memcpy(&value, &buffer[pos], sizeof(int));\\n        if (value < minValue || value > maxValue) return NULL;\\n        \\n        TreeNode* node = new TreeNode(value);\\n        pos += sizeof(int);\\n        node->left = reconstruct(buffer, pos, minValue, value);\\n        node->right = reconstruct(buffer, pos, value, maxValue);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886396,
                "title": "c-simple-and-clean-preorder-traversal-solution",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93168,
                "title": "deserialize-from-preorder-and-computed-inorder-reusing-old-solution",
                "content": "I serialize the tree's values in preorder. For deserializing, I additionally compute inorder simply by sorting the preorder. And then I just use the `buildTree` function that I copied&pasted from [my old solution](https://discuss.leetcode.com/topic/16221/simple-o-n-without-map) for the old problem [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/).\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        def preorder(node):\\n            if node:\\n                vals.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        vals = []\\n        preorder(root)\\n        return ' '.join(vals)\\n\\n    def deserialize(self, data):\\n        preorder = map(int, data.split())\\n        inorder = sorted(preorder)\\n        return self.buildTree(preorder, inorder)\\n\\n    def buildTree(self, preorder, inorder):\\n        def build(stop):\\n            if inorder and inorder[-1] != stop:\\n                root = TreeNode(preorder.pop())\\n                root.left = build(root.val)\\n                inorder.pop()\\n                root.right = build(stop)\\n                return root\\n        preorder.reverse()\\n        inorder.reverse()\\n        return build(None)\\n```\\n(I had seen @shallpion's [title](https://discuss.leetcode.com/topic/65773/construct-bst-using-preorder-traversal) saying \"preorder\" before thinking about this problem, so can't be sure I would've had the idea myself, though I think I would've.)",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        def preorder(node):\\n            if node:\\n                vals.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        vals = []\\n        preorder(root)\\n        return ' '.join(vals)\\n\\n    def deserialize(self, data):\\n        preorder = map(int, data.split())\\n        inorder = sorted(preorder)\\n        return self.buildTree(preorder, inorder)\\n\\n    def buildTree(self, preorder, inorder):\\n        def build(stop):\\n            if inorder and inorder[-1] != stop:\\n                root = TreeNode(preorder.pop())\\n                root.left = build(root.val)\\n                inorder.pop()\\n                root.right = build(stop)\\n                return root\\n        preorder.reverse()\\n        inorder.reverse()\\n        return build(None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549891,
                "title": "bt-bst-c-solution-preorder-comma-seperated-with-comments",
                "content": "(1) Binary Search Tree\\n```\\nclass Codec {\\npublic:\\n    void serializehelper(TreeNode* root, string& s){\\n        if(root==nullptr) return;\\n        \\n        s+=to_string(root->val) + \",\"; // \\',\\' for seperating each value\\n        serializehelper(root->left, s);\\n        serializehelper(root->right, s);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"\";\\n        \\n        string s=\"\";\\n        serializehelper(root, s);\\n        \\n        return s;\\n    }\\n    \\n    int convertStringtoInt(string& data, int& pos){ // Find \\',\\' and return value\\n        pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        return value;\\n    }\\n    \\n    TreeNode* deserializehelper(string& data, int min, int max) {\\n        if(data.size()==0) return nullptr; // If no more elements, return nullptr\\n        \\n        int pos=0;\\n        int value = convertStringtoInt(data, pos); // Find new value and position of \\',\\'\\n        if (value < min || value > max) return nullptr; // Is new value in given range\\n        \\n        TreeNode* tnode = new TreeNode(value); \\n        data=data.substr(pos+1); // Update only when in range\\n        \\n        tnode->left=deserializehelper(data, min, tnode->val); // Branch off to left & right subtree with given ranges\\n        tnode->right=deserializehelper(data, tnode->val, max);\\n        return tnode;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        if(data==\"\") return nullptr;\\n        return deserializehelper(data, INT_MIN, INT_MAX);\\n    }\\n};\\n```\\n\\n(2) Binary Tree\\n```\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"X\";\\n        \\n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right); // to_string\\n    }\\n    int convertStringtoInt(string& data){\\n        int pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        data=data.substr(pos+1);\\n        return value;\\n    }\\n    TreeNode* deserializehelper(string& data) { // data is updated, hence by reference\\n        if(data[0]==\\'X\\'){\\n            if(data.size()>1)\\n                data=data.substr(2);  // keep removing data \\n            return nullptr;\\n        }\\n        \\n        TreeNode* tnode = new TreeNode(convertStringtoInt(data));  // covert data using stoi\\n        tnode->left=deserializehelper(data);\\n        tnode->right=deserializehelper(data);\\n        return tnode;\\n    }\\n    TreeNode* deserialize(string data) {\\n        return deserializehelper(data);\\n    }\\n};\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    void serializehelper(TreeNode* root, string& s){\\n        if(root==nullptr) return;\\n        \\n        s+=to_string(root->val) + \",\"; // \\',\\' for seperating each value\\n        serializehelper(root->left, s);\\n        serializehelper(root->right, s);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"\";\\n        \\n        string s=\"\";\\n        serializehelper(root, s);\\n        \\n        return s;\\n    }\\n    \\n    int convertStringtoInt(string& data, int& pos){ // Find \\',\\' and return value\\n        pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        return value;\\n    }\\n    \\n    TreeNode* deserializehelper(string& data, int min, int max) {\\n        if(data.size()==0) return nullptr; // If no more elements, return nullptr\\n        \\n        int pos=0;\\n        int value = convertStringtoInt(data, pos); // Find new value and position of \\',\\'\\n        if (value < min || value > max) return nullptr; // Is new value in given range\\n        \\n        TreeNode* tnode = new TreeNode(value); \\n        data=data.substr(pos+1); // Update only when in range\\n        \\n        tnode->left=deserializehelper(data, min, tnode->val); // Branch off to left & right subtree with given ranges\\n        tnode->right=deserializehelper(data, tnode->val, max);\\n        return tnode;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        if(data==\"\") return nullptr;\\n        return deserializehelper(data, INT_MIN, INT_MAX);\\n    }\\n};\\n```\n```\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"X\";\\n        \\n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right); // to_string\\n    }\\n    int convertStringtoInt(string& data){\\n        int pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        data=data.substr(pos+1);\\n        return value;\\n    }\\n    TreeNode* deserializehelper(string& data) { // data is updated, hence by reference\\n        if(data[0]==\\'X\\'){\\n            if(data.size()>1)\\n                data=data.substr(2);  // keep removing data \\n            return nullptr;\\n        }\\n        \\n        TreeNode* tnode = new TreeNode(convertStringtoInt(data));  // covert data using stoi\\n        tnode->left=deserializehelper(data);\\n        tnode->right=deserializehelper(data);\\n        return tnode;\\n    }\\n    TreeNode* deserialize(string data) {\\n        return deserializehelper(data);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93224,
                "title": "concise-iterative-python-solution-using-stack-beat-99",
                "content": "The idea is serialize the data into pre-order string.\\n\\nIn deserialize, we stack to build the tree.\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        res, stk = [], []\\n        while stk or root:\\n            if root:\\n                res.append(str(root.val))\\n                stk.append(root)\\n                root = root.left\\n            else:\\n                root = stk.pop()\\n                root = root.right\\n        return ' '.join(res)\\n\\n    def deserialize(self, data):\\n        if not data:\\n            return None\\n        data = map(int, data.split(' '))\\n        stk = []\\n        root = node = TreeNode(data[0])\\n        for n in data[1:]:\\n            if n < node.val:\\n                node.left = TreeNode(n)\\n                stk.append(node)\\n                node = node.left\\n            else:\\n                while stk and stk[-1].val < n:\\n                    node = stk.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        res, stk = [], []\\n        while stk or root:\\n            if root:\\n                res.append(str(root.val))\\n                stk.append(root)\\n                root = root.left\\n            else:\\n                root = stk.pop()\\n                root = root.right\\n        return ' '.join(res)\\n\\n    def deserialize(self, data):\\n        if not data:\\n            return None\\n        data = map(int, data.split(' '))\\n        stk = []\\n        root = node = TreeNode(data[0])\\n        for n in data[1:]:\\n            if n < node.val:\\n                node.left = TreeNode(n)\\n                stk.append(node)\\n                node = node.left\\n            else:\\n                while stk and stk[-1].val < n:\\n                    node = stk.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93180,
                "title": "using-lower-bound-and-upper-bound-to-deserialize-bst",
                "content": "The idea is to encode every non null root value by preorder traversal \\n\\nwhen deserializing the tree, we can pass by the lower bound and upper bound to know the boundary of a subtree.\\n\\nThis approach has an overhead of looking up one extra number, which would be O ( 2N )\\n\\n```\\n    // Encodes a tree to a single string.\\n    void serialize(TreeNode* root, ostringstream& out )\\n    {\\n        if ( !root ) return;\\n        out << root->val << \",\";\\n        serialize(root->left, out);\\n        serialize(root->right, out);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        ostringstream ss;\\n        serialize(root, ss);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(const string& s, int lower, int upper, int & pos )\\n    {\\n        // pos is a variable to record the end of decoded buffer \\n        if ( pos == s.size() ) return nullptr;\\n        int cur_pos = pos;\\n        int number = 0;\\n        while( s[cur_pos] != ',')\\n        {\\n            number = number * 10 + s[cur_pos] - '0';\\n            ++cur_pos;\\n        }\\n        ++cur_pos;\\n        // The next number is not part of current subtree, should return nullptr\\n        if ( number < lower || number > upper ) return nullptr;\\n\\n        TreeNode* root = new TreeNode( number );\\n        pos = cur_pos; // update pos \\n        root->left =  deserialize( s, lower, root->val, pos );\\n        root->right = deserialize( s, root->val, upper, pos );\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return deserialize( data, INT_MIN, INT_MAX, pos );\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // Encodes a tree to a single string.\\n    void serialize(TreeNode* root, ostringstream& out )\\n    {\\n        if ( !root ) return;\\n        out << root->val << \",\";\\n        serialize(root->left, out);\\n        serialize(root->right, out);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        ostringstream ss;\\n        serialize(root, ss);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(const string& s, int lower, int upper, int & pos )\\n    {\\n        // pos is a variable to record the end of decoded buffer \\n        if ( pos == s.size() ) return nullptr;\\n        int cur_pos = pos;\\n        int number = 0;\\n        while( s[cur_pos] != ',')\\n        {\\n            number = number * 10 + s[cur_pos] - '0';\\n            ++cur_pos;\\n        }\\n        ++cur_pos;\\n        // The next number is not part of current subtree, should return nullptr\\n        if ( number < lower || number > upper ) return nullptr;\\n\\n        TreeNode* root = new TreeNode( number );\\n        pos = cur_pos; // update pos \\n        root->left =  deserialize( s, lower, root->val, pos );\\n        root->right = deserialize( s, root->val, upper, pos );\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return deserialize( data, INT_MIN, INT_MAX, pos );\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164504,
                "title": "java-concise-solution",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#\";\\n        }\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[]strs = data.split(\",\");\\n        return deserialize(strs, new int[]{0});\\n    }\\n    private TreeNode deserialize(String[]arr, int[]idx){\\n        if(arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[idx[0]++]));\\n        root.left = deserialize(arr, idx);\\n        root.right = deserialize(arr, idx);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#\";\\n        }\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[]strs = data.split(\",\");\\n        return deserialize(strs, new int[]{0});\\n    }\\n    private TreeNode deserialize(String[]arr, int[]idx){\\n        if(arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[idx[0]++]));\\n        root.left = deserialize(arr, idx);\\n        root.right = deserialize(arr, idx);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886354,
                "title": "python-o-n-solution-using-preorder-traversal-explained",
                "content": "My idea to solve this problem is to use **Problem 1008**. Construct Binary Search Tree from Preorder Traversal. So:\\n\\n1. For our serialization we just get preorder traversel (iterative or recursion, whatever you want, I used iterative, using stack).\\n2. For deserialization we use solution with `O(n)` time complexity: we give the function two bounds - `up` and `down`: the maximum number it will handle. The left recursion will take the elements smaller than `node.val` and  the right recursion will take the remaining elements smaller than `bound`.\\n\\n**Complexity**: both for serialization and deserialization is `O(n)`, because `self.index` will be increased by one on each iteration.\\n\\n```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root: return \"\"\\n        stack, out = [root], []\\n        while stack:\\n            cur = stack.pop()\\n            out.append(cur.val)\\n            for child in filter(None, [cur.right, cur.left]):\\n                stack += [child]\\n                \\n        return \\' \\'.join(map(str, out))\\n        \\n    def deserialize(self, data):\\n        preorder = [int(i) for i in data.split()]\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n            \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root: return \"\"\\n        stack, out = [root], []\\n        while stack:\\n            cur = stack.pop()\\n            out.append(cur.val)\\n            for child in filter(None, [cur.right, cur.left]):\\n                stack += [child]\\n                \\n        return \\' \\'.join(map(str, out))\\n        \\n    def deserialize(self, data):\\n        preorder = [int(i) for i in data.split()]\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n            \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93170,
                "title": "pre-or-post-order-with-only-keeping-one-bound-beat-98-and-95",
                "content": "the post-order:\\n\\n'''\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n        sb.append(Integer.valueOf(root.val)).append(\" \");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {nodes.length - 1};\\n        return deserialize(nodes, index, Integer.MIN_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int min) {\\n        if (index[0] < 0 || Integer.valueOf(nodes[index[0]]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]--]));\\n        root.right = deserialize(nodes, index, root.val);\\n        root.left = deserialize(nodes, index, min);\\n        return root;\\n    }\\n}\\n\\n'''\\n\\npre-order\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        sb.append(root.val).append(\" \");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {0};\\n        return deserialize(nodes, index, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int max) {\\n        if (index[0] >= nodes.length || Integer.valueOf(nodes[index[0]]) >= max) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]++]));\\n        root.left = deserialize(nodes, index, root.val);\\n        root.right = deserialize(nodes, index, max);\\n        return root;\\n    }\\n}\\n\\n'''",
                "solutionTags": [],
                "code": "the post-order:\\n\\n'''\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n        sb.append(Integer.valueOf(root.val)).append(\" \");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {nodes.length - 1};\\n        return deserialize(nodes, index, Integer.MIN_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int min) {\\n        if (index[0] < 0 || Integer.valueOf(nodes[index[0]]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]--]));\\n        root.right = deserialize(nodes, index, root.val);\\n        root.left = deserialize(nodes, index, min);\\n        return root;\\n    }\\n}\\n\\n'''\\n\\npre-order\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        sb.append(root.val).append(\" \");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {0};\\n        return deserialize(nodes, index, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int max) {\\n        if (index[0] >= nodes.length || Integer.valueOf(nodes[index[0]]) >= max) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]++]));\\n        root.left = deserialize(nodes, index, root.val);\\n        root.right = deserialize(nodes, index, max);\\n        return root;\\n    }\\n}\\n\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 502589,
                "title": "python-o-n-sol-by-pre-order-traversal-75-with-explanation",
                "content": "Python O(n) sol by pre-order traversal.\\n\\n---\\n\\nHint:\\n1. Pre-order traversal of binary search tree is **unique and only**. (i.e., no repetition between two different BSTs)\\n\\n2. **Pre-order traversal rule** of binary search tree is ( **current node, left-child, right-child**)\\n\\n3. Left child value < current node value < Right child value **if all elements are unique**.\\n\\n---\\n\\nAlgorithm:\\n\\nSerialization: \\nGenerate a string to represent the input BST with preorder traversal.\\n\\nDeseialization:\\nDecode the serialization string to rebuild BST by preorder traversal.\\n\\n---\\n\\nExample illustration\\n\\n---\\n\\nSerialization:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581313601.png)\\n\\n---\\n\\nDeserialization:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581313629.png)\\n\\n---\\n\\n```\\nfrom collections import deque\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        \\n        # record of preorder traversal path\\n        path_of_preorder = []\\n        \\n        # Generate pre-order traversal path of binary search tree\\n        def helper( node ):\\n            \\n            if node:\\n                path_of_preorder.append( node.val )\\n                helper( node.left )\\n                helper( node.right )\\n        \\n        # ---------------------------------------------\\n        helper( root )\\n        # output as string, each node is separated by \\'#\\'\\n        return \\'#\\'.join( map(str, path_of_preorder) )\\n                \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            # corner case handle for empty tree\\n            return None\\n        \\n        # convert input string into doubly linked list of integer type, each node is separated by \\'#\\'\\n        node_values = deque(  int(value) for value in data.split(\\'#\\') )\\n        \\n        # Reconstruct binary search tree by pre-order traversal\\n        def helper( lower_bound, upper_bound):\\n            \\n            if node_values and lower_bound < node_values[0] < upper_bound:\\n                \\n                root_value = node_values.popleft()\\n                root_node = TreeNode( root_value )\\n                \\n                root_node.left = helper( lower_bound, root_value )\\n                root_node.right = helper( root_value, upper_bound )\\n                \\n                return root_node\\n        \\n        # ---------------------------------------------\\n        \\n        return helper( float(\\'-inf\\'), float(\\'inf\\'))    \\n```\\n\\n---\\n\\nRelative leetcode challenge:\\n[Leetcode #1008 Construct Binary Search Tree from Preorder Traversal](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)\\n\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nfrom collections import deque\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        \\n        # record of preorder traversal path\\n        path_of_preorder = []\\n        \\n        # Generate pre-order traversal path of binary search tree\\n        def helper( node ):\\n            \\n            if node:\\n                path_of_preorder.append( node.val )\\n                helper( node.left )\\n                helper( node.right )\\n        \\n        # ---------------------------------------------\\n        helper( root )\\n        # output as string, each node is separated by \\'#\\'\\n        return \\'#\\'.join( map(str, path_of_preorder) )\\n                \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            # corner case handle for empty tree\\n            return None\\n        \\n        # convert input string into doubly linked list of integer type, each node is separated by \\'#\\'\\n        node_values = deque(  int(value) for value in data.split(\\'#\\') )\\n        \\n        # Reconstruct binary search tree by pre-order traversal\\n        def helper( lower_bound, upper_bound):\\n            \\n            if node_values and lower_bound < node_values[0] < upper_bound:\\n                \\n                root_value = node_values.popleft()\\n                root_node = TreeNode( root_value )\\n                \\n                root_node.left = helper( lower_bound, root_value )\\n                root_node.right = helper( root_value, upper_bound )\\n                \\n                return root_node\\n        \\n        # ---------------------------------------------\\n        \\n        return helper( float(\\'-inf\\'), float(\\'inf\\'))    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 93179,
                "title": "java-o-n-recursive-dfs-without-null-changed-from-serialize-and-deserialize-bt",
                "content": "Thanks to [this post](https://discuss.leetcode.com/topic/66495/using-lower-bound-and-upper-bound-to-deserialize-bst), I realize that I can make use of lower and upper bound.\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) { // preorder\\n        StringBuilder sb = new StringBuilder();\\n        serializedfs(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serializedfs(TreeNode root, StringBuilder sb){\\n        if(root == null) return; // no \"null \"\\n        sb.append(root.val).append(\" \");\\n        serializedfs(root.left, sb);\\n        serializedfs(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length() == 0) return null;\\n        String[] list = data.split(\" \");\\n        TreeNode dummy = new TreeNode(0);\\n        deserializedfs(list, 0, dummy, true, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        return dummy.left;\\n    }\\n    \\n    private int deserializedfs(String[] list, int pos, TreeNode par, boolean isleft, \\n                                                        int lower, int upper){\\n        if(pos >= list.length) return pos;\\n    \\n        int val = Integer.valueOf(list[pos]);\\n        if(val < lower || val > upper) return pos-1; // have not used this pos, so minus one\\n        TreeNode cur = new TreeNode(val);\\n        \\n        if(isleft) par.left = cur;\\n        else       par.right = cur;\\n\\n        pos = deserializedfs(list, ++pos, cur, true, lower, val);\\n        pos = deserializedfs(list, ++pos, cur, false, val, upper);\\n        return pos;\\n    }",
                "solutionTags": [],
                "code": "Thanks to [this post](https://discuss.leetcode.com/topic/66495/using-lower-bound-and-upper-bound-to-deserialize-bst), I realize that I can make use of lower and upper bound.\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) { // preorder\\n        StringBuilder sb = new StringBuilder();\\n        serializedfs(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serializedfs(TreeNode root, StringBuilder sb){\\n        if(root == null) return; // no \"null \"\\n        sb.append(root.val).append(\" \");\\n        serializedfs(root.left, sb);\\n        serializedfs(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length() == 0) return null;\\n        String[] list = data.split(\" \");\\n        TreeNode dummy = new TreeNode(0);\\n        deserializedfs(list, 0, dummy, true, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        return dummy.left;\\n    }\\n    \\n    private int deserializedfs(String[] list, int pos, TreeNode par, boolean isleft, \\n                                                        int lower, int upper){\\n        if(pos >= list.length) return pos;\\n    \\n        int val = Integer.valueOf(list[pos]);\\n        if(val < lower || val > upper) return pos-1; // have not used this pos, so minus one\\n        TreeNode cur = new TreeNode(val);\\n        \\n        if(isleft) par.left = cur;\\n        else       par.right = cur;\\n\\n        pos = deserializedfs(list, ++pos, cur, true, lower, val);\\n        pos = deserializedfs(list, ++pos, cur, false, val, upper);\\n        return pos;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 886326,
                "title": "python-bfs-90",
                "content": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n                \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n                \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93184,
                "title": "easy-to-understand-c-solution-using-preorder-traversal-and-iostringstream",
                "content": "Because of BST, so we can use `PreOrder Traversal` to rebuild the tree, so do with serialize and deserialize. After using `iostringstream`, we can easily get the values and build the tree.\\n\\n```\\nclass Codec \\n{\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n    {\\n        ostringstream out;\\n        mySerialize(root, out);\\n        return out.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) \\n    {\\n        if(data == \"\") return NULL;\\n        istringstream in(data);\\n        return myDeserialize(in);\\n    }\\nprivate:\\n\\tvoid mySerialize(TreeNode* root, ostringstream &out)\\n\\t{\\n\\t\\tif(root == NULL) return;\\n\\t\\tout << root->val << \" \";\\n\\t\\tmySerialize(root->left, out);\\n\\t\\tmySerialize(root->right, out);\\n\\t}\\n\\n\\tTreeNode* myDeserialize(istringstream &in)\\n\\t{\\n\\t\\tstring val;\\n\\t\\tin >> val;\\n\\t\\tTreeNode *root = new TreeNode(stoi(val));\\n\\t\\twhile(in >> val)\\n\\t\\t\\tbuildTree(root, stoi(val));\\n\\t\\treturn root;\\n\\t}\\n\\n\\tvoid buildTree(TreeNode* root, int n)\\n\\t{\\n\\t\\tif(root->val > n)\\n\\t\\t{\\n\\t\\t\\tif(root->left == NULL)\\n\\t\\t\\t\\troot->left = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->left, n);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(root->right == NULL)\\n\\t\\t\\t\\troot->right = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->right, n);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec \\n{\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n    {\\n        ostringstream out;\\n        mySerialize(root, out);\\n        return out.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) \\n    {\\n        if(data == \"\") return NULL;\\n        istringstream in(data);\\n        return myDeserialize(in);\\n    }\\nprivate:\\n\\tvoid mySerialize(TreeNode* root, ostringstream &out)\\n\\t{\\n\\t\\tif(root == NULL) return;\\n\\t\\tout << root->val << \" \";\\n\\t\\tmySerialize(root->left, out);\\n\\t\\tmySerialize(root->right, out);\\n\\t}\\n\\n\\tTreeNode* myDeserialize(istringstream &in)\\n\\t{\\n\\t\\tstring val;\\n\\t\\tin >> val;\\n\\t\\tTreeNode *root = new TreeNode(stoi(val));\\n\\t\\twhile(in >> val)\\n\\t\\t\\tbuildTree(root, stoi(val));\\n\\t\\treturn root;\\n\\t}\\n\\n\\tvoid buildTree(TreeNode* root, int n)\\n\\t{\\n\\t\\tif(root->val > n)\\n\\t\\t{\\n\\t\\t\\tif(root->left == NULL)\\n\\t\\t\\t\\troot->left = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->left, n);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(root->right == NULL)\\n\\t\\t\\t\\troot->right = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->right, n);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212043,
                "title": "python-solution",
                "content": "One can use the encoding and decoding scheme in 297. Serialize and Deserialize Binary Tree. However, it does not use the properties of a BST: The left (right) subtree of a node contains only nodes with keys smaller (greater) than the node\\'s key. Therefore, the encoding strings there does not satisfy the requirement that it should be as compact as possible. In particular, the null nodes need to be specified in the encoding string, and is redundant here. With the aforementioned BST property, one can actually recover a BST from its preorder traversal alone (without specifying the null nodes), assuming that the node values are distinct.\\n\\nAs a concrete example, suppose the preorder traversal of some BST gives `s = \"5,4,2,3,7,9,10\"`. Since the preorder traversal traverses the tree in the order `root -> left subtree -> right subtree`, we know that `\"5\"` must be the value of the `root` of the BST. Furthermore, by the BST property, all values smaller (larger) than `5` should be all values of nodes from the left (right) subtree. Hence, we we just need to iterate over `s[1:]` and find the first occurence (at index `i`) of some number larger than `5`. Then the left subtree would consists of values `s[1:i]` (`[\"4\",\"2\",\"3\"]` in this example), and the right subtree would consists of values `s[i:]` (`[\"7\",\"9\",\"10\"]` in this example). Calling the deserialize method recursively on `s[1:i]`, and `s[i:]` gives us the roots of the left subtree `l` and right subtree `r` respectively. And by assigning `root.left = l`, and `root.right = r`, and returning `root`, we finish the deserialization procedure.\\n\\nTime complexity for `serialize`: `O(n)`. Time complexity for `deserialize`: `O(n^2)`. Space complexity for both `serialize` and `deserialize`: `O(n)`.\\n\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def helper(arr, i, j):\\n            if i > j:\\n                return\\n            if i == j:\\n                node = TreeNode(arr[i])\\n                return node\\n            for k in range(i+1, j+1):\\n                if arr[k] > arr[i]:\\n                    l = helper(arr, i+1, k-1)\\n                    r = helper(arr, k, j)\\n                    root = TreeNode(arr[i])\\n                    root.left = l\\n                    root.right = r\\n                    return root\\n            l = helper(arr, i+1, j)\\n            root = TreeNode(arr[i])\\n            root.left = l\\n            return root\\n        \\n        arr = data.split(\",\")\\n        arr.pop()\\n        data = [int(x) for x in arr]\\n        return helper(data, 0, len(data)-1)\\n```\\n\\nA better solution with `O(n)` iterative deserialization:\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        lst = data.split(\",\")\\n        lst.pop()\\n        stack = []\\n        head = None\\n        for n in lst:\\n            n = int(n)\\n            if not head:\\n                head = TreeNode(n)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(n)\\n                if n < stack[-1].val:\\n                    stack[-1].left = node\\n                else:\\n                    while stack and stack[-1].val < n: \\n                        u = stack.pop()\\n                    u.right = node\\n                stack.append(node)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def helper(arr, i, j):\\n            if i > j:\\n                return\\n            if i == j:\\n                node = TreeNode(arr[i])\\n                return node\\n            for k in range(i+1, j+1):\\n                if arr[k] > arr[i]:\\n                    l = helper(arr, i+1, k-1)\\n                    r = helper(arr, k, j)\\n                    root = TreeNode(arr[i])\\n                    root.left = l\\n                    root.right = r\\n                    return root\\n            l = helper(arr, i+1, j)\\n            root = TreeNode(arr[i])\\n            root.left = l\\n            return root\\n        \\n        arr = data.split(\",\")\\n        arr.pop()\\n        data = [int(x) for x in arr]\\n        return helper(data, 0, len(data)-1)\\n```\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        lst = data.split(\",\")\\n        lst.pop()\\n        stack = []\\n        head = None\\n        for n in lst:\\n            n = int(n)\\n            if not head:\\n                head = TreeNode(n)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(n)\\n                if n < stack[-1].val:\\n                    stack[-1].left = node\\n                else:\\n                    while stack and stack[-1].val < n: \\n                        u = stack.pop()\\n                    u.right = node\\n                stack.append(node)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886180,
                "title": "python-preorder-traversal-clean-concise-o-n",
                "content": "Same with problem: [297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)\\n\\n```python\\nclass Codec:\\n    def serialize(self, root):\\n        if root == None:\\n            return \"$\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        nodes = data.split(\",\")\\n        self.i = 0\\n        def dfs():\\n            if self.i == len(nodes) or nodes[self.i] == \"$\":\\n                self.i += 1\\n                return None\\n            root = TreeNode(int(nodes[self.i]))\\n            self.i += 1\\n            root.left = dfs()\\n            root.right = dfs()\\n            return root\\n        \\n        return dfs()\\n```\\n**Complexity**\\n- Time & Space: `O(N)`, where `N` is number of nodes in BST.",
                "solutionTags": [],
                "code": "```python\\nclass Codec:\\n    def serialize(self, root):\\n        if root == None:\\n            return \"$\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        nodes = data.split(\",\")\\n        self.i = 0\\n        def dfs():\\n            if self.i == len(nodes) or nodes[self.i] == \"$\":\\n                self.i += 1\\n                return None\\n            root = TreeNode(int(nodes[self.i]))\\n            self.i += 1\\n            root.left = dfs()\\n            root.right = dfs()\\n            return root\\n        \\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886276,
                "title": "c-super-simple-clean-short-soluion-only-11-lines",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312687,
                "title": "easy-java-solution-2-approaches-beats-100-online-submissions",
                "content": "# Approach\\n1. **Perform DFS and store the result in a string seperated by \\',\\' and null is represented by \\'x\\'**\\n2. **To helpdeserialize follow the approach to build a Tree**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n\\n        helpserialize(root,res);\\n\\n        return res.toString();\\n    }\\n\\n    private void helpserialize(TreeNode root, StringBuilder res){\\n        if(root == null){\\n            res.append(\"x,\");\\n            return ;\\n        }\\n\\n        res.append(root.val);\\n        res.append(\\',\\');\\n\\n        helpserialize(root.left, res);\\n        helpserialize(root.right, res);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Deque<String> q = new LinkedList<>();\\n\\n        q.addAll(Arrays.asList(data.split(\",\")));\\n\\n        return helpdeserialize(q);\\n    }\\n\\n    private TreeNode helpdeserialize(Deque<String> q){\\n        String res = q.remove();\\n\\n        if(res.equals(\"x\")){\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.parseInt(res));\\n\\n        root.left = helpdeserialize(q);\\n        root.right = helpdeserialize(q);\\n\\n        return root;\\n    }\\n}\\n```\\n\\n# Java O(1) Code\\n\\n# I mean... why not \\uD83D\\uDE02\\n```\\npublic class Codec {\\n\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n\\n        helpserialize(root,res);\\n\\n        return res.toString();\\n    }\\n\\n    private void helpserialize(TreeNode root, StringBuilder res){\\n        if(root == null){\\n            res.append(\"x,\");\\n            return ;\\n        }\\n\\n        res.append(root.val);\\n        res.append(\\',\\');\\n\\n        helpserialize(root.left, res);\\n        helpserialize(root.right, res);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Deque<String> q = new LinkedList<>();\\n\\n        q.addAll(Arrays.asList(data.split(\",\")));\\n\\n        return helpdeserialize(q);\\n    }\\n\\n    private TreeNode helpdeserialize(Deque<String> q){\\n        String res = q.remove();\\n\\n        if(res.equals(\"x\")){\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.parseInt(res));\\n\\n        root.left = helpdeserialize(q);\\n        root.right = helpdeserialize(q);\\n\\n        return root;\\n    }\\n}\\n```\n```\\npublic class Codec {\\n\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821685,
                "title": "small-and-simple-code-in-c-with-o-n-time-complexity",
                "content": "Do the dry run to understand\\nexample:\\n1 ( 2 (4) (5) ) (3 (6) ( 7 (8) (9) ) )\\n1 -> children 2 and 3\\n2 -> children 4 and 5\\n3 -> children 6 and 7\\n7 -> children 8 and 9\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        if(root == NULL) return str;\\n        str = to_string(root->val) + \"(\" + serialize(root->left) + \")\" + \"(\" + serialize(root->right) + \")\";\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        if(i < data.size() && data[i] == \\'(\\') i++;\\n        if(i>=data.size() || data[i] == \\')\\') {\\n            return NULL;\\n        }\\n        \\n        int num = 0;\\n        while(data[i] <= \\'9\\' && data[i] >= \\'0\\') {\\n            num = num * 10 + (data[i] - \\'0\\');\\n            i++;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        root->left = decode(data, i);\\n        i++;\\n        root->right = decode(data, i);\\n        i++;\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        int i=0;\\n        return decode(data, i);       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        if(root == NULL) return str;\\n        str = to_string(root->val) + \"(\" + serialize(root->left) + \")\" + \"(\" + serialize(root->right) + \")\";\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        if(i < data.size() && data[i] == \\'(\\') i++;\\n        if(i>=data.size() || data[i] == \\')\\') {\\n            return NULL;\\n        }\\n        \\n        int num = 0;\\n        while(data[i] <= \\'9\\' && data[i] >= \\'0\\') {\\n            num = num * 10 + (data[i] - \\'0\\');\\n            i++;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        root->left = decode(data, i);\\n        i++;\\n        root->right = decode(data, i);\\n        i++;\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        int i=0;\\n        return decode(data, i);       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93199,
                "title": "extremely-elegant-and-simple-javascript-solution",
                "content": "My serialized list takes the form of: \\n`[root, <elements smaller than root>, <elements bigger than root>]` and this is true recursively. I cheated a little bit by using `JSON.stringify` and `JSON.parse` but the general idea is there.\\n\\n```\\nvar serialize = function(root) {\\n    function traverse(node) {\\n        if (!node) {\\n            return [];\\n        }\\n        return [node.val].concat(traverse(node.left), traverse(node.right));\\n    }\\n    return JSON.stringify(traverse(root));\\n};\\n\\nvar deserialize = function(data) {\\n    function construct(arr) {\\n        if (!arr.length) {\\n            return null;\\n        }\\n        const root = new TreeNode(arr[0]);\\n        root.left = construct(arr.filter(num => num < root.val));\\n        root.right = construct(arr.filter(num => num > root.val));\\n        return root;\\n    }\\n    return construct(JSON.parse(data));\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar serialize = function(root) {\\n    function traverse(node) {\\n        if (!node) {\\n            return [];\\n        }\\n        return [node.val].concat(traverse(node.left), traverse(node.right));\\n    }\\n    return JSON.stringify(traverse(root));\\n};\\n\\nvar deserialize = function(data) {\\n    function construct(arr) {\\n        if (!arr.length) {\\n            return null;\\n        }\\n        const root = new TreeNode(arr[0]);\\n        root.left = construct(arr.filter(num => num < root.val));\\n        root.right = construct(arr.filter(num => num > root.val));\\n        return root;\\n    }\\n    return construct(JSON.parse(data));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886500,
                "title": "serialize-and-deserialize-bst-python",
                "content": "```\\ndef serialize(self, root: TreeNode) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return \\' \\'.join(map(str, vals))\\n        \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val,maxVal)\\n                return node\\n\\n        return build(float(\\'-inf\\'), float(\\'inf\\'))\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef serialize(self, root: TreeNode) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return \\' \\'.join(map(str, vals))\\n        \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val,maxVal)\\n                return node\\n\\n        return build(float(\\'-inf\\'), float(\\'inf\\'))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 605664,
                "title": "simple-javascript-solution",
                "content": "```\\nlet serialize = (root, result = []) => {\\n  if (root) {\\n    result.push(root.val);\\n    result.push(...serialize(root.left));\\n    result.push(...serialize(root.right));\\n  } else {\\n    result.push(null);\\n  }\\n  return result;\\n};\\n\\nlet deserialize = (data) => {\\n  let val = data.shift();\\n  if (val == null) return null;\\n  let node = new TreeNode(val);\\n  node.left = deserialize(data);\\n  node.right = deserialize(data);\\n  return node;\\n};\\n```\\n\\nSee more @ https://github.com/osdevisnot/leetcode",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet serialize = (root, result = []) => {\\n  if (root) {\\n    result.push(root.val);\\n    result.push(...serialize(root.left));\\n    result.push(...serialize(root.right));\\n  } else {\\n    result.push(null);\\n  }\\n  return result;\\n};\\n\\nlet deserialize = (data) => {\\n  let val = data.shift();\\n  if (val == null) return null;\\n  let node = new TreeNode(val);\\n  node.left = deserialize(data);\\n  node.right = deserialize(data);\\n  return node;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545174,
                "title": "c-level-order-serialization",
                "content": "We can use a queue serialize the tree level-by-level. If a child node is null, we just add a separator (instead of `null` or something to save space).\\n\\nFor example, this tree `[5,1,7,null,3,6,8,2,null,null]` will be serialized as `5,1,7,,3,6,8,2`.\\n\\n```cpp\\nstring serialize(TreeNode* root) {\\n    string res;\\n    vector<TreeNode*> q{root};\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            res += (n == nullptr ? \"\" : to_string(n->val)) + \",\";\\n            if (n != nullptr) {\\n                q1.push_back(n->left);\\n                q1.push_back(n->right);                    \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    while (!res.empty() && res.back() == \\',\\')\\n        res.pop_back();\\n    return res;\\n}\\nTreeNode* readNode(string& data, int &i) {\\n   string val;\\n   while (i < data.size() && data[i] != \\',\\')\\n        val += data[i++];\\n    ++i;\\n    return val.empty() ? nullptr : new TreeNode(stoi(val));\\n}\\nTreeNode* deserialize(string data) {\\n    TreeNode tmp;\\n    data = \",\" + data;\\n    vector<TreeNode*> q{&tmp};\\n    int i = 0;\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            if (n != nullptr) {\\n                q1.push_back(n->left = readNode(data, i));\\n                q1.push_back(n->right = readNode(data, i));                \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return tmp.right;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring serialize(TreeNode* root) {\\n    string res;\\n    vector<TreeNode*> q{root};\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            res += (n == nullptr ? \"\" : to_string(n->val)) + \",\";\\n            if (n != nullptr) {\\n                q1.push_back(n->left);\\n                q1.push_back(n->right);                    \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    while (!res.empty() && res.back() == \\',\\')\\n        res.pop_back();\\n    return res;\\n}\\nTreeNode* readNode(string& data, int &i) {\\n   string val;\\n   while (i < data.size() && data[i] != \\',\\')\\n        val += data[i++];\\n    ++i;\\n    return val.empty() ? nullptr : new TreeNode(stoi(val));\\n}\\nTreeNode* deserialize(string data) {\\n    TreeNode tmp;\\n    data = \",\" + data;\\n    vector<TreeNode*> q{&tmp};\\n    int i = 0;\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            if (n != nullptr) {\\n                q1.push_back(n->left = readNode(data, i));\\n                q1.push_back(n->right = readNode(data, i));                \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return tmp.right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426956,
                "title": "python-preorder-deque-solution-beats-98",
                "content": "```\\n\\tdef serialize(self, root):\\n        if not root:\\n            return \"X,\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        queue = collections.deque(data.split(\\',\\'))\\n        return self.deserializeHelper(queue)\\n    \\n    def deserializeHelper(self, queue):\\n        if queue:\\n            node = queue.popleft()\\n            if node == \\'X\\':\\n                return None\\n            new_node = TreeNode(node)\\n            new_node.left = self.deserializeHelper(queue)\\n            new_node.right = self.deserializeHelper(queue)\\n            return new_node",
                "solutionTags": [],
                "code": "```\\n\\tdef serialize(self, root):\\n        if not root:\\n            return \"X,\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        queue = collections.deque(data.split(\\',\\'))\\n        return self.deserializeHelper(queue)\\n    \\n    def deserializeHelper(self, queue):\\n        if queue:\\n            node = queue.popleft()\\n            if node == \\'X\\':\\n                return None\\n            new_node = TreeNode(node)\\n            new_node.left = self.deserializeHelper(queue)\\n            new_node.right = self.deserializeHelper(queue)\\n            return new_node",
                "codeTag": "Python3"
            },
            {
                "id": 887278,
                "title": "serialize-and-deserialize-bst-java-preorder-traversal",
                "content": "```\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        if(root==null) return \"\";\\n        \\n        List<String> data = new ArrayList<>();\\n        preorderTraversal(root, data);\\n        \\n        return String.join(\",\", data);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        \\n        if(data.length()==0) return null;\\n        \\n        String[] nodes= data.split(\",\");\\n        \\n        return convertPreorderTree( nodes, 0, nodes.length-1);\\n    }\\n    \\n    private void preorderTraversal(TreeNode root, List<String> data){\\n        \\n        if(root==null) return;\\n        \\n        data.add(\"\"+root.val);\\n        \\n        preorderTraversal(root.left, data);\\n        preorderTraversal(root.right, data);\\n    }\\n    \\n    private TreeNode convertPreorderTree(String[] preorder, int start, int end){\\n        \\n        if(start > end) return null;\\n        \\n        TreeNode node= new TreeNode(Integer.parseInt(preorder[start]));\\n        \\n        int i= start+1;\\n        while(i<=end && Integer.parseInt(preorder[i]) < Integer.parseInt(preorder[start])){\\n            i++;\\n        }\\n        \\n        node.left = convertPreorderTree(preorder, start+1, i-1);\\n        node.right = convertPreorderTree(preorder, i, end);\\n        \\n        return node;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        if(root==null) return \"\";\\n        \\n        List<String> data = new ArrayList<>();\\n        preorderTraversal(root, data);\\n        \\n        return String.join(\",\", data);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        \\n        if(data.length()==0) return null;\\n        \\n        String[] nodes= data.split(\",\");\\n        \\n        return convertPreorderTree( nodes, 0, nodes.length-1);\\n    }\\n    \\n    private void preorderTraversal(TreeNode root, List<String> data){\\n        \\n        if(root==null) return;\\n        \\n        data.add(\"\"+root.val);\\n        \\n        preorderTraversal(root.left, data);\\n        preorderTraversal(root.right, data);\\n    }\\n    \\n    private TreeNode convertPreorderTree(String[] preorder, int start, int end){\\n        \\n        if(start > end) return null;\\n        \\n        TreeNode node= new TreeNode(Integer.parseInt(preorder[start]));\\n        \\n        int i= start+1;\\n        while(i<=end && Integer.parseInt(preorder[i]) < Integer.parseInt(preorder[start])){\\n            i++;\\n        }\\n        \\n        node.left = convertPreorderTree(preorder, start+1, i-1);\\n        node.right = convertPreorderTree(preorder, i, end);\\n        \\n        return node;\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2411860,
                "title": "two-approaches-20ms-easy-0ms-object-oriented",
                "content": "Solution 1:\\n```\\npublic class Codec { // 20ms solution\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root==null)return \"#\";\\n        return root.val+\" \"+serialize(root.left)+\" \"+serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    String[] arr;int index;\\n    public TreeNode deserialize(String data) {\\n        arr=data.split(\" \");\\n        index=0;\\n        return go();\\n    }\\n    \\n    private TreeNode go() {\\n        int index=this.index++;\\n        if(arr[index].equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(arr[index]));\\n        root.left=go();\\n        root.right=go();\\n        return root;\\n    }\\n}\\n```\\n\\nSolution 2:\\n```\\npublic class Codec { // 0ms solution\\n    static TreeNode node;\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec { // 20ms solution\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root==null)return \"#\";\\n        return root.val+\" \"+serialize(root.left)+\" \"+serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    String[] arr;int index;\\n    public TreeNode deserialize(String data) {\\n        arr=data.split(\" \");\\n        index=0;\\n        return go();\\n    }\\n    \\n    private TreeNode go() {\\n        int index=this.index++;\\n        if(arr[index].equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(arr[index]));\\n        root.left=go();\\n        root.right=go();\\n        return root;\\n    }\\n}\\n```\n```\\npublic class Codec { // 0ms solution\\n    static TreeNode node;\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420020,
                "title": "using-preorder-traversal",
                "content": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        res = []\\n        \\n        def dfs(root):\\n            if not root:\\n                res.append(\\'N\\')\\n                return\\n            \\n            res.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        dfs(root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = data.split(\\',\\')\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \\'N\\':\\n                self.i += 1\\n                return None\\n            \\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            \\n            return node\\n        \\n        return dfs()\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        res = []\\n        \\n        def dfs(root):\\n            if not root:\\n                res.append(\\'N\\')\\n                return\\n            \\n            res.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        dfs(root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = data.split(\\',\\')\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \\'N\\':\\n                self.i += 1\\n                return None\\n            \\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            \\n            return node\\n        \\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887187,
                "title": "c-bfs-based-solution-explained-99-time-5-memory",
                "content": "I have to admit that I am still not great in all those tricks you can do with x-order traversals and then rebuild stuff using invariants. But I will get there; for now, I just wanted to have fun, so I went to solve it my own way, creating an encoding of comma-separated values (similar to how you build trees in LC\\'s input fields, just having empty strings instead of writing `\"null\"` there) on one hand and reading it on the others.\\n\\nTurned out my solution is still definitely efficient and can solve [a hard problem](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) without changing a single comma of it (okay, I admit before I set the value of empty nodes to `-1` and now I changed to `INT_MIN` to be compiant with the new rules, but that is about it).\\n\\nBut let\\'s proceed in order:\\n\\n## Encoding Part\\n\\nAs usual, edge cases out of the table first: if the tree is empty, we return just an empty string.\\n\\nIf not, we declare a few variables:\\n* `res`, a string initialised with the value of `root->val` converted to string;\\n* `len`, to store the length of our queue (more about it in just about one line!), initialised to `1` (since we know at least `root` is a valid node);\\n* `q`, a queue of `TreeNode` pointers, that we go and fill in immediately with `root`.\\n\\nThen we start with our BFS, which will loop as long as `len` is not `0`; inside, with another loop, we will keep removing the first `len` elements in front of the the queue and, for each one of them, we will:\\n* assign it to `root` (no need to create a new variable here);\\n* add a comma to `res`;\\n* if we have `root->left`, then we will:\\n\\t* add the stringified version of its value to `res`;\\n\\t* add the node itself to `q`;\\n* add another comma to `res`;\\n* if we have `root->right`, then we will:\\n\\t* add the stringified version of its value to `res`;\\n\\t* add the node itself to `q`.\\n\\nIf you try to proceed step-by-step, you will see that this will convert a starting tree to a format rather similar to the one used in LC\\'s custom inputs, just leaving an empty string where they put `\"null\"` as mentioned, to save space, and with possibly some extra trailing commas on the last level.\\n\\nIf you want to test yourself the logic with a non-trivial tree, try to put as a custom input `[100,90,110,80,95,105,115,70,null,null,98,104,106,null,200,60,75,null,99,null,null,null,107,116,201]` and it should give you back `\"100,90,110,80,95,105,115,70,,,98,104,106,,200,60,75,,99,,,,107,116,201,,,,,,,,,,,,\"`.\\n\\nOnce we are done, we can return `res` :)\\n\\n## Decoding Part\\n\\nSpecularly, first of all away with the edge cases: if the input string `ser` (short for \"serialised\", but also mirroring `res` above: how cool is that? Yeah, not much, but I am a simple man) is empty, we just return a `NULL` (=empty) tree.\\n\\nNow, support variables:\\n* `len`, similar to the one above, preset to `1` and used for the BFS approach;\\n* `nextVal`, where we will store what we read from each bit of serialisation;\\n* `root`, initialised with the first value read from the `ser` and our result variable, and `curr`, both `TreeNode` pointers;\\n* `q`, a queue of `TreeNode` pointers like the one above, initialised with `root`.\\n\\nEvery step of reading from the input string will be done using a class variable, `pos`, initialised to `0` and progressively incremented, and using the helper function `readString` that will take one character at a time (or no characters at all, for `NULL` nodes) to compose `res`, that will be then returned after being converted to a number (if not empty) or `INT_MIN` (if empty).\\n\\nIn our BFS, again same as above, we will loop until `len` is not `0` and internally we will extract at each round the first `len` nodes in front of `q`; I know here I could have just probably kept running until I had nodes in the queue, but I really enjoyed the symmetry of the 2 parts of the solution and I deem it important: elegant code is code that is more easily read, used and maintained.\\n\\nOr so I like to delude myself.\\n\\nAnyway, for each extracted node, we will:\\n* read from the input string `ser` and assign it to `nextVal`;\\n* if `nextVale` is not `INT_MIN`, we will then create a new `TreeNode` with that avalue, add it as a left branch to `curr` and push it into `q`;\\n* read again from the input string `s` and assign it to `nextVal`;\\n* if `nextVale` is not `INT_MIN`, we will then create a new `TreeNode` with that avalue, add it as a right branch to `curr` and push it into `q`,\\n\\nRinse and repeat until `q` is empty (`ser` will never be empty before it) and finally you can return `root` :)\\n\\nThe code:\\n\\n```cpp\\nclass Codec {\\npublic:\\n    // encoding logic\\n    string serialize(TreeNode* root) {\\n        // edge case out\\n        if (!root) return \"\";\\n        // support variables\\n        string res = to_string(root->val);\\n        int len = 1;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// BFS here!\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                root = q.front();\\n                q.pop();\\n                res += \\',\\';\\n                if (root->left) {\\n                    res += to_string(root->left->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->left);\\n                }\\n                res += \\',\\';\\n                if (root->right) {\\n                    res += to_string(root->right->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return res;\\n    }\\n    \\n    // decoding logic\\n    int pos = 0;\\n    int readString(string &s) {\\n        string tmp = \"\";\\n        while(pos < s.size() && s[pos] != \\',\\') tmp += s[pos++];\\n        pos++;\\n        return tmp.size() ? stoi(tmp) : INT_MIN;\\n    }\\n\\n    TreeNode* deserialize(string ser) {\\n        if (!ser.size()) return NULL;\\n        int len = 1, nextVal;\\n        TreeNode *root = new TreeNode(readString(ser)), *curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // adding left and right branches if present to both the tree and the queue\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->left = new TreeNode(nextVal);\\n                    q.push(curr->left);\\n                }\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->right = new TreeNode(nextVal);\\n                    q.push(curr->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Codec {\\npublic:\\n    // encoding logic\\n    string serialize(TreeNode* root) {\\n        // edge case out\\n        if (!root) return \"\";\\n        // support variables\\n        string res = to_string(root->val);\\n        int len = 1;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// BFS here!\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                root = q.front();\\n                q.pop();\\n                res += \\',\\';\\n                if (root->left) {\\n                    res += to_string(root->left->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->left);\\n                }\\n                res += \\',\\';\\n                if (root->right) {\\n                    res += to_string(root->right->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return res;\\n    }\\n    \\n    // decoding logic\\n    int pos = 0;\\n    int readString(string &s) {\\n        string tmp = \"\";\\n        while(pos < s.size() && s[pos] != \\',\\') tmp += s[pos++];\\n        pos++;\\n        return tmp.size() ? stoi(tmp) : INT_MIN;\\n    }\\n\\n    TreeNode* deserialize(string ser) {\\n        if (!ser.size()) return NULL;\\n        int len = 1, nextVal;\\n        TreeNode *root = new TreeNode(readString(ser)), *curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // adding left and right branches if present to both the tree and the queue\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->left = new TreeNode(nextVal);\\n                    q.push(curr->left);\\n                }\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->right = new TreeNode(nextVal);\\n                    q.push(curr->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201547,
                "title": "easy-to-understand-javascript-solution-84ms-beats-91",
                "content": "Serialize: push all nodes\\' value into an array in pre-order, and join them with \\',\\' or any non-numeric character\\n```\\nvar serialize = function(root) {\\n    if (root === null) return \\'\\';\\n    let result = [];\\n    serializeHelper(root, result);\\n    return result.join(\\',\\');\\n};\\n\\nconst serializeHelper = function(node, result) {\\n    if (node) {\\n        result.push(node.val);\\n        serializeHelper(node.left, result);\\n        serializeHelper(node.right, result);\\n    }\\n};\\n```\\nDeserialize: Split the data to get the pre-order array. Here we know two facts:\\n1. The input tree and all its sub-trees are BST, so all values from the left sub-tree are less than the value of root node, and all values from the right sub-tree are greater than the value of root node.\\n2. The array is a pre-order traversal of the tree, which means root always comes first, then left sub-tree (could be missing), then right sub-tree (could be missing).\\n\\nSo, the tree can be reconstructed by:\\n\\n1. Set array[0] as root and remove it from the array. \\n2. Check the new array[0]. It could be either root.left or root.right (when root.left is null). We can decide it by checking if array[0] is in the range of two sub-trees. These ranges are (currentLowerBound, root.val) and (root.val, currentUpperBound);\\n3. Do the same thing recursively to left and right subtree.\\n\\n```\\nvar deserialize = function(data) {\\n    if (!data) return null;\\n    const array = data.split(\\',\\');\\n    return deserializeHelper(array, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\\n};\\n\\nconst deserializeHelper = function(array, min, max) {\\n    if (array.length === 0) return null;\\n    let val = +array[0];\\n    if (val < min || val > max) return null;\\n    array.shift();\\n    let root = new TreeNode(val);\\n    root.left = deserializeHelper(array, min, val);\\n    root.right = deserializeHelper(array, val, max);\\n    return root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar serialize = function(root) {\\n    if (root === null) return \\'\\';\\n    let result = [];\\n    serializeHelper(root, result);\\n    return result.join(\\',\\');\\n};\\n\\nconst serializeHelper = function(node, result) {\\n    if (node) {\\n        result.push(node.val);\\n        serializeHelper(node.left, result);\\n        serializeHelper(node.right, result);\\n    }\\n};\\n```\n```\\nvar deserialize = function(data) {\\n    if (!data) return null;\\n    const array = data.split(\\',\\');\\n    return deserializeHelper(array, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\\n};\\n\\nconst deserializeHelper = function(array, min, max) {\\n    if (array.length === 0) return null;\\n    let val = +array[0];\\n    if (val < min || val > max) return null;\\n    array.shift();\\n    let root = new TreeNode(val);\\n    root.left = deserializeHelper(array, min, val);\\n    root.right = deserializeHelper(array, val, max);\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847876,
                "title": "golang-bfs-solution-o-n",
                "content": "```\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    var queue []*TreeNode\\n\\n\\tenqueue(&queue, root)\\n\\n\\tvar result string\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tdequeuedElement := dequeue(&queue)\\n\\n\\t\\tif dequeuedElement != nil {\\n\\t\\t\\tresult = result + fmt.Sprintf(\"%v\", dequeuedElement.Val) + \",\"\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Left)\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Right)\\n\\t\\t} else {\\n\\t\\t\\tresult = result + \"nil\" + \",\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[:len(result)-1]\\n}\\n\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    splittedData := strings.Split(data, \",\")\\n\\n\\tvar result []*TreeNode\\n\\n\\tfor _, num := range splittedData {\\n\\t\\tif num == \"nil\" {\\n\\t\\t\\tresult = append(result, nil)\\n\\t\\t} else {\\n\\t\\t\\titem := TreeNode{\\n\\t\\t\\t\\tVal: toInt(num),\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = append(result, &item)\\n\\t\\t}\\n\\t}\\n    \\n    begin := 0\\n    \\n\\tfor _, node := range result {\\n\\t\\tif node == nil {\\n            continue\\n\\t\\t} else {\\n\\t\\t\\tleft := 2 * begin + 1\\n\\t\\t\\tright := 2 * begin + 2\\n\\n\\t\\t\\tif left < len(result) {\\n\\t\\t\\t\\tnode.Left = result[left]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif right < len(result) {\\n\\t\\t\\t\\tnode.Right = result[right]\\n\\t\\t\\t}\\n            \\n            begin++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[0]\\n}\\n\\nfunc enqueue(queue *[]*TreeNode, newItem *TreeNode) {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\t*queue = append(*queue, newItem)\\n}\\n\\nfunc dequeue(queue *[]*TreeNode) *TreeNode {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*queue) == 0 {\\n\\t\\tpanic(\"empty queue\")\\n\\t}\\n\\n\\tdequeuedElement := (*queue)[0]\\n\\n\\t*queue = (*queue)[1:len(*queue)]\\n\\n\\treturn dequeuedElement\\n}\\n\\nfunc toInt(s string) int {\\n\\tvalue, err := strconv.Atoi(s)\\n\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\n\\treturn value\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    var queue []*TreeNode\\n\\n\\tenqueue(&queue, root)\\n\\n\\tvar result string\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tdequeuedElement := dequeue(&queue)\\n\\n\\t\\tif dequeuedElement != nil {\\n\\t\\t\\tresult = result + fmt.Sprintf(\"%v\", dequeuedElement.Val) + \",\"\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Left)\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Right)\\n\\t\\t} else {\\n\\t\\t\\tresult = result + \"nil\" + \",\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[:len(result)-1]\\n}\\n\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    splittedData := strings.Split(data, \",\")\\n\\n\\tvar result []*TreeNode\\n\\n\\tfor _, num := range splittedData {\\n\\t\\tif num == \"nil\" {\\n\\t\\t\\tresult = append(result, nil)\\n\\t\\t} else {\\n\\t\\t\\titem := TreeNode{\\n\\t\\t\\t\\tVal: toInt(num),\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = append(result, &item)\\n\\t\\t}\\n\\t}\\n    \\n    begin := 0\\n    \\n\\tfor _, node := range result {\\n\\t\\tif node == nil {\\n            continue\\n\\t\\t} else {\\n\\t\\t\\tleft := 2 * begin + 1\\n\\t\\t\\tright := 2 * begin + 2\\n\\n\\t\\t\\tif left < len(result) {\\n\\t\\t\\t\\tnode.Left = result[left]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif right < len(result) {\\n\\t\\t\\t\\tnode.Right = result[right]\\n\\t\\t\\t}\\n            \\n            begin++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[0]\\n}\\n\\nfunc enqueue(queue *[]*TreeNode, newItem *TreeNode) {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\t*queue = append(*queue, newItem)\\n}\\n\\nfunc dequeue(queue *[]*TreeNode) *TreeNode {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*queue) == 0 {\\n\\t\\tpanic(\"empty queue\")\\n\\t}\\n\\n\\tdequeuedElement := (*queue)[0]\\n\\n\\t*queue = (*queue)[1:len(*queue)]\\n\\n\\treturn dequeuedElement\\n}\\n\\nfunc toInt(s string) int {\\n\\tvalue, err := strconv.Atoi(s)\\n\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\n\\treturn value\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886165,
                "title": "java-solution-with-explanation-using-an-example-for-better-understanding-queue-preorder",
                "content": "**EXPLANATION**\\n\\nTaking Example 1 of the question: ***BST = [2, 1, 3]***\\n\\n1. **SERIALIZE / ENCODE**: Use **Preorder Traversal** to serialize the BST where each node value is separated by a comma (**\",\"**).  So after serialization of the above tree, we will return a string like this: **2,1,3**.\\n\\n2. **DESERIALIZE / DECODE**: Here comes the importance of using **Preorder Traversal** in the above step.  By doing this, we ensured that all the parent nodes (roots) come before the children nodes *(all **left** nodes followed by all **right** nodes)*.  So all we have to do now is **Add** all the nodes in the string into a **Queue** and keep creating the tree node-by-node.  For this, the steps are:\\n\\ni) Repeat the below steps until **queue** is not empty.\\nii) Pop out a node from the front of the queue.  If the node is not null, then create a new node by using it\\'s value.\\niii) Recursively call the *Deserialize Function* to store all the **left children** first and then again to store all the **right children** of a particular node.\\niv) Return the node.\\n\\n*For example, our serialized string was **2,1,3***.  So we add them in the queue one-by-one.  So our **queue** looks like **[2,1,3]**.\\n\\nNow, popping **2** from the queue, we are left with **[1,3]**.\\n\\nRecursively call the function to store its left child.  New node is **1**, and both its **left child** and **right child** will be stored as null in the next two recursive calls.  So **1** gets stored as the **Left Child** of node **2**.  Similarly, **3** gets stored as the **Right Child** of node **2**.\\n\\nIn the end, we return node **2** which is the root of the deserialized tree. That\\'s it and you have your deserialized tree.\\n\\n*------Please **upvote** if you liked the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize (TreeNode root) {\\n        if (root == null)\\n            return \"\";\\n        return String.valueOf (root.val) + \",\" + serialize (root.left) + \",\" + serialize (root.right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize (String data) {\\n        String S [] = data.split (\",\");\\n        Queue <String> queue = new LinkedList ();\\n        for (String s: S)\\n            queue.add (s);\\n        return deserializeUtil (queue);\\n    }\\n    \\n    public TreeNode deserializeUtil (Queue <String> queue) {\\n        while (!queue.isEmpty ()) {\\n            String s = queue.poll ();\\n            if (s.equals (\"\"))\\n                return null;\\n            TreeNode node = new TreeNode (Integer.valueOf (s));\\n            node.left = deserializeUtil (queue);\\n            node.right = deserializeUtil (queue);\\n            return node;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize (TreeNode root) {\\n        if (root == null)\\n            return \"\";\\n        return String.valueOf (root.val) + \",\" + serialize (root.left) + \",\" + serialize (root.right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize (String data) {\\n        String S [] = data.split (\",\");\\n        Queue <String> queue = new LinkedList ();\\n        for (String s: S)\\n            queue.add (s);\\n        return deserializeUtil (queue);\\n    }\\n    \\n    public TreeNode deserializeUtil (Queue <String> queue) {\\n        while (!queue.isEmpty ()) {\\n            String s = queue.poll ();\\n            if (s.equals (\"\"))\\n                return null;\\n            TreeNode node = new TreeNode (Integer.valueOf (s));\\n            node.left = deserializeUtil (queue);\\n            node.right = deserializeUtil (queue);\\n            return node;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208589,
                "title": "java-o-n-iterative-no-nulls",
                "content": "The whole point of this question is to use the BST property to at get rid of nulls in your serialized string (Question #297). Anything less is a suboptimal solution.\\n\\n  - To Serialize just do an iterative pre-order traversal. (in real world, recursive can stack overflow if BST is unbalanced)\\n  - To Deserialize:\\n\\t  - if next node is smaller then parent just (left) add to parent.\\n\\t  - if next node is larger then parent pop the stack until you find the largest parent you can (right) add to.\\n\\t  - finally stack the next node as a candidate parent.\\n\\nEach node gets in and out of stack only once, so time complexity `O(n)`, and the serialized string has no nulls, or markers only the nodes.\\n\\n```java\\n    public String serialize(TreeNode n) {\\n        if (n == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        while (n!=null) {\\n            sb.append(n.val).append(\",\");\\n            if (n.right != null) stack.push(n.right);\\n            n = (n.left == null && !stack.isEmpty()) ? stack.pop() : n.left;\\n        }\\n        sb.setLength(sb.length()-1);\\n        return sb.toString();\\n    }\\n\\n    public TreeNode deserialize(String s) {\\n        if (\"\".equals(s)) return null;\\n        String[] tokens = s.split(\",\");\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode head = new TreeNode(Integer.valueOf(tokens[0]));\\n        stack.push(head);\\n        \\n        for (int i=1;i<tokens.length;i++) {\\n            \\n            TreeNode parent = stack.peek();\\n            TreeNode next = new TreeNode(Integer.valueOf(tokens[i]));\\n            \\n            if (next.val < parent.val) parent.left = next;\\n            else {\\n                parent = stack.pop();\\n                while (!stack.isEmpty() && next.val > stack.peek().val) parent = stack.pop();\\n                parent.right = next;\\n            }\\n            stack.push(next);\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public String serialize(TreeNode n) {\\n        if (n == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        while (n!=null) {\\n            sb.append(n.val).append(\",\");\\n            if (n.right != null) stack.push(n.right);\\n            n = (n.left == null && !stack.isEmpty()) ? stack.pop() : n.left;\\n        }\\n        sb.setLength(sb.length()-1);\\n        return sb.toString();\\n    }\\n\\n    public TreeNode deserialize(String s) {\\n        if (\"\".equals(s)) return null;\\n        String[] tokens = s.split(\",\");\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode head = new TreeNode(Integer.valueOf(tokens[0]));\\n        stack.push(head);\\n        \\n        for (int i=1;i<tokens.length;i++) {\\n            \\n            TreeNode parent = stack.peek();\\n            TreeNode next = new TreeNode(Integer.valueOf(tokens[i]));\\n            \\n            if (next.val < parent.val) parent.left = next;\\n            else {\\n                parent = stack.pop();\\n                while (!stack.isEmpty() && next.val > stack.peek().val) parent = stack.pop();\\n                parent.right = next;\\n            }\\n            stack.push(next);\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93181,
                "title": "preorder-serialize-and-recursive-deserialize-c-26ms",
                "content": "```\\nclass Codec {\\npublic:\\n    //Encodes a tree to a single string.\\n    void serialize(TreeNode* root, vector<int> &val)\\n    {\\n        if(root == NULL) return;\\n        val.push_back(root->val);\\n        serialize(root->left, val);\\n        serialize(root->right, val);\\n    }\\n\\n    string serialize(TreeNode* root) {\\n        vector<int> val;\\n        serialize(root, val);\\n        char *p = (char*)val.data();\\n        string str(p, val.size() * sizeof(int));\\n        return str;\\n    }\\n    \\n    // deserialize val[l .. r]\\n    TreeNode* deserializeSubtree(int *val, int l, int r)\\n    {\\n        if(l > r) return NULL;\\n        TreeNode *subRoot = new TreeNode(val[l]);\\n        int i = l+1;\\n        while(i <= r && val[i] < val[l]) ++i; \\n        subRoot->left = deserializeSubtree(val, l+1, i-1);\\n        subRoot->right = deserializeSubtree(val, i, r);\\n        return subRoot;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        //preorder traversed string\\n        int n = data.size() / sizeof(int);\\n        TreeNode *root = deserializeSubtree((int*)data.data(), 0, n-1);\\n        return root;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n    //Encodes a tree to a single string.\\n    void serialize(TreeNode* root, vector<int> &val)\\n    {\\n        if(root == NULL) return;\\n        val.push_back(root->val);\\n        serialize(root->left, val);\\n        serialize(root->right, val);\\n    }\\n\\n    string serialize(TreeNode* root) {\\n        vector<int> val;\\n        serialize(root, val);\\n        char *p = (char*)val.data();\\n        string str(p, val.size() * sizeof(int));\\n        return str;\\n    }\\n    \\n    // deserialize val[l .. r]\\n    TreeNode* deserializeSubtree(int *val, int l, int r)\\n    {\\n        if(l > r) return NULL;\\n        TreeNode *subRoot = new TreeNode(val[l]);\\n        int i = l+1;\\n        while(i <= r && val[i] < val[l]) ++i; \\n        subRoot->left = deserializeSubtree(val, l+1, i-1);\\n        subRoot->right = deserializeSubtree(val, i, r);\\n        return subRoot;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        //preorder traversed string\\n        int n = data.size() / sizeof(int);\\n        TreeNode *root = deserializeSubtree((int*)data.data(), 0, n-1);\\n        return root;\\n    }\\n    \\n};",
                "codeTag": "Java"
            },
            {
                "id": 2674576,
                "title": "c-preorder-traversal-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197492,
                "title": "simple-c-code-preorder-traversal-queue-easy-to-understand",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        queue<string> q;\\n        string s=\"\";\\n        for(int i=0;i<data.size();i++){\\n            if(data[i]==\\',\\'){\\n                q.push(s);\\n                s=\"\";\\n                continue;\\n            }\\n            s+=data[i];\\n        }\\n        return helper(q);\\n    }\\n    \\n    TreeNode* helper(queue<string> &q){\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=helper(q);\\n        root->right=helper(q);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        queue<string> q;\\n        string s=\"\";\\n        for(int i=0;i<data.size();i++){\\n            if(data[i]==\\',\\'){\\n                q.push(s);\\n                s=\"\";\\n                continue;\\n            }\\n            s+=data[i];\\n        }\\n        return helper(q);\\n    }\\n    \\n    TreeNode* helper(queue<string> &q){\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=helper(q);\\n        root->right=helper(q);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094710,
                "title": "simple-c-solution-comment-your-thoughts-time-and-space-o-n",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root){\\n            return \"NULL\";\\n        }\\n        \\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        \\n        return to_string(root->val) + \" \" + left + \" \" + right;\\n    }\\n    \\n    TreeNode* helper_des(stringstream& ss, string s) {\\n        ss >> s;\\n        if(s == \"NULL\"){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(stoi(s));\\n        \\n        root->left = helper_des(ss, s);\\n        root->right = helper_des(ss, s);\\n        \\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        return helper_des(ss, \"\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root){\\n            return \"NULL\";\\n        }\\n        \\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        \\n        return to_string(root->val) + \" \" + left + \" \" + right;\\n    }\\n    \\n    TreeNode* helper_des(stringstream& ss, string s) {\\n        ss >> s;\\n        if(s == \"NULL\"){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(stoi(s));\\n        \\n        root->left = helper_des(ss, s);\\n        root->right = helper_des(ss, s);\\n        \\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        return helper_des(ss, \"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091281,
                "title": "easy-java-solution-using-bst-property-similiar-to-validating-bst-problem",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    int serializedTreeIndexPointer;\\n    public String serialize(TreeNode root) {\\n      StringBuilder serializedTree = new StringBuilder();\\n      preorder(root, serializedTree);\\n      return serializedTree.toString();\\n    }\\n    \\n   void preorder(TreeNode root, StringBuilder serializedTree) {\\n       if (root == null) {\\n          return;\\n       }\\n\\n        serializedTree.append(root.val).append(\",\");\\n        preorder(root.left, serializedTree);\\n        preorder(root.right, serializedTree);\\n   }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String serializedTree) {\\n        serializedTreeIndexPointer = 0;\\n        String serializedArray[] = serializedTree.split(\",\");\\n        return treeBuilder(serializedArray, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n\\n    }\\n    \\n    TreeNode treeBuilder(String serializedArray[], int min, int max) {\\n        if (serializedTreeIndexPointer >= serializedArray.length)\\n            return null;\\n        \\n        Integer a = parseStringToInt(serializedArray[serializedTreeIndexPointer]);\\n         if ( a == null || a > max || a < min) {\\n          return null;\\n         }\\n\\n       TreeNode root = new TreeNode(Integer.parseInt(serializedArray[serializedTreeIndexPointer++]));\\n       root.left = treeBuilder(serializedArray, min, root.val);\\n       root.right = treeBuilder(serializedArray, root.val, max);\\n        \\n       return root;\\n    }\\n    \\n    Integer parseStringToInt(String s) {\\n        try {\\n          return Integer.parseInt(s);\\n        }\\n        catch (NumberFormatException e) {\\n            return null;}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    int serializedTreeIndexPointer;\\n    public String serialize(TreeNode root) {\\n      StringBuilder serializedTree = new StringBuilder();\\n      preorder(root, serializedTree);\\n      return serializedTree.toString();\\n    }\\n    \\n   void preorder(TreeNode root, StringBuilder serializedTree) {\\n       if (root == null) {\\n          return;\\n       }\\n\\n        serializedTree.append(root.val).append(\",\");\\n        preorder(root.left, serializedTree);\\n        preorder(root.right, serializedTree);\\n   }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String serializedTree) {\\n        serializedTreeIndexPointer = 0;\\n        String serializedArray[] = serializedTree.split(\",\");\\n        return treeBuilder(serializedArray, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n\\n    }\\n    \\n    TreeNode treeBuilder(String serializedArray[], int min, int max) {\\n        if (serializedTreeIndexPointer >= serializedArray.length)\\n            return null;\\n        \\n        Integer a = parseStringToInt(serializedArray[serializedTreeIndexPointer]);\\n         if ( a == null || a > max || a < min) {\\n          return null;\\n         }\\n\\n       TreeNode root = new TreeNode(Integer.parseInt(serializedArray[serializedTreeIndexPointer++]));\\n       root.left = treeBuilder(serializedArray, min, root.val);\\n       root.right = treeBuilder(serializedArray, root.val, max);\\n        \\n       return root;\\n    }\\n    \\n    Integer parseStringToInt(String s) {\\n        try {\\n          return Integer.parseInt(s);\\n        }\\n        catch (NumberFormatException e) {\\n            return null;}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887438,
                "title": "python3-solution-explained-video-code-inorder-preorder",
                "content": "[](https://www.youtube.com/watch?v=g6Q1cpQvz8A)\\nhttps://www.youtube.com/watch?v=g6Q1cpQvz8A\\n```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        res = []\\n        \\n        def preorder(root):\\n            if root:\\n                res.append(str(root.val))\\n                preorder(root.left)\\n                preorder(root.right)\\n        \\n        preorder(root)\\n        return \" \".join(res)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        data = [int(x) for x in data.split()]\\n        \\n        def build(pre, inorder):\\n            if not pre:\\n                return None\\n            \\n            node = TreeNode(pre[0])\\n            temp = inorder.index(node.val)\\n            node.left = build(pre[1: temp + 1], inorder[:temp])\\n            node.right = build(pre[temp + 1 :], inorder[temp + 1 :])\\n            \\n            return node\\n        \\n        return build(data, sorted(data))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        res = []\\n        \\n        def preorder(root):\\n            if root:\\n                res.append(str(root.val))\\n                preorder(root.left)\\n                preorder(root.right)\\n        \\n        preorder(root)\\n        return \" \".join(res)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        data = [int(x) for x in data.split()]\\n        \\n        def build(pre, inorder):\\n            if not pre:\\n                return None\\n            \\n            node = TreeNode(pre[0])\\n            temp = inorder.index(node.val)\\n            node.left = build(pre[1: temp + 1], inorder[:temp])\\n            node.right = build(pre[temp + 1 :], inorder[temp + 1 :])\\n            \\n            return node\\n        \\n        return build(data, sorted(data))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886209,
                "title": "python-recursion",
                "content": "Serialize the pre-order traversal into a string. Reconstruct from this representation. Both functions can be implemented by recursion.\\n\\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        s1 = self.serialize(root.left)\\n        s2 = self.serialize(root.right)\\n        ret = str(root.val)\\n        if s1: ret += \\' \\' + s1\\n        if s2: ret += \\' \\' + s2\\n        return ret\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return []\\n        def recur(arr):\\n            this = TreeNode(arr[0])\\n            left = [e for e in arr[1:] if e<arr[0]]\\n            right = [e for e in arr[1:] if e>arr[0]]\\n            if left: this.left = recur(left)\\n            if right: this.right = recur(right)\\n            return this\\n        arr = data.strip().split(\\' \\')\\n        arr = [int(e) for e in arr]\\n        return recur(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        s1 = self.serialize(root.left)\\n        s2 = self.serialize(root.right)\\n        ret = str(root.val)\\n        if s1: ret += \\' \\' + s1\\n        if s2: ret += \\' \\' + s2\\n        return ret\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return []\\n        def recur(arr):\\n            this = TreeNode(arr[0])\\n            left = [e for e in arr[1:] if e<arr[0]]\\n            right = [e for e in arr[1:] if e>arr[0]]\\n            if left: this.left = recur(left)\\n            if right: this.right = recur(right)\\n            return this\\n        arr = data.strip().split(\\' \\')\\n        arr = [int(e) for e in arr]\\n        return recur(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733367,
                "title": "c-custom-low-level-data-mapping-no-strings-no-recursion-no-built-in-ds-simple-n-short",
                "content": "**Context :** This solution of mine uses a custom low-level raw data mapping representaion. There is no string parsing involved, no recursive approach is being used, and no built-in Data Structures are used. I have kept this code like all of my other published code as barebone C code as possible.\\n\\n**Details :** Before arriving at below custom data representation, I gave the string approach a try and was way slower due to the overhead in parsing, etc. So, I decided to redesign this in terms of my own custom data representation. In this representation, each of the node\\'s address\\'s LS-16bits act as key which get mapped onto unique 1-indexed numbers. These mapped indexes are then used as offsets for each of those nodes. Each node will refer to its child nodes using those offsets. Each node in the sequence of such nodes will hold the value of a specific node and its left-child-off and right-child-off. It took considerable time to get to this far but I feel it\\'s totally worth it!\\n\\n**NOTE :** My below solution works for both BST and Binary Tree as there is no dependency on the structure or organization of the nodes or values therin. Just choose the key/mask width as per the address-range(LS-bits) of node addresses. As I observed, for the other Binary Tree case, I had to consider at least 17 lower bits of node addresses for their unique mapping whereas for the below BST, 16 lower bits were sufficient. Hence, I use appropriate width for key type as uint32_t(for 17-bits case) and uint16_t(for 16-bits case) controlled by WIDE_RANGE feature macro.\\n\\n```\\n//#define WIDE_RANGE\\n\\n#ifdef WIDE_RANGE\\n#define KEY_MASK    0x1ffff\\ntypedef uint32_t keyy_t;\\n#else\\n#define KEY_MASK    0xffff\\ntypedef uint16_t keyy_t;\\n#endif // WIDE_RANGE\\n\\n#define KEY(a)      ((uintptr_t)(a) & KEY_MASK)\\n\\nstruct srlz_data {\\n    int val;\\n    keyy_t loff, roff;   \\n} __attribute__ ((packed));\\n\\nstruct srlz {\\n    size_t sz; // To help on-disk storage/retrieval, etc\\n    size_t n;\\n    struct srlz_data z[100000];\\n} __attribute__ ((packed));\\n    \\nchar* serialize(struct TreeNode* root) {\\n    int of[KEY_MASK] = { 0 }, i = 1, k;\\n    struct TreeNode *n[10000] = { root };\\n    struct srlz *d = malloc(sizeof *d);\\n    struct srlz_data *z = d->z;\\n    d->sz = sizeof *d;\\n    of[KEY(root)] = i++;        \\n    for (int f = 0, b = 1 ; root && f < b ; f++) {\\n        z[of[k = KEY(n[f])]].val = n[f]->val;\\n        z[of[k]].loff = n[f]->left ? of[KEY(n[b++] = n[f]->left)] = i++ : 0;\\n        z[of[k]].roff = n[f]->right ? of[KEY(n[b++] = n[f]->right)] = i++ : 0;\\n    }\\n    return d->n = root ? i : 0, (char *)d;\\n}\\n\\nstruct TreeNode* deserialize(char* data) {\\n    struct srlz *d = (void *)data;\\n    struct srlz_data *z = d->z + 1;\\n    size_t c = d->n;\\n    struct TreeNode *n[100000] = { [1] = c ? malloc(sizeof **n) : NULL };\\n    for (int i = 1 ; i < c ; n[i++]->val = z++->val) {\\n        n[i]->left = z->loff ? n[z->loff] = malloc(sizeof **n) : NULL;\\n        n[i]->right = z->roff ? n[z->roff] = malloc(sizeof **n) : NULL;\\n    }\\n    return n[1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//#define WIDE_RANGE\\n\\n#ifdef WIDE_RANGE\\n#define KEY_MASK    0x1ffff\\ntypedef uint32_t keyy_t;\\n#else\\n#define KEY_MASK    0xffff\\ntypedef uint16_t keyy_t;\\n#endif // WIDE_RANGE\\n\\n#define KEY(a)      ((uintptr_t)(a) & KEY_MASK)\\n\\nstruct srlz_data {\\n    int val;\\n    keyy_t loff, roff;   \\n} __attribute__ ((packed));\\n\\nstruct srlz {\\n    size_t sz; // To help on-disk storage/retrieval, etc\\n    size_t n;\\n    struct srlz_data z[100000];\\n} __attribute__ ((packed));\\n    \\nchar* serialize(struct TreeNode* root) {\\n    int of[KEY_MASK] = { 0 }, i = 1, k;\\n    struct TreeNode *n[10000] = { root };\\n    struct srlz *d = malloc(sizeof *d);\\n    struct srlz_data *z = d->z;\\n    d->sz = sizeof *d;\\n    of[KEY(root)] = i++;        \\n    for (int f = 0, b = 1 ; root && f < b ; f++) {\\n        z[of[k = KEY(n[f])]].val = n[f]->val;\\n        z[of[k]].loff = n[f]->left ? of[KEY(n[b++] = n[f]->left)] = i++ : 0;\\n        z[of[k]].roff = n[f]->right ? of[KEY(n[b++] = n[f]->right)] = i++ : 0;\\n    }\\n    return d->n = root ? i : 0, (char *)d;\\n}\\n\\nstruct TreeNode* deserialize(char* data) {\\n    struct srlz *d = (void *)data;\\n    struct srlz_data *z = d->z + 1;\\n    size_t c = d->n;\\n    struct TreeNode *n[100000] = { [1] = c ? malloc(sizeof **n) : NULL };\\n    for (int i = 1 ; i < c ; n[i++]->val = z++->val) {\\n        n[i]->left = z->loff ? n[z->loff] = malloc(sizeof **n) : NULL;\\n        n[i]->right = z->roff ? n[z->roff] = malloc(sizeof **n) : NULL;\\n    }\\n    return n[1];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 494967,
                "title": "javascript-solution-preorder",
                "content": "### The idea\\n1. Utilize the fact BST can be reconstructed from preorder/postorder array\\n``` javascript\\nvar serialize = function(root) {\\n    let preorder = [];\\n    let dfs = function(node) {\\n        if (node==null) return;\\n        preorder.push(node.val);\\n        dfs(node.left);\\n        dfs(node.right);\\n    }\\n    dfs(root);\\n    return preorder.join(\\',\\');\\n};\\n\\n var deserialize = function(data) {\\n    if (data == \\'\\') return null;\\n    let preorder = data.split(\\',\\');\\n    let recur = function(lower, upper) {\\n        if (Number(preorder[0]) < lower || Number(preorder[0]) > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar serialize = function(root) {\\n    let preorder = [];\\n    let dfs = function(node) {\\n        if (node==null) return;\\n        preorder.push(node.val);\\n        dfs(node.left);\\n        dfs(node.right);\\n    }\\n    dfs(root);\\n    return preorder.join(\\',\\');\\n};\\n\\n var deserialize = function(data) {\\n    if (data == \\'\\') return null;\\n    let preorder = data.split(\\',\\');\\n    let recur = function(lower, upper) {\\n        if (Number(preorder[0]) < lower || Number(preorder[0]) > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165387,
                "title": "recursive-preorder-python-solution-20-lines",
                "content": "```\\nclass Codec:\\n    \\n    def serialize(self, root):\\n        if not root: return\\n        def serializeTree(node):\\n            if not node:\\n                return \\'null\\'\\n            return str(node.val) + \",\" + serializeTree(node.left) + \",\" + serializeTree(node.right)\\n        return serializeTree(root)\\n        \\n\\n    def deserialize(self, data):\\n        if not data: return \\n        def deserializeTree(a, i):\\n            if i >= len(a) or a[i] == \\'null\\': \\n                return [None, i + 1]\\n            else:\\n                node = TreeNode(a[i])\\n                node.left, j = deserializeTree(a, i + 1)\\n                node.right, j = deserializeTree(a, j) \\n                return [node, j]\\n        return deserializeTree(data.split(\\',\\'), 0)[0]",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    \\n    def serialize(self, root):\\n        if not root: return\\n        def serializeTree(node):\\n            if not node:\\n                return \\'null\\'\\n            return str(node.val) + \",\" + serializeTree(node.left) + \",\" + serializeTree(node.right)\\n        return serializeTree(root)\\n        \\n\\n    def deserialize(self, data):\\n        if not data: return \\n        def deserializeTree(a, i):\\n            if i >= len(a) or a[i] == \\'null\\': \\n                return [None, i + 1]\\n            else:\\n                node = TreeNode(a[i])\\n                node.left, j = deserializeTree(a, i + 1)\\n                node.right, j = deserializeTree(a, j) \\n                return [node, j]\\n        return deserializeTree(data.split(\\',\\'), 0)[0]",
                "codeTag": "Java"
            },
            {
                "id": 93212,
                "title": "simple-python-preorder",
                "content": "In ```serialize``` step we do a preorder traversal to get the string. For reconstructing the BST, ```l``` and ```r``` are the left and right boundaries of our ```current``` array. Since it's preorder traversal, for root value ```A[l]```, once we find the first point ```A[mid] < A[l]```, we know all values from this point until the right boundary are for the right subtree, and points before that until left boundary are the left subtree.\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def preorder(node):\\n            if node:\\n                res.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        res = []\\n        preorder(root)\\n        return \" \".join(res)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(l, r):\\n            if l >= r: return None\\n            root = TreeNode(A[l])\\n            mid = l+1\\n            while mid < r and A[mid] < root.val: mid += 1\\n            root.left = build(l+1, mid)\\n            root.right = build(mid, r)\\n            return root\\n            \\n        A = map(int, data.split())\\n        return build(0, len(A))\\n```",
                "solutionTags": [],
                "code": "```serialize```\n```l```\n```r```\n```current```\n```A[l]```\n```A[mid] < A[l]```\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def preorder(node):\\n            if node:\\n                res.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        res = []\\n        preorder(root)\\n        return \" \".join(res)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(l, r):\\n            if l >= r: return None\\n            root = TreeNode(A[l])\\n            mid = l+1\\n            while mid < r and A[mid] < root.val: mid += 1\\n            root.left = build(l+1, mid)\\n            root.right = build(mid, r)\\n            return root\\n            \\n        A = map(int, data.split())\\n        return build(0, len(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93261,
                "title": "java-o-n-recursive-solution",
                "content": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"*.\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val);\\n        if (root.left == null && root.right == null) {\\n            sb.append(\"*.\");\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        int[] begin = {0};\\n        return deserializeMethod(data, begin);\\n    }\\n\\n    private TreeNode deserializeMethod(String data, int[] begin) {\\n        int index = data.indexOf(\".\", begin[0]);\\n        TreeNode node = null;\\n        if (data.charAt(index - 1) == '*') {\\n            String str = data.substring(begin[0], index - 1);\\n            begin[0] = index + 1;\\n            if (str.equals(\"\")) {\\n                return null;\\n            }\\n            node = new TreeNode(Integer.parseInt(str));\\n        } else {\\n            String str = data.substring(begin[0], index);\\n            begin[0] = index + 1;\\n            node = new TreeNode(Integer.parseInt(str));\\n            node.left = deserializeMethod(data, begin);\\n            node.right = deserializeMethod(data, begin);\\n        }\\n        return node;\\n    }",
                "solutionTags": [],
                "code": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"*.\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val);\\n        if (root.left == null && root.right == null) {\\n            sb.append(\"*.\");\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        int[] begin = {0};\\n        return deserializeMethod(data, begin);\\n    }\\n\\n    private TreeNode deserializeMethod(String data, int[] begin) {\\n        int index = data.indexOf(\".\", begin[0]);\\n        TreeNode node = null;\\n        if (data.charAt(index - 1) == '*') {\\n            String str = data.substring(begin[0], index - 1);\\n            begin[0] = index + 1;\\n            if (str.equals(\"\")) {\\n                return null;\\n            }\\n            node = new TreeNode(Integer.parseInt(str));\\n        } else {\\n            String str = data.substring(begin[0], index);\\n            begin[0] = index + 1;\\n            node = new TreeNode(Integer.parseInt(str));\\n            node.left = deserializeMethod(data, begin);\\n            node.right = deserializeMethod(data, begin);\\n        }\\n        return node;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 93265,
                "title": "2-concise-java-solutions-o-n-and-o-n2-with-using-bst-s-feature-not-the-old-generic-solution-for-binary-tree",
                "content": "**Idea:**\\nWe are given a BST, so it is possible to **reconstruct the tree by using Pre-Order traverse array**.\\n\\n*Notice we have 1 requirement \"The encoded string should be as compact as possible.\" So let us forget the generic BFS/DFS solution for Binary Tree (Adding \"#\" or \"NULL\" for empty node)*\\n\\n\\nSerialize:\\nVery straightforward, simplify do a pre-order traverse and append to String.\\n\\n* Version 1: Two lines\\n```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n```\\n\\n* Version 2: Use StringBuilder to save a little bit time.\\n```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val).append(\",\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n```\\n\\nDeserialize\\nSince we have a pre-order array. We always know the **first element is the root**. \\nSo our strategy is to cut the array into different parts by appyling BST feature.\\n\\n* Version 1:  O(N2)\\n1.Passing start bound and end bound to helper function, which means to reconstruct tree in this scope (start ~ end).\\n2.Find the first element larger than current root, the first element index will be the middle cutting point. Which means all elements left to it need to be the **root.left**, all elements right after it need to be **root.right**. Recursively call the helper function.\\n```\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) return null;\\n        String[] sArr = data.split(\",\");\\n        return helper(sArr, 0, sArr.length - 1);\\n    }\\n    \\n    public TreeNode helper(String[] sArr, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) return new TreeNode(Integer.parseInt(sArr[start]));\\n        TreeNode node = new TreeNode(Integer.parseInt(sArr[start]));\\n        int mid = start + 1;\\n        while (mid <= end) {\\n            if (Integer.parseInt(sArr[mid]) > Integer.parseInt(sArr[start])) {\\n                break;\\n            }\\n            mid++;\\n        }\\n        node.left = helper(sArr, start + 1, mid - 1);\\n        node.right = helper(sArr, mid, end);\\n        return node;\\n    }\\n```\\n\\n\\n* Version 2: O(N)\\n1.Similar id to @cccrrryyy 's solution: https://discuss.leetcode.com/topic/66495/using-lower-bound-and-upper-bound-to-deserialize-bst\\n2.Pass a **min value (low bound)** and a **max value (high bound)** to helper function. \\n3.I use **int[] currIdx** to simulate a static index variable, cuz I really don't  like using a static/member/global variable.\\n```\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) return null;\\n        String[] sArr = data.split(\",\");\\n        int[] currIdx = {0};\\n        return helper(sArr, currIdx, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode helper(String[] sArr, int[] currIdx, int min, int max) {\\n        if (currIdx[0] > sArr.length - 1) return null;\\n        int curr = Integer.parseInt(sArr[currIdx[0]]);\\n\\n        if (curr < min || curr > max) return null;\\n\\n        TreeNode node = new TreeNode(curr);\\n        currIdx[0]++;\\n        node.left = helper(sArr, currIdx, min, curr);\\n        node.right = helper(sArr, currIdx, curr, max);\\n        return node;\\n\\n    }",
                "solutionTags": [],
                "code": "```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n```\n```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val).append(\",\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n```\n```\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) return null;\\n        String[] sArr = data.split(\",\");\\n        return helper(sArr, 0, sArr.length - 1);\\n    }\\n    \\n    public TreeNode helper(String[] sArr, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) return new TreeNode(Integer.parseInt(sArr[start]));\\n        TreeNode node = new TreeNode(Integer.parseInt(sArr[start]));\\n        int mid = start + 1;\\n        while (mid <= end) {\\n            if (Integer.parseInt(sArr[mid]) > Integer.parseInt(sArr[start])) {\\n                break;\\n            }\\n            mid++;\\n        }\\n        node.left = helper(sArr, start + 1, mid - 1);\\n        node.right = helper(sArr, mid, end);\\n        return node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3262799,
                "title": "simple-solution-using-level-order-traversal",
                "content": "\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n\\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *currNode = q.front();\\n            q.pop();\\n            if(currNode == NULL) s.append(\"#,\");\\n            else s.append(to_string(currNode->val) + \\',\\');\\n            if(currNode != NULL){\\n                q.push(currNode->left);\\n                q.push(currNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL;\\n        stringstream  s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode*root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode * node = q.front();\\n            q.pop();\\n\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->left = NULL;\\n            }\\n            else{\\n                TreeNode* leftNode = new TreeNode(stoi(str));\\n                node->left = leftNode;\\n                q.push(leftNode);\\n            }\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->right = NULL;\\n            }\\n            else{\\n                TreeNode* rightNode = new TreeNode(stoi(str));\\n                node->right = rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n\\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *currNode = q.front();\\n            q.pop();\\n            if(currNode == NULL) s.append(\"#,\");\\n            else s.append(to_string(currNode->val) + \\',\\');\\n            if(currNode != NULL){\\n                q.push(currNode->left);\\n                q.push(currNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL;\\n        stringstream  s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode*root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode * node = q.front();\\n            q.pop();\\n\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->left = NULL;\\n            }\\n            else{\\n                TreeNode* leftNode = new TreeNode(stoi(str));\\n                node->left = leftNode;\\n                q.push(leftNode);\\n            }\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->right = NULL;\\n            }\\n            else{\\n                TreeNode* rightNode = new TreeNode(stoi(str));\\n                node->right = rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743634,
                "title": "c-preorder-traversal-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n{\\n   string str=\"\";\\n   fun(root,str);\\n   return str;          \\n}\\nvoid fun(TreeNode* root,string &str)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n    str.append(to_string(root->val));\\n    str.push_back(\\'-\\');\\n\\tfun(root->left,str);\\n\\tfun(root->right,str);\\n    \\n}\\n// Decodes your encoded data to tree.\\nTreeNode* deserialize(string str) \\n{\\n\\tTreeNode* root=NULL;\\n    string s=\"\";\\n    for(int i=0;i<str.length();i++)\\n    {\\n    \\tif(str[i]==\\'-\\')\\n    \\t{\\n    \\t\\tint num=stoi(s);\\n    \\t\\troot=fun(root,num);\\n    \\t\\ts.clear();\\n    \\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t   s.push_back(str[i]);\\t\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\nTreeNode* fun(TreeNode* root,int &num)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn new TreeNode(num);\\n\\t}\\n\\tif(num > root->val)\\n\\t{\\n\\t\\troot->right=fun(root->right,num);\\n\\t}\\n\\tif(num < root->val)\\n\\t{\\n\\t\\troot->left=fun(root->left,num);\\n\\t}\\n\\treturn root;\\n}\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n{\\n   string str=\"\";\\n   fun(root,str);\\n   return str;          \\n}\\nvoid fun(TreeNode* root,string &str)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n    str.append(to_string(root->val));\\n    str.push_back(\\'-\\');\\n\\tfun(root->left,str);\\n\\tfun(root->right,str);\\n    \\n}\\n// Decodes your encoded data to tree.\\nTreeNode* deserialize(string str) \\n{\\n\\tTreeNode* root=NULL;\\n    string s=\"\";\\n    for(int i=0;i<str.length();i++)\\n    {\\n    \\tif(str[i]==\\'-\\')\\n    \\t{\\n    \\t\\tint num=stoi(s);\\n    \\t\\troot=fun(root,num);\\n    \\t\\ts.clear();\\n    \\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t   s.push_back(str[i]);\\t\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\nTreeNode* fun(TreeNode* root,int &num)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn new TreeNode(num);\\n\\t}\\n\\tif(num > root->val)\\n\\t{\\n\\t\\troot->right=fun(root->right,num);\\n\\t}\\n\\tif(num < root->val)\\n\\t{\\n\\t\\troot->left=fun(root->left,num);\\n\\t}\\n\\treturn root;\\n}\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936631,
                "title": "python-dfs-easy-and-simple-solution",
                "content": "```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        res = []\\n        \\n        def dfs(node):\\n            if not node:\\n                res.append(\"N\")\\n                return\\n            res.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n            \\n        dfs(root)\\n        return \",\".join(res)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        vals = data.split(\",\")\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \"N\":\\n                self.i += 1\\n                return None\\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            return node\\n        return dfs()\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        res = []\\n        \\n        def dfs(node):\\n            if not node:\\n                res.append(\"N\")\\n                return\\n            res.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n            \\n        dfs(root)\\n        return \",\".join(res)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        vals = data.split(\",\")\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \"N\":\\n                self.i += 1\\n                return None\\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            return node\\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164482,
                "title": "java-solution-level-order-traversal",
                "content": "# Level Order Traversal\\nNote that this is not the most compact solution and that this does not use the special property of binary search tree. It\\'s however simple to implement and does the job.\\n\\nTo Serialize:\\n* We traverse the BST in level order.\\n* We use a separator and append the node values to our string. We use `blank` (i.e. `\"\"`) character for the nulls to save some space.\\n\\nTo Deserialize:\\n* We split the string by separator.\\n* With the way we have serialized (we had also put nulls for all nodes) can use the binary tree property that for a parent at index `i`:\\n  * the left child will be at position `2 * i + 1`\\n  * the right child will be at position `2 * i + 2`\\n* We construct the tree by using queue. We process parent nodes and enqueue child nodes and continue this process until queue is empty.\\n\\n```\\npublic class Codec {\\n    \\n    public static final String SEPARATOR = \",\";\\n    public static final String EMPTY_STRING = \"\";\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        StringBuilder builder = new StringBuilder();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode node = queue.poll();\\n            \\n            if(node!=null) {\\n                builder.append(node.val);\\n                queue.offer(node.left);\\n                queue.offer(node.right);\\n            } else {\\n                builder.append(EMPTY_STRING);\\n            }\\n            \\n            // append separator\\n            builder.append(SEPARATOR);\\n        }\\n        \\n        // rmeove last space\\n        builder.deleteCharAt(builder.length() - 1);\\n        \\n        return builder.toString();\\n    }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n\\n        String[] values = data.split(SEPARATOR);\\n        if(values[0].equals(EMPTY_STRING)) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.valueOf(values[0]));\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n       \\n        int parentIndex=0;\\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode parent = queue.poll();\\n\\n            int leftChildIndex = 2 * parentIndex + 1;\\n            int rightChildIndex = 2 * parentIndex + 2; \\n            \\n            if(leftChildIndex < values.length) {\\n                if(values[leftChildIndex].equals(EMPTY_STRING)) {\\n                    parent.left = null;\\n                } else {\\n                    int val = Integer.valueOf(values[leftChildIndex]);\\n                    TreeNode leftChild = new TreeNode(val);\\n                    parent.left = leftChild;\\n                    queue.offer(leftChild);\\n                }\\n            }\\n\\n            if(rightChildIndex<values.length) {\\n                if(values[rightChildIndex].equals(EMPTY_STRING)) {\\n                    parent.right = null;\\n                } else {\\n                    int val = Integer.valueOf(values[rightChildIndex]);\\n                    TreeNode rightChild = new TreeNode(val);\\n                    parent.right = rightChild;\\n                    queue.offer(rightChild);\\n                }            \\n            }\\n\\n            parentIndex++;    \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    \\n    public static final String SEPARATOR = \",\";\\n    public static final String EMPTY_STRING = \"\";\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        StringBuilder builder = new StringBuilder();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode node = queue.poll();\\n            \\n            if(node!=null) {\\n                builder.append(node.val);\\n                queue.offer(node.left);\\n                queue.offer(node.right);\\n            } else {\\n                builder.append(EMPTY_STRING);\\n            }\\n            \\n            // append separator\\n            builder.append(SEPARATOR);\\n        }\\n        \\n        // rmeove last space\\n        builder.deleteCharAt(builder.length() - 1);\\n        \\n        return builder.toString();\\n    }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n\\n        String[] values = data.split(SEPARATOR);\\n        if(values[0].equals(EMPTY_STRING)) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.valueOf(values[0]));\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n       \\n        int parentIndex=0;\\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode parent = queue.poll();\\n\\n            int leftChildIndex = 2 * parentIndex + 1;\\n            int rightChildIndex = 2 * parentIndex + 2; \\n            \\n            if(leftChildIndex < values.length) {\\n                if(values[leftChildIndex].equals(EMPTY_STRING)) {\\n                    parent.left = null;\\n                } else {\\n                    int val = Integer.valueOf(values[leftChildIndex]);\\n                    TreeNode leftChild = new TreeNode(val);\\n                    parent.left = leftChild;\\n                    queue.offer(leftChild);\\n                }\\n            }\\n\\n            if(rightChildIndex<values.length) {\\n                if(values[rightChildIndex].equals(EMPTY_STRING)) {\\n                    parent.right = null;\\n                } else {\\n                    int val = Integer.valueOf(values[rightChildIndex]);\\n                    TreeNode rightChild = new TreeNode(val);\\n                    parent.right = rightChild;\\n                    queue.offer(rightChild);\\n                }            \\n            }\\n\\n            parentIndex++;    \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886404,
                "title": "python-simple-clean-and-short-solution",
                "content": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        def encode(root):\\n            return \"\" if not root else str(root.val) + \"-\" + encode(root.left)+encode(root.right)\\n\\n        return encode(root)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def insert(root, val):\\n            if not root:\\n                return TreeNode(val)\\n\\n            if val <= root.val:\\n                root.left = insert(root.left,val)\\n\\n            else:\\n                root.right = insert(root.right,val)\\n\\n            return root\\n        \\n        root = None\\n        my_list = data.split(\"-\")\\n        my_list.pop(len(my_list)-1)\\n        for item in my_list:\\n            root = insert(root, int(item));\\n\\n        return root;\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        def encode(root):\\n            return \"\" if not root else str(root.val) + \"-\" + encode(root.left)+encode(root.right)\\n\\n        return encode(root)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def insert(root, val):\\n            if not root:\\n                return TreeNode(val)\\n\\n            if val <= root.val:\\n                root.left = insert(root.left,val)\\n\\n            else:\\n                root.right = insert(root.right,val)\\n\\n            return root\\n        \\n        root = None\\n        my_list = data.split(\"-\")\\n        my_list.pop(len(my_list)-1)\\n        for item in my_list:\\n            root = insert(root, int(item));\\n\\n        return root;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641070,
                "title": "java-bfs-queue",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if(root ==null) return sb.toString();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            if(node !=null){\\n                q.add(node.left);\\n                q.add(node.right);\\n                sb.append(node.val+\",\");\\n            }else{\\n                sb.append(\"#\"+\",\");\\n            }\\n        }\\n        return sb.toString();\\n        \\n    }\\n\\n    // Decodes encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        TreeNode head = null;\\n        if(data ==null || data.length() ==0) return head;\\n        String[] nodes = data.split(\",\");//get elements include null;\\n        TreeNode[] treeNodes = new TreeNode[nodes.length];//get a TreeNode array\\n        for(int i = 0; i<nodes.length; i++){\\n            if(! nodes[i].equals(\"#\") )\\n                treeNodes[i] = new TreeNode(Integer.valueOf(nodes[i]));//change non-null elem into node\\n        }\\n        for(int i =0,j=1; j<treeNodes.length;i++){\\n            if(treeNodes[i] != null){\\n                treeNodes[i].left = treeNodes[j++];\\n                treeNodes[i].right = treeNodes[j++];\\n            }\\n        }\\n        return treeNodes[0];       \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if(root ==null) return sb.toString();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            if(node !=null){\\n                q.add(node.left);\\n                q.add(node.right);\\n                sb.append(node.val+\",\");\\n            }else{\\n                sb.append(\"#\"+\",\");\\n            }\\n        }\\n        return sb.toString();\\n        \\n    }\\n\\n    // Decodes encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        TreeNode head = null;\\n        if(data ==null || data.length() ==0) return head;\\n        String[] nodes = data.split(\",\");//get elements include null;\\n        TreeNode[] treeNodes = new TreeNode[nodes.length];//get a TreeNode array\\n        for(int i = 0; i<nodes.length; i++){\\n            if(! nodes[i].equals(\"#\") )\\n                treeNodes[i] = new TreeNode(Integer.valueOf(nodes[i]));//change non-null elem into node\\n        }\\n        for(int i =0,j=1; j<treeNodes.length;i++){\\n            if(treeNodes[i] != null){\\n                treeNodes[i].left = treeNodes[j++];\\n                treeNodes[i].right = treeNodes[j++];\\n            }\\n        }\\n        return treeNodes[0];       \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492943,
                "title": "javascript-preorder",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n  if(!root) return \\'\\'\\n  return \"\" + root.val + \\',\\' + serialize(root.left) + \\',\\' + serialize(root.right)\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const arr = data.split(\\',\\')\\n    return helper(arr)\\n    \\n    function helper(arr) {\\n        const val = arr.shift()\\n        if(!val) return null \\n        const node = new TreeNode(val)\\n        node.left = helper(arr)\\n        node.right = helper(arr)\\n        return node\\n    }\\n    \\n    \\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n  if(!root) return \\'\\'\\n  return \"\" + root.val + \\',\\' + serialize(root.left) + \\',\\' + serialize(root.right)\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const arr = data.split(\\',\\')\\n    return helper(arr)\\n    \\n    function helper(arr) {\\n        const val = arr.shift()\\n        if(!val) return null \\n        const node = new TreeNode(val)\\n        node.left = helper(arr)\\n        node.right = helper(arr)\\n        return node\\n    }\\n    \\n    \\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 479632,
                "title": "easy-to-follow-python-using-queue",
                "content": "```\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([root])\\n        res = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n                res.append(str(node.val))\\n            else:\\n                res.append(\\'None\\')\\n        return \\' \\'.join(res)\\n    \\n    \\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data_q = collections.deque(data.split(\\' \\'))\\n        root = TreeNode(int(data_q.popleft()))\\n        tree_q = collections.deque([root])\\n        while tree_q:\\n            node = tree_q.popleft()\\n            left = data_q.popleft()\\n            right = data_q.popleft()\\n            if left != \\'None\\':\\n                left_node = TreeNode(int(left))\\n                node.left = left_node\\n                tree_q.append(left_node)\\n            if right != \\'None\\':\\n                right_node = TreeNode(int(right))\\n                node.right = right_node\\n                tree_q.append(right_node)\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([root])\\n        res = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n                res.append(str(node.val))\\n            else:\\n                res.append(\\'None\\')\\n        return \\' \\'.join(res)\\n    \\n    \\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data_q = collections.deque(data.split(\\' \\'))\\n        root = TreeNode(int(data_q.popleft()))\\n        tree_q = collections.deque([root])\\n        while tree_q:\\n            node = tree_q.popleft()\\n            left = data_q.popleft()\\n            right = data_q.popleft()\\n            if left != \\'None\\':\\n                left_node = TreeNode(int(left))\\n                node.left = left_node\\n                tree_q.append(left_node)\\n            if right != \\'None\\':\\n                right_node = TreeNode(int(right))\\n                node.right = right_node\\n                tree_q.append(right_node)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 285149,
                "title": "python-preorder-queue-solution-with-comments",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        # Pre-Order Traversal of Tree\\n        # Putting a marker to notify None/null, so we can recognize it during deserialization\\n        if root == None:\\n            return \\'X,\\'\\n        \\n        left_subtree = self.serialize(root.left) \\n        right_subtree = self.serialize(root.right)\\n        \\n        # Putting a delimiter on which we can split our string on during deserialization\\n        return str(root.val) + \",\" + left_subtree + right_subtree\\n    \\n    def deserializeHelper(self, data):\\n        # If we encounter our marker(\"X\") for None/null node, pop out from our queue(data) and return None\\n        # Also its our base condition!!!\\n        if data[0] == \"X\":\\n            del data[0]\\n            return None\\n        \\n        # Making a tree node with the front most element in the queue\\n        new_node = TreeNode(data[0])\\n        del data[0] # Popping our element from queue\\n        \\n        # When we encounter one \"X\" we move from left subtree to current(new_node) and when we encounter\\n        # two \"X\"\\'s we are moving to the parent (Just trying to explain the recursion taking place)\\n        new_node.left = self.deserializeHelper(data) \\n        new_node.right = self.deserializeHelper(data)\\n        \\n        return new_node\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # Splitting our data on the delimeter we used during serialization\\n        data = data.split(\",\")\\n        del data[-1] # Last one will be None/null so omitting it\\n        return self.deserializeHelper(data)\\n       \\n# Thanks to BackToBackSWE (Youtube Channel) for helping me understand this question better\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        # Pre-Order Traversal of Tree\\n        # Putting a marker to notify None/null, so we can recognize it during deserialization\\n        if root == None:\\n            return \\'X,\\'\\n        \\n        left_subtree = self.serialize(root.left) \\n        right_subtree = self.serialize(root.right)\\n        \\n        # Putting a delimiter on which we can split our string on during deserialization\\n        return str(root.val) + \",\" + left_subtree + right_subtree\\n    \\n    def deserializeHelper(self, data):\\n        # If we encounter our marker(\"X\") for None/null node, pop out from our queue(data) and return None\\n        # Also its our base condition!!!\\n        if data[0] == \"X\":\\n            del data[0]\\n            return None\\n        \\n        # Making a tree node with the front most element in the queue\\n        new_node = TreeNode(data[0])\\n        del data[0] # Popping our element from queue\\n        \\n        # When we encounter one \"X\" we move from left subtree to current(new_node) and when we encounter\\n        # two \"X\"\\'s we are moving to the parent (Just trying to explain the recursion taking place)\\n        new_node.left = self.deserializeHelper(data) \\n        new_node.right = self.deserializeHelper(data)\\n        \\n        return new_node\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # Splitting our data on the delimeter we used during serialization\\n        data = data.split(\",\")\\n        del data[-1] # Last one will be None/null so omitting it\\n        return self.deserializeHelper(data)\\n       \\n# Thanks to BackToBackSWE (Youtube Channel) for helping me understand this question better\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146267,
                "title": "a-simple-solution-with-only-12-lines-of-code-beats-98",
                "content": "This solution utilizes a small array to hold the position of current value, which simplifies the code to the minimum.\\n\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null) return \"#\";\\n        \\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\",\");\\n        \\n        return deserialize(values, new int[1]);\\n    }\\n    \\n    private TreeNode deserialize(String[] values, int[] pos){\\n        if(\"#\".equals(values[pos[0]])){\\n            pos[0]++;\\n            return null;\\n        }\\n        \\n        TreeNode cur = new TreeNode(Integer.valueOf(values[pos[0]]));\\n        pos[0]++;\\n        \\n        cur.left = deserialize(values, pos);\\n        cur.right = deserialize(values, pos);\\n        \\n        return cur;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null) return \"#\";\\n        \\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\",\");\\n        \\n        return deserialize(values, new int[1]);\\n    }\\n    \\n    private TreeNode deserialize(String[] values, int[] pos){\\n        if(\"#\".equals(values[pos[0]])){\\n            pos[0]++;\\n            return null;\\n        }\\n        \\n        TreeNode cur = new TreeNode(Integer.valueOf(values[pos[0]]));\\n        pos[0]++;\\n        \\n        cur.left = deserialize(values, pos);\\n        cur.right = deserialize(values, pos);\\n        \\n        return cur;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93195,
                "title": "python-solution-serializing-as-preorder-list",
                "content": "The remarkable difference from serialize/deserialize Binary Tree ( https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ ) is, **BST can be constructed just from its preorder array** while a general binary tree requires both [in-order and and pre-order](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/#/description ) or [in-order and post-order](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/#/description).\\n\\nSo for serializing BST, just perform a pre-order traversal and stringify the result array.\\nDeserialization can be also done in the same manner as:\\nhttp://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-2/\\n\\n```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root:\\n            return \"none\"\\n        cur = root\\n        \\n        res = \"\"\\n        stack = []\\n        while cur:\\n            res += str(cur.val) + \",\"\\n            \\n            if cur.right:\\n                stack.append(cur)\\n            \\n            if cur.left:\\n                cur = cur.left\\n            elif not stack:\\n                break\\n            else:\\n                cur = stack.pop()\\n                cur = cur.right\\n        return res[:-1] # remove the last \",\"\\n          \\n    def deserialize(self, data):\\n        if data == \"none\":\\n            return None\\n        vals = data.split(\",\")\\n        root = TreeNode(int(vals[0]))\\n        cur = root\\n        \\n        stack = []\\n        for i in range(1, len(vals)):\\n            val = int(vals[i])\\n            \\n            if val < cur.val:\\n                cur.left = TreeNode(val)\\n                stack.append(cur)\\n                cur = cur.left\\n            else:\\n                while stack and cur.val < val:\\n                    if stack[-1].val < val:\\n                        cur = stack.pop()\\n                    else:\\n                        break\\n                cur.right = TreeNode(val)\\n                cur = cur.right\\n        return root\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root:\\n            return \"none\"\\n        cur = root\\n        \\n        res = \"\"\\n        stack = []\\n        while cur:\\n            res += str(cur.val) + \",\"\\n            \\n            if cur.right:\\n                stack.append(cur)\\n            \\n            if cur.left:\\n                cur = cur.left\\n            elif not stack:\\n                break\\n            else:\\n                cur = stack.pop()\\n                cur = cur.right\\n        return res[:-1] # remove the last \",\"\\n          \\n    def deserialize(self, data):\\n        if data == \"none\":\\n            return None\\n        vals = data.split(\",\")\\n        root = TreeNode(int(vals[0]))\\n        cur = root\\n        \\n        stack = []\\n        for i in range(1, len(vals)):\\n            val = int(vals[i])\\n            \\n            if val < cur.val:\\n                cur.left = TreeNode(val)\\n                stack.append(cur)\\n                cur = cur.left\\n            else:\\n                while stack and cur.val < val:\\n                    if stack[-1].val < val:\\n                        cur = stack.pop()\\n                    else:\\n                        break\\n                cur.right = TreeNode(val)\\n                cur = cur.right\\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 93288,
                "title": "c-pre-order-serialize-very-compact-no-commas-no-null-no-separators",
                "content": "Here is the idea.  Each node can be serialized with a prefix char and and Abs value.  The prefix char acts as the separator and denotes the sign of the value and if the value has a left or right or both or is a leaf.\\n\\nI use this code but any similar codes could be used\\n```\\n'x' = leaf\\n'l' = left node only\\n'r' = right node only\\n'f' = full or both left and right\\n```\\n\\nif the value is negative I take the capitalization of the prefix\\n```\\n'X' = leaf and negative value\\n'L' = left node only and negative value\\n'R' = right node only and negative value\\n'F' = full or both left and right and negative value\\n```\\n\\nFor example:\\nA node with value \"2\" and a left node only\\n```\\nl2\\n```\\nA node with a value of \"-1234\" which is a leaf\\n```\\nX1234\\n```\\n\\nThese could be strung together to form a root \"2\" with left node leaf \"-1234\"\\n```\\nl2X1234\\n```\\n\\nThis could be further optimized by choosing codes in the upper alphabet and serializing numbers in hex.  And of course you could compact this even further by using a binary system and encoding as integers.  But I thought the main trick here of using the prefix was the piece I wanted to share.\\n\\n```\\n \\n    public class Codec\\n    {\\n        // Encodes a tree to a single string.\\n        public string serialize(TreeNode root)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            BuildSerialize(root, sb);\\n            return sb.ToString();\\n        }\\n\\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(string data)\\n        {\\n            NodeIter nodeIter = new NodeIter(data);\\n            TreeNode root = this.BuildDeserialize(nodeIter);\\n            return root;\\n        }\\n\\n        private void BuildSerialize(TreeNode node, StringBuilder sb)\\n        {\\n            // pre-order\\n            if (node == null) return;\\n            sb.Append(SerializeNode(node));\\n            BuildSerialize(node.left, sb);\\n            BuildSerialize(node.right, sb);\\n        }\\n\\n        private string SerializeNode(TreeNode node)\\n        {\\n            if (node == null) return \"\";\\n\\n            char c = '$';\\n            if (node.left != null && node.right != null) c = 'f'; // full - both left and right\\n            else if (node.left != null) c = 'l'; // left only\\n            else if (node.right != null) c = 'r'; // right only\\n            else c = 'x'; // leaf\\n\\n            if (node.val < 0) c = Char.ToUpper(c); // negative value identified by upper case\\n\\n            return c.ToString() + Math.Abs(node.val).ToString();\\n        }\\n\\n        private TreeNode BuildDeserialize(NodeIter nodeIter)\\n        {\\n            TreeNode node = nodeIter.Next();\\n            if (node == null) return node;\\n            if (node.left != null)\\n            {\\n                node.left = BuildDeserialize(nodeIter);\\n            }\\n            if (node.right != null)\\n            {\\n                node.right = BuildDeserialize(nodeIter);\\n            }\\n            return node;\\n        }\\n    }\\n\\n    public class NodeIter\\n    {\\n        private string str = null;\\n        private int pos = 0;\\n        public NodeIter(string s)\\n        {\\n            this.str = s == null ? \"\" : s;\\n        }\\n\\n        public TreeNode Next()\\n        {\\n            TreeNode node = null;\\n            if (this.pos < this.str.Length)\\n            {\\n                node = new TreeNode(1);\\n                char c = this.str[this.pos];\\n                if (Char.IsUpper(c)) node.val = -1;\\n                switch (Char.ToLower(c))\\n                {\\n                    case 'x': break;\\n                    case 'l': node.left = new TreeNode(0); break;\\n                    case 'r': node.right = new TreeNode(0); break;\\n                    case 'f': node.left = new TreeNode(0); node.right = new TreeNode(0); break;\\n                    default: break;\\n                }\\n\\n                this.pos++;\\n                int val = 0;\\n                while (this.pos < this.str.Length && Char.IsDigit(this.str[this.pos]))\\n                {\\n                    val = val * 10 + this.str[this.pos] - '0';\\n                    this.pos++;\\n                }\\n                node.val *= val;\\n            }\\n            return node;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n'x' = leaf\\n'l' = left node only\\n'r' = right node only\\n'f' = full or both left and right\\n```\n```\\n'X' = leaf and negative value\\n'L' = left node only and negative value\\n'R' = right node only and negative value\\n'F' = full or both left and right and negative value\\n```\n```\\nl2\\n```\n```\\nX1234\\n```\n```\\nl2X1234\\n```\n```\\n \\n    public class Codec\\n    {\\n        // Encodes a tree to a single string.\\n        public string serialize(TreeNode root)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            BuildSerialize(root, sb);\\n            return sb.ToString();\\n        }\\n\\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(string data)\\n        {\\n            NodeIter nodeIter = new NodeIter(data);\\n            TreeNode root = this.BuildDeserialize(nodeIter);\\n            return root;\\n        }\\n\\n        private void BuildSerialize(TreeNode node, StringBuilder sb)\\n        {\\n            // pre-order\\n            if (node == null) return;\\n            sb.Append(SerializeNode(node));\\n            BuildSerialize(node.left, sb);\\n            BuildSerialize(node.right, sb);\\n        }\\n\\n        private string SerializeNode(TreeNode node)\\n        {\\n            if (node == null) return \"\";\\n\\n            char c = '$';\\n            if (node.left != null && node.right != null) c = 'f'; // full - both left and right\\n            else if (node.left != null) c = 'l'; // left only\\n            else if (node.right != null) c = 'r'; // right only\\n            else c = 'x'; // leaf\\n\\n            if (node.val < 0) c = Char.ToUpper(c); // negative value identified by upper case\\n\\n            return c.ToString() + Math.Abs(node.val).ToString();\\n        }\\n\\n        private TreeNode BuildDeserialize(NodeIter nodeIter)\\n        {\\n            TreeNode node = nodeIter.Next();\\n            if (node == null) return node;\\n            if (node.left != null)\\n            {\\n                node.left = BuildDeserialize(nodeIter);\\n            }\\n            if (node.right != null)\\n            {\\n                node.right = BuildDeserialize(nodeIter);\\n            }\\n            return node;\\n        }\\n    }\\n\\n    public class NodeIter\\n    {\\n        private string str = null;\\n        private int pos = 0;\\n        public NodeIter(string s)\\n        {\\n            this.str = s == null ? \"\" : s;\\n        }\\n\\n        public TreeNode Next()\\n        {\\n            TreeNode node = null;\\n            if (this.pos < this.str.Length)\\n            {\\n                node = new TreeNode(1);\\n                char c = this.str[this.pos];\\n                if (Char.IsUpper(c)) node.val = -1;\\n                switch (Char.ToLower(c))\\n                {\\n                    case 'x': break;\\n                    case 'l': node.left = new TreeNode(0); break;\\n                    case 'r': node.right = new TreeNode(0); break;\\n                    case 'f': node.left = new TreeNode(0); node.right = new TreeNode(0); break;\\n                    default: break;\\n                }\\n\\n                this.pos++;\\n                int val = 0;\\n                while (this.pos < this.str.Length && Char.IsDigit(this.str[this.pos]))\\n                {\\n                    val = val * 10 + this.str[this.pos] - '0';\\n                    this.pos++;\\n                }\\n                node.val *= val;\\n            }\\n            return node;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93290,
                "title": "c-28ms-soluton-used-the-same-encoding-scheme-leetcode-uses-to-serialize-deserialize-tree-problem-i-o",
                "content": "#### Encoding scheme\\nFor below tree\\n```\\n    2\\n   / \\\\\\n  1   4\\n     / \\\\\\n    3   5\\n```\\nAfter serialization\\n```\\n2,1,4,#,#,3,5\\n```\\n#### Implementation\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\n    string getNextNode(string const& data, int& offset) {\\n        int end = data.find(',', offset);\\n        if(end == string::npos) {\\n            end = data.length();\\n        }\\n        string sNodeValue = data.substr(offset, end - offset);\\n        offset = end + 1;\\n        \\n        return sNodeValue;\\n    }\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string result = \"\";\\n        if(!root) return result;\\n        queue <TreeNode*> Q;\\n        Q.push(root);\\n        result += to_string(root->val);\\n        result += ',';\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(node->left) {\\n                result += to_string(node->left->val);\\n                result += ',';\\n                Q.push(node->left);\\n            } else {\\n                result += \"#,\";\\n            }\\n            if(node->right) {\\n                result += to_string(node->right->val);\\n                result += ',';\\n                Q.push(node->right);\\n            } else {\\n                result += \"#,\";\\n            }\\n            Q.pop();\\n        }\\n        // triming , and # from end\\n        int i = result.size() - 1;\\n        for(--i; i >= 0 and result[i] == '#'; i -= 2);\\n        return result.substr(0, i + 1);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = nullptr;\\n        if(data.empty()) return root;\\n        queue<TreeNode*> Q;\\n        int offset = 0;\\n        int nodeValue = stoi(getNextNode(data, offset));\\n        root = new TreeNode(nodeValue);\\n        Q.push(root);\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int leftNodeValue = stoi(sValue);\\n                    node->left = new TreeNode(leftNodeValue);\\n                    Q.push(node->left);  \\n                }\\n            }\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int rightNodeValue = stoi(sValue);\\n                    node->right = new TreeNode(rightNodeValue);\\n                    Q.push(node->right);  \\n                }\\n            }\\n            Q.pop();\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```",
                "solutionTags": [],
                "code": "```\\n    2\\n   / \\\\\\n  1   4\\n     / \\\\\\n    3   5\\n```\n```\\n2,1,4,#,#,3,5\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\n    string getNextNode(string const& data, int& offset) {\\n        int end = data.find(',', offset);\\n        if(end == string::npos) {\\n            end = data.length();\\n        }\\n        string sNodeValue = data.substr(offset, end - offset);\\n        offset = end + 1;\\n        \\n        return sNodeValue;\\n    }\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string result = \"\";\\n        if(!root) return result;\\n        queue <TreeNode*> Q;\\n        Q.push(root);\\n        result += to_string(root->val);\\n        result += ',';\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(node->left) {\\n                result += to_string(node->left->val);\\n                result += ',';\\n                Q.push(node->left);\\n            } else {\\n                result += \"#,\";\\n            }\\n            if(node->right) {\\n                result += to_string(node->right->val);\\n                result += ',';\\n                Q.push(node->right);\\n            } else {\\n                result += \"#,\";\\n            }\\n            Q.pop();\\n        }\\n        // triming , and # from end\\n        int i = result.size() - 1;\\n        for(--i; i >= 0 and result[i] == '#'; i -= 2);\\n        return result.substr(0, i + 1);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = nullptr;\\n        if(data.empty()) return root;\\n        queue<TreeNode*> Q;\\n        int offset = 0;\\n        int nodeValue = stoi(getNextNode(data, offset));\\n        root = new TreeNode(nodeValue);\\n        Q.push(root);\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int leftNodeValue = stoi(sValue);\\n                    node->left = new TreeNode(leftNodeValue);\\n                    Q.push(node->left);  \\n                }\\n            }\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int rightNodeValue = stoi(sValue);\\n                    node->right = new TreeNode(rightNodeValue);\\n                    Q.push(node->right);  \\n                }\\n            }\\n            Q.pop();\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93255,
                "title": "construct-bst-using-preorder-traversal",
                "content": "At first I thought this was the same as serialization/deserialization of a generic BT. Since the problem suggests minimal codec size and avoid using any external variable/function/etc I chose preorder and using stack to avoid using aux function. It can be made a little easier if using recursion I suppose. Also I think postorder works as well.\\n\\n\\n\\n    class Codec {\\n    public:\\n    \\n    \\t// Encodes a tree to a single string.\\n    \\tstring serialize(TreeNode* root) {\\n    \\t\\t// preorder traversal\\n    \\t\\tstring ret;\\n    \\t\\tif(!root) return ret;\\n    \\t\\t\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\t\\twhile(!stk.empty()){\\n    \\t\\t\\tTreeNode *r = stk.top();\\n    \\t\\t\\tstk.pop();\\n    \\t\\t\\tret += to_string(r->val) + \",\";\\n    \\t\\t\\tif(r->right) stk.push(r->right);\\n    \\t\\t\\tif(r->left) stk.push(r->left);\\n    \\n    \\t\\t}\\n    \\t\\treturn ret.substr(0, ret.size()-1);\\n    \\t}\\n    \\n    \\t// Decodes your encoded data to tre.\\n    \\tTreeNode* deserialize(string data) {\\n    \\t    if(data.size() == 0) return nullptr;\\n    \\t    \\n    \\t\\tint id = 0;\\n    \\t\\t// take root at first\\n    \\t\\tint r = id;\\n    \\t\\twhile(isdigit(data[r])) r++;\\n    \\t\\tint v = stoi(data.substr(id, r-id));\\n    \\t\\tid = r+1;\\n    \\n    \\t\\tTreeNode *root = new TreeNode(v);\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\n    \\t\\twhile(id < (int) data.size()) {\\n    \\t\\t\\tint r = id;\\n    \\t\\t\\twhile(isdigit(data[r]))\\tr++;\\n    \\t\\t\\tint v = stoi(data.substr(id, r - id));\\n    \\t\\t\\tid = r + 1;\\n    \\n    \\t\\t\\tTreeNode *node = nullptr;\\n    \\t\\t\\twhile(!stk.empty() && v > stk.top()->val) {\\n    \\t\\t\\t\\tnode = stk.top();\\n    \\t\\t\\t\\tstk.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\tif(node) {\\n    \\t\\t\\t\\tnode->right = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(node->right);\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tstk.top()->left = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(stk.top()->left);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn root;\\n    \\t}\\n    \\t// for debug\\n    \\tvoid f(TreeNode *root) {\\n    \\t\\tif(!root) return;\\n    \\t\\tf(root->left);\\n    \\t\\tcout << root->val << \", \";\\n    \\t\\tf(root->right);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "At first I thought this was the same as serialization/deserialization of a generic BT. Since the problem suggests minimal codec size and avoid using any external variable/function/etc I chose preorder and using stack to avoid using aux function. It can be made a little easier if using recursion I suppose. Also I think postorder works as well.\\n\\n\\n\\n    class Codec {\\n    public:\\n    \\n    \\t// Encodes a tree to a single string.\\n    \\tstring serialize(TreeNode* root) {\\n    \\t\\t// preorder traversal\\n    \\t\\tstring ret;\\n    \\t\\tif(!root) return ret;\\n    \\t\\t\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\t\\twhile(!stk.empty()){\\n    \\t\\t\\tTreeNode *r = stk.top();\\n    \\t\\t\\tstk.pop();\\n    \\t\\t\\tret += to_string(r->val) + \",\";\\n    \\t\\t\\tif(r->right) stk.push(r->right);\\n    \\t\\t\\tif(r->left) stk.push(r->left);\\n    \\n    \\t\\t}\\n    \\t\\treturn ret.substr(0, ret.size()-1);\\n    \\t}\\n    \\n    \\t// Decodes your encoded data to tre.\\n    \\tTreeNode* deserialize(string data) {\\n    \\t    if(data.size() == 0) return nullptr;\\n    \\t    \\n    \\t\\tint id = 0;\\n    \\t\\t// take root at first\\n    \\t\\tint r = id;\\n    \\t\\twhile(isdigit(data[r])) r++;\\n    \\t\\tint v = stoi(data.substr(id, r-id));\\n    \\t\\tid = r+1;\\n    \\n    \\t\\tTreeNode *root = new TreeNode(v);\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\n    \\t\\twhile(id < (int) data.size()) {\\n    \\t\\t\\tint r = id;\\n    \\t\\t\\twhile(isdigit(data[r]))\\tr++;\\n    \\t\\t\\tint v = stoi(data.substr(id, r - id));\\n    \\t\\t\\tid = r + 1;\\n    \\n    \\t\\t\\tTreeNode *node = nullptr;\\n    \\t\\t\\twhile(!stk.empty() && v > stk.top()->val) {\\n    \\t\\t\\t\\tnode = stk.top();\\n    \\t\\t\\t\\tstk.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\tif(node) {\\n    \\t\\t\\t\\tnode->right = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(node->right);\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tstk.top()->left = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(stk.top()->left);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn root;\\n    \\t}\\n    \\t// for debug\\n    \\tvoid f(TreeNode *root) {\\n    \\t\\tif(!root) return;\\n    \\t\\tf(root->left);\\n    \\t\\tcout << root->val << \", \";\\n    \\t\\tf(root->right);\\n    \\t}\\n    };",
                "codeTag": "C++"
            },
            {
                "id": 4031517,
                "title": "3-line-code-only-100-faster-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res=root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res=root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302829,
                "title": "c-serialize-deserialize-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string s=\"\";\\n        if(!root){\\n            return s;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(!node){\\n                s+=\"#,\";\\n            }\\n            else{\\n                s+=to_string(node->val)+\\',\\';\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()){return NULL;}\\n        string s=\"\";\\n        stringstream x(data);\\n        getline(x, s, \\',\\');\\n        TreeNode* root=new TreeNode(stoi(s));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->left=NULL;\\n            }\\n            else{\\n                TreeNode* lft=new TreeNode(stoi(s));\\n                node->left=lft;\\n                q.push(lft);\\n            }\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->right=NULL;\\n            }\\n            else{\\n                TreeNode* rgt=new TreeNode(stoi(s));\\n                node->right=rgt;\\n                q.push(rgt);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string s=\"\";\\n        if(!root){\\n            return s;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(!node){\\n                s+=\"#,\";\\n            }\\n            else{\\n                s+=to_string(node->val)+\\',\\';\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()){return NULL;}\\n        string s=\"\";\\n        stringstream x(data);\\n        getline(x, s, \\',\\');\\n        TreeNode* root=new TreeNode(stoi(s));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->left=NULL;\\n            }\\n            else{\\n                TreeNode* lft=new TreeNode(stoi(s));\\n                node->left=lft;\\n                q.push(lft);\\n            }\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->right=NULL;\\n            }\\n            else{\\n                TreeNode* rgt=new TreeNode(stoi(s));\\n                node->right=rgt;\\n                q.push(rgt);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274720,
                "title": "449-time-91-2-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor the serialize function:\\n\\n1. If the given root is None, return an empty string.\\n2. Create an empty stack and push the root node to it.\\n3. Create an empty string called serialized.\\n4. While the stack is not empty, pop a node from the stack.\\n5. If the node is None, append \"$,\" to the serialized string.\\n6. Otherwise, append the node\\'s value followed by \",\" to the serialized string.\\n7. Push the node\\'s right child to the stack (if it exists).\\n8. Push the node\\'s left child to the stack (if it exists).\\n9. Return the serialized string without the last comma.\\n\\nFor the deserialize function:\\n\\n1. If the given data string is empty, return None.\\n2. Split the data string by comma and create a deque called queue from the resulting list.\\n3. Call the _deserialize function with queue as the argument and return its result.\\n\\nFor the _deserialize function:\\n\\n1. Pop the leftmost value from the queue and store it in a variable called value.\\n2. If value is \"$\", return None.\\n3. Create a new TreeNode with the integer value of value.\\n4. Set the node\\'s left child to the result of calling _deserialize recursively with queue.\\n5. Set the node\\'s right child to the result of calling _deserialize recursively with queue.\\n6. Return the node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\"\"\"\\n        if not root:\\n            return \"\"\\n        stack = [root]\\n        serialized = \"\"\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                serialized += \"$,\"\\n            else:\\n                serialized += str(node.val) + \",\"\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return serialized[:-1]\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\"\"\"\\n        if not data:\\n            return None\\n        values = data.split(\",\")\\n        queue = deque(values)\\n        return self._deserialize(queue)\\n\\n    def _deserialize(self, queue: Deque[str]) -> Optional[TreeNode]:\\n        value = queue.popleft()\\n        if value == \"$\":\\n            return None\\n        node = TreeNode(int(value))\\n        node.left = self._deserialize(queue)\\n        node.right = self._deserialize(queue)\\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\"\"\"\\n        if not root:\\n            return \"\"\\n        stack = [root]\\n        serialized = \"\"\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                serialized += \"$,\"\\n            else:\\n                serialized += str(node.val) + \",\"\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return serialized[:-1]\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\"\"\"\\n        if not data:\\n            return None\\n        values = data.split(\",\")\\n        queue = deque(values)\\n        return self._deserialize(queue)\\n\\n    def _deserialize(self, queue: Deque[str]) -> Optional[TreeNode]:\\n        value = queue.popleft()\\n        if value == \"$\":\\n            return None\\n        node = TreeNode(int(value))\\n        node.left = self._deserialize(queue)\\n        node.right = self._deserialize(queue)\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051832,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to implement a serialization and deserialization method for a binary tree. The serialization method should take a binary tree and convert it into a string format, while the deserialization method should take the string format and convert it back into a binary tree.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe serialization method can be done by doing a breadth-first traversal of the tree and appending the values of the nodes to a list. If a node is None, append \"null\" to the list. After the traversal, join the list into a string using \",\" as the delimiter.\\n\\nThe deserialization method can be done by splitting the string into a list using \",\" as the delimiter. Create the root node using the first element in the list and append it to a queue. Then, for each element in the list, starting from the second element, check if the element is \"null\" or not. If it is not \"null\", create a new node with that value and append it to the left or right of the current node in the queue, depending on whether it is the left or right child. Append the new node to the queue as well. Repeat this process until all elements in the list have been processed.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        queue = [root]\\n        output = []\\n        while queue:\\n            current = queue.pop(0)\\n            if current:\\n                output.append(str(current.val))\\n                queue.append(current.left)\\n                queue.append(current.right)\\n            else:\\n                output.append(\"null\")\\n        return \",\".join(output)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        data = data.split(\",\")\\n        root = TreeNode(int(data[0]))\\n        queue = [root]\\n        i = 1\\n        while queue:\\n            current = queue.pop(0)\\n            if data[i] != \"null\":\\n                current.left = TreeNode(int(data[i]))\\n                queue.append(current.left)\\n            i += 1\\n            if data[i] != \"null\":\\n                current.right = TreeNode(int(data[i]))\\n                queue.append(current.right)\\n            i += 1\\n        return root\\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        queue = [root]\\n        output = []\\n        while queue:\\n            current = queue.pop(0)\\n            if current:\\n                output.append(str(current.val))\\n                queue.append(current.left)\\n                queue.append(current.right)\\n            else:\\n                output.append(\"null\")\\n        return \",\".join(output)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        data = data.split(\",\")\\n        root = TreeNode(int(data[0]))\\n        queue = [root]\\n        i = 1\\n        while queue:\\n            current = queue.pop(0)\\n            if data[i] != \"null\":\\n                current.left = TreeNode(int(data[i]))\\n                queue.append(current.left)\\n            i += 1\\n            if data[i] != \"null\":\\n                current.right = TreeNode(int(data[i]))\\n                queue.append(current.right)\\n            i += 1\\n        return root\\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747947,
                "title": "short-and-clean-solution",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        if(!root)return \"#\";\\n        return to_string(root->val)+\"#\"+serialize(root->left) + serialize(root->right);\\n    }\\n    TreeNode* decode(stringstream& take,string res = \"\"){\\n        getline(take,res,\\'#\\');\\n        if(res.empty())return NULL;\\n        \\n        TreeNode* root= new TreeNode(stoi(res));\\n        root->left = decode(take), root->right = decode(take);\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream take(data);\\n        return decode(take);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        if(!root)return \"#\";\\n        return to_string(root->val)+\"#\"+serialize(root->left) + serialize(root->right);\\n    }\\n    TreeNode* decode(stringstream& take,string res = \"\"){\\n        getline(take,res,\\'#\\');\\n        if(res.empty())return NULL;\\n        \\n        TreeNode* root= new TreeNode(stoi(res));\\n        root->left = decode(take), root->right = decode(take);\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream take(data);\\n        return decode(take);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254332,
                "title": "java-simple-preorder-solution",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"n\" + \"/\");\\n            return;\\n        }\\n        sb.append(root.val + \"/\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        preorder(root, sb);\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode constructTree(String preorder[], int index[], int end) {\\n        if (index[0] > end) return null;\\n        if (preorder[index[0]].equals(\"n\")) {\\n            index[0] += 1;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(preorder[index[0]]));\\n        index[0] += 1;\\n        root.left = constructTree(preorder, index, end);\\n        root.right = constructTree(preorder, index, end);\\n        return root;\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        String preorder[] = data.split(\"/\");\\n        TreeNode root = constructTree(preorder, new int[1], preorder.length - 1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"n\" + \"/\");\\n            return;\\n        }\\n        sb.append(root.val + \"/\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        preorder(root, sb);\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode constructTree(String preorder[], int index[], int end) {\\n        if (index[0] > end) return null;\\n        if (preorder[index[0]].equals(\"n\")) {\\n            index[0] += 1;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(preorder[index[0]]));\\n        index[0] += 1;\\n        root.left = constructTree(preorder, index, end);\\n        root.right = constructTree(preorder, index, end);\\n        return root;\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        String preorder[] = data.split(\"/\");\\n        TreeNode root = constructTree(preorder, new int[1], preorder.length - 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707052,
                "title": "c-simple-level-order-traversal",
                "content": "\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"\";\\n        string s=\"\";\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            if(temp==NULL)\\n            {\\n                s.append(\"#,\");\\n            }\\n            else\\n            {\\n                s.append(to_string(temp->val)+\\',\\');\\n            }\\n            \\n            if(temp!=NULL)\\n            {\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n        }\\n\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.length()==0)\\n            return NULL;\\n        \\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root=new TreeNode(stoi(str));\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->left=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* leftNode=new TreeNode(stoi(str));\\n                temp->left=leftNode;\\n                q.push(leftNode);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->right=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* rightNode=new TreeNode(stoi(str));\\n                temp->right=rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n\\n",
                "solutionTags": [
                    "String",
                    "Queue"
                ],
                "code": "\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"\";\\n        string s=\"\";\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            if(temp==NULL)\\n            {\\n                s.append(\"#,\");\\n            }\\n            else\\n            {\\n                s.append(to_string(temp->val)+\\',\\');\\n            }\\n            \\n            if(temp!=NULL)\\n            {\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n        }\\n\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.length()==0)\\n            return NULL;\\n        \\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root=new TreeNode(stoi(str));\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->left=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* leftNode=new TreeNode(stoi(str));\\n                temp->left=leftNode;\\n                q.push(leftNode);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->right=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* rightNode=new TreeNode(stoi(str));\\n                temp->right=rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1391262,
                "title": "c-queue-and-preorder",
                "content": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n     string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n    \\n    TreeNode* deserializeHelper(queue<string>& q) {\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=deserializeHelper(q);\\n        root->right=deserializeHelper(q);\\n        return root;       \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        queue<string> q;\\n        cout << data<< endl;\\n        while (ss.good()) {\\n            string str;\\n            getline(ss, str,\\',\\');\\n            q.push(str);\\n        }\\n        return deserializeHelper(q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n     string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n    \\n    TreeNode* deserializeHelper(queue<string>& q) {\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=deserializeHelper(q);\\n        root->right=deserializeHelper(q);\\n        return root;       \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        queue<string> q;\\n        cout << data<< endl;\\n        while (ss.good()) {\\n            string str;\\n            getline(ss, str,\\',\\');\\n            q.push(str);\\n        }\\n        return deserializeHelper(q);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1365738,
                "title": "simple-straightforward-java-solution",
                "content": "Simple and easy to understand Java solution.\\n(Not the most efficient, due to the simple deserialization approach)\\n\\n```\\n    // since this is a binary search tree, we\\'ll just output values in BFS\\n    // order (when serializind), then add all values to the tree one by one (when deserializing)\\n    // serialize will take O(n)\\n    // deserialize will take O(n*h), where h is the height of the tree (n in the\\n    // worst case, and log(n) if the tree is balanced)\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            TreeNode n = q.remove();\\n            sb.append(n.val).append(\\',\\');\\n            if (n.left != null)\\n                q.add(n.left);\\n            if (n.right != null)\\n                q.add(n.right);\\n        }\\n        sb.setLength(sb.length()-1); // remove last \\',\\'\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null) {\\n            return null;\\n        }\\n        \\n        String[] vals = data.split(\",\");\\n        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\\n        for (int i=1; i<vals.length; i++) {\\n            add(root, Integer.parseInt(vals[i]));\\n        }\\n        return root;\\n    }\\n    \\n    private static void add(TreeNode root, int val) {\\n        TreeNode cur = root;\\n        TreeNode parent = null;\\n        while (cur != null) {\\n            parent = cur;\\n            cur = (val <= cur.val) ? cur.left : cur.right;\\n        }\\n        if (val <= parent.val) {\\n            parent.left = new TreeNode(val);\\n        } else {\\n            parent.right = new TreeNode(val);\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    // since this is a binary search tree, we\\'ll just output values in BFS\\n    // order (when serializind), then add all values to the tree one by one (when deserializing)\\n    // serialize will take O(n)\\n    // deserialize will take O(n*h), where h is the height of the tree (n in the\\n    // worst case, and log(n) if the tree is balanced)\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            TreeNode n = q.remove();\\n            sb.append(n.val).append(\\',\\');\\n            if (n.left != null)\\n                q.add(n.left);\\n            if (n.right != null)\\n                q.add(n.right);\\n        }\\n        sb.setLength(sb.length()-1); // remove last \\',\\'\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null) {\\n            return null;\\n        }\\n        \\n        String[] vals = data.split(\",\");\\n        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\\n        for (int i=1; i<vals.length; i++) {\\n            add(root, Integer.parseInt(vals[i]));\\n        }\\n        return root;\\n    }\\n    \\n    private static void add(TreeNode root, int val) {\\n        TreeNode cur = root;\\n        TreeNode parent = null;\\n        while (cur != null) {\\n            parent = cur;\\n            cur = (val <= cur.val) ? cur.left : cur.right;\\n        }\\n        if (val <= parent.val) {\\n            parent.left = new TreeNode(val);\\n        } else {\\n            parent.right = new TreeNode(val);\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033310,
                "title": "serialize-deserialize-bst-bt",
                "content": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\\nhttps://leetcode.com/problems/serialize-and-deserialize-bst/\\n\\nIn my opinion, although the first one is marked as hard, it is actually easier than the second one. Because for the second one, you need to utilize the binary search tree property and make the tree COMPACT as required by the problem. By compact it means you can\\'t append \"null\" values to indicate tree structure. Instead, you need to utilize bst properties to get tree structure.\\n\\nSolution for BST:\\n```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        \\n        //post order traveral: left, right, root\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //left \\n        String left = serialize(root.left);\\n        if (left.length() > 0) {\\n            sb.append(left).append(\",\");\\n        }\\n        \\n        //right\\n        String right = serialize(root.right);\\n        if (right.length() > 0) {\\n            sb.append(right).append(\",\");\\n        }\\n        \\n        //root\\n        sb.append(root.val).append(\",\");\\n\\n        String result = sb.substring(0, sb.length() - 1).toString();\\n        return result;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() <= 0) {\\n            return null;\\n        }\\n        String[] array = data.split(\",\");\\n        index = array.length - 1;\\n        return helper(array, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n        \\n    public TreeNode helper(String[] array, int lower, int upper){\\n        if (index < 0) {\\n            return null;\\n        }\\n        int num = Integer.valueOf(array[index]);\\n        if (num < lower || num > upper) {\\n            return null;\\n        }\\n        index--;\\n        TreeNode root = new TreeNode(num);\\n        root.right = helper(array, num, upper);\\n        root.left = helper(array, lower, num);\\n        return root;\\n    }\\n}\\n```\\n\\nSolution for BT (Not this problem):\\n```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"null\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //preorder traversal\\n        sb.append(root.val)\\n            .append(\",\")\\n            .append(serialize(root.left))\\n            .append(\",\")\\n            .append(serialize(root.right));\\n\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] array = data.split(\",\");\\n        return helper(array);\\n    }\\n    \\n    public TreeNode helper(String[] array){\\n        if (array[index].equals(\"null\")) {\\n            index++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(array[index++]));\\n        root.left = helper(array);\\n        root.right = helper(array);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        \\n        //post order traveral: left, right, root\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //left \\n        String left = serialize(root.left);\\n        if (left.length() > 0) {\\n            sb.append(left).append(\",\");\\n        }\\n        \\n        //right\\n        String right = serialize(root.right);\\n        if (right.length() > 0) {\\n            sb.append(right).append(\",\");\\n        }\\n        \\n        //root\\n        sb.append(root.val).append(\",\");\\n\\n        String result = sb.substring(0, sb.length() - 1).toString();\\n        return result;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() <= 0) {\\n            return null;\\n        }\\n        String[] array = data.split(\",\");\\n        index = array.length - 1;\\n        return helper(array, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n        \\n    public TreeNode helper(String[] array, int lower, int upper){\\n        if (index < 0) {\\n            return null;\\n        }\\n        int num = Integer.valueOf(array[index]);\\n        if (num < lower || num > upper) {\\n            return null;\\n        }\\n        index--;\\n        TreeNode root = new TreeNode(num);\\n        root.right = helper(array, num, upper);\\n        root.left = helper(array, lower, num);\\n        return root;\\n    }\\n}\\n```\n```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"null\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //preorder traversal\\n        sb.append(root.val)\\n            .append(\",\")\\n            .append(serialize(root.left))\\n            .append(\",\")\\n            .append(serialize(root.right));\\n\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] array = data.split(\",\");\\n        return helper(array);\\n    }\\n    \\n    public TreeNode helper(String[] array){\\n        if (array[index].equals(\"null\")) {\\n            index++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(array[index++]));\\n        root.left = helper(array);\\n        root.right = helper(array);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003049,
                "title": "simple-python-solution-faster-than-98-16-detailed-comments-easy-to-understand",
                "content": "```\\n# O(n) time and space complexity for both serialization and \\n# deserialization\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        # if we see a None\\n        if not root:\\n            return \"-1\"\\n        # Otherwise we serialize root, roo.left and root.right\\n        # preorder traversal\\n        return str(root.val) + \",\"+self.serialize(root.left) + \",\" + self.serialize(root.right)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        # from preorder list to tree\\n        def helper(dq): \\n            # using the dq we deserialize one by one\\n            value = dq.popleft()\\n            # if we see -1, means we need to form null node\\n            if value == -1:\\n                return None\\n            # form the actual node\\n            node = TreeNode(value)\\n            # form node\\'s left\\n            node.left = helper(dq)\\n            # form node\\'s right\\n            node.right = helper(dq)\\n            \\n            return node\\n        \\n        # at first get the node integer vals from the serial of \\n        # the tree \\n        #print(data)\\n        data = map(int,data.split(\",\"))\\n        # form a deque needed to deserialize\\n        dq = deque(data)\\n        # we call helper with the deque list\\n        return helper(dq)\\n        \\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```\\nRuntime: 64 ms, faster than 98.16% of Python3 online submissions for Serialize and Deserialize BST.",
                "solutionTags": [],
                "code": "```\\n# O(n) time and space complexity for both serialization and \\n# deserialization\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        # if we see a None\\n        if not root:\\n            return \"-1\"\\n        # Otherwise we serialize root, roo.left and root.right\\n        # preorder traversal\\n        return str(root.val) + \",\"+self.serialize(root.left) + \",\" + self.serialize(root.right)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        # from preorder list to tree\\n        def helper(dq): \\n            # using the dq we deserialize one by one\\n            value = dq.popleft()\\n            # if we see -1, means we need to form null node\\n            if value == -1:\\n                return None\\n            # form the actual node\\n            node = TreeNode(value)\\n            # form node\\'s left\\n            node.left = helper(dq)\\n            # form node\\'s right\\n            node.right = helper(dq)\\n            \\n            return node\\n        \\n        # at first get the node integer vals from the serial of \\n        # the tree \\n        #print(data)\\n        data = map(int,data.split(\",\"))\\n        # form a deque needed to deserialize\\n        dq = deque(data)\\n        # we call helper with the deque list\\n        return helper(dq)\\n        \\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960377,
                "title": "its-funny-we-can-cheat-like-this",
                "content": "```\\nvar last *TreeNode \\n\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\n// Serializes a tree to a single string.\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    last = root\\n    return \"\"\\n}\\n\\n// Deserializes your encoded data to tree.\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    return last\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar last *TreeNode \\n\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\n// Serializes a tree to a single string.\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    last = root\\n    return \"\"\\n}\\n\\n// Deserializes your encoded data to tree.\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    return last\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887456,
                "title": "serialize-and-deserialize-bst-c",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887397,
                "title": "c-just-preorder-traversal-which-gives-unique-bst-structure-no-delimiter",
                "content": "1.  Preorder uniquely determines stucture of a BST. Just construct a BST by feeding elements from a preorder array.\\n2.  Used 4 chars per integer element by serializing  binary representation. No need of a delimiter while deserializing.\\n3.  Complexity serializiation(preorder) : O(n)\\n4.   Complexity dserializiation(constructing binary tree): O(nlogn) (average case)\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void postOrder(TreeNode* root, string& res){\\n        if(!root)\\n            return;\\n        vector<char> buf(sizeof(int), 0);\\n        memcpy(buf.data(), &(root->val), sizeof(int));\\n        for(auto c:buf)\\n            res.push_back(c);\\n        postOrder(root->left, res);\\n        postOrder(root->right, res);\\n        \\n    }\\n    string serialize(TreeNode* root) {\\n        string res;\\n        postOrder(root, res);\\n        return res;\\n    }\\n\\n    TreeNode* deserialize(int elem, TreeNode* root){\\n        if(!root)\\n            return new TreeNode(elem);\\n        if(root->val >  elem)\\n            root->left  = deserialize(elem, root->left);\\n        else\\n           root->right  = deserialize(elem, root->right); \\n        return root;\\n\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        TreeNode* root = nullptr;\\n        while(i< data.size()){\\n            int elem = 0;\\n            memcpy(&elem, &data[i], sizeof(int));\\n            i+=sizeof(int);\\n            root = deserialize(elem, root);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void postOrder(TreeNode* root, string& res){\\n        if(!root)\\n            return;\\n        vector<char> buf(sizeof(int), 0);\\n        memcpy(buf.data(), &(root->val), sizeof(int));\\n        for(auto c:buf)\\n            res.push_back(c);\\n        postOrder(root->left, res);\\n        postOrder(root->right, res);\\n        \\n    }\\n    string serialize(TreeNode* root) {\\n        string res;\\n        postOrder(root, res);\\n        return res;\\n    }\\n\\n    TreeNode* deserialize(int elem, TreeNode* root){\\n        if(!root)\\n            return new TreeNode(elem);\\n        if(root->val >  elem)\\n            root->left  = deserialize(elem, root->left);\\n        else\\n           root->right  = deserialize(elem, root->right); \\n        return root;\\n\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        TreeNode* root = nullptr;\\n        while(i< data.size()){\\n            int elem = 0;\\n            memcpy(&elem, &data[i], sizeof(int));\\n            i+=sizeof(int);\\n            root = deserialize(elem, root);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887291,
                "title": "serialize-and-deserialize-bst-explained-o-n-beats-98-41-32ms-queue-cpp",
                "content": "### Here I have used pre-order traversal (root left right) to both serialize and deserialize the tree.\\n\\n## **Serialize:**\\nThe main idea is when you are at any node of the tree, append its value to the string and push its children to the queue and continue till the queue is empty.\\n\\n**Things to note:** \\n- Have a look at the constraints, directly appending to the string will only let you handle values within 7 bit range (char). So you have to devise some other way of appending to it correctly.\\n- Here I have conveted the int to string using to_string() method and stored them space seperated.\\n\\n## **Deserialize:**\\nThe idea for deserialization is similar to that of serialize, if the root is null, initialize the tree and push the children of root in the queue. Then pop nodes out from queue and keep putting data to the tree and its children to the queue until the string exhausts. \\n\\n**Things to note:**\\n- You have to make sure you extract data from the string correctly in the format that you stored data in it.\\n-  Here I used strtok() method to extract data from \" \" seperated string and atoi() method to convert the char* to int and put the value in the tree.\\n\\n\\n```c++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n        string ans = \"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *temp = q.front(); q.pop();\\n            if(temp != NULL) {\\n                ans+=to_string(temp->val) + \" \";\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n            else ans+=\"null \";\\n        }\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        // reverse(data.begin(), data.end());\\n        queue<TreeNode*> q;\\n        TreeNode *ans=NULL;\\n        char *dat = new char [data.size() + 1];\\n        strcpy(dat, data.c_str());\\n        char *token = strtok(dat, \" \");\\n        while(token!=NULL){\\n            // cout << atoi(token) << endl; token = strtok(NULL, \" \");\\n            if(ans==NULL){\\n                ans = new TreeNode(atoi(token));\\n                token = strtok(NULL, \" \");\\n                q.push(ans);\\n            }else{\\n                TreeNode *temp = q.front(); q.pop();\\n                if(strcmp(token, \"null\")) {temp->left = new TreeNode(atoi(token));\\n                q.push(temp->left);}\\n                token = strtok(NULL, \" \");\\n                if(token==NULL) break;\\n                if(strcmp(token, \"null\")) {temp->right = new TreeNode(atoi(token));\\n                q.push(temp->right);}\\n                token = strtok(NULL, \" \");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```c++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n        string ans = \"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *temp = q.front(); q.pop();\\n            if(temp != NULL) {\\n                ans+=to_string(temp->val) + \" \";\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n            else ans+=\"null \";\\n        }\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        // reverse(data.begin(), data.end());\\n        queue<TreeNode*> q;\\n        TreeNode *ans=NULL;\\n        char *dat = new char [data.size() + 1];\\n        strcpy(dat, data.c_str());\\n        char *token = strtok(dat, \" \");\\n        while(token!=NULL){\\n            // cout << atoi(token) << endl; token = strtok(NULL, \" \");\\n            if(ans==NULL){\\n                ans = new TreeNode(atoi(token));\\n                token = strtok(NULL, \" \");\\n                q.push(ans);\\n            }else{\\n                TreeNode *temp = q.front(); q.pop();\\n                if(strcmp(token, \"null\")) {temp->left = new TreeNode(atoi(token));\\n                q.push(temp->left);}\\n                token = strtok(NULL, \" \");\\n                if(token==NULL) break;\\n                if(strcmp(token, \"null\")) {temp->right = new TreeNode(atoi(token));\\n                q.push(temp->right);}\\n                token = strtok(NULL, \" \");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 886633,
                "title": "swift-beat-100",
                "content": "```\\nclass Codec {\\n    // Encodes a tree to a single string.\\n    func serialize(_ root: TreeNode?) -> String {\\n        var arr = [String]()\\n        serialize(root, &arr)\\n        return arr.joined(separator: \",\")\\n    }\\n    \\n    func serialize(_ root: TreeNode?, _ arr: inout [String]) {        \\n        guard let root = root else{\\n            return\\n        }\\n        arr.append(\"\\\\(root.val)\")\\n        serialize(root.left, &arr)\\n        serialize(root.right, &arr)\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    func deserialize(_ data: String) -> TreeNode? {\\n         guard data != \"\" else{\\n            return nil\\n        }\\n        \\n        let arr = data.components(separatedBy:\",\")\\n        var index = 0\\n        return deserialize(arr, &index, Int.min, Int.max)\\n    }\\n    \\n    func deserialize(_ arr: [String], _ index: inout Int, _ minVal: Int, _ maxVal: Int) -> TreeNode? {\\n        guard index < arr.count, let val = Int(arr[index]) else{\\n            return nil\\n        }\\n        \\n        if val < minVal || val > maxVal{\\n            return nil\\n        }\\n        \\n        let node = TreeNode(val)\\n        index += 1\\n        \\n        node.left = deserialize(arr, &index, minVal, val)\\n        node.right = deserialize(arr, &index, val, maxVal)\\n        \\n        return node\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\n    // Encodes a tree to a single string.\\n    func serialize(_ root: TreeNode?) -> String {\\n        var arr = [String]()\\n        serialize(root, &arr)\\n        return arr.joined(separator: \",\")\\n    }\\n    \\n    func serialize(_ root: TreeNode?, _ arr: inout [String]) {        \\n        guard let root = root else{\\n            return\\n        }\\n        arr.append(\"\\\\(root.val)\")\\n        serialize(root.left, &arr)\\n        serialize(root.right, &arr)\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    func deserialize(_ data: String) -> TreeNode? {\\n         guard data != \"\" else{\\n            return nil\\n        }\\n        \\n        let arr = data.components(separatedBy:\",\")\\n        var index = 0\\n        return deserialize(arr, &index, Int.min, Int.max)\\n    }\\n    \\n    func deserialize(_ arr: [String], _ index: inout Int, _ minVal: Int, _ maxVal: Int) -> TreeNode? {\\n        guard index < arr.count, let val = Int(arr[index]) else{\\n            return nil\\n        }\\n        \\n        if val < minVal || val > maxVal{\\n            return nil\\n        }\\n        \\n        let node = TreeNode(val)\\n        index += 1\\n        \\n        node.left = deserialize(arr, &index, minVal, val)\\n        node.right = deserialize(arr, &index, val, maxVal)\\n        \\n        return node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753392,
                "title": "level-order-traversal-also-works",
                "content": "We can use a queue to do a BFS, and encode the values in the order of nodes visited during BFS.\\n\\nWhen decoding, just insert the values back in that order with BST insertion, building the tree level by level. \\n\\nThe time complexity for reconstruction is O(n*log(n)), though, slightly worse than O(n) best case.\\n\\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        ans = []\\n        q = collections.deque([root])\\n        while q:  # BFS\\n            node = q.popleft()\\n            ans.append(node.val)\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n        return \\',\\'.join([str(v) for v in ans[::-1]])  # reverse order so that when decoding, popping from the back takes O(1)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return None\\n        data = [int(s) for s in data.split(\\',\\')]\\n        root = TreeNode(data.pop())\\n        \\n        def insert(node, v):\\n            left = True if v < node.val else False\\n            if left:\\n                if not node.left:\\n                    node.left = TreeNode(v)\\n                else:\\n                    insert(node.left, v)  # recursively insert\\n            else:\\n                if not node.right:\\n                    node.right = TreeNode(v)\\n                else:\\n                    insert(node.right, v)  # recursively insert\\n        \\n        while data:\\n            insert(root, data.pop())  # insert the value into the tree\\n            \\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        ans = []\\n        q = collections.deque([root])\\n        while q:  # BFS\\n            node = q.popleft()\\n            ans.append(node.val)\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n        return \\',\\'.join([str(v) for v in ans[::-1]])  # reverse order so that when decoding, popping from the back takes O(1)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return None\\n        data = [int(s) for s in data.split(\\',\\')]\\n        root = TreeNode(data.pop())\\n        \\n        def insert(node, v):\\n            left = True if v < node.val else False\\n            if left:\\n                if not node.left:\\n                    node.left = TreeNode(v)\\n                else:\\n                    insert(node.left, v)  # recursively insert\\n            else:\\n                if not node.right:\\n                    node.right = TreeNode(v)\\n                else:\\n                    insert(node.right, v)  # recursively insert\\n        \\n        while data:\\n            insert(root, data.pop())  # insert the value into the tree\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722105,
                "title": "javascript",
                "content": "Use \" \" rather than signal(eg. 3) will extra char in string. Need compact\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let res = \"\";\\n    if (!root) return res;\\n    var preorder = function(root){\\n        if (!root) return;\\n        res += \\'#\\' + root.val;\\n        preorder(root.left);\\n        preorder(root.right);\\n    }\\n    preorder(root);\\n    return res.slice(1);\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    let dataArr = data.split(\\'#\\').filter(el => el != \\'\\');\\n    let treeRoot = null;\\n    for(let i = 0; i < dataArr.length; i++){\\n        treeRoot = insert(treeRoot, Number(dataArr[i]));\\n    }\\n    return treeRoot;\\n};\\nvar insert = function(parent, value){\\n    if (!parent){\\n        return new TreeNode(value); //create treenode(build tree)\\n    }\\n    if (parent.val > value){//go left branch\\n        parent.left = insert(parent.left, value);\\n    }\\n    else{\\n        parent.right = insert(parent.right, value);\\n    }\\n    return parent;\\n}\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let res = \"\";\\n    if (!root) return res;\\n    var preorder = function(root){\\n        if (!root) return;\\n        res += \\'#\\' + root.val;\\n        preorder(root.left);\\n        preorder(root.right);\\n    }\\n    preorder(root);\\n    return res.slice(1);\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    let dataArr = data.split(\\'#\\').filter(el => el != \\'\\');\\n    let treeRoot = null;\\n    for(let i = 0; i < dataArr.length; i++){\\n        treeRoot = insert(treeRoot, Number(dataArr[i]));\\n    }\\n    return treeRoot;\\n};\\nvar insert = function(parent, value){\\n    if (!parent){\\n        return new TreeNode(value); //create treenode(build tree)\\n    }\\n    if (parent.val > value){//go left branch\\n        parent.left = insert(parent.left, value);\\n    }\\n    else{\\n        parent.right = insert(parent.right, value);\\n    }\\n    return parent;\\n}\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 703202,
                "title": "cpp-sol-with-comments",
                "content": "// Runtime: 60 ms, faster than 37.72% of C++ online submissions for Serialize and Deserialize BST.\\n// Memory Usage: 31.7 MB, less than 28.61% of C++ online submissions for Serialize and Deserialize BST.\\n    // change the tree to root$root->left$root->right$\\n//since bst therefore if we create a vector from the above string root root->left root->right we can track the left sub tree as all the value for left sub tree will be less than or equals to root \\n```\\nclass Codec {\\n    string serialize2(TreeNode* root){\\n        if(!root) return \"\";\\n        string left, right, ans;\\n        ans = to_string(root->val) + \"$\";\\n        left = serialize2(root->left);\\n        right = serialize2(root->right);\\n        return ans + left + right;\\n    }\\n    TreeNode* deserialize2(vector<int>& data, int s, int e){\\n        if (s > e) return NULL;\\n        TreeNode * root = new TreeNode(data[s]);//creating root\\n        int i = s+1;\\n        while(i <= e && data[i] <= data[s]) i++;//finding the end point for left subtree , all the values less than root belongs to left sub tree\\n        root->left = deserialize2(data,s+1,i-1);\\n        root->right = deserialize2(data,i,e);\\n        return root;\\n    }\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string temp = serialize2(root);\\n        return temp;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> ser ;\\n        string s;\\n        stringstream ss(data);\\n        while(getline(ss,s,\\'$\\')){\\n            ser.push_back(stoi(s));\\n        }\\n        return deserialize2(ser,0,ser.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));",
                "solutionTags": [],
                "code": "// Runtime: 60 ms, faster than 37.72% of C++ online submissions for Serialize and Deserialize BST.\\n// Memory Usage: 31.7 MB, less than 28.61% of C++ online submissions for Serialize and Deserialize BST.\\n    // change the tree to root$root->left$root->right$\\n//since bst therefore if we create a vector from the above string root root->left root->right we can track the left sub tree as all the value for left sub tree will be less than or equals to root \\n```\\nclass Codec {\\n    string serialize2(TreeNode* root){\\n        if(!root) return \"\";\\n        string left, right, ans;\\n        ans = to_string(root->val) + \"$\";\\n        left = serialize2(root->left);\\n        right = serialize2(root->right);\\n        return ans + left + right;\\n    }\\n    TreeNode* deserialize2(vector<int>& data, int s, int e){\\n        if (s > e) return NULL;\\n        TreeNode * root = new TreeNode(data[s]);//creating root\\n        int i = s+1;\\n        while(i <= e && data[i] <= data[s]) i++;//finding the end point for left subtree , all the values less than root belongs to left sub tree\\n        root->left = deserialize2(data,s+1,i-1);\\n        root->right = deserialize2(data,i,e);\\n        return root;\\n    }\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string temp = serialize2(root);\\n        return temp;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> ser ;\\n        string s;\\n        stringstream ss(data);\\n        while(getline(ss,s,\\'$\\')){\\n            ser.push_back(stoi(s));\\n        }\\n        return deserialize2(ser,0,ser.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));",
                "codeTag": "Java"
            },
            {
                "id": 700390,
                "title": "python-simple-recursive-solution",
                "content": "```\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## Similar to 297. Serialize and Deserialize Binary Tree ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def dfs(root, string):\\n            if root is None:\\n                string += \\'None,\\'\\n            else:\\n                string += str(root.val) + \\',\\'\\n                string = dfs(root.left, string)\\n                string = dfs(root.right, string)\\n            return string\\n        return dfs(root, \\'\\')\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def dfs(l):\\n            if(l[0] == \"None\"):\\n                l.pop(0)\\n                return None\\n            root = TreeNode( l.pop(0) )\\n            root.left = dfs(l)\\n            root.right = dfs(l)\\n            return root\\n        return dfs( data.split(\",\")[:-1] )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## Similar to 297. Serialize and Deserialize Binary Tree ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def dfs(root, string):\\n            if root is None:\\n                string += \\'None,\\'\\n            else:\\n                string += str(root.val) + \\',\\'\\n                string = dfs(root.left, string)\\n                string = dfs(root.right, string)\\n            return string\\n        return dfs(root, \\'\\')\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def dfs(l):\\n            if(l[0] == \"None\"):\\n                l.pop(0)\\n                return None\\n            root = TreeNode( l.pop(0) )\\n            root.left = dfs(l)\\n            root.right = dfs(l)\\n            return root\\n        return dfs( data.split(\",\")[:-1] )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522843,
                "title": "simple-python-preorder-traverse",
                "content": "```\\n\\'\\'\\'\\npreorder or pstorder traverse to print out the tree. Because BST property, no need to insert \\'Null\\'\\nFor preorder traver, current root is the first number in data. \\nAll numbers smaller than current root go to the left subtree.\\nAll numbers larger than current root go to the right subtree.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        preorder traverse to print out tree\\n        \"\"\"\\n        def helper(res, root):\\n            if not root:\\n                return\\n            res.append((str(root.val)))\\n            helper(res, root.left)\\n            helper(res, root.right)\\n        res = []\\n        helper(res, root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(data):\\n            if not data:\\n                return None\\n            cur = data[0]\\n            root = TreeNode(cur)\\n            root.left = helper([d for d in data if d < cur])\\n            root.right = helper([d for d in data if d > cur])\\n            return root\\n        if not data:\\n            return None\\n        data = data.split(\\',\\')\\n        return helper([int(d) for d in data])\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\npreorder or pstorder traverse to print out the tree. Because BST property, no need to insert \\'Null\\'\\nFor preorder traver, current root is the first number in data. \\nAll numbers smaller than current root go to the left subtree.\\nAll numbers larger than current root go to the right subtree.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        preorder traverse to print out tree\\n        \"\"\"\\n        def helper(res, root):\\n            if not root:\\n                return\\n            res.append((str(root.val)))\\n            helper(res, root.left)\\n            helper(res, root.right)\\n        res = []\\n        helper(res, root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(data):\\n            if not data:\\n                return None\\n            cur = data[0]\\n            root = TreeNode(cur)\\n            root.left = helper([d for d in data if d < cur])\\n            root.right = helper([d for d in data if d > cur])\\n            return root\\n        if not data:\\n            return None\\n        data = data.split(\\',\\')\\n        return helper([int(d) for d in data])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462987,
                "title": "serialize-and-deserialize-bst-concise-java-solution",
                "content": "```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"X,\";\\n        }\\n\\n        String leftSubtree = serialize(root.left);\\n        String rightSubtree = serialize(root.right);\\n\\n        return root.val + \",\" + leftSubtree + rightSubtree;\\n    }\\n\\n\\n    \\n    public TreeNode deserialize(String data) {\\n        \\n        Queue<String> nodes = new LinkedList<>();\\n        \\n        nodes.addAll(Arrays.asList(data.split(\",\")));\\n        \\n        return getNode(nodes);\\n    }\\n\\n    \\n    public TreeNode getNode(Queue<String> nodes) {\\n        String nodeVal = nodes.poll();\\n\\n        if (nodeVal.equals(\"X\")) {\\n          return null;\\n        }\\n\\n        TreeNode node = new TreeNode(Integer.valueOf(nodeVal));\\n        node.left = getNode(nodes);\\n        node.right = getNode(nodes);\\n\\n        return node;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"X,\";\\n        }\\n\\n        String leftSubtree = serialize(root.left);\\n        String rightSubtree = serialize(root.right);\\n\\n        return root.val + \",\" + leftSubtree + rightSubtree;\\n    }\\n\\n\\n    \\n    public TreeNode deserialize(String data) {\\n        \\n        Queue<String> nodes = new LinkedList<>();\\n        \\n        nodes.addAll(Arrays.asList(data.split(\",\")));\\n        \\n        return getNode(nodes);\\n    }\\n\\n    \\n    public TreeNode getNode(Queue<String> nodes) {\\n        String nodeVal = nodes.poll();\\n\\n        if (nodeVal.equals(\"X\")) {\\n          return null;\\n        }\\n\\n        TreeNode node = new TreeNode(Integer.valueOf(nodeVal));\\n        node.left = getNode(nodes);\\n        node.right = getNode(nodes);\\n\\n        return node;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448040,
                "title": "share-my-recursive-solution-in-c",
                "content": "Generally speaking we cannot rebuild a binary tree from its preorder however it is a BST, so preorder is enough.\\n```\\nvoid getPreorderHelper(TreeNode* root, ostringstream& preorder)\\n{\\n    if (root == nullptr)\\n    {\\n        return;\\n    }\\n\\n    preorder << root->val << \" \";\\n    getPreorderHelper(root->left, preorder);\\n    getPreorderHelper(root->right, preorder);\\n}\\nstring serialize(TreeNode* root)\\n{\\n    ostringstream seq;\\n    getPreorderHelper(root, seq);\\n    return seq.str();\\n}\\nTreeNode* buildFromPreorderHelper(vector<int>& nums, const int start, const int end)\\n{\\n    if (start > end)\\n    {\\n        return nullptr;\\n    }\\n\\n    int pivot;\\n    for (pivot = start; pivot <= end && nums[pivot] <= nums[start]; ++pivot);\\n    \\n\\tTreeNode* root = new TreeNode(nums[start]);\\n\\troot->left = buildFromPreorderHelper(nums, start + 1, pivot - 1);\\n    root->right = buildFromPreorderHelper(nums, pivot, end);\\n\\n    return root;\\n}\\nTreeNode* deserialize(string data)\\n{\\n    vector<int> nums;\\n    istringstream is(data);\\n    for (string num; is >> num; nums.push_back(stoi(num)));\\n    return buildFromPreorderHelper(nums, 0, nums.size() - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid getPreorderHelper(TreeNode* root, ostringstream& preorder)\\n{\\n    if (root == nullptr)\\n    {\\n        return;\\n    }\\n\\n    preorder << root->val << \" \";\\n    getPreorderHelper(root->left, preorder);\\n    getPreorderHelper(root->right, preorder);\\n}\\nstring serialize(TreeNode* root)\\n{\\n    ostringstream seq;\\n    getPreorderHelper(root, seq);\\n    return seq.str();\\n}\\nTreeNode* buildFromPreorderHelper(vector<int>& nums, const int start, const int end)\\n{\\n    if (start > end)\\n    {\\n        return nullptr;\\n    }\\n\\n    int pivot;\\n    for (pivot = start; pivot <= end && nums[pivot] <= nums[start]; ++pivot);\\n    \\n\\tTreeNode* root = new TreeNode(nums[start]);\\n\\troot->left = buildFromPreorderHelper(nums, start + 1, pivot - 1);\\n    root->right = buildFromPreorderHelper(nums, pivot, end);\\n\\n    return root;\\n}\\nTreeNode* deserialize(string data)\\n{\\n    vector<int> nums;\\n    istringstream is(data);\\n    for (string num; is >> num; nums.push_back(stoi(num)));\\n    return buildFromPreorderHelper(nums, 0, nums.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 377025,
                "title": "python3-using-list",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nfrom  collections import deque\\nclass Codec:\\n\\n    def serialize(self, root):\\n        if root == None: \\n            return  \\'\\'\\n        q = deque([(root)]) \\n        l = []\\n        while q:\\n            n = q.popleft()\\n            if n != None:\\n                q.append(n.left)\\n                q.append(n.right)\\n                l.append(str(n.val))\\n            else:\\n                l.append(\\'Null\\')\\n\\n        return \\' \\'.join(l)\\n    \\n    def deserialize(self, data):\\n        if data == \\'\\': return None\\n        array = data.split(\\' \\')\\n        root = TreeNode(int(array[0]))\\n        q = deque([root])\\n        index = 1\\n        while q:\\n            n = q.popleft()\\n            if array[index] != \\'Null\\':\\n                n.left = TreeNode(int(array[index]))\\n                q.append(n.left)\\n            index += 1\\n            if array[index] != \\'Null\\':\\n                n.right = TreeNode(int(array[index]))\\n                q.append(n.right)\\n            index += 1\\n        return root\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nfrom  collections import deque\\nclass Codec:\\n\\n    def serialize(self, root):\\n        if root == None: \\n            return  \\'\\'\\n        q = deque([(root)]) \\n        l = []\\n        while q:\\n            n = q.popleft()\\n            if n != None:\\n                q.append(n.left)\\n                q.append(n.right)\\n                l.append(str(n.val))\\n            else:\\n                l.append(\\'Null\\')\\n\\n        return \\' \\'.join(l)\\n    \\n    def deserialize(self, data):\\n        if data == \\'\\': return None\\n        array = data.split(\\' \\')\\n        root = TreeNode(int(array[0]))\\n        q = deque([root])\\n        index = 1\\n        while q:\\n            n = q.popleft()\\n            if array[index] != \\'Null\\':\\n                n.left = TreeNode(int(array[index]))\\n                q.append(n.left)\\n            index += 1\\n            if array[index] != \\'Null\\':\\n                n.right = TreeNode(int(array[index]))\\n                q.append(n.right)\\n            index += 1\\n        return root\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357543,
                "title": "by-using-only-preorder-traversal",
                "content": "The logic is to save pre order traversal of the tree. Mark null node with \"N\" and separate each node value with any delimeter. i am usign \",\" for the same.\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void myfun(TreeNode* root, string& str)\\n    {\\n        if (!root)\\n        {\\n            str+=\"N\";\\n            return;\\n        }\\n        str+=to_string(root->val);\\n        str+=\",\";\\n        myfun(root->left, str);\\n        str+=\",\";\\n        myfun(root->right, str);\\n    }\\n    string serialize(TreeNode* root) {\\n        string ans;\\n        myfun(root, ans);\\n        ans+=\",\";\\n       // cout<<ans;\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* myfun2(string str, int& index, int l)\\n    {\\n        string t;\\n        int i;\\n        for ( i=index;i<l;i++){\\n            if (str[i] == \\',\\')\\n                break;\\n            t+=str[i];\\n        }\\n        index =i+1;\\n        if (t == \"N\")\\n            return NULL;\\n        TreeNode* root = new TreeNode(stoi(t));\\n\\n        root->left = myfun2(str,index,l );\\n        root->right = myfun2(str,index, l);\\n        return root;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int index =0;\\n        return myfun2(data,index, data.size());\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void myfun(TreeNode* root, string& str)\\n    {\\n        if (!root)\\n        {\\n            str+=\"N\";\\n            return;\\n        }\\n        str+=to_string(root->val);\\n        str+=\",\";\\n        myfun(root->left, str);\\n        str+=\",\";\\n        myfun(root->right, str);\\n    }\\n    string serialize(TreeNode* root) {\\n        string ans;\\n        myfun(root, ans);\\n        ans+=\",\";\\n       // cout<<ans;\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* myfun2(string str, int& index, int l)\\n    {\\n        string t;\\n        int i;\\n        for ( i=index;i<l;i++){\\n            if (str[i] == \\',\\')\\n                break;\\n            t+=str[i];\\n        }\\n        index =i+1;\\n        if (t == \"N\")\\n            return NULL;\\n        TreeNode* root = new TreeNode(stoi(t));\\n\\n        root->left = myfun2(str,index,l );\\n        root->right = myfun2(str,index, l);\\n        return root;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int index =0;\\n        return myfun2(data,index, data.size());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 316339,
                "title": "c-iterative-postorder-simple-4-byte-encoding-decoding-string-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //convert integer to 4 byte string\\n    string IntToStr( int val )\\n    {\\n        //Convert integer to char\\n        \\n        string s;\\n        char temp = (char)((val >> 24) & 0xff); //consider only last 8 bytes \"->(0x01) 0x00 0x00 0x00 \"\\n        s.push_back ( temp );\\n        \\n        char temp1 = (char)((val >> 16) & 0xff);\\n        s.push_back ( temp1 );\\n        \\n        char temp2 = (char)((val >> 8) & 0xff); \\n        s.push_back ( temp2 );\\n        \\n        char temp3 = (char)((val) & 0xff); //consider only first 8 bytes \"0x00 0x00 0x00 (0x01)<-\"\\n        s.push_back ( temp3 );\\n       // cout << \"encoded \" << val << \" \" << s << endl;\\n        return s;\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        \\n        TreeNode* current = root;\\n        stack<TreeNode*> s; \\n        string result = \"\";\\n        \\n        if ( !current )\\n            return \"\";\\n        \\n        \\n        while ( current || !s.empty() )\\n        {\\n            if ( current )\\n            { \\n                    if ( current->right )\\n                    {\\n                        s.push ( current->right );\\n                    }\\n                    s.push ( current );\\n                    current = current->left;\\n            }else \\n            {//if current null or reached the end of the tree;\\n                \\n                if ( s.empty() )\\n                    break;   \\n               \\n                //current\\'s right element not yet processed;\\n                if ( !s.empty() ) \\n                {\\n                    current = s.top();\\n                    s.pop();\\n                \\n                    if ( !s.empty() && current->right == s.top() )\\n                    {\\n                        s.pop();\\n                        s.push ( current );\\n                        current = current->right;\\n                    }\\n                    else \\n                    {//process element;\\n                        result = result + IntToStr( current->val );\\n                        current = NULL;\\n                    }   \\n                }\\n            }\\n        }\\n       // cout << result << endl;\\n        return result;\\n    }\\n    \\n   \\n    TreeNode* deserializeHelper(vector<int>& data, int startRange, int endRange )\\n    {\\n        if ( data.size() == 0 )\\n            return NULL;\\n    \\n        int val = data.back();\\n        \\n       cout << \"processing  \" << val << endl; \\n        if ( val < startRange || val >  endRange )\\n            return NULL;\\n        \\n        data.pop_back();\\n        cout << \"taking out  \" << val << endl;\\n        TreeNode* root = new TreeNode( val );\\n        \\n        root->right = deserializeHelper( data, val, endRange ); //in right value should be greater then current value\\n        //start = current to max int\\n       \\n        root->left = deserializeHelper( data, startRange, val ); //in left tree value should be less than current value; \\n        //start = min int to max current val \\n        return root;\\n    }\\n    \\n    //Convert 4byte string to integer \\n    int StrToInt ( string s )\\n    {\\n        int result = 0;\\n        for ( int i = 0; i < s.size(); ++i )\\n        {\\n            //2 was encoded as \"0x00 0x00 0x00 00000010\"\\n            //256 was encoded as \"0x00 0x00 000000001 0x00\"\\n            //512 was encoded as \"0x00 00000001 0x00 0x00\"\\n            //Every char or single byte can be represented as 0-255 chars\\n            int temp = (int)s[i];\\n            result = result* 256 + temp;\\n        }\\n      //  cout << \"result \" << result << endl;\\n        return result;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n       \\n         if ( data.size() == 0 )\\n            return NULL;\\n        \\n        vector<int> treeData;\\n        for ( int i = 0; i <= data.size() - 4; i = i + 4 ) //read 4 chars at a time\\n        {\\n            string s = data.substr(i,4);\\n            int temp = StrToInt(s);\\n            treeData.push_back ( temp );\\n        }\\n        \\n        return deserializeHelper( treeData , INT_MIN, INT_MAX ) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //convert integer to 4 byte string\\n    string IntToStr( int val )\\n    {\\n        //Convert integer to char\\n        \\n        string s;\\n        char temp = (char)((val >> 24) & 0xff); //consider only last 8 bytes \"->(0x01) 0x00 0x00 0x00 \"\\n        s.push_back ( temp );\\n        \\n        char temp1 = (char)((val >> 16) & 0xff);\\n        s.push_back ( temp1 );\\n        \\n        char temp2 = (char)((val >> 8) & 0xff); \\n        s.push_back ( temp2 );\\n        \\n        char temp3 = (char)((val) & 0xff); //consider only first 8 bytes \"0x00 0x00 0x00 (0x01)<-\"\\n        s.push_back ( temp3 );\\n       // cout << \"encoded \" << val << \" \" << s << endl;\\n        return s;\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        \\n        TreeNode* current = root;\\n        stack<TreeNode*> s; \\n        string result = \"\";\\n        \\n        if ( !current )\\n            return \"\";\\n        \\n        \\n        while ( current || !s.empty() )\\n        {\\n            if ( current )\\n            { \\n                    if ( current->right )\\n                    {\\n                        s.push ( current->right );\\n                    }\\n                    s.push ( current );\\n                    current = current->left;\\n            }else \\n            {//if current null or reached the end of the tree;\\n                \\n                if ( s.empty() )\\n                    break;   \\n               \\n                //current\\'s right element not yet processed;\\n                if ( !s.empty() ) \\n                {\\n                    current = s.top();\\n                    s.pop();\\n                \\n                    if ( !s.empty() && current->right == s.top() )\\n                    {\\n                        s.pop();\\n                        s.push ( current );\\n                        current = current->right;\\n                    }\\n                    else \\n                    {//process element;\\n                        result = result + IntToStr( current->val );\\n                        current = NULL;\\n                    }   \\n                }\\n            }\\n        }\\n       // cout << result << endl;\\n        return result;\\n    }\\n    \\n   \\n    TreeNode* deserializeHelper(vector<int>& data, int startRange, int endRange )\\n    {\\n        if ( data.size() == 0 )\\n            return NULL;\\n    \\n        int val = data.back();\\n        \\n       cout << \"processing  \" << val << endl; \\n        if ( val < startRange || val >  endRange )\\n            return NULL;\\n        \\n        data.pop_back();\\n        cout << \"taking out  \" << val << endl;\\n        TreeNode* root = new TreeNode( val );\\n        \\n        root->right = deserializeHelper( data, val, endRange ); //in right value should be greater then current value\\n        //start = current to max int\\n       \\n        root->left = deserializeHelper( data, startRange, val ); //in left tree value should be less than current value; \\n        //start = min int to max current val \\n        return root;\\n    }\\n    \\n    //Convert 4byte string to integer \\n    int StrToInt ( string s )\\n    {\\n        int result = 0;\\n        for ( int i = 0; i < s.size(); ++i )\\n        {\\n            //2 was encoded as \"0x00 0x00 0x00 00000010\"\\n            //256 was encoded as \"0x00 0x00 000000001 0x00\"\\n            //512 was encoded as \"0x00 00000001 0x00 0x00\"\\n            //Every char or single byte can be represented as 0-255 chars\\n            int temp = (int)s[i];\\n            result = result* 256 + temp;\\n        }\\n      //  cout << \"result \" << result << endl;\\n        return result;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n       \\n         if ( data.size() == 0 )\\n            return NULL;\\n        \\n        vector<int> treeData;\\n        for ( int i = 0; i <= data.size() - 4; i = i + 4 ) //read 4 chars at a time\\n        {\\n            string s = data.substr(i,4);\\n            int temp = StrToInt(s);\\n            treeData.push_back ( temp );\\n        }\\n        \\n        return deserializeHelper( treeData , INT_MIN, INT_MAX ) ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 291742,
                "title": "c-solution-with-recursion",
                "content": "```\\n#include <sstream>\\n\\nclass Codec {\\nprivate:\\n    void addNodeToString(stringstream& ss, TreeNode* ptrNode) {\\n        if (ptrNode == nullptr) return;\\n        ss << ptrNode->val << \\' \\';\\n        addNodeToString(ss, ptrNode->left);\\n        addNodeToString(ss, ptrNode->right);\\n    }\\n    \\n    void recInsert(const int& i, TreeNode*& ptrNode) {  \\n        if (ptrNode == nullptr) {\\n            ptrNode = new TreeNode(i);\\n            return;\\n        }\\n        if (i < ptrNode->val) recInsert(i, ptrNode->left);\\n        else recInsert(i, ptrNode->right);\\n    }\\n    \\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        stringstream ss;\\n        addNodeToString(ss, root);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(string data) {        \\n        TreeNode* root = nullptr;\\n        stringstream ss { data };\\n        for (int i; ss >> i; ){   \\n            recInsert(i, root);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <sstream>\\n\\nclass Codec {\\nprivate:\\n    void addNodeToString(stringstream& ss, TreeNode* ptrNode) {\\n        if (ptrNode == nullptr) return;\\n        ss << ptrNode->val << \\' \\';\\n        addNodeToString(ss, ptrNode->left);\\n        addNodeToString(ss, ptrNode->right);\\n    }\\n    \\n    void recInsert(const int& i, TreeNode*& ptrNode) {  \\n        if (ptrNode == nullptr) {\\n            ptrNode = new TreeNode(i);\\n            return;\\n        }\\n        if (i < ptrNode->val) recInsert(i, ptrNode->left);\\n        else recInsert(i, ptrNode->right);\\n    }\\n    \\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        stringstream ss;\\n        addNodeToString(ss, root);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(string data) {        \\n        TreeNode* root = nullptr;\\n        stringstream ss { data };\\n        for (int i; ss >> i; ){   \\n            recInsert(i, root);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 277318,
                "title": "java-9-ms-easy-solution-50-faster",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return null;\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n         if (data == null || data.isEmpty()) return null;\\n\\n            String args[] = data.split(\",\");\\n\\n            TreeNode node = null;\\n            for (String str : args) {\\n                if (str == null || str.equals(\"null\")) continue;\\n                node = insert(node, Integer.parseInt(str));\\n            }\\n\\n            return node;\\n    }\\n    \\n    \\n        private TreeNode insert(TreeNode root, Integer val) {\\n            if (root == null) {\\n                root = new TreeNode(val);\\n                return root;\\n            }\\n\\n            if (val < root.val) {\\n                root.left = insert(root.left, val);\\n            } else if (val > root.val) {\\n                root.right = insert(root.right, val);\\n            }\\n\\n            return root;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return null;\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n         if (data == null || data.isEmpty()) return null;\\n\\n            String args[] = data.split(\",\");\\n\\n            TreeNode node = null;\\n            for (String str : args) {\\n                if (str == null || str.equals(\"null\")) continue;\\n                node = insert(node, Integer.parseInt(str));\\n            }\\n\\n            return node;\\n    }\\n    \\n    \\n        private TreeNode insert(TreeNode root, Integer val) {\\n            if (root == null) {\\n                root = new TreeNode(val);\\n                return root;\\n            }\\n\\n            if (val < root.val) {\\n                root.left = insert(root.left, val);\\n            } else if (val > root.val) {\\n                root.right = insert(root.right, val);\\n            }\\n\\n            return root;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262624,
                "title": "my-c-json-solution-with-some-explanation-parse-json-in-one-pass",
                "content": "I knew json may not the most effective way here.\\nBut because json is a very popular and readable data format, I decided to convert tree into json.\\nAnd here is a snippet of json example:\\n```\\n{\\n\\t\"v\": 2,\\n\\t\"l\": {\\n\\t\\t\"v\": 1\\n\\t},\\n\\t\"r\": {\\n\\t\\t\"v\": 3\\n\\t}\\n}\\n```\\nHere is my code:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string encode(TreeNode* root){\\n        if(root==nullptr){\\n            return \"{}\";\\n        }\\n        string ret = \"{\\\\\"v\\\\\":\";\\n        ret += to_string(root->val);\\n        if(root->left){\\n            ret+= (\",\\\\\"l\\\\\":\" + encode(root->left));\\n        }\\n        if(root->right){\\n            ret+= (\",\\\\\"r\\\\\":\" + encode(root->right));\\n        }\\n        ret += \"}\";\\n        return ret;\\n    }\\n    int value(const string& str, int& i){\\n        int ret = 0;\\n        while(str[i]>=\\'0\\'&&str[i]<=\\'9\\'){\\n            ret = ret*10 + str[i] - \\'0\\';\\n            i++;\\n        }\\n        return ret;\\n    }\\n    TreeNode* decode(const string& str, int& i){\\n        if(i>=str.size()){\\n            return nullptr;\\n        }\\n        else if(str[i]!=\\'{\\'){\\n            return nullptr;\\n        }\\n        i++;\\n        TreeNode* ret = nullptr;\\n        TreeNode *left = nullptr, *right = nullptr;\\n        if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'v\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n            i+=4;\\n            ret = new TreeNode(value(str,i));\\n        }\\n        if(ret){\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'l\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                left = decode(str,i);\\n            }\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'r\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                right = decode(str,i);\\n            }\\n            ret->left = left;\\n            ret->right = right;\\n        }\\n        if(str[i]==\\'}\\'){\\n            i++;\\n        }\\n        return ret;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data,i);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```\\n",
                "solutionTags": [],
                "code": "```\\n{\\n\\t\"v\": 2,\\n\\t\"l\": {\\n\\t\\t\"v\": 1\\n\\t},\\n\\t\"r\": {\\n\\t\\t\"v\": 3\\n\\t}\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string encode(TreeNode* root){\\n        if(root==nullptr){\\n            return \"{}\";\\n        }\\n        string ret = \"{\\\\\"v\\\\\":\";\\n        ret += to_string(root->val);\\n        if(root->left){\\n            ret+= (\",\\\\\"l\\\\\":\" + encode(root->left));\\n        }\\n        if(root->right){\\n            ret+= (\",\\\\\"r\\\\\":\" + encode(root->right));\\n        }\\n        ret += \"}\";\\n        return ret;\\n    }\\n    int value(const string& str, int& i){\\n        int ret = 0;\\n        while(str[i]>=\\'0\\'&&str[i]<=\\'9\\'){\\n            ret = ret*10 + str[i] - \\'0\\';\\n            i++;\\n        }\\n        return ret;\\n    }\\n    TreeNode* decode(const string& str, int& i){\\n        if(i>=str.size()){\\n            return nullptr;\\n        }\\n        else if(str[i]!=\\'{\\'){\\n            return nullptr;\\n        }\\n        i++;\\n        TreeNode* ret = nullptr;\\n        TreeNode *left = nullptr, *right = nullptr;\\n        if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'v\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n            i+=4;\\n            ret = new TreeNode(value(str,i));\\n        }\\n        if(ret){\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'l\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                left = decode(str,i);\\n            }\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'r\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                right = decode(str,i);\\n            }\\n            ret->left = left;\\n            ret->right = right;\\n        }\\n        if(str[i]==\\'}\\'){\\n            i++;\\n        }\\n        return ret;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data,i);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244201,
                "title": "python-with-comments-preorder-traversal",
                "content": "```\\nfrom collections import deque\\n\\nclass Codec:\\n    # recursive function to serialize BST\\n    # using a pre-order traversal\\n    # simply stores node values to a list\\n    def serialize_bst(self, root, preorder):\\n        if root is None:\\n            return\\n        preorder.append(str(root.val))\\n        self.serialize_bst(root.left, preorder)\\n        self.serialize_bst(root.right, preorder)\\n        \\n    # serialize BST to pre-order traversal\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        preorder = []\\n        self.serialize_bst(root, preorder)\\n        return \\',\\'.join(preorder)\\n\\n    # recursive function to deserialize BST from preorder queue\\n    def deserialize_bst(self, queue, maximum):\\n        # base case: empty queue\\n        if len(queue) == 0:\\n            return None\\n        \\n        # if the head of the queue is too big\\n        # then this node is not meant to be placed here\\n        if int(queue[0]) > maximum:\\n            return None\\n        \\n        # create root node\\n        root = TreeNode(int(queue.popleft()))\\n    \\n        # create left and right subtrees\\n        root.left = self.deserialize_bst(queue, root.val)\\n        root.right = self.deserialize_bst(queue, maximum)\\n        \\n        # return root node\\n        return root\\n    \\n    # deserialize BST pre-order traversal\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # sanity check: empty input be ignored, don\\'t creat queue\\n        if len(data) == 0:\\n            return None\\n        queue = deque(data.split(\\',\\'))\\n        # the maximum value is infinity\\n        root = self.deserialize_bst(queue, float(\\'inf\\'))\\n        return root    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Codec:\\n    # recursive function to serialize BST\\n    # using a pre-order traversal\\n    # simply stores node values to a list\\n    def serialize_bst(self, root, preorder):\\n        if root is None:\\n            return\\n        preorder.append(str(root.val))\\n        self.serialize_bst(root.left, preorder)\\n        self.serialize_bst(root.right, preorder)\\n        \\n    # serialize BST to pre-order traversal\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        preorder = []\\n        self.serialize_bst(root, preorder)\\n        return \\',\\'.join(preorder)\\n\\n    # recursive function to deserialize BST from preorder queue\\n    def deserialize_bst(self, queue, maximum):\\n        # base case: empty queue\\n        if len(queue) == 0:\\n            return None\\n        \\n        # if the head of the queue is too big\\n        # then this node is not meant to be placed here\\n        if int(queue[0]) > maximum:\\n            return None\\n        \\n        # create root node\\n        root = TreeNode(int(queue.popleft()))\\n    \\n        # create left and right subtrees\\n        root.left = self.deserialize_bst(queue, root.val)\\n        root.right = self.deserialize_bst(queue, maximum)\\n        \\n        # return root node\\n        return root\\n    \\n    # deserialize BST pre-order traversal\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # sanity check: empty input be ignored, don\\'t creat queue\\n        if len(data) == 0:\\n            return None\\n        queue = deque(data.split(\\',\\'))\\n        # the maximum value is infinity\\n        root = self.deserialize_bst(queue, float(\\'inf\\'))\\n        return root    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 233148,
                "title": "java-preorder-recursion-solution-easy-to-understand",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        // pre-order traversal\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();    \\n    }\\n    \\n    private void serializeHelper(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val + \" \");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() == 0) return null;\\n        // split the string and change to an integer array\\n        String[] strNodes = data.split(\" \");\\n        int n = strNodes.length;\\n        int[] nodes = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nodes[i] = Integer.parseInt(strNodes[i]);\\n        }\\n        \\n        return deserializeHelper(nodes, 0, n - 1);   \\n    }\\n    \\n    private TreeNode deserializeHelper(int[] nodes, int low, int high) {\\n        if (low > high) return null;\\n        TreeNode root = new TreeNode(nodes[low]);\\n        \\n        // find the first index that is larger than low\\n        // [low + 1, j - 1] is the left subtree, [j, high] is the right subtree\\n        int j = low + 1;\\n        for (; j <= high; j++) {\\n            if (nodes[j] > nodes[low]) break;\\n        }\\n        root.left = deserializeHelper(nodes, low + 1, j - 1);\\n        root.right = deserializeHelper(nodes, j, high);\\n        return root; \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        // pre-order traversal\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();    \\n    }\\n    \\n    private void serializeHelper(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val + \" \");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() == 0) return null;\\n        // split the string and change to an integer array\\n        String[] strNodes = data.split(\" \");\\n        int n = strNodes.length;\\n        int[] nodes = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nodes[i] = Integer.parseInt(strNodes[i]);\\n        }\\n        \\n        return deserializeHelper(nodes, 0, n - 1);   \\n    }\\n    \\n    private TreeNode deserializeHelper(int[] nodes, int low, int high) {\\n        if (low > high) return null;\\n        TreeNode root = new TreeNode(nodes[low]);\\n        \\n        // find the first index that is larger than low\\n        // [low + 1, j - 1] is the left subtree, [j, high] is the right subtree\\n        int j = low + 1;\\n        for (; j <= high; j++) {\\n            if (nodes[j] > nodes[low]) break;\\n        }\\n        root.left = deserializeHelper(nodes, low + 1, j - 1);\\n        root.right = deserializeHelper(nodes, j, high);\\n        return root; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187710,
                "title": "java-pre-order-level-order",
                "content": "Hope it helps!\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#!\";\\n        }\\n        String val = root.val + \"!\";\\n        val += serialize(root.left);\\n        val += serialize(root.right);\\n        return val;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> queue = new LinkedList<>();\\n        String[] list = data.split(\"!\");\\n        for(String s : list){\\n            queue.offer(s);\\n        }\\n        return reconPreOrder(queue);\\n    }\\n    private TreeNode reconPreOrder(Queue<String> queue){\\n        String s = queue.poll();\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        TreeNode head = new TreeNode(Integer.valueOf(s));\\n        head.left = reconPreOrder(queue);\\n        head.right = reconPreOrder(queue);\\n        return head;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        String res = \"\";\\n        if(root == null){\\n            res += \"#!\";\\n            return res;\\n        }\\n        res += root.val + \"!\";\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode head = queue.poll();\\n            if(head.left != null){\\n                queue.offer(head.left);\\n                res += head.left.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n            if(head.right != null){\\n                queue.offer(head.right);\\n                res += head.right.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n        }\\n        return res;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\"!\");\\n        int index = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode head = generateNode(values[index++]);\\n        if(head != null){\\n            queue.offer(head);\\n        }\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            node.left = generateNode(values[index++]);\\n            node.right = generateNode(values[index++]);\\n            if(node.left != null){\\n                queue.offer(node.left);\\n            }\\n            if(node.right != null){\\n                queue.offer(node.right);\\n            }\\n            \\n        }\\n        return head;\\n    }\\n    private TreeNode generateNode(String s){\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        return new TreeNode(Integer.valueOf(s));\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\nany questions is welcome!",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#!\";\\n        }\\n        String val = root.val + \"!\";\\n        val += serialize(root.left);\\n        val += serialize(root.right);\\n        return val;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> queue = new LinkedList<>();\\n        String[] list = data.split(\"!\");\\n        for(String s : list){\\n            queue.offer(s);\\n        }\\n        return reconPreOrder(queue);\\n    }\\n    private TreeNode reconPreOrder(Queue<String> queue){\\n        String s = queue.poll();\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        TreeNode head = new TreeNode(Integer.valueOf(s));\\n        head.left = reconPreOrder(queue);\\n        head.right = reconPreOrder(queue);\\n        return head;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        String res = \"\";\\n        if(root == null){\\n            res += \"#!\";\\n            return res;\\n        }\\n        res += root.val + \"!\";\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode head = queue.poll();\\n            if(head.left != null){\\n                queue.offer(head.left);\\n                res += head.left.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n            if(head.right != null){\\n                queue.offer(head.right);\\n                res += head.right.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n        }\\n        return res;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\"!\");\\n        int index = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode head = generateNode(values[index++]);\\n        if(head != null){\\n            queue.offer(head);\\n        }\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            node.left = generateNode(values[index++]);\\n            node.right = generateNode(values[index++]);\\n            if(node.left != null){\\n                queue.offer(node.left);\\n            }\\n            if(node.right != null){\\n                queue.offer(node.right);\\n            }\\n            \\n        }\\n        return head;\\n    }\\n    private TreeNode generateNode(String s){\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        return new TreeNode(Integer.valueOf(s));\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184785,
                "title": "c-preorder-recursion-beats-100",
                "content": "    public class Codec\n    {\n\n        // Encodes a tree to a single string.\n        public string serialize(TreeNode root)\n        {\n            if (root == null) return string.Empty;\n\n            StringBuilder sb = new StringBuilder();\n            PreOrder(root, sb);\n            sb.Remove(sb.Length - 1, 1);\n            return sb.ToString();\n        }\n\n        void PreOrder(TreeNode r, StringBuilder sb)\n        {\n            sb.Append(r.val);\n            sb.Append(\",\");\n            if (r.left != null)\n            {\n                PreOrder(r.left, sb);\n            }\n            if (r.right != null)\n            {\n                PreOrder(r.right, sb);\n            }\n        }\n\n        // Decodes your encoded data to tree.\n        public TreeNode deserialize(string data)\n        {\n            if (data == string.Empty) return null;\n\n            int[] d = data.Split(',').Select(s => int.Parse(s)).ToArray();\n            int ri = 0;\n            return deserialize(d, ref ri, Int32.MaxValue);\n        }\n\n        private TreeNode deserialize(int[] data, ref int ri, int max)\n        {\n            TreeNode r = new TreeNode(data[ri]);\n\n            if (++ri == data.Length) return r;\n\n            if (data[ri] <= r.val)\n            {\n                r.left = deserialize(data, ref ri, r.val);\n            }\n\n            if (ri == data.Length) return r;\n\n            if (r.val < data[ri] && data[ri] <= max)\n            {\n                r.right = deserialize(data, ref ri, max);\n            }\n\n            return r;\n        }\n    }\n",
                "solutionTags": [],
                "code": "    public class Codec\n    {\n        public string serialize(TreeNode root)\n        {\n            if (root == null) return string.Empty;\n            StringBuilder sb = new StringBuilder();\n            PreOrder(root, sb);\n            sb.Remove(sb.Length - 1, 1);\n            return sb.ToString();\n        }\n        void PreOrder(TreeNode r, StringBuilder sb)\n        {\n            sb.Append(r.val);\n            sb.Append(\",\");\n            if (r.left != null)\n            {\n                PreOrder(r.left, sb);\n            }\n            if (r.right != null)\n            {\n                PreOrder(r.right, sb);\n            }\n        }\n        public TreeNode deserialize(string data)\n        {\n            if (data == string.Empty) return null;\n            int[] d = data.Split(',').Select(s => int.Parse(s)).ToArray();\n            int ri = 0;\n            return deserialize(d, ref ri, Int32.MaxValue);\n        }\n        private TreeNode deserialize(int[] data, ref int ri, int max)\n        {\n            TreeNode r = new TreeNode(data[ri]);\n            if (++ri == data.Length) return r;\n            if (data[ri] <= r.val)\n            {\n                r.left = deserialize(data, ref ri, r.val);\n            }\n            if (ri == data.Length) return r;\n            if (r.val < data[ri] && data[ri] <= max)\n            {\n                r.right = deserialize(data, ref ri, max);\n            }\n            return r;\n        }\n    }",
                "codeTag": "Java"
            },
            {
                "id": 93176,
                "title": "java-solution-beats-99-3-super-easy-to-understand",
                "content": "i firstly converts the bst in to a string with pre order traversal such that when we need to convert it back , it would be easy to know what is the root. Then recursively convert with the lower and upper boundary check.\\n\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n        helper(root , res);\\n        return new String(res);\\n    }\\n\\n    public void helper(TreeNode root , StringBuilder a) {\\n        if (root == null) return;\\n        a.append((char)(root.val));\\n        helper(root.left , a);\\n        helper(root.right , a);\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    int index = 0;\\n    public TreeNode deserialize(String data) {\\n        char[] input = data.toCharArray();\\n        return helper2(input , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n        \\n    }\\n    private TreeNode helper2(char[] input , int min , int max) {\\n        if (index >= input.length || Integer.valueOf(input[index]) >= max || Integer.valueOf(input[index]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(input[index++]));\\n        root.left = helper2(input , min,Integer.valueOf(root.val));\\n        root.right = helper2(input , Integer.valueOf(root.val) , max);\\n        return root;\\n    }\\n}\\n'''",
                "solutionTags": [],
                "code": "i firstly converts the bst in to a string with pre order traversal such that when we need to convert it back , it would be easy to know what is the root. Then recursively convert with the lower and upper boundary check.\\n\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n        helper(root , res);\\n        return new String(res);\\n    }\\n\\n    public void helper(TreeNode root , StringBuilder a) {\\n        if (root == null) return;\\n        a.append((char)(root.val));\\n        helper(root.left , a);\\n        helper(root.right , a);\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    int index = 0;\\n    public TreeNode deserialize(String data) {\\n        char[] input = data.toCharArray();\\n        return helper2(input , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n        \\n    }\\n    private TreeNode helper2(char[] input , int min , int max) {\\n        if (index >= input.length || Integer.valueOf(input[index]) >= max || Integer.valueOf(input[index]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(input[index++]));\\n        root.left = helper2(input , min,Integer.valueOf(root.val));\\n        root.right = helper2(input , Integer.valueOf(root.val) , max);\\n        return root;\\n    }\\n}\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 93191,
                "title": "a-few-solutions",
                "content": "Whitespace delimited serialization/deserialization of the pre-order traversal of the tree.  `null` values are represented as `-1`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Codec() {\\n    fun serialize(root: TreeNode?): String {\\n        var A = mutableListOf<Int>()\\n        fun go(node: TreeNode? = root) {\\n            if (node == null) {\\n                A.add(-1)\\n                return\\n            }\\n            A.add(node?.`val`)\\n            go(node?.left)\\n            go(node?.right)\\n        }\\n        go()\\n        return A.joinToString(\" \")\\n    }\\n    fun deserialize(S: String): TreeNode? {\\n        var A = ArrayDeque<Int>(S.split(\" \").map{ it.toInt() })\\n        fun go(): TreeNode? {\\n            if (A.size == 0)\\n                return null\\n            var x = A.removeFirst().toInt()\\n            var root = if (-1 < x) TreeNode(x) else null\\n            root?.left = go()\\n            root?.right = go()\\n            return root\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet serialize = (root, q = []) => {\\n    let go = root => {\\n        if (!root) {\\n            q.push(-1);\\n            return;\\n        }\\n        q.push(root.val);\\n        go(root.left);\\n        go(root.right);\\n    };\\n    go(root);\\n    return q.join(\\' \\');\\n};\\nlet deserialize = (data, q = data.split(\\' \\')) => {\\n    let go = () => {\\n        if (!q.length)\\n            return;\\n        let x = q.shift();\\n        let root = -1 < x ? new TreeNode(x) : null;\\n        if (root) root.left  = go();\\n        if (root) root.right = go();\\n        return root;\\n    };\\n    return go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        q = []\\n        def go(root):\\n            if not root:\\n                q.append(-1)\\n                return\\n            q.append(root.val)\\n            go(root.left)\\n            go(root.right)\\n        go(root)\\n        return \\' \\'.join([str(x) for x in q])\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        q = deque([int(s) for s in data.split(\\' \\')])\\n        def go():\\n            if not len(q):\\n                return\\n            x = q.popleft()\\n            root = TreeNode(x) if -1 < x else None\\n            if root: root.left  = go()\\n            if root: root.right = go()\\n            return root\\n        return go()\\n```\\n\\n*C++*\\n```\\nclass Codec {\\npublic:\\n    using fun1 = function<void(TreeNode*)>;\\n    using fun2 = function<TreeNode*()>;\\n    string serialize(TreeNode* root, vector<int> q = {}) {\\n        fun1 go = [&](auto root) {\\n            if (!root) {\\n                q.push_back(-1);\\n                return;\\n            }\\n            q.push_back(root->val);\\n            go(root->left);\\n            go(root->right);\\n        };\\n        go(root);\\n        ostringstream stream; copy(q.begin(), q.end(), ostream_iterator<int>(stream, \" \"));\\n        return stream.str();\\n    }\\n    TreeNode* deserialize(string data) {\\n        istringstream stream{ data };\\n        fun2 go = [&](int x = 0) -> TreeNode* {\\n            if (!(stream >> x))\\n                return nullptr;\\n            auto root = -1 < x ? new TreeNode(x) : nullptr;\\n            if (root) root->left  = go();\\n            if (root) root->right = go();\\n            return root;\\n        };\\n        return go();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec() {\\n    fun serialize(root: TreeNode?): String {\\n        var A = mutableListOf<Int>()\\n        fun go(node: TreeNode? = root) {\\n            if (node == null) {\\n                A.add(-1)\\n                return\\n            }\\n            A.add(node?.`val`)\\n            go(node?.left)\\n            go(node?.right)\\n        }\\n        go()\\n        return A.joinToString(\" \")\\n    }\\n    fun deserialize(S: String): TreeNode? {\\n        var A = ArrayDeque<Int>(S.split(\" \").map{ it.toInt() })\\n        fun go(): TreeNode? {\\n            if (A.size == 0)\\n                return null\\n            var x = A.removeFirst().toInt()\\n            var root = if (-1 < x) TreeNode(x) else null\\n            root?.left = go()\\n            root?.right = go()\\n            return root\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nlet serialize = (root, q = []) => {\\n    let go = root => {\\n        if (!root) {\\n            q.push(-1);\\n            return;\\n        }\\n        q.push(root.val);\\n        go(root.left);\\n        go(root.right);\\n    };\\n    go(root);\\n    return q.join(\\' \\');\\n};\\nlet deserialize = (data, q = data.split(\\' \\')) => {\\n    let go = () => {\\n        if (!q.length)\\n            return;\\n        let x = q.shift();\\n        let root = -1 < x ? new TreeNode(x) : null;\\n        if (root) root.left  = go();\\n        if (root) root.right = go();\\n        return root;\\n    };\\n    return go();\\n};\\n```\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        q = []\\n        def go(root):\\n            if not root:\\n                q.append(-1)\\n                return\\n            q.append(root.val)\\n            go(root.left)\\n            go(root.right)\\n        go(root)\\n        return \\' \\'.join([str(x) for x in q])\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        q = deque([int(s) for s in data.split(\\' \\')])\\n        def go():\\n            if not len(q):\\n                return\\n            x = q.popleft()\\n            root = TreeNode(x) if -1 < x else None\\n            if root: root.left  = go()\\n            if root: root.right = go()\\n            return root\\n        return go()\\n```\n```\\nclass Codec {\\npublic:\\n    using fun1 = function<void(TreeNode*)>;\\n    using fun2 = function<TreeNode*()>;\\n    string serialize(TreeNode* root, vector<int> q = {}) {\\n        fun1 go = [&](auto root) {\\n            if (!root) {\\n                q.push_back(-1);\\n                return;\\n            }\\n            q.push_back(root->val);\\n            go(root->left);\\n            go(root->right);\\n        };\\n        go(root);\\n        ostringstream stream; copy(q.begin(), q.end(), ostream_iterator<int>(stream, \" \"));\\n        return stream.str();\\n    }\\n    TreeNode* deserialize(string data) {\\n        istringstream stream{ data };\\n        fun2 go = [&](int x = 0) -> TreeNode* {\\n            if (!(stream >> x))\\n                return nullptr;\\n            auto root = -1 < x ? new TreeNode(x) : nullptr;\\n            if (root) root->left  = go();\\n            if (root) root->right = go();\\n            return root;\\n        };\\n        return go();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93211,
                "title": "c-level-traversal-by-using-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        if (root==null) return null;\\n        var list = new List<string>();\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Count>0){\\n            var count = q.Count;\\n            var node = q.Dequeue();\\n            \\n            if(node != null){\\n                list.Add(node.val.ToString());  \\n                q.Enqueue(node.left);\\n                q.Enqueue(node.right);\\n            }\\n            else{\\n                list.Add(\"#\");\\n            }\\n        }\\n        \\n        return string.Join(\",\", list);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        if(data == null) return null;\\n        var list = data.Split(new char[]{','}, StringSplitOptions.RemoveEmptyEntries);\\n        if(list.Length == 0 ) return null;\\n        var root = new TreeNode(int.Parse(list[0]));\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        \\n        for(var i=1;i<list.Length;i=i+2){\\n            var node = q.Dequeue();\\n            \\n            if(!list[i].Equals(\"#\")){\\n                node.left = new TreeNode(int.Parse(list[i]));\\n                q.Enqueue(node.left);\\n            }\\n            \\n            if(i+1<list.Length && !list[i+1].Equals(\"#\")){\\n                node.right = new TreeNode(int.Parse(list[i+1]));\\n                q.Enqueue(node.right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        if (root==null) return null;\\n        var list = new List<string>();\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Count>0){\\n            var count = q.Count;\\n            var node = q.Dequeue();\\n            \\n            if(node != null){\\n                list.Add(node.val.ToString());  \\n                q.Enqueue(node.left);\\n                q.Enqueue(node.right);\\n            }\\n            else{\\n                list.Add(\"#\");\\n            }\\n        }\\n        \\n        return string.Join(\",\", list);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        if(data == null) return null;\\n        var list = data.Split(new char[]{','}, StringSplitOptions.RemoveEmptyEntries);\\n        if(list.Length == 0 ) return null;\\n        var root = new TreeNode(int.Parse(list[0]));\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        \\n        for(var i=1;i<list.Length;i=i+2){\\n            var node = q.Dequeue();\\n            \\n            if(!list[i].Equals(\"#\")){\\n                node.left = new TreeNode(int.Parse(list[i]));\\n                q.Enqueue(node.left);\\n            }\\n            \\n            if(i+1<list.Length && !list[i+1].Equals(\"#\")){\\n                node.right = new TreeNode(int.Parse(list[i+1]));\\n                q.Enqueue(node.right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93210,
                "title": "java-dfs-queue-solution",
                "content": "\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"$,\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>();\\n        String[] strs = data.split(\",\");\\n        for (String str : strs) {\\n            q.add(str);\\n        }\\n        return dfs(q);\\n    }\\n    \\n    private TreeNode dfs(Queue<String> q) {\\n        String str = q.remove();\\n        if (str.equals(\"$\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(str));\\n        root.left = dfs(q);\\n        root.right = dfs(q);\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"$,\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>();\\n        String[] strs = data.split(\",\");\\n        for (String str : strs) {\\n            q.add(str);\\n        }\\n        return dfs(q);\\n    }\\n    \\n    private TreeNode dfs(Queue<String> q) {\\n        String str = q.remove();\\n        if (str.equals(\"$\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(str));\\n        root.left = dfs(q);\\n        root.right = dfs(q);\\n        return root;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 93260,
                "title": "easy-bfs-java",
                "content": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        StringBuilder s=new StringBuilder();\\n        if(root==null)\\n        return \"*-\";\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode temp=q.remove();\\n            if(temp==null)\\n            s.append(\"*-\");\\n            else{\\n            s.append(temp.val+\"-\");\\n            q.add(temp.left);\\n            q.add(temp.right);\\n            }\\n        }\\n        \\n        return s.toString();\\n    }\\n\\n// Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n       String[] val=data.split(\"-\");\\n       \\n       if(val.length==0)\\n       return null;\\n       if(val[0].equals(\"*\"))\\n       return null;\\n       Queue<TreeNode> q=new LinkedList<TreeNode>();\\n       TreeNode root=new TreeNode(Integer.parseInt(val[0]));\\n       q.add(root);\\n       for(int i=1;i<val.length;i=i+2){\\n           TreeNode Node=q.remove();\\n           if(!val[i].equals(\"*\")){\\n               Node.left=new TreeNode(Integer.parseInt(val[i]));\\n               q.add(Node.left);\\n           }\\n           if(i+1<val.length && !val[i+1].equals(\"*\")){\\n               Node.right=new TreeNode(Integer.parseInt(val[i+1]));\\n               q.add(Node.right);\\n           }\\n       }\\n    \\n       return root;\\n    }",
                "solutionTags": [],
                "code": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        StringBuilder s=new StringBuilder();\\n        if(root==null)\\n        return \"*-\";\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode temp=q.remove();\\n            if(temp==null)\\n            s.append(\"*-\");\\n            else{\\n            s.append(temp.val+\"-\");\\n            q.add(temp.left);\\n            q.add(temp.right);\\n            }\\n        }\\n        \\n        return s.toString();\\n    }\\n\\n// Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n       String[] val=data.split(\"-\");\\n       \\n       if(val.length==0)\\n       return null;\\n       if(val[0].equals(\"*\"))\\n       return null;\\n       Queue<TreeNode> q=new LinkedList<TreeNode>();\\n       TreeNode root=new TreeNode(Integer.parseInt(val[0]));\\n       q.add(root);\\n       for(int i=1;i<val.length;i=i+2){\\n           TreeNode Node=q.remove();\\n           if(!val[i].equals(\"*\")){\\n               Node.left=new TreeNode(Integer.parseInt(val[i]));\\n               q.add(Node.left);\\n           }\\n           if(i+1<val.length && !val[i+1].equals(\"*\")){\\n               Node.right=new TreeNode(Integer.parseInt(val[i+1]));\\n               q.add(Node.right);\\n           }\\n       }\\n    \\n       return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 93283,
                "title": "python-solution-using-bst-property",
                "content": "BST is a special BT, so the solution of lc 297 can be directly applied to this problem. However, this problem asks us to encode the string as compact as possible. The BST property can be harnessed to save the null indicators that were used in lc 297. The following solution is adapted from [this post](https://discuss.leetcode.com/topic/66450/python-o-n-solution-easy-to-understand) with some modifications. \\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n        self._preorder(root, vals)\\n        return ','.join(vals)\\n        \\n    def _preorder(self, node, vals):\\n        if node:\\n            vals.append(str(node.val))\\n            self._preorder(node.left, vals)\\n            self._preorder(node.right, vals)\\n        \\n    def deserialize(self, data):\\n        vals = collections.deque(map(int, data.split(','))) if data else []\\n        return self._build(vals, -float('inf'), float('inf'))\\n\\n    def _build(self, vals, minVal, maxVal):\\n        if vals and minVal < vals[0] < maxVal:\\n            val = vals.popleft()\\n            root = TreeNode(val)\\n            root.left = self._build(vals, minVal, val)\\n            root.right = self._build(vals, val, maxVal)\\n            return root\\n        else:\\n            return None\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n        self._preorder(root, vals)\\n        return ','.join(vals)\\n        \\n    def _preorder(self, node, vals):\\n        if node:\\n            vals.append(str(node.val))\\n            self._preorder(node.left, vals)\\n            self._preorder(node.right, vals)\\n        \\n    def deserialize(self, data):\\n        vals = collections.deque(map(int, data.split(','))) if data else []\\n        return self._build(vals, -float('inf'), float('inf'))\\n\\n    def _build(self, vals, minVal, maxVal):\\n        if vals and minVal < vals[0] < maxVal:\\n            val = vals.popleft()\\n            root = TreeNode(val)\\n            root.left = self._build(vals, minVal, val)\\n            root.right = self._build(vals, val, maxVal)\\n            return root\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93273,
                "title": "java-easy-to-understand-o-n-2-solution",
                "content": "I think there should be O(n) solution which utilize the properties of BST with some boundary MIN/MAX values checking, while I haven't figured them out. Here is somewhat easy to understand O(n^2) solution. If you have done #297, this solution should be obvious.\\n```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return sb.toString();\\n        preorder(root, sb);\\n        return sb.substring(0, sb.length() - 1);\\n    }\\n    private void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\"#\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        String[]arr = data.split(\"#\");\\n        return buildTree(arr, 0, arr.length - 1);\\n    }\\n    private TreeNode buildTree(String[] arr, int l, int r) {\\n        if (l > r) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[l]));\\n        int splitIndex = findIndex(arr, Integer.parseInt(arr[l]), l + 1, r);\\n        root.left = buildTree(arr, l + 1, splitIndex - 1);\\n        root.right = buildTree(arr, splitIndex, r);\\n        return root;\\n    }\\n    private int findIndex(String[] arr, int target, int l, int r) {\\n        int i = l;\\n        for (; i <= r; i++) {\\n            if (Integer.parseInt(arr[i]) > target) break;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return sb.toString();\\n        preorder(root, sb);\\n        return sb.substring(0, sb.length() - 1);\\n    }\\n    private void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\"#\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        String[]arr = data.split(\"#\");\\n        return buildTree(arr, 0, arr.length - 1);\\n    }\\n    private TreeNode buildTree(String[] arr, int l, int r) {\\n        if (l > r) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[l]));\\n        int splitIndex = findIndex(arr, Integer.parseInt(arr[l]), l + 1, r);\\n        root.left = buildTree(arr, l + 1, splitIndex - 1);\\n        root.right = buildTree(arr, splitIndex, r);\\n        return root;\\n    }\\n    private int findIndex(String[] arr, int target, int l, int r) {\\n        int i = l;\\n        for (; i <= r; i++) {\\n            if (Integer.parseInt(arr[i]) > target) break;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007250,
                "title": "c-another-way-to-solve-this-beats-99",
                "content": "This code works for any binary tree*\\n\\n**Serialization (encode):**\\n- Serialize the binary tree in a preorder traversal.\\n- Use \\'-\\' as the delimiter to separate values.\\n- Include a \\'-\\' after each value, even for null nodes, to maintain structure.\\n\\n**Deserialization (decode):**\\n- Deserialize the string data by reading values one by one.\\n- While parsing, create tree nodes for non-null values and reconnect them.\\n- Use \\'-\\' as the delimiter to separate values.\\n- Recursively reconstruct the binary tree from the serialized string.\\n\\n# Code\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (!root) return \"-\";\\n        return to_string(root->val)+\"-\" + serialize(root->left) + serialize(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        int num = 0; bool notnull = false;\\n        while (data[i]<=\\'9\\' && data[i]>=\\'0\\') {\\n            num = num*10 + (data[i]-\\'0\\');\\n            i++;\\n            notnull = true;\\n        }\\n        if (!notnull) {\\n            i++;\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        i++;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\n\\n    TreeNode* deserialize (string data) {\\n        int i=0;\\n        return decode(data, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (!root) return \"-\";\\n        return to_string(root->val)+\"-\" + serialize(root->left) + serialize(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        int num = 0; bool notnull = false;\\n        while (data[i]<=\\'9\\' && data[i]>=\\'0\\') {\\n            num = num*10 + (data[i]-\\'0\\');\\n            i++;\\n            notnull = true;\\n        }\\n        if (!notnull) {\\n            i++;\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        i++;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\n\\n    TreeNode* deserialize (string data) {\\n        int i=0;\\n        return decode(data, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801571,
                "title": "just-leverage-the-typical-bst-insert-function",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* r) {\\n        string s;\\n        encode(r,s);\\n        cout<<s<<endl;\\n        return s;\\n    }\\n    \\n    void encode(TreeNode *r, string &s)\\n    {\\n        if(!r)\\n            return ;\\n        \\n        s=s+to_string(r->val)+\"-\";\\n        encode(r->left,s);\\n        encode(r->right,s);\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string s) {\\n        \\n        string c;\\n        stringstream ss(s);\\n        TreeNode* r = NULL;\\n        while(getline(ss,c,\\'-\\'))\\n        {\\n            r = insert(r,stoi(c));\\n        }\\n        \\n        return r;\\n        \\n        \\n    }\\n    \\n    TreeNode* insert(TreeNode* r, int c)\\n    {\\n        if(!r)\\n        {\\n            r = new TreeNode(c);\\n            return r;\\n        }\\n        else if(c<=r->val)\\n        {\\n            r->left =  insert(r->left, c);\\n        }\\n        else\\n            r->right= insert(r->right,c);\\n        return r;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* r) {\\n        string s;\\n        encode(r,s);\\n        cout<<s<<endl;\\n        return s;\\n    }\\n    \\n    void encode(TreeNode *r, string &s)\\n    {\\n        if(!r)\\n            return ;\\n        \\n        s=s+to_string(r->val)+\"-\";\\n        encode(r->left,s);\\n        encode(r->right,s);\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string s) {\\n        \\n        string c;\\n        stringstream ss(s);\\n        TreeNode* r = NULL;\\n        while(getline(ss,c,\\'-\\'))\\n        {\\n            r = insert(r,stoi(c));\\n        }\\n        \\n        return r;\\n        \\n        \\n    }\\n    \\n    TreeNode* insert(TreeNode* r, int c)\\n    {\\n        if(!r)\\n        {\\n            r = new TreeNode(c);\\n            return r;\\n        }\\n        else if(c<=r->val)\\n        {\\n            r->left =  insert(r->left, c);\\n        }\\n        else\\n            r->right= insert(r->right,c);\\n        return r;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3704442,
                "title": "easy-implementation-using-level-order-traversal-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"\";\\n        string ans = to_string(root->val) + \",\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root = q.front();\\n            q.pop();\\n            if(root->left){\\n                ans += (to_string(root->left->val) + \",\");\\n                q.push(root->left);\\n            } \\n            else ans += (\"#,\");\\n            if(root->right){\\n                ans += (to_string(root->right->val) + \",\");\\n                q.push(root->right);\\n            }\\n            else ans += (\"#,\"); \\n        }\\n        return ans;\\n    }\\n\\n    int num(string &data,int &idx){\\n        string s = \"\";\\n        while(idx < data.length() && data[idx] != \\',\\'){\\n            s += data[idx];\\n            idx++;\\n        }\\n        idx++;\\n        if(s == \"#\") return -1;\\n        return stoi(s);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return NULL;\\n        int idx = 0;\\n        TreeNode* root = new TreeNode(num(data,idx));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(idx < data.length() && !q.empty()){\\n            TreeNode* node = q.front(); q.pop();\\n            int left = num(data,idx);\\n            int right = num(data,idx);\\n            node->left = (left == -1) ? NULL : new TreeNode(left);\\n            node->right = (right == -1) ? NULL : new TreeNode(right);\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"\";\\n        string ans = to_string(root->val) + \",\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root = q.front();\\n            q.pop();\\n            if(root->left){\\n                ans += (to_string(root->left->val) + \",\");\\n                q.push(root->left);\\n            } \\n            else ans += (\"#,\");\\n            if(root->right){\\n                ans += (to_string(root->right->val) + \",\");\\n                q.push(root->right);\\n            }\\n            else ans += (\"#,\"); \\n        }\\n        return ans;\\n    }\\n\\n    int num(string &data,int &idx){\\n        string s = \"\";\\n        while(idx < data.length() && data[idx] != \\',\\'){\\n            s += data[idx];\\n            idx++;\\n        }\\n        idx++;\\n        if(s == \"#\") return -1;\\n        return stoi(s);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return NULL;\\n        int idx = 0;\\n        TreeNode* root = new TreeNode(num(data,idx));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(idx < data.length() && !q.empty()){\\n            TreeNode* node = q.front(); q.pop();\\n            int left = num(data,idx);\\n            int right = num(data,idx);\\n            node->left = (left == -1) ? NULL : new TreeNode(left);\\n            node->right = (right == -1) ? NULL : new TreeNode(right);\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397254,
                "title": "flaws-in-the-oj-cheating-the-judge",
                "content": "The OJ for this problem does not use separate process/vm for serializing and deserializing. That makes it trivial to cheat the platform. (I\\'m not recommending anyone do that. It\\'s just plain fun.)\\n\\n```\\n// Just messing with the OJ a bit\\nlet cheatMap = {};\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let key = String(Math.random());\\n    cheatMap[key] = root;\\n    return key;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    return cheatMap[data];\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n// Just messing with the OJ a bit\\nlet cheatMap = {};\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let key = String(Math.random());\\n    cheatMap[key] = root;\\n    return key;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    return cheatMap[data];\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3361063,
                "title": "solution",
                "content": "```C++ []\\nclass Codec {\\n    void encode(TreeNode* root, string& data) {\\n        if(!root) {\\n            data += \\'x\\';\\n            return;\\n        }\\n        data += \\'n\\';\\n        char* buffer = (char*)&root->val;\\n        for(int i = 0; i < 4; ++i)\\n            data += buffer[i];\\n        encode(root->left, data);\\n        encode(root->right, data);\\n    }\\n    TreeNode* decode(string& data, int& i) {\\n        auto c = data[i++];\\n        if(c == \\'x\\') return nullptr;\\n        TreeNode* root = new TreeNode();\\n        memcpy(&root->val, data.data() + i, sizeof(int));\\n        i += 4;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\npublic:\\n    string serialize(TreeNode* root) {\\n        string data;\\n        encode(root, data);\\n        return data;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data, i);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n        return \\' \\'.join(map(str, vals))\\n\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(-math.inf, math.inf)\\n        return helper(values, 0, len(values) - 1)\\n```\\n\\n```Java []\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nclass Codec {\\n    private static TreeNode tree;\\n    public String serialize(TreeNode root) {\\n        tree = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return tree;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Codec {\\n    void encode(TreeNode* root, string& data) {\\n        if(!root) {\\n            data += \\'x\\';\\n            return;\\n        }\\n        data += \\'n\\';\\n        char* buffer = (char*)&root->val;\\n        for(int i = 0; i < 4; ++i)\\n            data += buffer[i];\\n        encode(root->left, data);\\n        encode(root->right, data);\\n    }\\n    TreeNode* decode(string& data, int& i) {\\n        auto c = data[i++];\\n        if(c == \\'x\\') return nullptr;\\n        TreeNode* root = new TreeNode();\\n        memcpy(&root->val, data.data() + i, sizeof(int));\\n        i += 4;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\npublic:\\n    string serialize(TreeNode* root) {\\n        string data;\\n        encode(root, data);\\n        return data;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data, i);\\n    }\\n};\\n```\n```Python3 []\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n        return \\' \\'.join(map(str, vals))\\n\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(-math.inf, math.inf)\\n        return helper(values, 0, len(values) - 1)\\n```\n```Java []\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nclass Codec {\\n    private static TreeNode tree;\\n    public String serialize(TreeNode root) {\\n        tree = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return tree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681847,
                "title": "my-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> bfs with \\'N\\'\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> bfs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    # \\u043F\\u0440\\u0435\\u0432\\u0440\\u0430\\u0442\\u0438\\u0442\\u044C \\u0434\\u0435\\u0440\\u0435\\u0432\\u0443 \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0443\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        mas = []\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                left = temp.left \\n                right = temp.right\\n                left_val = \\'N\\' if left is None else left.val\\n                right_val = \\'N\\' if right is None else right.val\\n                line = f\"{temp.val} {left_val} {right_val}\"\\n                mas.append(line)\\n                stack.append(right)\\n                stack.append(left)\\n        return \"\\\\n\".join(mas)\\n\\n    # \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0442\\u044C \\u0438\\u0437 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        dct = {}\\n        first = None\\n        for elem in data.split(\\'\\\\n\\'):\\n            # \\u043F\\u043E\\u0442\\u043E\\u0442\\u043C \\u043D\\u0430\\u0448\\u0435\\u043B \\u0431\\u0430\\u0433\\u0443, \\u0447\\u0442\\u043E \\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0434\\u043B\\u044F \\u043F\\u0443\\u0441\\u0442\\u043E\\u0433\\u043E \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430\\n            if not elem:\\n                continue\\n            a, b, c = elem.split()\\n            if first is None:\\n                first = int(a)\\n            dct[int(a)] = [int(b) if b != \\'N\\' else None, int(c) if c != \\'N\\' else None]\\n        \\n        if first is None:\\n            return []\\n        head = root = TreeNode(first)\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            \\n            if dct[temp.val][1] is not None:\\n                temp.right = TreeNode(dct[temp.val][1])\\n                stack.append(temp.right)\\n\\n            if dct[temp.val][0] is not None:\\n                temp.left = TreeNode(dct[temp.val][0])\\n                stack.append(temp.left)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    # \\u043F\\u0440\\u0435\\u0432\\u0440\\u0430\\u0442\\u0438\\u0442\\u044C \\u0434\\u0435\\u0440\\u0435\\u0432\\u0443 \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0443\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        mas = []\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                left = temp.left \\n                right = temp.right\\n                left_val = \\'N\\' if left is None else left.val\\n                right_val = \\'N\\' if right is None else right.val\\n                line = f\"{temp.val} {left_val} {right_val}\"\\n                mas.append(line)\\n                stack.append(right)\\n                stack.append(left)\\n        return \"\\\\n\".join(mas)\\n\\n    # \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0442\\u044C \\u0438\\u0437 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        dct = {}\\n        first = None\\n        for elem in data.split(\\'\\\\n\\'):\\n            # \\u043F\\u043E\\u0442\\u043E\\u0442\\u043C \\u043D\\u0430\\u0448\\u0435\\u043B \\u0431\\u0430\\u0433\\u0443, \\u0447\\u0442\\u043E \\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0434\\u043B\\u044F \\u043F\\u0443\\u0441\\u0442\\u043E\\u0433\\u043E \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430\\n            if not elem:\\n                continue\\n            a, b, c = elem.split()\\n            if first is None:\\n                first = int(a)\\n            dct[int(a)] = [int(b) if b != \\'N\\' else None, int(c) if c != \\'N\\' else None]\\n        \\n        if first is None:\\n            return []\\n        head = root = TreeNode(first)\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            \\n            if dct[temp.val][1] is not None:\\n                temp.right = TreeNode(dct[temp.val][1])\\n                stack.append(temp.right)\\n\\n            if dct[temp.val][0] is not None:\\n                temp.left = TreeNode(dct[temp.val][0])\\n                stack.append(temp.left)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641272,
                "title": "python-upper-lower-approach-preorder-dfs",
                "content": "```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        self.ans = []\\n        \\n        def dfs(node):\\n            if not node: return\\n            self.ans.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        dfs(root)\\n        return \",\".join(self.ans)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        if not data: return None\\n        ans = [int(d) for d in data.split(\",\")]\\n        \\n        \\n        def dfs(ans, l, u):\\n            if not ans: return None\\n            if not l <= ans[0] <= u : return None\\n            \\n            node = ans.pop(0) #O(n)\\n            root = TreeNode(node)\\n            \\n            root.left = dfs(ans, l, root.val)\\n            root.right = dfs(ans, root.val, u)\\n            \\n            return root\\n        return dfs(ans, -float(\\'inf\\'), float(\\'inf\\'))\\n```\\n\\nExplaination : After 13 October 2022\\nhttps://youtu.be/01f4F9HOb5k\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        self.ans = []\\n        \\n        def dfs(node):\\n            if not node: return\\n            self.ans.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        dfs(root)\\n        return \",\".join(self.ans)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        if not data: return None\\n        ans = [int(d) for d in data.split(\",\")]\\n        \\n        \\n        def dfs(ans, l, u):\\n            if not ans: return None\\n            if not l <= ans[0] <= u : return None\\n            \\n            node = ans.pop(0) #O(n)\\n            root = TreeNode(node)\\n            \\n            root.left = dfs(ans, l, root.val)\\n            root.right = dfs(ans, root.val, u)\\n            \\n            return root\\n        return dfs(ans, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411852,
                "title": "cringiest-solution-0ms-100-faster-solution-using-static",
                "content": "```\\npublic class Codec {\\n    static TreeNode node;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    static TreeNode node;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386800,
                "title": "c-pre-order-traversal-simple-recursion",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n\\t * };\\n\\t */\\n\\tclass Codec {\\n\\tpublic:\\n\\n\\t\\tvoid serialize_helper(TreeNode* root , string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\ts.push_back(\\'/\\');\\n\\t\\t\\t\\ts.push_back(\\',\\');\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring t = to_string(root -> val);\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < t.size()){\\n\\t\\t\\t\\ts.push_back(t[i++]);\\n\\t\\t\\t}\\n\\t\\t\\ts.push_back(\\',\\');\\n\\n\\t\\t\\tserialize_helper(root -> left , s);\\n\\t\\t\\tserialize_helper(root -> right , s);\\n\\t\\t}\\n\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\t string s = \"\";\\n\\t\\t\\t serialize_helper(root , s);\\n\\t\\t\\t return s;\\n\\t\\t}\\n\\n\\t\\tint idx =  0;\\n\\t\\tTreeNode* deserialize_helper(string data){\\n\\n\\t\\t\\tstring t;\\n\\t\\t\\twhile(idx < data.size() && data[idx] != \\',\\'){\\n\\t\\t\\t\\tt.push_back(data[idx++]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(idx >= data.size() || t == \"/\"){\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\n\\t\\t\\tTreeNode* root = new TreeNode(stoi(t));\\n\\t\\t\\tidx++;\\n\\t\\t\\troot -> left  = deserialize_helper(data);\\n\\t\\t\\troot -> right = deserialize_helper(data);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data){\\n\\t\\t\\treturn deserialize_helper(data);\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// Your Codec object will be instantiated and called as such:\\n\\t// Codec* ser = new Codec();\\n\\t// Codec* deser = new Codec();\\n\\t// string tree = ser->serialize(root);\\n\\t// TreeNode* ans = deser->deserialize(tree);\\n\\t// return ans;",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n\\t * };\\n\\t */\\n\\tclass Codec {\\n\\tpublic:\\n\\n\\t\\tvoid serialize_helper(TreeNode* root , string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\ts.push_back(\\'/\\');\\n\\t\\t\\t\\ts.push_back(\\',\\');\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring t = to_string(root -> val);\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < t.size()){\\n\\t\\t\\t\\ts.push_back(t[i++]);\\n\\t\\t\\t}\\n\\t\\t\\ts.push_back(\\',\\');\\n\\n\\t\\t\\tserialize_helper(root -> left , s);\\n\\t\\t\\tserialize_helper(root -> right , s);\\n\\t\\t}\\n\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\t string s = \"\";\\n\\t\\t\\t serialize_helper(root , s);\\n\\t\\t\\t return s;\\n\\t\\t}\\n\\n\\t\\tint idx =  0;\\n\\t\\tTreeNode* deserialize_helper(string data){\\n\\n\\t\\t\\tstring t;\\n\\t\\t\\twhile(idx < data.size() && data[idx] != \\',\\'){\\n\\t\\t\\t\\tt.push_back(data[idx++]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(idx >= data.size() || t == \"/\"){\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\n\\t\\t\\tTreeNode* root = new TreeNode(stoi(t));\\n\\t\\t\\tidx++;\\n\\t\\t\\troot -> left  = deserialize_helper(data);\\n\\t\\t\\troot -> right = deserialize_helper(data);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data){\\n\\t\\t\\treturn deserialize_helper(data);\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// Your Codec object will be instantiated and called as such:\\n\\t// Codec* ser = new Codec();\\n\\t// Codec* deser = new Codec();\\n\\t// string tree = ser->serialize(root);\\n\\t// TreeNode* ans = deser->deserialize(tree);\\n\\t// return ans;",
                "codeTag": "Java"
            },
            {
                "id": 2371696,
                "title": "c-easy-bfs-solution-fast",
                "content": "```\\nstring serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* atNode = q.front();\\n            q.pop();\\n            if(atNode==NULL) s.append(\"#,\");\\n            else s.append(to_string(atNode->val)+\\',\\');\\n            if(atNode!=NULL){\\n                q.push(atNode->left);\\n                q.push(atNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size()==0) return NULL;\\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->left = NULL;\\n            else{\\n                TreeNode* treeLeft = new TreeNode(stoi(str));\\n                node->left = treeLeft;\\n                q.push(treeLeft);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->right = NULL;\\n            else{\\n                TreeNode* treeRight = new TreeNode(stoi(str));\\n                node->right = treeRight;\\n                q.push(treeRight);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nstring serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* atNode = q.front();\\n            q.pop();\\n            if(atNode==NULL) s.append(\"#,\");\\n            else s.append(to_string(atNode->val)+\\',\\');\\n            if(atNode!=NULL){\\n                q.push(atNode->left);\\n                q.push(atNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size()==0) return NULL;\\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->left = NULL;\\n            else{\\n                TreeNode* treeLeft = new TreeNode(stoi(str));\\n                node->left = treeLeft;\\n                q.push(treeLeft);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->right = NULL;\\n            else{\\n                TreeNode* treeRight = new TreeNode(stoi(str));\\n                node->right = treeRight;\\n                q.push(treeRight);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2320578,
                "title": "c-fast-simple-commented-picture",
                "content": "![image](https://assets.leetcode.com/users/images/e76a629b-b87e-47d9-92d0-2e294aa530bc_1658560288.5641255.png)\\n\\n![image](https://assets.leetcode.com/users/images/ed2b6a27-63b1-41c1-b031-7f3b1b7c5bcc_1658560294.6596942.png)\\n\\n![image](https://assets.leetcode.com/users/images/99407c1c-7db5-4aab-b864-e7c5cdba4083_1658560312.2203279.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/e76a629b-b87e-47d9-92d0-2e294aa530bc_1658560288.5641255.png)\\n\\n![image](https://assets.leetcode.com/users/images/ed2b6a27-63b1-41c1-b031-7f3b1b7c5bcc_1658560294.6596942.png)\\n\\n![image](https://assets.leetcode.com/users/images/99407c1c-7db5-4aab-b864-e7c5cdba4083_1658560312.2203279.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2269505,
                "title": "c-preorder-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"#,\";\\n        return to_string(root->val) + \\',\\' + serialize(root->left) + serialize(root->right) ;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int ind=0;\\n    TreeNode* deserialize(string& data) {\\n        if(ind==data.length())\\n            return NULL;\\n        \\n        string t;\\n        while(ind<data.length() && data[ind]!=\\',\\')\\n        {\\n            t+=data[ind++];\\n        }\\n        ind++;\\n        if(t==\"#\")\\n            return NULL;\\n        int val=stoi(t);\\n        TreeNode* root= new TreeNode(val);\\n        root->left=deserialize(data);\\n        root->right=deserialize(data);\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"#,\";\\n        return to_string(root->val) + \\',\\' + serialize(root->left) + serialize(root->right) ;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int ind=0;\\n    TreeNode* deserialize(string& data) {\\n        if(ind==data.length())\\n            return NULL;\\n        \\n        string t;\\n        while(ind<data.length() && data[ind]!=\\',\\')\\n        {\\n            t+=data[ind++];\\n        }\\n        ind++;\\n        if(t==\"#\")\\n            return NULL;\\n        int val=stoi(t);\\n        TreeNode* root= new TreeNode(val);\\n        root->left=deserialize(data);\\n        root->right=deserialize(data);\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262627,
                "title": "python-easy-solution-for-both-binary-tree-and-bst",
                "content": "## Solution\\n1. pre-order visit + mid-order visit  --> for binary tree\\n2. only pre-order visit  --> for BST\\n3. only level order visit --> reference solution \\n\\n```\\nfrom collections import deque\\nfrom typing import Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass CodecNormalTree:\\n    \"\"\"For binary tree (normal tree), we need to store both pre-order and mid-order\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.midorder_list = []\\n        self.preorder_visit(root)\\n        self.midorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        m = \\',\\'.join(map(str, self.midorder_list))\\n        return p + \\' \\' + m\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def midorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.midorder_visit(root.left)\\n        self.midorder_list.append(root.val)\\n        self.midorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p, m = data.split(\\' \\')\\n        if not p or not m:\\n            return None\\n        p_list = p.split(\\',\\')\\n        m_list = m.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = list(map(int, m_list))\\n        \\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass Codec_PreMid:\\n    \"\"\"For BST, we can utilize its feature: mid order is sorted!\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.preorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        return p\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p_list = data.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = sorted(self.preorder_list)\\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass CodecBFS:\\n    \"\"\"For BST, we can utilize its feature: level order is unique\"\"\"\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\nfrom typing import Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass CodecNormalTree:\\n    \"\"\"For binary tree (normal tree), we need to store both pre-order and mid-order\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.midorder_list = []\\n        self.preorder_visit(root)\\n        self.midorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        m = \\',\\'.join(map(str, self.midorder_list))\\n        return p + \\' \\' + m\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def midorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.midorder_visit(root.left)\\n        self.midorder_list.append(root.val)\\n        self.midorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p, m = data.split(\\' \\')\\n        if not p or not m:\\n            return None\\n        p_list = p.split(\\',\\')\\n        m_list = m.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = list(map(int, m_list))\\n        \\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass Codec_PreMid:\\n    \"\"\"For BST, we can utilize its feature: mid order is sorted!\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.preorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        return p\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p_list = data.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = sorted(self.preorder_list)\\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass CodecBFS:\\n    \"\"\"For BST, we can utilize its feature: level order is unique\"\"\"\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202099,
                "title": "java-level-order-traversal-readable-code",
                "content": "```\\npublic class Codec {\\n    /**\\n     * Traverses binary tree in level order \\n     * Stores node values in string(comma separated)\\n     */\\n    private String levelOrderTrav(TreeNode root){\\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.add(root);\\n        TreeNode itr = null;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            if(itr!=null) {\\n                sb.append(itr.val+\",\");\\n                que.add(itr.left);\\n                que.add(itr.right);\\n            }\\n            else sb.append(\"n,\");\\n        }\\n        return sb.substring(0, sb.length()-1).toString();\\n    }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return levelOrderTrav(root);\\n    }\\n    /**\\n     * Contructs Binary Tree from leverl order traversalcomma separated string)\\n     */\\n    private TreeNode constructBstFromLevelOrderTrav(String data){\\n        String[] nodeValues = data.split(\",\");\\n        if(nodeValues[0].equals(\"n\")) return null; //zero nodes\\n        Queue<TreeNode> que = new LinkedList<>();\\n        TreeNode root = new TreeNode(Integer.parseInt(nodeValues[0]));\\n        que.add(root);\\n        TreeNode itr = null;\\n        int indx = 1;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            String valL = nodeValues[indx++];\\n            String valR = nodeValues[indx++];\\n            if(!valL.equals(\"n\")){\\n                itr.left = new TreeNode(Integer.parseInt(valL));\\n                que.add(itr.left);\\n            }\\n            if(!valR.equals(\"n\")){\\n                itr.right = new TreeNode(Integer.parseInt(valR));\\n                que.add(itr.right);\\n            }\\n        }\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return constructBstFromLevelOrderTrav(data);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    /**\\n     * Traverses binary tree in level order \\n     * Stores node values in string(comma separated)\\n     */\\n    private String levelOrderTrav(TreeNode root){\\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.add(root);\\n        TreeNode itr = null;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            if(itr!=null) {\\n                sb.append(itr.val+\",\");\\n                que.add(itr.left);\\n                que.add(itr.right);\\n            }\\n            else sb.append(\"n,\");\\n        }\\n        return sb.substring(0, sb.length()-1).toString();\\n    }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return levelOrderTrav(root);\\n    }\\n    /**\\n     * Contructs Binary Tree from leverl order traversalcomma separated string)\\n     */\\n    private TreeNode constructBstFromLevelOrderTrav(String data){\\n        String[] nodeValues = data.split(\",\");\\n        if(nodeValues[0].equals(\"n\")) return null; //zero nodes\\n        Queue<TreeNode> que = new LinkedList<>();\\n        TreeNode root = new TreeNode(Integer.parseInt(nodeValues[0]));\\n        que.add(root);\\n        TreeNode itr = null;\\n        int indx = 1;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            String valL = nodeValues[indx++];\\n            String valR = nodeValues[indx++];\\n            if(!valL.equals(\"n\")){\\n                itr.left = new TreeNode(Integer.parseInt(valL));\\n                que.add(itr.left);\\n            }\\n            if(!valR.equals(\"n\")){\\n                itr.right = new TreeNode(Integer.parseInt(valR));\\n                que.add(itr.right);\\n            }\\n        }\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return constructBstFromLevelOrderTrav(data);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089613,
                "title": "c-extreme-compression-each-node-only-takes-2-chars-regardless-of-the-value",
                "content": "- The input range (i.e. `[0, 10000]`) can be represented by 14bits.\\n- We use another 2 bits to represent whether the node has left leaf or right leaf. Hence a single node can be represented by `uint16_t`, which is 2 chars. The top 2 bits can be reserved for representing left/right node existence.\\n- This probably can be further compressed using huffman encoding, but I didn\\'t go that far.\\n- Overall beats 90% time, 80% space (is the space measured by length of string or footprint of the program?)\\n```\\nclass Codec {\\npublic:\\n    const uint16_t kLeftBit = 0x8000;\\n    const uint16_t kRightBit = 0x4000;\\n    void encode(TreeNode* node, std::string& ret) {\\n        if (node == nullptr) {\\n            return;\\n        }\\n        // guranteed to be less than 14 bit\\n        uint16_t val = static_cast<uint16_t>(node->val);\\n        if (node->left != nullptr) {\\n            val |= kLeftBit;\\n        }\\n        if (node->right != nullptr) {\\n            val |= kRightBit;\\n        }\\n\\n        ret += static_cast<char>(val & 0x00ff);\\n        ret += static_cast<char>((val >> 8) & 0x00ff);\\n        encode(node->left, ret);\\n        encode(node->right, ret);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        std::string ret{\"\"};\\n        encode(root, ret);\\n        return ret;\\n    }\\n    \\n    TreeNode* decode(std::string& data, int& idx) {\\n        if (idx >= data.length()) {\\n            return nullptr;\\n        }\\n        uint16_t low = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t high = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t val = ((high << 8) & 0xff00) | low;\\n        \\n        bool hasLeft = (val & kLeftBit) > 0;\\n        bool hasRight = (val & kRightBit) > 0;\\n        // clear highest 2 bits\\n        val &= 0x3fff;\\n        TreeNode* curr = new TreeNode(static_cast<int>(val));\\n        if (hasLeft) {\\n            curr->left = decode(data, idx);\\n        }\\n        if (hasRight) {\\n            curr->right = decode(data, idx);\\n        }\\n        return curr;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int idx{0};\\n        return decode(data, idx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n    const uint16_t kLeftBit = 0x8000;\\n    const uint16_t kRightBit = 0x4000;\\n    void encode(TreeNode* node, std::string& ret) {\\n        if (node == nullptr) {\\n            return;\\n        }\\n        // guranteed to be less than 14 bit\\n        uint16_t val = static_cast<uint16_t>(node->val);\\n        if (node->left != nullptr) {\\n            val |= kLeftBit;\\n        }\\n        if (node->right != nullptr) {\\n            val |= kRightBit;\\n        }\\n\\n        ret += static_cast<char>(val & 0x00ff);\\n        ret += static_cast<char>((val >> 8) & 0x00ff);\\n        encode(node->left, ret);\\n        encode(node->right, ret);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        std::string ret{\"\"};\\n        encode(root, ret);\\n        return ret;\\n    }\\n    \\n    TreeNode* decode(std::string& data, int& idx) {\\n        if (idx >= data.length()) {\\n            return nullptr;\\n        }\\n        uint16_t low = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t high = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t val = ((high << 8) & 0xff00) | low;\\n        \\n        bool hasLeft = (val & kLeftBit) > 0;\\n        bool hasRight = (val & kRightBit) > 0;\\n        // clear highest 2 bits\\n        val &= 0x3fff;\\n        TreeNode* curr = new TreeNode(static_cast<int>(val));\\n        if (hasLeft) {\\n            curr->left = decode(data, idx);\\n        }\\n        if (hasRight) {\\n            curr->right = decode(data, idx);\\n        }\\n        return curr;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int idx{0};\\n        return decode(data, idx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027240,
                "title": "java-dfs-solution",
                "content": "```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        //pre-order root left right\\n        if(root == null)\\n            return \"\";\\n        String left = serialize(root.left);\\n        String right = serialize(root.right);\\n        return root.val + \",\" + left + right; \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data == null || data.length() == 0)\\n            return null;\\n        String[] temp = data.split(\",\");\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < temp.length; i ++){\\n            queue.offer(Integer.parseInt(temp[i]));\\n        }\\n        return build(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode build(Queue<Integer> queue, int low, int high){\\n        if(queue.isEmpty() || queue.peek() < low || queue.peek() > high){\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(queue.poll());\\n        root.left = build(queue, low, root.val);\\n        root.right = build(queue, root.val, high);\\n        \\n        return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        //pre-order root left right\\n        if(root == null)\\n            return \"\";\\n        String left = serialize(root.left);\\n        String right = serialize(root.right);\\n        return root.val + \",\" + left + right; \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data == null || data.length() == 0)\\n            return null;\\n        String[] temp = data.split(\",\");\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < temp.length; i ++){\\n            queue.offer(Integer.parseInt(temp[i]));\\n        }\\n        return build(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode build(Queue<Integer> queue, int low, int high){\\n        if(queue.isEmpty() || queue.peek() < low || queue.peek() > high){\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(queue.poll());\\n        root.left = build(queue, low, root.val);\\n        root.right = build(queue, root.val, high);\\n        \\n        return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976530,
                "title": "python-bfs-iterative-solution-serialized-string-compact",
                "content": "```python\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        result, q = [], []\\n        if root: q.append(root)\\n        for n in q:\\n            result.append(str(n.val))\\n            if n.left: q.append(n.left)\\n            if n.right: q.append(n.right)\\n        return \",\".join(result)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if len(data) == 0: return None\\n        nodes, q, pos = data.split(\",\"), deque(), 1\\n        root = TreeNode(int(nodes[0]))\\n        q.append([root, -sys.maxsize, sys.maxsize])\\n        while q:\\n            n, lb, ub = q.popleft()\\n            if pos < len(nodes) and int(nodes[pos]) < n.val and lb <= int(nodes[pos]) <= ub:\\n                n.left = TreeNode(int(nodes[pos]))\\n                q.append([n.left, lb, n.val])\\n                pos += 1\\n            if pos < len(nodes) and int(nodes[pos]) > n.val and lb <= int(nodes[pos]) <= ub:\\n                n.right = TreeNode(int(nodes[pos]))\\n                q.append([n.right, n.val, ub])\\n                pos += 1\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```python\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        result, q = [], []\\n        if root: q.append(root)\\n        for n in q:\\n            result.append(str(n.val))\\n            if n.left: q.append(n.left)\\n            if n.right: q.append(n.right)\\n        return \",\".join(result)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if len(data) == 0: return None\\n        nodes, q, pos = data.split(\",\"), deque(), 1\\n        root = TreeNode(int(nodes[0]))\\n        q.append([root, -sys.maxsize, sys.maxsize])\\n        while q:\\n            n, lb, ub = q.popleft()\\n            if pos < len(nodes) and int(nodes[pos]) < n.val and lb <= int(nodes[pos]) <= ub:\\n                n.left = TreeNode(int(nodes[pos]))\\n                q.append([n.left, lb, n.val])\\n                pos += 1\\n            if pos < len(nodes) and int(nodes[pos]) > n.val and lb <= int(nodes[pos]) <= ub:\\n                n.right = TreeNode(int(nodes[pos]))\\n                q.append([n.right, n.val, ub])\\n                pos += 1\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952378,
                "title": "python-preorder-traversal-monotonic-stack-87-time-70-space",
                "content": "In case you don\\'t know, the pre-order traversal of the BST can be re-worked by a monotonic stack (try yourself to find out why and how, or check my codes).\\nSo we can pre-order traverse the BST to encode (only save non-empty nodes to save space), then use monotonic stack to re-incarnate the BST.\\nBoth time and space complexity of this method is O(n) (n is num of non-empty nodes).\\n```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        if not root.left and not root.right:\\n            return str(root.val) + \",\"\\n        if root.left and not root.right:\\n            return str(root.val) + \",\" + self.serialize(root.left)\\n        if not root.left and root.right:\\n            return str(root.val) + \",\" + self.serialize(root.right)\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        tmp = []\\n        start = 0\\n        end = 0\\n        while end < len(data):\\n            while end < len(data) and data[end] != \",\":\\n                end += 1\\n            tmp.append(int(data[start:end]))\\n            end += 1\\n            start = end\\n        root = TreeNode(tmp[0])\\n        s = [root]\\n        for x in tmp[1:]:\\n            node = TreeNode(x)\\n            if s and x < s[-1].val:\\n                s[-1].left = node\\n                s.append(node)\\n                continue\\n            cur = None\\n            while s and s[-1].val < x:\\n                cur = s.pop()\\n            if cur:\\n                cur.right = node\\n            s.append(node)\\n        return root",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "In case you don\\'t know, the pre-order traversal of the BST can be re-worked by a monotonic stack (try yourself to find out why and how, or check my codes).\\nSo we can pre-order traverse the BST to encode (only save non-empty nodes to save space), then use monotonic stack to re-incarnate the BST.\\nBoth time and space complexity of this method is O(n) (n is num of non-empty nodes).\\n```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        if not root.left and not root.right:\\n            return str(root.val) + \",\"\\n        if root.left and not root.right:\\n            return str(root.val) + \",\" + self.serialize(root.left)\\n        if not root.left and root.right:\\n            return str(root.val) + \",\" + self.serialize(root.right)\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        tmp = []\\n        start = 0\\n        end = 0\\n        while end < len(data):\\n            while end < len(data) and data[end] != \",\":\\n                end += 1\\n            tmp.append(int(data[start:end]))\\n            end += 1\\n            start = end\\n        root = TreeNode(tmp[0])\\n        s = [root]\\n        for x in tmp[1:]:\\n            node = TreeNode(x)\\n            if s and x < s[-1].val:\\n                s[-1].left = node\\n                s.append(node)\\n                continue\\n            cur = None\\n            while s and s[-1].val < x:\\n                cur = s.pop()\\n            if cur:\\n                cur.right = node\\n            s.append(node)\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 1891766,
                "title": "clean-postorder-in-python",
                "content": "```\\nclass Codec:\\n    SEP = \",\"\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def postorder(n: TreeNode = root):\\n            if not n:\\n                return\\n            yield from postorder(n.left)\\n            yield from postorder(n.right)\\n            yield n.val\\n            \\n        return Codec.SEP.join(map(str, postorder()))\\n\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        data = [int(x) for x in data.split(Codec.SEP) if x]\\n        \\n        def helper(lo=-1, hi=10_001) -> TreeNode:\\n            if not data or data[-1] < lo or data[-1] > hi:\\n                return None\\n            n, v = TreeNode(data[-1]), data.pop()\\n            n.right, n.left = helper(v, hi), helper(lo, v)\\n            return n\\n        \\n        return helper()\\n```\\n\\ncomplaint: could be even cleaner if `TreeNode.__init__` supports keyword arguments for `left` and `right` :P",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n    SEP = \",\"\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def postorder(n: TreeNode = root):\\n            if not n:\\n                return\\n            yield from postorder(n.left)\\n            yield from postorder(n.right)\\n            yield n.val\\n            \\n        return Codec.SEP.join(map(str, postorder()))\\n\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        data = [int(x) for x in data.split(Codec.SEP) if x]\\n        \\n        def helper(lo=-1, hi=10_001) -> TreeNode:\\n            if not data or data[-1] < lo or data[-1] > hi:\\n                return None\\n            n, v = TreeNode(data[-1]), data.pop()\\n            n.right, n.left = helper(v, hi), helper(lo, v)\\n            return n\\n        \\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777228,
                "title": "c",
                "content": "```\\nclass Codec {\\npublic:\\n\\n   string serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s =\"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()) {\\n           TreeNode* curNode = q.front();\\n           q.pop();\\n           if(curNode==NULL) s.append(\"#,\");\\n           else s.append(to_string(curNode->val)+\\',\\');\\n           if(curNode != NULL){\\n               q.push(curNode->left);\\n               q.push(curNode->right);            \\n           }\\n        }\\n        return s;\\n    }\\n\\n    // deserializing the string data \\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL; \\n        stringstream s(data);\\n        string str; \\n        getline(s, str, \\',\\');\\n        TreeNode *root = new TreeNode(stoi(str));\\n        queue<TreeNode*> q; \\n        q.push(root); \\n        while(!q.empty()) {\\n            \\n            TreeNode *node = q.front(); \\n            q.pop(); \\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->left = NULL; \\n            }\\n            else {\\n                TreeNode* leftNode = new TreeNode(stoi(str)); \\n                node->left = leftNode; \\n                q.push(leftNode); \\n            }\\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->right = NULL; \\n            }\\n            else {\\n                TreeNode* rightNode = new TreeNode(stoi(str)); \\n                node->right = rightNode;\\n                q.push(rightNode); \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n   string serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s =\"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()) {\\n           TreeNode* curNode = q.front();\\n           q.pop();\\n           if(curNode==NULL) s.append(\"#,\");\\n           else s.append(to_string(curNode->val)+\\',\\');\\n           if(curNode != NULL){\\n               q.push(curNode->left);\\n               q.push(curNode->right);            \\n           }\\n        }\\n        return s;\\n    }\\n\\n    // deserializing the string data \\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL; \\n        stringstream s(data);\\n        string str; \\n        getline(s, str, \\',\\');\\n        TreeNode *root = new TreeNode(stoi(str));\\n        queue<TreeNode*> q; \\n        q.push(root); \\n        while(!q.empty()) {\\n            \\n            TreeNode *node = q.front(); \\n            q.pop(); \\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->left = NULL; \\n            }\\n            else {\\n                TreeNode* leftNode = new TreeNode(stoi(str)); \\n                node->left = leftNode; \\n                q.push(leftNode); \\n            }\\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->right = NULL; \\n            }\\n            else {\\n                TreeNode* rightNode = new TreeNode(stoi(str)); \\n                node->right = rightNode;\\n                q.push(rightNode); \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676450,
                "title": "c-92-postorder",
                "content": "**Runtime:** 28 ms, faster than 92.32% of C++ online submissions for Serialize and Deserialize BST.\\n**Memory Usage:** 27 MB, less than 62.26% of C++ online submissions for Serialize and Deserialize BST.\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str;\\n        postorder(root, str);\\n        if(str.size() > 0) str.pop_back();\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return nullptr;\\n        vector<int> nums;\\n        int curr = 0;\\n        for(int i = 0; i <= data.size(); ++i) {\\n            if(i == data.size() || data[i] == \\' \\') {\\n                nums.push_back(curr);\\n                curr = 0;\\n            }else {\\n                curr = curr * 10 - \\'0\\' + data[i];\\n            }\\n        }\\n        return deserHelper(nums, INT_MIN, INT_MAX);\\n    }\\n    \\n    void postorder(TreeNode* root, string& str) {\\n        if(root == nullptr) return;\\n        postorder(root->left, str);\\n        postorder(root->right, str);\\n        str.append(to_string(root->val));\\n        str.append(\" \");\\n    }\\n    \\n    TreeNode* deserHelper(vector<int>& nums, int lower, int upper) {\\n        if(nums.empty()) return nullptr;\\n        int val = nums[nums.size() - 1];\\n        if(val < lower || val > upper) return nullptr;\\n        nums.pop_back();\\n        TreeNode* root = new TreeNode(val);\\n        root->right = deserHelper(nums, val, upper);\\n        root->left = deserHelper(nums, lower, val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str;\\n        postorder(root, str);\\n        if(str.size() > 0) str.pop_back();\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return nullptr;\\n        vector<int> nums;\\n        int curr = 0;\\n        for(int i = 0; i <= data.size(); ++i) {\\n            if(i == data.size() || data[i] == \\' \\') {\\n                nums.push_back(curr);\\n                curr = 0;\\n            }else {\\n                curr = curr * 10 - \\'0\\' + data[i];\\n            }\\n        }\\n        return deserHelper(nums, INT_MIN, INT_MAX);\\n    }\\n    \\n    void postorder(TreeNode* root, string& str) {\\n        if(root == nullptr) return;\\n        postorder(root->left, str);\\n        postorder(root->right, str);\\n        str.append(to_string(root->val));\\n        str.append(\" \");\\n    }\\n    \\n    TreeNode* deserHelper(vector<int>& nums, int lower, int upper) {\\n        if(nums.empty()) return nullptr;\\n        int val = nums[nums.size() - 1];\\n        if(val < lower || val > upper) return nullptr;\\n        nums.pop_back();\\n        TreeNode* root = new TreeNode(val);\\n        root->right = deserHelper(nums, val, upper);\\n        root->left = deserHelper(nums, lower, val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669607,
                "title": "python-3-way-general-tree-preorder-postorder",
                "content": "Approach 1, general Binary Tree method. \\n\\n```\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def helper(node, string):\\n            if not node:\\n                string += \\'None,\\'\\n            else:\\n                string += str(node.val) + \\',\\'\\n                string = helper(node.left, string)\\n                string = helper(node.right, string)\\n            return string\\n        return helper(root, \\'\\')\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(l):\\n            if l[0] == \\'None\\':\\n                l.pop(0)\\n                return None\\n            root = TreeNode(l[0])\\n            l.pop(0)\\n            root.left = helper(l)\\n            root.right = helper(l)\\n            return root\\n        data_list = data.split(\\',\\')\\n        root = helper(data_list)\\n        return root\\n```\\n\\nApproach 2, preorder way\\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return [node.val] + helper(node.left) + helper(node.right) if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            data = [int(x) for x in data.split() if x]\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[0] < lower or data[0] > upper:\\n                    return None\\n                val = data[0]\\n                root = TreeNode(val)\\n                root.left = helper(lower, val)\\n                root.right = helper(val, upper)\\n                return root\\n            return helper()\\n```\\n\\napproach 3, postorder way\\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return helper(node.left) + helper(node.right) + [node.val] if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n                  \\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[-1] < lower or data[-1] > upper:\\n                    return None # if root is not within the range, means there is no node. \\n                val = data.pop()\\n                root = TreeNode(val)\\n                root.right = helper(val, upper) #pop() is poping the last element, so we need to do right first, as it is left -> right -> root\\n                root.left = helper(lower, val)\\n                return root\\n            data = [int(x) for x in data.split(\\' \\') if x]\\n            return helper()\\n```",
                "solutionTags": [],
                "code": "```\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def helper(node, string):\\n            if not node:\\n                string += \\'None,\\'\\n            else:\\n                string += str(node.val) + \\',\\'\\n                string = helper(node.left, string)\\n                string = helper(node.right, string)\\n            return string\\n        return helper(root, \\'\\')\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(l):\\n            if l[0] == \\'None\\':\\n                l.pop(0)\\n                return None\\n            root = TreeNode(l[0])\\n            l.pop(0)\\n            root.left = helper(l)\\n            root.right = helper(l)\\n            return root\\n        data_list = data.split(\\',\\')\\n        root = helper(data_list)\\n        return root\\n```\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return [node.val] + helper(node.left) + helper(node.right) if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            data = [int(x) for x in data.split() if x]\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[0] < lower or data[0] > upper:\\n                    return None\\n                val = data[0]\\n                root = TreeNode(val)\\n                root.left = helper(lower, val)\\n                root.right = helper(val, upper)\\n                return root\\n            return helper()\\n```\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return helper(node.left) + helper(node.right) + [node.val] if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n                  \\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[-1] < lower or data[-1] > upper:\\n                    return None # if root is not within the range, means there is no node. \\n                val = data.pop()\\n                root = TreeNode(val)\\n                root.right = helper(val, upper) #pop() is poping the last element, so we need to do right first, as it is left -> right -> root\\n                root.left = helper(lower, val)\\n                return root\\n            data = [int(x) for x in data.split(\\' \\') if x]\\n            return helper()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1662351,
                "title": "c-fast-codec-apis-post-order-traversal-while-encoding",
                "content": "```cpp\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) return \"(#)\";\\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        return \"(\" + to_string(root->val) + left + right + \")\";\\n    }\\n    \\n    \\n    TreeNode *decode(string &data, int &n) {\\n        ++n;\\n        string curNum = \"\";\\n        while(data[n] != \\')\\' && data[n] != \\'(\\') {\\n            curNum += data[n];\\n            ++n;\\n        }\\n        TreeNode *root = nullptr;\\n        if (curNum != \"#\") {\\n            root = new TreeNode(stoi(curNum));\\n            if(data[n] == \\'(\\') root->left = decode(data, n);\\n            if(data[n] == \\'(\\') root->right = decode(data, n);\\n        }\\n        ++n;\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int n = 0;\\n        return decode(data, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) return \"(#)\";\\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        return \"(\" + to_string(root->val) + left + right + \")\";\\n    }\\n    \\n    \\n    TreeNode *decode(string &data, int &n) {\\n        ++n;\\n        string curNum = \"\";\\n        while(data[n] != \\')\\' && data[n] != \\'(\\') {\\n            curNum += data[n];\\n            ++n;\\n        }\\n        TreeNode *root = nullptr;\\n        if (curNum != \"#\") {\\n            root = new TreeNode(stoi(curNum));\\n            if(data[n] == \\'(\\') root->left = decode(data, n);\\n            if(data[n] == \\'(\\') root->right = decode(data, n);\\n        }\\n        ++n;\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int n = 0;\\n        return decode(data, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643817,
                "title": "c-using-bytes-to-compact",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) {\\n            return \"\";\\n        }\\n        std::vector<unsigned char> bytes;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while (!st.empty()) {\\n            TreeNode* top = st.top();\\n            bytes.resize(bytes.size()+sizeof(int));\\n            memcpy(&bytes[bytes.size()-sizeof(int)], &(top->val), sizeof(int));\\n            st.pop();\\n            if (top->left != nullptr) {\\n                st.push(top->left);\\n            }\\n            if (top->right != nullptr) {\\n                st.push(top->right);\\n            }\\n        }\\n        return std::string(bytes.begin(), bytes.end());\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if (data.empty()) {\\n            return nullptr;\\n        }\\n        TreeNode* result = nullptr;\\n        for (int i=0; i<data.length(); i+=sizeof(int)) {\\n            int val;\\n            memcpy(&val, &data[i], sizeof(int));\\n            Insert(result, val);\\n        }\\n        return result;\\n    }\\n    \\n    void Insert(TreeNode*& root, int val) {\\n        if (root == nullptr) {\\n            root = new TreeNode(val);\\n            return;\\n        }\\n        if (val < root->val) {\\n            Insert(root->left, val);\\n        } else {\\n            Insert(root->right, val);\\n        }\\n    }\\n    \\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) {\\n            return \"\";\\n        }\\n        std::vector<unsigned char> bytes;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while (!st.empty()) {\\n            TreeNode* top = st.top();\\n            bytes.resize(bytes.size()+sizeof(int));\\n            memcpy(&bytes[bytes.size()-sizeof(int)], &(top->val), sizeof(int));\\n            st.pop();\\n            if (top->left != nullptr) {\\n                st.push(top->left);\\n            }\\n            if (top->right != nullptr) {\\n                st.push(top->right);\\n            }\\n        }\\n        return std::string(bytes.begin(), bytes.end());\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if (data.empty()) {\\n            return nullptr;\\n        }\\n        TreeNode* result = nullptr;\\n        for (int i=0; i<data.length(); i+=sizeof(int)) {\\n            int val;\\n            memcpy(&val, &data[i], sizeof(int));\\n            Insert(result, val);\\n        }\\n        return result;\\n    }\\n    \\n    void Insert(TreeNode*& root, int val) {\\n        if (root == nullptr) {\\n            root = new TreeNode(val);\\n            return;\\n        }\\n        if (val < root->val) {\\n            Insert(root->left, val);\\n        } else {\\n            Insert(root->right, val);\\n        }\\n    }\\n    \\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625604,
                "title": "solved-using-preorder-bst-traversal-again-building-back-the-tree-from-string-with-explanation",
                "content": "Accepted\\t\\n32 ms\\t\\n28.5 MB\\t\\ncpp\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return preorderTraverse(root);\\n    }\\n    \\n    // this function will create a preoder string of given bst\\n    // why preorder?\\n    // bcz then after we can easily create back the same bst using that preorder string of a bst\\n    string preorderTraverse(TreeNode* root)\\n    {\\n        if(!root)\\n            return\"\";\\n        \\n        return to_string(root->val) + \"-\" + preorderTraverse(root->left) + preorderTraverse(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        vector<int>preorder;\\n        \\n        // cout<<data;\\n        \\n        // convert string to integers again & save them to vector\\n        while (getline (ss, item, \\'-\\')) \\n        {\\n            preorder.push_back(stoi(item));\\n        }\\n        \\n        int start=0,end=preorder.size()-1;\\n        return  makeTree(preorder,start,end);\\n    }\\n    \\n    // building out a bst from given preorder\\n    TreeNode* makeTree(vector<int> &preorder ,int start, int end)\\n    {\\n        if(start<=end)\\n        {\\n            TreeNode* newnode = new TreeNode(preorder[start]);\\n            \\n            int bigger=start+1;\\n            while(bigger<=end && preorder[start]>preorder[bigger])\\n            {\\n                bigger++;\\n            }\\n            \\n            if(bigger>end)\\n            {\\n                newnode->left = makeTree(preorder,start+1,end);\\n                newnode->right = NULL;\\n            }\\n            else\\n            {\\n                newnode->left = makeTree(preorder,start+1,bigger-1);\\n                newnode->right = makeTree(preorder,bigger,end);\\n            }\\n            \\n            return newnode;\\n        }\\n        else\\n        {\\n            return NULL;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return preorderTraverse(root);\\n    }\\n    \\n    // this function will create a preoder string of given bst\\n    // why preorder?\\n    // bcz then after we can easily create back the same bst using that preorder string of a bst\\n    string preorderTraverse(TreeNode* root)\\n    {\\n        if(!root)\\n            return\"\";\\n        \\n        return to_string(root->val) + \"-\" + preorderTraverse(root->left) + preorderTraverse(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        vector<int>preorder;\\n        \\n        // cout<<data;\\n        \\n        // convert string to integers again & save them to vector\\n        while (getline (ss, item, \\'-\\')) \\n        {\\n            preorder.push_back(stoi(item));\\n        }\\n        \\n        int start=0,end=preorder.size()-1;\\n        return  makeTree(preorder,start,end);\\n    }\\n    \\n    // building out a bst from given preorder\\n    TreeNode* makeTree(vector<int> &preorder ,int start, int end)\\n    {\\n        if(start<=end)\\n        {\\n            TreeNode* newnode = new TreeNode(preorder[start]);\\n            \\n            int bigger=start+1;\\n            while(bigger<=end && preorder[start]>preorder[bigger])\\n            {\\n                bigger++;\\n            }\\n            \\n            if(bigger>end)\\n            {\\n                newnode->left = makeTree(preorder,start+1,end);\\n                newnode->right = NULL;\\n            }\\n            else\\n            {\\n                newnode->left = makeTree(preorder,start+1,bigger-1);\\n                newnode->right = makeTree(preorder,bigger,end);\\n            }\\n            \\n            return newnode;\\n        }\\n        else\\n        {\\n            return NULL;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1562441,
                "title": "java-easyy-with-2-preorder-traversl-o-2n",
                "content": "```\\npublic class Codec {\\n  public void helper(TreeNode node,StringBuilder str){\\n      if(node==null){\\n          str.append(\"#\"+\" \");\\n          return ;\\n      }\\n      \\n      str.append(node.val+\" \");\\n      helper(node.left,str);\\n      helper(node.right,str);\\n  }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder str=new StringBuilder();\\n        helper(root,str);\\n        \\n        return str.toString();\\n    }\\n \\n    public TreeNode dhelper(String[] arr,int []idx){\\n        if(idx[0]>arr.length || arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        int i=idx[0];\\n        idx[0]++;\\n        int val=Integer.parseInt(arr[i]);\\n        \\n        TreeNode left=dhelper(arr,idx);\\n        TreeNode right=dhelper(arr,idx);\\n        \\n        TreeNode node=new TreeNode(val);\\n        \\n        node.left=left;\\n        node.right=right;\\n        \\n        \\n        return node;\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String arr[]=data.split(\" \");\\n        int idx[]=new int[1];\\n        return dhelper(arr,idx);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n  public void helper(TreeNode node,StringBuilder str){\\n      if(node==null){\\n          str.append(\"#\"+\" \");\\n          return ;\\n      }\\n      \\n      str.append(node.val+\" \");\\n      helper(node.left,str);\\n      helper(node.right,str);\\n  }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder str=new StringBuilder();\\n        helper(root,str);\\n        \\n        return str.toString();\\n    }\\n \\n    public TreeNode dhelper(String[] arr,int []idx){\\n        if(idx[0]>arr.length || arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        int i=idx[0];\\n        idx[0]++;\\n        int val=Integer.parseInt(arr[i]);\\n        \\n        TreeNode left=dhelper(arr,idx);\\n        TreeNode right=dhelper(arr,idx);\\n        \\n        TreeNode node=new TreeNode(val);\\n        \\n        node.left=left;\\n        node.right=right;\\n        \\n        \\n        return node;\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String arr[]=data.split(\" \");\\n        int idx[]=new int[1];\\n        return dhelper(arr,idx);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1557031,
                "title": "simple-c-solution-using-preorder-concept",
                "content": "class Codec {\\npublic:\\n\\n    TreeNode* helper(stringstream &str){\\n        string s;\\n        getline(str, s, \\' \\');\\n        if(s == \"#\")\\n            return NULL;\\n        TreeNode *root = new TreeNode(stoi(s));\\n        root->left = helper(str);\\n        root->right = helper(str);\\n        return root;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL)\\n            return \"#\";\\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream s(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        return helper(s);\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Codec {\\npublic:\\n\\n    TreeNode* helper(stringstream &str){\\n        string s;\\n        getline(str, s, \\' \\');\\n        if(s == \"#\")\\n            return NULL;\\n        TreeNode *root = new TreeNode(stoi(s));\\n        root->left = helper(str);\\n        root->right = helper(str);\\n        return root;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL)\\n            return \"#\";\\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream s(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        return helper(s);\\n\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1529425,
                "title": "c-easy-solution-with-short-explanation",
                "content": "\\t/*In Serialize part we are traversing the tree in Preorder and then storing it in the string \\n\\twith a space after each number in order to identify distinct numbers.....(preorder function is for this)\\n\\t\\n\\tnow in deserializing we are storing the string into a vector(pre) and then sorting it into another\\n\\tvector (in)  now we are converting it into tree using preorder and inorder traversal\\n\\t(solve function is for this) :) */\\n\\t\\n\\t\\n\\tclass Codec {\\n\\tpublic:\\n        string pre=\"\";\\n    int x=0;\\n    \\n\\t  //Deserialize\\n    TreeNode* solve(vector<int>& pre,vector<int>& in,int i,int j){\\n            if(i > j) return NULL;\\n            int m;\\n            if(x < pre.size()){\\n                for(m=i;m<=j;++m){\\n                    if(pre[x] == in[m]){\\n                        x++;\\n                       break; \\n                    }\\n                }\\n            } else return NULL;\\n            TreeNode* temp = new TreeNode(in[m]);\\n            temp->left=solve(pre,in,i,m-1);\\n            temp->right=solve(pre,in,m+1,j);\\n            \\n            return temp;\\n            \\n        }\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root);\\n        return pre;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> in;\\n        int i=0;\\n        while(i <data.size()){\\n            if(data[i]!=\\' \\'){\\n                int val=0;\\n                while(i < data.size() && data[i]!=\\' \\'){\\n                    val=val*10+(data[i++]-48);\\n                }\\n                in.push_back(val);\\n            }else i++;\\n        }\\n        vector<int> pre=in;\\n        sort(in.begin(),in.end());\\n        \\n      return solve(pre,in,0,pre.size()-1);\\n    }\\n    \\n    \\n    //for preorder\\n    void preorder(TreeNode* root){\\n        if(!root) return;\\n        pre+=to_string(root->val);\\n        pre+= \" \";\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "\\t/*In Serialize part we are traversing the tree in Preorder and then storing it in the string \\n\\twith a space after each number in order to identify distinct numbers.....(preorder function is for this)\\n\\t\\n\\tnow in deserializing we are storing the string into a vector(pre) and then sorting it into another\\n\\tvector (in)  now we are converting it into tree using preorder and inorder traversal\\n\\t(solve function is for this) :) */\\n\\t\\n\\t\\n\\tclass Codec {\\n\\tpublic:\\n        string pre=\"\";\\n    int x=0;\\n    \\n\\t  //Deserialize\\n    TreeNode* solve(vector<int>& pre,vector<int>& in,int i,int j){\\n            if(i > j) return NULL;\\n            int m;\\n            if(x < pre.size()){\\n                for(m=i;m<=j;++m){\\n                    if(pre[x] == in[m]){\\n                        x++;\\n                       break; \\n                    }\\n                }\\n            } else return NULL;\\n            TreeNode* temp = new TreeNode(in[m]);\\n            temp->left=solve(pre,in,i,m-1);\\n            temp->right=solve(pre,in,m+1,j);\\n            \\n            return temp;\\n            \\n        }\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root);\\n        return pre;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> in;\\n        int i=0;\\n        while(i <data.size()){\\n            if(data[i]!=\\' \\'){\\n                int val=0;\\n                while(i < data.size() && data[i]!=\\' \\'){\\n                    val=val*10+(data[i++]-48);\\n                }\\n                in.push_back(val);\\n            }else i++;\\n        }\\n        vector<int> pre=in;\\n        sort(in.begin(),in.end());\\n        \\n      return solve(pre,in,0,pre.size()-1);\\n    }\\n    \\n    \\n    //for preorder\\n    void preorder(TreeNode* root){\\n        if(!root) return;\\n        pre+=to_string(root->val);\\n        pre+= \" \";\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1527925,
                "title": "javascript-optimize-solution-for-serialize-and-deserialize-bst",
                "content": "``` \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    if(root === null) {\\n        return \\'X\\';\\n    }\\n       let leftTree = serialize(root.left);\\n       let rightTree = serialize(root.right);\\n       return root.val + \\',\\' +leftTree + \\',\\' + rightTree;\\n    \\n    \\n    \\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const queue = [...data.split(\\',\\')];\\n    return helper(queue);\\n    function helper(queue) {\\n        let val = queue.shift();\\n        if (val === \\'X\\') {\\n            return null;\\n        }\\n        const node = new TreeNode(val);\\n        node.left = helper(queue);\\n        node.right = helper(queue);\\n        return node\\n    }\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ````",
                "solutionTags": [],
                "code": "``` \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    if(root === null) {\\n        return \\'X\\';\\n    }\\n       let leftTree = serialize(root.left);\\n       let rightTree = serialize(root.right);\\n       return root.val + \\',\\' +leftTree + \\',\\' + rightTree;\\n    \\n    \\n    \\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const queue = [...data.split(\\',\\')];\\n    return helper(queue);\\n    function helper(queue) {\\n        let val = queue.shift();\\n        if (val === \\'X\\') {\\n            return null;\\n        }\\n        const node = new TreeNode(val);\\n        node.left = helper(queue);\\n        node.right = helper(queue);\\n        return node\\n    }\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447456,
                "title": "preorder-binarysearch",
                "content": "Preorder of a bst is enough for its idenity first save its preorder in a string.\\nwhile deserializing we can store preorder in vector then can convert preorder to BST,we can use binary search to find number of nodes going to left and right.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void f(TreeNode* root,string& s){\\n        if(!root)\\n            return;\\n        s=s+to_string(root->val);\\n        s.push_back(\\'*\\');\\n        f(root->left,s);\\n        f(root->right,s);\\n    }\\n    string serialize(TreeNode* root) {\\n        string s;\\n        f(root,s);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int bs(vector<int>&v,int l,int h){\\n        int x=h+1;\\n        int i=l-1;\\n        while(l<=h){\\n            int m=(l+h)/2;\\n            if(v[m]>v[i]){\\n                x=m;\\n                h=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return x;\\n    }\\n    TreeNode* g(vector<int>&v,int l,int h){\\n        if(h<l)\\n            return NULL;\\n         if(l==h)\\n             return new TreeNode(v[l]);\\n        int x=bs(v,l+1,h);\\n        return new TreeNode(v[l],g(v,l+1,x-1),g(v,x,h));\\n    }\\n    TreeNode* deserialize(string data) {\\n        vector<int>v;\\n        string t;\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            if(data[i]==\\'*\\')\\n            {    v.push_back(stoi(t));\\n                t=\"\";}\\n            else\\n                t.push_back(data[i]);\\n            \\n        }\\n        return g(v,0,v.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void f(TreeNode* root,string& s){\\n        if(!root)\\n            return;\\n        s=s+to_string(root->val);\\n        s.push_back(\\'*\\');\\n        f(root->left,s);\\n        f(root->right,s);\\n    }\\n    string serialize(TreeNode* root) {\\n        string s;\\n        f(root,s);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int bs(vector<int>&v,int l,int h){\\n        int x=h+1;\\n        int i=l-1;\\n        while(l<=h){\\n            int m=(l+h)/2;\\n            if(v[m]>v[i]){\\n                x=m;\\n                h=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return x;\\n    }\\n    TreeNode* g(vector<int>&v,int l,int h){\\n        if(h<l)\\n            return NULL;\\n         if(l==h)\\n             return new TreeNode(v[l]);\\n        int x=bs(v,l+1,h);\\n        return new TreeNode(v[l],g(v,l+1,x-1),g(v,x,h));\\n    }\\n    TreeNode* deserialize(string data) {\\n        vector<int>v;\\n        string t;\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            if(data[i]==\\'*\\')\\n            {    v.push_back(stoi(t));\\n                t=\"\";}\\n            else\\n                t.push_back(data[i]);\\n            \\n        }\\n        return g(v,0,v.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400933,
                "title": "beat-99-2ms-no-delimiter-e-g-comma-no-stack-queue-just-turn-val-into-char",
                "content": "```\\npublic class Codec {\\n\\n    /*\\n    max node.val is 10000, less than 6xxxx(max value of char)   \\n    So just turn node.val into char.\\n    Serialize with preorder (parent > left > right)\\n    */\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        helper_serialize(sb, root);\\n        return sb.toString();\\n    }\\n    \\n    private void helper_serialize(StringBuilder sb, TreeNode root) {\\n        if (root == null) \\n            return;\\n        sb.append((char)(root.val + \\'0\\'));\\n        helper_serialize(sb, root.left);\\n        helper_serialize(sb, root.right);\\n    }\\n\\n    /*\\n    it\\'s BST, so it\\'s already in proper order as long as you add the node in order.\\n    */\\n    public TreeNode deserialize(String data) {\\n        TreeNode root = null;\\n        for(char c : data.toCharArray()) {\\n            root = add(root, c - \\'0\\');\\n        }\\n        return root;\\n    }\\n    private TreeNode add(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n        \\n        if (val < root.val) {\\n            root.left = add(root.left, val);\\n        } else {\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n\\nFYI what char looks like when int is above 9:\\n\\n```\\nint: 5 char: 5\\nint: 6 char: 6\\nint: 7 char: 7\\nint: 8 char: 8\\nint: 9 char: 9\\nint: 10 char: :\\nint: 11 char: ;\\nint: 12 char: <\\nint: 13 char: =\\nint: 14 char: >\\nint: 15 char: ?\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n\\n    /*\\n    max node.val is 10000, less than 6xxxx(max value of char)   \\n    So just turn node.val into char.\\n    Serialize with preorder (parent > left > right)\\n    */\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        helper_serialize(sb, root);\\n        return sb.toString();\\n    }\\n    \\n    private void helper_serialize(StringBuilder sb, TreeNode root) {\\n        if (root == null) \\n            return;\\n        sb.append((char)(root.val + \\'0\\'));\\n        helper_serialize(sb, root.left);\\n        helper_serialize(sb, root.right);\\n    }\\n\\n    /*\\n    it\\'s BST, so it\\'s already in proper order as long as you add the node in order.\\n    */\\n    public TreeNode deserialize(String data) {\\n        TreeNode root = null;\\n        for(char c : data.toCharArray()) {\\n            root = add(root, c - \\'0\\');\\n        }\\n        return root;\\n    }\\n    private TreeNode add(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n        \\n        if (val < root.val) {\\n            root.left = add(root.left, val);\\n        } else {\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nint: 5 char: 5\\nint: 6 char: 6\\nint: 7 char: 7\\nint: 8 char: 8\\nint: 9 char: 9\\nint: 10 char: :\\nint: 11 char: ;\\nint: 12 char: <\\nint: 13 char: =\\nint: 14 char: >\\nint: 15 char: ?\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386028,
                "title": "python-solution-based-on-preorder-and-inorder-traversals",
                "content": "Using preorder only (utilize BST property):\\n```Python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def preorderTraversal(node):\\n            if not node:\\n                return\\n            data.append(str(node.val))\\n            preorderTraversal(node.left)\\n            preorderTraversal(node.right)\\n        data = []\\n        preorderTraversal(root)\\n        return \".\".join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def buildTree(values):\\n            if not values:\\n                return\\n            root = TreeNode(values[0])\\n            # find the smallest value that is \\n            # greater than root\\n            idx = 1\\n            while idx < len(values) and values[idx] < values[0]:\\n                idx += 1\\n            root.left = buildTree(values[1:idx])\\n            root.right = buildTree(values[idx:])\\n            return root\\n            \\n        values = [int(x) for x in data.split(\".\") if x]\\n        return buildTree(values)\\n            \\n        \\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```\\n\\nUse both preorder and inorder (don\\'t utilize BST property)\\n```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.inorderTraversal(root.left)\\n        self.inorder.append(str(root.val))\\n        self.inorderTraversal(root.right)\\n        \\n    def preorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.preorder.append(str(root.val))\\n        self.preorderTraversal(root.left)\\n        self.preorderTraversal(root.right)\\n    \\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        self.inorder = []\\n        self.preorder = []\\n        self.inorderTraversal(root)\\n        self.preorderTraversal(root)\\n        return \".\".join(self.inorder)+\\',\\'+\\'.\\'.join(self.preorder)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def reconstruct(inorder, preorder):\\n            if not inorder:\\n                return\\n            \\n            if preorder[0]:\\n                root = TreeNode()\\n                root.val = int(preorder[0])\\n                size_left = inorder.index(preorder[0])\\n                root.left = reconstruct(inorder[:size_left], preorder[1:1+size_left])\\n                root.right = reconstruct(inorder[size_left+1:], preorder[1+size_left:])\\n                return root\\n        \\n        traversals = data.split(\\',\\')\\n        inorder = traversals[0].split(\\'.\\')\\n        preorder = traversals[1].split(\\'.\\')\\n        \\n        return reconstruct(inorder, preorder)\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```Python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def preorderTraversal(node):\\n            if not node:\\n                return\\n            data.append(str(node.val))\\n            preorderTraversal(node.left)\\n            preorderTraversal(node.right)\\n        data = []\\n        preorderTraversal(root)\\n        return \".\".join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def buildTree(values):\\n            if not values:\\n                return\\n            root = TreeNode(values[0])\\n            # find the smallest value that is \\n            # greater than root\\n            idx = 1\\n            while idx < len(values) and values[idx] < values[0]:\\n                idx += 1\\n            root.left = buildTree(values[1:idx])\\n            root.right = buildTree(values[idx:])\\n            return root\\n            \\n        values = [int(x) for x in data.split(\".\") if x]\\n        return buildTree(values)\\n            \\n        \\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```\n```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.inorderTraversal(root.left)\\n        self.inorder.append(str(root.val))\\n        self.inorderTraversal(root.right)\\n        \\n    def preorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.preorder.append(str(root.val))\\n        self.preorderTraversal(root.left)\\n        self.preorderTraversal(root.right)\\n    \\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        self.inorder = []\\n        self.preorder = []\\n        self.inorderTraversal(root)\\n        self.preorderTraversal(root)\\n        return \".\".join(self.inorder)+\\',\\'+\\'.\\'.join(self.preorder)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def reconstruct(inorder, preorder):\\n            if not inorder:\\n                return\\n            \\n            if preorder[0]:\\n                root = TreeNode()\\n                root.val = int(preorder[0])\\n                size_left = inorder.index(preorder[0])\\n                root.left = reconstruct(inorder[:size_left], preorder[1:1+size_left])\\n                root.right = reconstruct(inorder[size_left+1:], preorder[1+size_left:])\\n                return root\\n        \\n        traversals = data.split(\\',\\')\\n        inorder = traversals[0].split(\\'.\\')\\n        preorder = traversals[1].split(\\'.\\')\\n        \\n        return reconstruct(inorder, preorder)\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377431,
                "title": "python-preorder-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def process(node: TreeNode):\\n            if not node:\\n                return\\n            numbers.append(node.val)\\n            process(node.left)\\n            process(node.right)\\n            \\n        numbers = []\\n        process(root);\\n        answer = \"\"\\n        for num in numbers:\\n            if answer:\\n                answer += \" \"\\n            answer += str(num)\\n        print(answer)\\n        return answer\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def create(sortedNumbers: List[int], numbers: List[int]) -> TreeNode:\\n            assert len(numbers) == len(sortedNumbers)\\n            if not numbers:\\n                return None\\n            \\n            val = numbers[0]\\n            valIndex = bisect_left(sortedNumbers, val)\\n            \\n            left = create(sortedNumbers[:valIndex], numbers[1:valIndex + 1])\\n            right = create(sortedNumbers[valIndex + 1:], numbers[valIndex + 1:])\\n            \\n            return TreeNode(val, left, right)\\n            \\n        numbers = [int(number) for number in data.split()]\\n        sortedNumbers = sorted(numbers)\\n        return create(sortedNumbers, numbers)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def process(node: TreeNode):\\n            if not node:\\n                return\\n            numbers.append(node.val)\\n            process(node.left)\\n            process(node.right)\\n            \\n        numbers = []\\n        process(root);\\n        answer = \"\"\\n        for num in numbers:\\n            if answer:\\n                answer += \" \"\\n            answer += str(num)\\n        print(answer)\\n        return answer\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def create(sortedNumbers: List[int], numbers: List[int]) -> TreeNode:\\n            assert len(numbers) == len(sortedNumbers)\\n            if not numbers:\\n                return None\\n            \\n            val = numbers[0]\\n            valIndex = bisect_left(sortedNumbers, val)\\n            \\n            left = create(sortedNumbers[:valIndex], numbers[1:valIndex + 1])\\n            right = create(sortedNumbers[valIndex + 1:], numbers[valIndex + 1:])\\n            \\n            return TreeNode(val, left, right)\\n            \\n        numbers = [int(number) for number in data.split()]\\n        sortedNumbers = sorted(numbers)\\n        return create(sortedNumbers, numbers)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356432,
                "title": "python-bfs-beat-99-66",
                "content": "This is a general method for all binary tree\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([(root)])\\n        data = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                data.append(str(node.val))\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                data.append(\\'#\\')\\n        return \\',\\'.join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data = data.split(\\',\\')\\n        q = collections.deque(data)\\n        root = TreeNode(int(q.popleft()))\\n        p = collections.deque([root]) # memory non-empty nodes\\n        while q:\\n            node = p.popleft()\\n            left = q.popleft()\\n            right = q.popleft()\\n            if left != \\'#\\':\\n                node.left = TreeNode(int(left))\\n                p.append(node.left) # add non-empty node\\n            if right != \\'#\\':\\n                node.right = TreeNode(int(right))\\n                p.append(node.right)# add non-empty node\\n        return root",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "This is a general method for all binary tree\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([(root)])\\n        data = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                data.append(str(node.val))\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                data.append(\\'#\\')\\n        return \\',\\'.join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data = data.split(\\',\\')\\n        q = collections.deque(data)\\n        root = TreeNode(int(q.popleft()))\\n        p = collections.deque([root]) # memory non-empty nodes\\n        while q:\\n            node = p.popleft()\\n            left = q.popleft()\\n            right = q.popleft()\\n            if left != \\'#\\':\\n                node.left = TreeNode(int(left))\\n                p.append(node.left) # add non-empty node\\n            if right != \\'#\\':\\n                node.right = TreeNode(int(right))\\n                p.append(node.right)# add non-empty node\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 1348989,
                "title": "c-simple-and-intuitive-99-easy-to-understand",
                "content": "```\\nclass Codec {\\npublic:\\n    void encode(TreeNode* root, string &str){\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val);\\n        str += \"-\";\\n        encode(root->left, str);\\n        encode(root->right, str);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        encode(root, str);\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = NULL;\\n        stringstream ss(data);\\n        string value;\\n        while(getline(ss, value, \\'-\\')){\\n            root = insert(root, stoi(value));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        if(root->val > data){\\n            root->left = insert(root->left, data);\\n            return root;\\n        }\\n        else{\\n            root->right = insert(root->right, data);\\n            return root;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    void encode(TreeNode* root, string &str){\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val);\\n        str += \"-\";\\n        encode(root->left, str);\\n        encode(root->right, str);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        encode(root, str);\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = NULL;\\n        stringstream ss(data);\\n        string value;\\n        while(getline(ss, value, \\'-\\')){\\n            root = insert(root, stoi(value));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        if(root->val > data){\\n            root->left = insert(root->left, data);\\n            return root;\\n        }\\n        else{\\n            root->right = insert(root->right, data);\\n            return root;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315977,
                "title": "81-faster-c-using-string-manipulation-and-postot",
                "content": "\\tclass Codec {\\n\\tpublic:\\n\\t\\tvoid inOrder(TreeNode* root, string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tqueue<TreeNode*> que;\\n\\t\\t\\tque.push(root);\\n\\t\\t\\twhile(!que.empty()){\\n\\t\\t\\t\\tauto temp = que.front();\\n\\t\\t\\t\\ts += to_string(temp->val)+\"-\";\\n\\t\\t\\t\\tque.pop();  \\n\\t\\t\\t\\tif(temp->left){\\n\\t\\t\\t\\t\\tque.push(temp->left);\\n\\t\\t\\t\\t} if(temp->right){\\n\\t\\t\\t\\t\\tque.push(temp->right);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tinOrder(root, s);\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\n\\t\\tTreeNode* insertNode(TreeNode* root, int key){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn new TreeNode(key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val > key){\\n\\t\\t\\t\\troot->left = insertNode(root->left, key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val < key){\\n\\t\\t\\t\\troot->right = insertNode(root->right, key);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data) {\\n\\t\\t\\tvector<int> vec;\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tfor(int i=0;i<data.size(); i++){\\n\\t\\t\\t\\tif(data[i] == \\'-\\'){\\n\\t\\t\\t\\t\\tvec.push_back(stoi(s));\\n\\t\\t\\t\\t\\ts = \"\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ts += data[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode* root = NULL;\\n\\t\\t\\tfor(int i=0;i<vec.size(); i++){\\n\\t\\t\\t\\troot = insertNode(root, vec[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Codec {\\n\\tpublic:\\n\\t\\tvoid inOrder(TreeNode* root, string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tqueue<TreeNode*> que;\\n\\t\\t\\tque.push(root);\\n\\t\\t\\twhile(!que.empty()){\\n\\t\\t\\t\\tauto temp = que.front();\\n\\t\\t\\t\\ts += to_string(temp->val)+\"-\";\\n\\t\\t\\t\\tque.pop();  \\n\\t\\t\\t\\tif(temp->left){\\n\\t\\t\\t\\t\\tque.push(temp->left);\\n\\t\\t\\t\\t} if(temp->right){\\n\\t\\t\\t\\t\\tque.push(temp->right);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tinOrder(root, s);\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\n\\t\\tTreeNode* insertNode(TreeNode* root, int key){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn new TreeNode(key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val > key){\\n\\t\\t\\t\\troot->left = insertNode(root->left, key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val < key){\\n\\t\\t\\t\\troot->right = insertNode(root->right, key);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data) {\\n\\t\\t\\tvector<int> vec;\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tfor(int i=0;i<data.size(); i++){\\n\\t\\t\\t\\tif(data[i] == \\'-\\'){\\n\\t\\t\\t\\t\\tvec.push_back(stoi(s));\\n\\t\\t\\t\\t\\ts = \"\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ts += data[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode* root = NULL;\\n\\t\\t\\tfor(int i=0;i<vec.size(); i++){\\n\\t\\t\\t\\troot = insertNode(root, vec[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1245040,
                "title": "java-easy-solution-using-preorder",
                "content": "**Do vote up if you like it :)**\\n```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serializeHelper(TreeNode root, StringBuilder sb){\\n        if(root == null){\\n            sb.append(\"null\").append(\",\");\\n            return;\\n        }\\n        sb.append(root.val).append(\",\");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] strArr = data.split(\",\");\\n        return deserializeHelper(strArr);\\n    }\\n    \\n    int idx = 0;\\n    public TreeNode deserializeHelper(String[] strArr){\\n        if(idx == strArr.length || strArr[idx].equals(\"null\")){\\n            idx++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(strArr[idx++]));\\n        root.left = deserializeHelper(strArr);\\n        root.right = deserializeHelper(strArr);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serializeHelper(TreeNode root, StringBuilder sb){\\n        if(root == null){\\n            sb.append(\"null\").append(\",\");\\n            return;\\n        }\\n        sb.append(root.val).append(\",\");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] strArr = data.split(\",\");\\n        return deserializeHelper(strArr);\\n    }\\n    \\n    int idx = 0;\\n    public TreeNode deserializeHelper(String[] strArr){\\n        if(idx == strArr.length || strArr[idx].equals(\"null\")){\\n            idx++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(strArr[idx++]));\\n        root.left = deserializeHelper(strArr);\\n        root.right = deserializeHelper(strArr);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227938,
                "title": "java-dfs-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    StringBuffer encode;\\n    public String serialize(TreeNode root) {\\n        encode = new StringBuffer();\\n        preOrder(root,encode);\\n      return encode.toString();\\n    }\\n    private void preOrder(TreeNode node,StringBuffer encode){\\n      if(node == null){\\n        encode.append(\"null,\");\\n        return ;\\n      }\\n      encode.append(node.val+\",\");\\n      preOrder(node.left,encode);\\n      preOrder(node.right,encode);\\n      \\n    }\\n    // Decodes your encoded data to tree.\\n    int idx = 0;\\n    public TreeNode deserialize(String data) {\\n        String arr[] = data.split(\",\");\\n       return deserialize(arr);\\n    }\\n   private TreeNode deserialize(String arr[]){\\n     if(idx >= arr.length || arr[idx].equals(\"null\")){\\n       idx++;\\n       return null;\\n     }\\n     \\n     TreeNode newNode = new TreeNode(Integer.parseInt(arr[idx++]));\\n     newNode.left = deserialize(arr);\\n     newNode.right = deserialize(arr);\\n     \\n     return newNode;\\n   }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    StringBuffer encode;\\n    public String serialize(TreeNode root) {\\n        encode = new StringBuffer();\\n        preOrder(root,encode);\\n      return encode.toString();\\n    }\\n    private void preOrder(TreeNode node,StringBuffer encode){\\n      if(node == null){\\n        encode.append(\"null,\");\\n        return ;\\n      }\\n      encode.append(node.val+\",\");\\n      preOrder(node.left,encode);\\n      preOrder(node.right,encode);\\n      \\n    }\\n    // Decodes your encoded data to tree.\\n    int idx = 0;\\n    public TreeNode deserialize(String data) {\\n        String arr[] = data.split(\",\");\\n       return deserialize(arr);\\n    }\\n   private TreeNode deserialize(String arr[]){\\n     if(idx >= arr.length || arr[idx].equals(\"null\")){\\n       idx++;\\n       return null;\\n     }\\n     \\n     TreeNode newNode = new TreeNode(Integer.parseInt(arr[idx++]));\\n     newNode.left = deserialize(arr);\\n     newNode.right = deserialize(arr);\\n     \\n     return newNode;\\n   }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223342,
                "title": "using-preorder-bst-property-o-n-without",
                "content": "```\\npublic class Codec {\\n    int idx = 0;\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return serializeHelper(root,\"\");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] arr = data.split(\",\");\\n        return deserializeHelper(arr, Long.MAX_VALUE, Long.MIN_VALUE, data);\\n    }\\n    \\n    \\n    private String serializeHelper(TreeNode root, String res) {\\n        if(root == null) {\\n            return res;\\n        }\\n        res+=root.val+\",\";\\n        res = serializeHelper(root.left, res);\\n        res = serializeHelper(root.right, res);\\n        return res;\\n    }\\n    \\n    \\n    private TreeNode deserializeHelper(String[] arr, long max, long min, String data) {\\n        if(arr.length == idx)\\n            return null;\\n        if(data == \"\")    //handling empty data\\n            return null;\\n        Integer value = Integer.valueOf(arr[idx]);\\n        if(value > max || value < min)  // using bst prop\\n            return null;\\n        idx++;\\n        TreeNode root = new TreeNode(value);\\n        root.left = deserializeHelper(arr, root.val, min, data);\\n        root.right = deserializeHelper(arr, max, root.val, data);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    int idx = 0;\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return serializeHelper(root,\"\");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] arr = data.split(\",\");\\n        return deserializeHelper(arr, Long.MAX_VALUE, Long.MIN_VALUE, data);\\n    }\\n    \\n    \\n    private String serializeHelper(TreeNode root, String res) {\\n        if(root == null) {\\n            return res;\\n        }\\n        res+=root.val+\",\";\\n        res = serializeHelper(root.left, res);\\n        res = serializeHelper(root.right, res);\\n        return res;\\n    }\\n    \\n    \\n    private TreeNode deserializeHelper(String[] arr, long max, long min, String data) {\\n        if(arr.length == idx)\\n            return null;\\n        if(data == \"\")    //handling empty data\\n            return null;\\n        Integer value = Integer.valueOf(arr[idx]);\\n        if(value > max || value < min)  // using bst prop\\n            return null;\\n        idx++;\\n        TreeNode root = new TreeNode(value);\\n        root.left = deserializeHelper(arr, root.val, min, data);\\n        root.right = deserializeHelper(arr, max, root.val, data);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194243,
                "title": "not-a-solution-but-an-hack-to-pass-all-the-test-cases-xd",
                "content": "Just store tree value globally and return the same when needed XD \\n\\n**This was not an solution i was just checking that does leetcode complier checks the reference of newly created tree or not .**\\n\\n```\\nTreeNode* t = NULL ;\\nclass Codec {\\npublic:\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        t = root; \\n\\t\\treturn \"blabla\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return t;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* t = NULL ;\\nclass Codec {\\npublic:\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        t = root; \\n\\t\\treturn \"blabla\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return t;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174286,
                "title": "c-solution",
                "content": "```\\npublic class Codec {\\n    List<char> values = new List<char>();\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        PreOrder(root);\\n        char[] arr = values.ToArray();\\n        return new string(arr);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        TreeNode node = null;\\n        for(int i=0;i<data.Length;i++){\\n            Console.WriteLine($\"str = {data[i]}\");\\n            int val = Convert.ToInt32(data[i] - \\'0\\');\\n            Console.WriteLine($\"int={val}\");\\n            node = Insert(node, val);\\n        }\\n        return node;\\n    }\\n    \\n    private TreeNode Insert(TreeNode node, int val){\\n        if(node == null){\\n            node = new TreeNode(val);\\n        }else if(val > node.val){\\n            node.right = Insert(node.right, val);\\n        } else if (val < node.val){\\n            node.left = Insert(node.left, val);\\n        }\\n        return node;\\n    }\\n    private void PreOrder(TreeNode node){\\n        if(node == null) return;\\n        values.Add((char)(node.val + \\'0\\'));\\n        PreOrder(node.left);\\n        PreOrder(node.right);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    List<char> values = new List<char>();\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        PreOrder(root);\\n        char[] arr = values.ToArray();\\n        return new string(arr);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        TreeNode node = null;\\n        for(int i=0;i<data.Length;i++){\\n            Console.WriteLine($\"str = {data[i]}\");\\n            int val = Convert.ToInt32(data[i] - \\'0\\');\\n            Console.WriteLine($\"int={val}\");\\n            node = Insert(node, val);\\n        }\\n        return node;\\n    }\\n    \\n    private TreeNode Insert(TreeNode node, int val){\\n        if(node == null){\\n            node = new TreeNode(val);\\n        }else if(val > node.val){\\n            node.right = Insert(node.right, val);\\n        } else if (val < node.val){\\n            node.left = Insert(node.left, val);\\n        }\\n        return node;\\n    }\\n    private void PreOrder(TreeNode node){\\n        if(node == null) return;\\n        values.Add((char)(node.val + \\'0\\'));\\n        PreOrder(node.left);\\n        PreOrder(node.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150143,
                "title": "short",
                "content": "**Serialize:** BFS, time `O(N)`;\\n**Deserialize:** iterative insert into BST, time `O(NlogN)`.\\n```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n                             \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        auto r{&out};\\n        int val{-1};\\n        for(stringstream ss{d}; ss>>d; *r = new TreeNode(val))\\n            for(val = stoi(d), r = &out; *r; r = val<=(*r)->val ? &(*r)->left : &(*r)->right);\\n        return out;\\n    }\\n};\\n```\\n<details>\\n<summary>\\nRecursive insert variation:\\n</summary>\\n\\n```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n\\n    TreeNode* insert(TreeNode* r, int val)\\n    {\\n        if(!r) return new TreeNode(val);\\n        TreeNode* & child = val<=r->val ? r->left : r->right;\\n        child = insert(child,  val);\\n        return r;\\n    }\\n                              \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        for(stringstream ss{d}; ss>>d; out = insert(out, stoi(d)));\\n        return out;\\n    }\\n};\\n```\\n</details>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n                             \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        auto r{&out};\\n        int val{-1};\\n        for(stringstream ss{d}; ss>>d; *r = new TreeNode(val))\\n            for(val = stoi(d), r = &out; *r; r = val<=(*r)->val ? &(*r)->left : &(*r)->right);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n\\n    TreeNode* insert(TreeNode* r, int val)\\n    {\\n        if(!r) return new TreeNode(val);\\n        TreeNode* & child = val<=r->val ? r->left : r->right;\\n        child = insert(child,  val);\\n        return r;\\n    }\\n                              \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        for(stringstream ss{d}; ss>>d; out = insert(out, stoi(d)));\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120513,
                "title": "c-serialize-deserialize-into-from-preorder-sequence-elegant-and-concise-beats-99",
                "content": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        ostringstream oss;\\n\\n        bool first = true;\\n        stack<TreeNode*> stk;\\n        if (root) {\\n            stk.emplace(root);\\n        }\\n        while (!stk.empty()) {\\n            TreeNode* node = stk.top();\\n            stk.pop();\\n\\n            if (0 < oss.tellp()) {\\n                oss << \" \";\\n            }\\n            oss << node->val;\\n\\n            if (node->right) {\\n                stk.push(node->right);\\n            }\\n            if (node->left) {\\n                stk.push(node->left);\\n            }\\n        }\\n\\n        return oss.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* pHead = nullptr;\\n        TreeNode** ppCur = &pHead;\\n\\n        int num;\\n        stack<TreeNode*> stk;\\n        for (istringstream iss(data); iss >> num;) {\\n            while (!stk.empty() && stk.top()->val < num) {\\n                ppCur = &(stk.top()->right);\\n                stk.pop();\\n            }\\n\\n            *ppCur = new TreeNode(num);\\n            stk.push(*ppCur);\\n\\n            ppCur = &((*ppCur)->left);\\n        }\\n\\n        return pHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        ostringstream oss;\\n\\n        bool first = true;\\n        stack<TreeNode*> stk;\\n        if (root) {\\n            stk.emplace(root);\\n        }\\n        while (!stk.empty()) {\\n            TreeNode* node = stk.top();\\n            stk.pop();\\n\\n            if (0 < oss.tellp()) {\\n                oss << \" \";\\n            }\\n            oss << node->val;\\n\\n            if (node->right) {\\n                stk.push(node->right);\\n            }\\n            if (node->left) {\\n                stk.push(node->left);\\n            }\\n        }\\n\\n        return oss.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* pHead = nullptr;\\n        TreeNode** ppCur = &pHead;\\n\\n        int num;\\n        stack<TreeNode*> stk;\\n        for (istringstream iss(data); iss >> num;) {\\n            while (!stk.empty() && stk.top()->val < num) {\\n                ppCur = &(stk.top()->right);\\n                stk.pop();\\n            }\\n\\n            *ppCur = new TreeNode(num);\\n            stk.push(*ppCur);\\n\\n            ppCur = &((*ppCur)->left);\\n        }\\n\\n        return pHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053261,
                "title": "java-preorder-solution",
                "content": "```\\npublic class Codec {\\n\\n    void preorder(TreeNode root, List list) {\\n        if(root==null)\\n            return;\\n        list.add(String.valueOf(root.val));\\n        preorder(root.left, list);\\n        preorder(root.right, list);\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        preorder(root, list);\\n        String result = String.join(\",\",list);\\n        return list.size()==0?\"\":result;\\n    }\\n\\n    int idx=0;\\n    public TreeNode decode(String[] arr, int len, int min, int max) {\\n        if(idx==len)\\n            return null;\\n        int val = Integer.parseInt(arr[idx]);\\n        if(val<min || val>max)\\n            return null;\\n        idx++;\\n        TreeNode node = new TreeNode(val);\\n        node.left = decode(arr, len, min, val);\\n        node.right = decode(arr, len, val, max);\\n        return node;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length()==0)\\n            return null;\\n        String[] arr = data.split(\",\");\\n        return decode(arr,arr.length,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    void preorder(TreeNode root, List list) {\\n        if(root==null)\\n            return;\\n        list.add(String.valueOf(root.val));\\n        preorder(root.left, list);\\n        preorder(root.right, list);\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        preorder(root, list);\\n        String result = String.join(\",\",list);\\n        return list.size()==0?\"\":result;\\n    }\\n\\n    int idx=0;\\n    public TreeNode decode(String[] arr, int len, int min, int max) {\\n        if(idx==len)\\n            return null;\\n        int val = Integer.parseInt(arr[idx]);\\n        if(val<min || val>max)\\n            return null;\\n        idx++;\\n        TreeNode node = new TreeNode(val);\\n        node.left = decode(arr, len, min, val);\\n        node.right = decode(arr, len, val, max);\\n        return node;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length()==0)\\n            return null;\\n        String[] arr = data.split(\",\");\\n        return decode(arr,arr.length,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043500,
                "title": "step-by-step-video-solutions-with-chinese-and-english",
                "content": "Leetcode\\u4E0A\\u6709\\u597D\\u51E0\\u4E2A\\u5173\\u4E8E\\u6811\\u7684\\u5E8F\\u5217\\u5316\\u7684\\u95EE\\u9898\\uFF0C\\u5206\\u522B\\u662F297/428/449. \\u4ED6\\u4EEC\\u4E4B\\u95F4\\u5404\\u6709\\u8054\\u7CFB\\u3002\\u6811\\u7684\\u5E8F\\u5217\\u5316\\u662F\\u4E00\\u4E2A\\u8001\\u751F\\u5E38\\u8C08\\u7684\\u95EE\\u9898\\uFF0C\\u4F46\\u662F\\u53C8\\u662F\\u4E00\\u4E2A\\u5F88\\u91CD\\u8981\\u7684\\u4E3B\\u9898\\u3002\\u6211\\u5728\\u4EE5\\u524D\\u9762\\u82F9\\u679C\\u7684\\u65F6\\u5019\\u5C31\\u88AB\\u95EE\\u5230\\uFF1A\\u5982\\u679C\\u5E8F\\u5217\\u5316\\u4E00\\u4E2A\\u4E8C\\u53C9\\u6811\\uFF0C\\u6BCF\\u4E2A\\u8282\\u70B9\\u7684data\\u662F\\'a\\'-\\'z\\'\\u6216\\u8005\\'A\\'-\\'Z\\'\\u3002\\u5F53\\u65F6\\u6211\\u7684\\u662F\\u5728\\u9762\\u8BD5\\u5B98\\u7684\\u63D0\\u793A\\u4E0B\\u624D\\u60F3\\u51FA\\u4ED6\\u60F3\\u8981\\u6211\\u5B9E\\u73B0\\u7684\\u65B9\\u6CD5\\u3002\\u6240\\u4EE5\\u501F\\u8FD9\\u4E2A\\u673A\\u4F1A\\u5206\\u4EAB\\u7ED9\\u5927\\u5BB6\\u3002\\n\\nThere are some tree serialization problems in Leetcode. They are Leetcode 297/428/449. Tree serialization and deserialization is a very common problem. There was an Apple interview question: How to serialize a binary tree if each node is a character \\'a\\'-\\'z\\' or \\'A\\'-\\'Z\\'. I gave the optimal solution after some hints. So I share it here.\\n\\n\\u4E2D\\u6587\\u89E3\\u7B54: https://youtu.be/8_JSg4RWvhY\\n\\nEnglish Solution: https://youtu.be/iZHDx-k2Mxw\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1026292,
                "title": "runtime-32-ms-faster-than-93-54-of-c-order-n-solution-preorder-recursion",
                "content": "class Codec {\\npublic:\\n    int start=0;\\n    TreeNode* myfunc(string &S,int count){\\n        int temp=start;\\n        int count1=count;\\n        while(count1--){\\n            if(S[start]!=\\'-\\'){\\n                start=temp;\\n                return NULL;\\n            }\\n            start++;\\n        }\\n        if(start>=S.size())return NULL;\\n        TreeNode* root=new TreeNode;\\n        int v=0;\\n        while(start<S.size()&&S[start]!=\\'-\\'){\\n            v=v*10+S[start]-48;\\n            start++;\\n        }\\n        start--;\\n        if(v==10001){\\n            start++;\\n            return NULL;\\n        }\\n        root->val=v;\\n        start++;\\n        root->left=myfunc(S,count+1);\\n        root->right=myfunc(S,count+1);\\n        return root;\\n    }\\n    string s;\\n    void preorder(TreeNode* root,int level){\\n        if(!root)return;\\n        s+=to_string(root->val);\\n        if(root->left){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->left,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n        if(root->right){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->right,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root,1);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return myfunc(data,0);\\n    }\\n};\\nhttps://leetcode.com/problems/recover-a-tree-from-preorder-traversal/\\nThe deserialize function also solve this question while serialize function changes in the preorder string needed for the string.\\nValue 10001 is use to check for a null value.\\nCan\\'t use -ve value to check as - is treated as dash.\\n\\nWith few basic modification we can solve this problem too https://leetcode.com/problems/serialize-and-deserialize-binary-tree/submissions/ . Just replace - with # and use a flag to maintain +ve and -ve numbers.\\nMake sure to *UPVOTE*",
                "solutionTags": [],
                "code": "class Codec {\\npublic:\\n    int start=0;\\n    TreeNode* myfunc(string &S,int count){\\n        int temp=start;\\n        int count1=count;\\n        while(count1--){\\n            if(S[start]!=\\'-\\'){\\n                start=temp;\\n                return NULL;\\n            }\\n            start++;\\n        }\\n        if(start>=S.size())return NULL;\\n        TreeNode* root=new TreeNode;\\n        int v=0;\\n        while(start<S.size()&&S[start]!=\\'-\\'){\\n            v=v*10+S[start]-48;\\n            start++;\\n        }\\n        start--;\\n        if(v==10001){\\n            start++;\\n            return NULL;\\n        }\\n        root->val=v;\\n        start++;\\n        root->left=myfunc(S,count+1);\\n        root->right=myfunc(S,count+1);\\n        return root;\\n    }\\n    string s;\\n    void preorder(TreeNode* root,int level){\\n        if(!root)return;\\n        s+=to_string(root->val);\\n        if(root->left){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->left,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n        if(root->right){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->right,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root,1);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return myfunc(data,0);\\n    }\\n};\\nhttps://leetcode.com/problems/recover-a-tree-from-preorder-traversal/\\nThe deserialize function also solve this question while serialize function changes in the preorder string needed for the string.\\nValue 10001 is use to check for a null value.\\nCan\\'t use -ve value to check as - is treated as dash.\\n\\nWith few basic modification we can solve this problem too https://leetcode.com/problems/serialize-and-deserialize-binary-tree/submissions/ . Just replace - with # and use a flag to maintain +ve and -ve numbers.\\nMake sure to *UPVOTE*",
                "codeTag": "Java"
            },
            {
                "id": 1008464,
                "title": "javascript-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    const result = [];\\n    if (!root) {\\n        return result;\\n    }\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        result[index] = node.val;\\n        if (node.left) {\\n            queue.push([node.left, 2 * index + 1]);\\n        }\\n        if (node.right) {\\n            queue.push([node.right, 2 * index + 2]);\\n        }\\n    }\\n    return result;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    if (!data || data.length < 1) {\\n        return null\\n    }\\n    const root = new TreeNode(data[0]);\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        const leftIndex = 2 * index + 1;\\n        const rightIndex = 2 * index + 2;\\n        const left = data[leftIndex];\\n        const right = data[rightIndex];\\n        if (left !== undefined) {\\n            node.left = new TreeNode(left);\\n            queue.push([node.left, leftIndex]);\\n        }\\n        if (right !== undefined) {\\n            node.right = new TreeNode(right);\\n            queue.push([node.right, rightIndex]);\\n        }\\n    }\\n    return root;\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    const result = [];\\n    if (!root) {\\n        return result;\\n    }\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        result[index] = node.val;\\n        if (node.left) {\\n            queue.push([node.left, 2 * index + 1]);\\n        }\\n        if (node.right) {\\n            queue.push([node.right, 2 * index + 2]);\\n        }\\n    }\\n    return result;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    if (!data || data.length < 1) {\\n        return null\\n    }\\n    const root = new TreeNode(data[0]);\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        const leftIndex = 2 * index + 1;\\n        const rightIndex = 2 * index + 2;\\n        const left = data[leftIndex];\\n        const right = data[rightIndex];\\n        if (left !== undefined) {\\n            node.left = new TreeNode(left);\\n            queue.push([node.left, leftIndex]);\\n        }\\n        if (right !== undefined) {\\n            node.right = new TreeNode(right);\\n            queue.push([node.right, rightIndex]);\\n        }\\n    }\\n    return root;\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003030,
                "title": "scala-solution-preorder-simple-solution",
                "content": "```\\n// Encodes a list of strings to a single string.\\ndef serialize(root: TreeNode): String = root match {\\n\\tcase null => \"x,\"\\n\\tcase root => root.value +\",\"+ serialize(root.left) + serialize(root.right)\\n}\\n\\n// Decodes a single string to a list of strings.\\ndef deserialize(data: String): TreeNode = {\\n\\tdef dfs(q: Queue[String]): TreeNode = {\\n\\t\\tval value = q.dequeue\\n\\t\\tif(value == \"x\") return null\\n\\n\\t\\tval root = TreeNode(value.toInt)\\n\\t\\troot.left = dfs(q)\\n\\t\\troot.right = dfs(q)\\n\\t\\troot\\n\\t}\\n\\tdfs(Queue[String]().enqueueAll(data.split(\",\")))\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Encodes a list of strings to a single string.\\ndef serialize(root: TreeNode): String = root match {\\n\\tcase null => \"x,\"\\n\\tcase root => root.value +\",\"+ serialize(root.left) + serialize(root.right)\\n}\\n\\n// Decodes a single string to a list of strings.\\ndef deserialize(data: String): TreeNode = {\\n\\tdef dfs(q: Queue[String]): TreeNode = {\\n\\t\\tval value = q.dequeue\\n\\t\\tif(value == \"x\") return null\\n\\n\\t\\tval root = TreeNode(value.toInt)\\n\\t\\troot.left = dfs(q)\\n\\t\\troot.right = dfs(q)\\n\\t\\troot\\n\\t}\\n\\tdfs(Queue[String]().enqueueAll(data.split(\",\")))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 945096,
                "title": "c-easy-bfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //use level order traversal as its easy and iterative compared to preorder\\n    //store level order traversal/BFS of tree and put special marker \\'NULL\\' for NULL and \\',\\' for separation\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string serializedOP=\"\";\\n        \\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        \\n        while(!bfs.empty())\\n        {\\n            TreeNode* temp = bfs.front();\\n            bfs.pop();\\n            if(temp == NULL)\\n            {\\n                serializedOP+=\"NULL,\";\\n            }\\n            else\\n            {\\n                serializedOP+=to_string(temp->val)+\",\";\\n                \\n                bfs.push(temp->left);\\n                bfs.push(temp->right);\\n            }\\n            \\n        }\\n        //cout<<serializedOP<<endl;\\n        return serializedOP;\\n    }\\n\\n    \\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty())\\n            return NULL;\\n        stringstream stream(data);\\n        string nodeVal;\\n        //each getline will give new nodeVal\\n        std::getline(stream,nodeVal,\\',\\');\\n        \\n        //if first is NULL then tree is empty\\n        if(nodeVal == \"NULL\")\\n            return NULL;\\n        \\n        //create root\\n        TreeNode* root = new TreeNode(stoi(nodeVal));\\n        queue<TreeNode*> bfs; \\n        bfs.push(root);\\n        \\n        \\n        while(!bfs.empty())\\n        {\\n            //take out first node\\n            TreeNode* temp = bfs.front();\\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->left = NULL;\\n            }\\n            else\\n            {\\n                temp->left = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->left);\\n            }\\n            \\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->right = NULL;\\n            }\\n            else\\n            {\\n                temp->right = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->right);\\n            }\\n            \\n            bfs.pop();\\n        }\\n        \\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser, deser;\\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //use level order traversal as its easy and iterative compared to preorder\\n    //store level order traversal/BFS of tree and put special marker \\'NULL\\' for NULL and \\',\\' for separation\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string serializedOP=\"\";\\n        \\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        \\n        while(!bfs.empty())\\n        {\\n            TreeNode* temp = bfs.front();\\n            bfs.pop();\\n            if(temp == NULL)\\n            {\\n                serializedOP+=\"NULL,\";\\n            }\\n            else\\n            {\\n                serializedOP+=to_string(temp->val)+\",\";\\n                \\n                bfs.push(temp->left);\\n                bfs.push(temp->right);\\n            }\\n            \\n        }\\n        //cout<<serializedOP<<endl;\\n        return serializedOP;\\n    }\\n\\n    \\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty())\\n            return NULL;\\n        stringstream stream(data);\\n        string nodeVal;\\n        //each getline will give new nodeVal\\n        std::getline(stream,nodeVal,\\',\\');\\n        \\n        //if first is NULL then tree is empty\\n        if(nodeVal == \"NULL\")\\n            return NULL;\\n        \\n        //create root\\n        TreeNode* root = new TreeNode(stoi(nodeVal));\\n        queue<TreeNode*> bfs; \\n        bfs.push(root);\\n        \\n        \\n        while(!bfs.empty())\\n        {\\n            //take out first node\\n            TreeNode* temp = bfs.front();\\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->left = NULL;\\n            }\\n            else\\n            {\\n                temp->left = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->left);\\n            }\\n            \\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->right = NULL;\\n            }\\n            else\\n            {\\n                temp->right = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->right);\\n            }\\n            \\n            bfs.pop();\\n        }\\n        \\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser, deser;\\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1564831,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1567263,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569114,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569848,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1568221,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1573178,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1574305,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1929806,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1820888,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1816458,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1564831,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1567263,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569114,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569848,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1568221,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1573178,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1574305,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1929806,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1820888,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1816458,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            }
        ]
    },
    {
        "title": "Delete Node in a BST",
        "question_content": "<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>\n\n<p>Basically, the deletion can be divided into two stages:</p>\n\n<ol>\n\t<li>Search for a node to remove.</li>\n\t<li>If the node is found, delete the node.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg\" style=\"width: 800px; height: 214px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 3\n<strong>Output:</strong> [5,4,6,2,null,null,7]\n<strong>Explanation:</strong> Given key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is [5,4,6,2,null,null,7], shown in the above BST.\nPlease notice that another valid answer is [5,2,6,null,4,null,7] and it&#39;s also accepted.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg\" style=\"width: 350px; height: 255px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 0\n<strong>Output:</strong> [5,3,6,2,4,null,7]\n<strong>Explanation:</strong> The tree does not contain a node with value = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], key = 0\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>Each node has a <strong>unique</strong> value.</li>\n\t<li><code>root</code> is a valid binary search tree.</li>\n\t<li><code>-10<sup>5</sup> &lt;= key &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it with time complexity <code>O(height of tree)</code>?</p>\n",
        "solutions": [
            {
                "id": 93296,
                "title": "recursive-easy-to-understand-java-solution",
                "content": "Steps:\\n1. Recursively find the node that has the same value as the key, while setting the left/right nodes equal to the returned subtree\\n2. Once the node is found, have to handle the below 4 cases\\n* node doesn't have left or right - return null\\n* node only has left subtree- return the left subtree\\n* node only has right subtree- return the right subtree\\n* node has both left and right - find the minimum value in the right subtree, set that value to the currently found node, then recursively delete the minimum value in the right subtree\\n\\n```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n    if(root == null){\\n        return null;\\n    }\\n    if(key < root.val){\\n        root.left = deleteNode(root.left, key);\\n    }else if(key > root.val){\\n        root.right = deleteNode(root.right, key);\\n    }else{\\n        if(root.left == null){\\n            return root.right;\\n        }else if(root.right == null){\\n            return root.left;\\n        }\\n        \\n        TreeNode minNode = findMin(root.right);\\n        root.val = minNode.val;\\n        root.right = deleteNode(root.right, root.val);\\n    }\\n    return root;\\n}\\n\\nprivate TreeNode findMin(TreeNode node){\\n    while(node.left != null){\\n        node = node.left;\\n    }\\n    return node;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n    if(root == null){\\n        return null;\\n    }\\n    if(key < root.val){\\n        root.left = deleteNode(root.left, key);\\n    }else if(key > root.val){\\n        root.right = deleteNode(root.right, key);\\n    }else{\\n        if(root.left == null){\\n            return root.right;\\n        }else if(root.right == null){\\n            return root.left;\\n        }\\n        \\n        TreeNode minNode = findMin(root.right);\\n        root.val = minNode.val;\\n        root.right = deleteNode(root.right, root.val);\\n    }\\n    return root;\\n}\\n\\nprivate TreeNode findMin(TreeNode node){\\n    while(node.left != null){\\n        node = node.left;\\n    }\\n    return node;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590789,
                "title": "c-shortest-recursive-solution-detailed-explanation-with-images",
                "content": "**Firstly, thanks for refering to my solution in advance :)**\\n**Please UPVOTE\\uD83D\\uDD3C if you like it :)**\\n\\nWhen we delete a node from a Binary Search Tree(BST), the BST properties should remain the same. \\nHence, we have 3 cases for deleting a node from a BST :\\n1.    ***The node is a leaf node*** - In this cases, we can just delete the node and return the root, since deleting any elaf node doesn\\'t affect the remainig tree.\\n![image](https://assets.leetcode.com/users/images/e3c9bd80-7b8d-40c5-9d44-2eec84772544_1637543079.1645782.png)\\n\\n2.   ***The node has one child*** - In this case, replace the node with the child node and return the root.\\n![image](https://assets.leetcode.com/users/images/82448a74-6e63-4981-bd93-68915b47536d_1637542697.778318.png)\\n\\n3.   ***The node has 2 children*** - In this case, in order to conserve the BST properties, we need to replace the node with it\\'s inorder successor (The next node that comes in the inorder traversal) i.e; we need to replace it with either :\\n                                 1. The greatest value node in it\\'s left subtree (or)\\n                                 2. The smallest value node in it\\'s right subtree\\nand return the root.\\n![image](https://assets.leetcode.com/users/images/03774f6e-5bf0-4805-8fc0-b810b636386e_1637542708.968784.png)\\n\\n\\n**Time Complexity :** O(h) - h = height of the tree.\\n(Worst case Time Complexity : O(n) )\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root) \\n            if(key < root->val) root->left = deleteNode(root->left, key);     //We frecursively call the function until we find the target node\\n            else if(key > root->val) root->right = deleteNode(root->right, key);       \\n            else{\\n                if(!root->left && !root->right) return NULL;          //No child condition\\n                if (!root->left || !root->right)\\n                    return root->left ? root->left : root->right;    //One child contion -> replace the node with it\\'s child\\n\\t\\t\\t\\t\\t                                                //Two child condition   \\n                TreeNode* temp = root->left;                        //(or) TreeNode *temp = root->right;\\n                while(temp->right != NULL) temp = temp->right;     //      while(temp->left != NULL) temp = temp->left;\\n                root->val = temp->val;                            //       root->val = temp->val;\\n                root->left = deleteNode(root->left, temp->val);  //        root->right = deleteNode(root->right, temp);\\t\\t\\n            }\\n        return root;\\n    }   \\n};\\n```\\n\\nIf you like my solution and explanation, **please UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root) \\n            if(key < root->val) root->left = deleteNode(root->left, key);     //We frecursively call the function until we find the target node\\n            else if(key > root->val) root->right = deleteNode(root->right, key);       \\n            else{\\n                if(!root->left && !root->right) return NULL;          //No child condition\\n                if (!root->left || !root->right)\\n                    return root->left ? root->left : root->right;    //One child contion -> replace the node with it\\'s child\\n\\t\\t\\t\\t\\t                                                //Two child condition   \\n                TreeNode* temp = root->left;                        //(or) TreeNode *temp = root->right;\\n                while(temp->right != NULL) temp = temp->right;     //      while(temp->left != NULL) temp = temp->left;\\n                root->val = temp->val;                            //       root->val = temp->val;\\n                root->left = deleteNode(root->left, temp->val);  //        root->right = deleteNode(root->right, temp);\\t\\t\\n            }\\n        return root;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821420,
                "title": "python-o-h-solution-explained",
                "content": "It will be easier if we consider some tree and try to understand, what we need to do in different cases.\\n\\n![image](https://assets.leetcode.com/users/images/cf035fc0-0e9e-4760-b2d4-a0d528d86b59_1598862784.8900957.png)\\n\\n0. First we need to find our node in tree, so we just traverse it until `root.val == key`.\\n1. Case 1: node do not have any children, like `1`, `8`, `11`, `14`, `6` or `18`: then we just delete it and nothing else to do here.\\n2. Case 2: node has left children, but do not have right, for example `3` or `20`. In this case we can just delete this node and put connection betweeen its parent and its children: for example for `3`, we put connection `5->1` and for `20` we put connection `17->18`. Note, that the property of BST will be fulfilled, because for parent all left subtree will be less than its value and nothing will change for others nodes.\\n3. Case 3: node has right children, but do not have left, for example `13` and `17`. This case is almost like case `2`: we just can delete node and reconnect its parent with its children.\\n4. Case 4: node has both children, like `12`, `5`, `7`, `9` or `15`. In this case we can not just delete it. Let us consider node `5`. We want to find succesor of this node: the node with next value, to do this we need to go one time to the right and then as left as possible. For node `5` our succesor will be `6`: we go `5->7->6`. How we can delete node `5` now? We swap nodes `5` and `6` (or just put value `6` to `5`) and then we need to deal with new tree, where we need to delete node which I put in square. How to do it? Just understand, that this node do not have left children, so it is either Case 1 or Case 3, which we already can solve.\\n\\n![image](https://assets.leetcode.com/users/images/f1136eab-e4bf-4108-a342-20d846903203_1598863026.615254.png)\\n\\n\\n**Complexity**: Complexity of finding node is `O(h)`, Cases 1,2,3 is `O(1)`. Complexity of Case `4` is `O(h)` as well, because we first find succesor and then apply one of the Cases 1,3 only once. So, overall complexity is `O(h)`. Space complexity is `O(h)` as well, because we use recursion and potentially we can find our node in the bottom of tree.\\n\\n```\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        if not root: return None\\n        \\n        if root.val == key:\\n            if not root.right: return root.left\\n            \\n            if not root.left: return root.right\\n            \\n            if root.left and root.right:\\n                temp = root.right\\n                while temp.left: temp = temp.left\\n                root.val = temp.val\\n                root.right = self.deleteNode(root.right, root.val)\\n\\n        elif root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n            \\n        return root\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        if not root: return None\\n        \\n        if root.val == key:\\n            if not root.right: return root.left\\n            \\n            if not root.left: return root.right\\n            \\n            if root.left and root.right:\\n                temp = root.right\\n                while temp.left: temp = temp.left\\n                root.val = temp.val\\n                root.right = self.deleteNode(root.right, root.val)\\n\\n        elif root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93298,
                "title": "iterative-solution-in-java-o-h-time-and-o-1-space",
                "content": "```\\n    private TreeNode deleteRootNode(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root.left == null) {\\n            return root.right;\\n        }\\n        if (root.right == null) {\\n            return root.left;\\n        }\\n        TreeNode next = root.right;\\n        TreeNode pre = null;\\n        for(; next.left != null; pre = next, next = next.left);\\n        next.left = root.left;\\n        if(root.right != next) {\\n            pre.left = next.right;\\n            next.right = root.right;\\n        }\\n        return next;\\n    }\\n    \\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        TreeNode cur = root;\\n        TreeNode pre = null;\\n        while(cur != null && cur.val != key) {\\n            pre = cur;\\n            if (key < cur.val) {\\n                cur = cur.left;\\n            } else if (key > cur.val) {\\n                cur = cur.right;\\n            }\\n        }\\n        if (pre == null) {\\n            return deleteRootNode(cur);\\n        }\\n        if (pre.left == cur) {\\n            pre.left = deleteRootNode(cur);\\n        } else {\\n            pre.right = deleteRootNode(cur);\\n        }\\n        return root;\\n    }\\n```\\nFind the node to be removed and its parent using binary search, and then use deleteRootNode to delete the root node of the subtree and return the new root node. This idea is taken from https://discuss.leetcode.com/topic/67309/an-easy-understanding-o-h-time-o-1-space-java-solution.\\n\\nI'd also like to share my thinkings of the other solutions I've seen. \\n1. There are many solutions that got high votes using recursive approach,  including the ones from the Princeton's Algorithm and Data Structure book. Don't you notice that recursive approach always takes extra space? Why not consider the iterative approach first?\\n2. Some solutions swap the values instead of swapping the nodes. In reality, the value of a node could be more complicated than just a single integer, so copying the contents might take much more time than just copying the reference. \\n3. As for the case when both children of the node to be deleted are not null, I transplant the successor to replace the node to be deleted, which is a bit harder to implement than just transplant the left subtree of the node to the left child of its successor.  The former way is used in many text books too. Why? My guess is that transplanting the successor can keep the height of the tree almost unchanged, while transplanting the whole left subtree could increase the height and thus making the tree more unbalanced.",
                "solutionTags": [],
                "code": "```\\n    private TreeNode deleteRootNode(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root.left == null) {\\n            return root.right;\\n        }\\n        if (root.right == null) {\\n            return root.left;\\n        }\\n        TreeNode next = root.right;\\n        TreeNode pre = null;\\n        for(; next.left != null; pre = next, next = next.left);\\n        next.left = root.left;\\n        if(root.right != next) {\\n            pre.left = next.right;\\n            next.right = root.right;\\n        }\\n        return next;\\n    }\\n    \\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        TreeNode cur = root;\\n        TreeNode pre = null;\\n        while(cur != null && cur.val != key) {\\n            pre = cur;\\n            if (key < cur.val) {\\n                cur = cur.left;\\n            } else if (key > cur.val) {\\n                cur = cur.right;\\n            }\\n        }\\n        if (pre == null) {\\n            return deleteRootNode(cur);\\n        }\\n        if (pre.left == cur) {\\n            pre.left = deleteRootNode(cur);\\n        } else {\\n            pre.right = deleteRootNode(cur);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93374,
                "title": "simple-python-solution-with-explanation",
                "content": "```\\n   def deleteNode(root, key):\\n\\tif not root: # if root doesn't exist, just return it\\n\\t\\treturn root\\n\\tif root.val > key: # if key value is less than root value, find the node in the left subtree\\n\\t\\troot.left = deleteNode(root.left, key)\\n\\telif root.val < key: # if key value is greater than root value, find the node in right subtree\\n\\t\\troot.right= deleteNode(root.right, key)\\n\\telse: #if we found the node (root.value == key), start to delete it\\n\\t\\tif not root.right: # if it doesn't have right children, we delete the node then new root would be root.left\\n\\t\\t\\treturn root.left\\n\\t\\tif not root.left: # if it has no left children, we delete the node then new root would be root.right\\n\\t\\t\\treturn root.right\\n               # if the node have both left and right children,  we replace its value with the minmimum value in the right subtree and then delete that minimum node in the right subtree\\n\\t\\ttemp = root.right\\n\\t\\tmini = temp.val\\n\\t\\twhile temp.left:\\n\\t\\t\\ttemp = temp.left\\n\\t\\t\\tmini = temp.val\\n\\t\\troot.val = mini # replace value\\n\\t\\troot.right = deleteNode(root.right,root.val) # delete the minimum node in right subtree\\n\\treturn root\\n\\n```",
                "solutionTags": [],
                "code": "```\\n   def deleteNode(root, key):\\n\\tif not root: # if root doesn't exist, just return it\\n\\t\\treturn root\\n\\tif root.val > key: # if key value is less than root value, find the node in the left subtree\\n\\t\\troot.left = deleteNode(root.left, key)\\n\\telif root.val < key: # if key value is greater than root value, find the node in right subtree\\n\\t\\troot.right= deleteNode(root.right, key)\\n\\telse: #if we found the node (root.value == key), start to delete it\\n\\t\\tif not root.right: # if it doesn't have right children, we delete the node then new root would be root.left\\n\\t\\t\\treturn root.left\\n\\t\\tif not root.left: # if it has no left children, we delete the node then new root would be root.right\\n\\t\\t\\treturn root.right\\n               # if the node have both left and right children,  we replace its value with the minmimum value in the right subtree and then delete that minimum node in the right subtree\\n\\t\\ttemp = root.right\\n\\t\\tmini = temp.val\\n\\t\\twhile temp.left:\\n\\t\\t\\ttemp = temp.left\\n\\t\\t\\tmini = temp.val\\n\\t\\troot.val = mini # replace value\\n\\t\\troot.right = deleteNode(root.right,root.val) # delete the minimum node in right subtree\\n\\treturn root\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 93293,
                "title": "very-concise-c-solution-for-general-binary-tree-not-only-bst",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return nullptr;\\n        if (root->val == key) {\\n            if (!root->right) {\\n                TreeNode* left = root->left;\\n                delete root;\\n                return left;\\n            }\\n            else {\\n                TreeNode* right = root->right;\\n                while (right->left)\\n                    right = right->left;\\n                swap(root->val, right->val);    \\n            }\\n        }\\n        root->left = deleteNode(root->left, key);\\n        root->right = deleteNode(root->right, key);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return nullptr;\\n        if (root->val == key) {\\n            if (!root->right) {\\n                TreeNode* left = root->left;\\n                delete root;\\n                return left;\\n            }\\n            else {\\n                TreeNode* right = root->right;\\n                while (right->left)\\n                    right = right->left;\\n                swap(root->val, right->val);    \\n            }\\n        }\\n        root->left = deleteNode(root->left, key);\\n        root->right = deleteNode(root->right, key);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591176,
                "title": "c-simple-solution-w-images-detailed-explanation-iterative-recursive-approach",
                "content": "We are given a BST with unique nodes and a `key` denoting value of node that must be deleted if it exists in the BST\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Iterative)***\\n\\nFirstly, we need to search for the `key` valued node in the BST. If it doesn\\'t exist, we can directly return the BST as it is.\\n\\nIf the node is found in BST, we need to delete it. But depending on where the node occurs, we need to employ different ways to delete it. So, it\\'s helpful to think about the various cases that may occur and see how we can deal with them separately. Let\\'s see the different cases possible (the node to be deleted will be referred as target node **`T`** below) -\\n\\n\\n\\n\\n<table>\\n<tr>\\n<th><p align=middle><b>Cases</b></p></th>\\n<th><p align=middle><b>Description</b></p></th>\\n</tr>\\n<tr></tr>\\n<tr>\\n\\n<td>\\n<img src=\"https://assets.leetcode.com/users/images/174063e0-4cdc-4266-86ec-b88ae57543bf_1637560166.1094403.png\" width = 550 />\\n</td>\\n<td><code>T</code> not found in BST after the search.</br> We can directly return root of BST as it is</td>\\n</tr>\\n<tr></tr>\\n<tr>\\n\\n<td>\\n<img src=\"https://assets.leetcode.com/users/images/d7efdff3-06d5-4d37-a97e-5e7b937fcc2c_1637560263.5852876.png\" width = 650 />\\n</td>\\n<td><code>T</code> found in the BST.</br> It has no children which means it is a leaf node.</br> So, we can delete it just by updating <code>T</code>\\'s parent pointer to null and then deleting <code>T</code></br></br>In example, we simply updated right pointer of <code>5</code>\\'s parent node-<code>4</code> as null</td>\\n</tr>\\n<tr></tr>\\n<tr>\\n\\n<td>\\n<img src=\"https://assets.leetcode.com/users/images/da114471-6214-40f6-a5d8-33ba8c19b156_1637560360.1852875.png\" width = 650  />\\n</td>\\n<td><code>T</code> found in BST and only has the right child/subtree</br>Cant directly delete <code>T</code> as it has its right child that must remain in the BST</br>we <b>update child pointer of parent of <code>T</code> to the right child of <code>T</code></b></br></br>In example, we updated left child pointer of <code>12</code> to point at <code>11</code> which is right child of the node to be deleted-<code>10</code></td>\\n</tr>\\n<tr></tr>\\n<tr>\\n\\n<td>\\n<img src=\"https://assets.leetcode.com/users/images/9da9df3e-7090-402e-a4e4-85c9cb7d60e5_1637560434.0931609.png\" width = 650  />\\n</td>\\n<td><code>T</code> found in BST and only has the left child/subtree. This is similar to previous case</br>Cant directly delete <code>T</code> bcoz we need to take care of its left child</br>We <b>update child pointer of parent of <code>T</code> to the left child of <code>T</code></b></br></br>In example, we updated left child pointer of <code>8</code> to point at <code>4</code> which is left child of node to be deleted-<code>6</code></td>\\n</tr>\\n<tr></tr>\\n<tr>\\n\\n<td>\\n<img src=\"https://assets.leetcode.com/users/images/887aa465-967f-448f-82e3-fb09b757f883_1637560507.9911222.png\" width = 650  />\\n</td>\\n<td><code>T</code> found in BST and has both left and right child/subtree</br>In this case, to maintain BST property, we have two choices - </br>\\n<ol>\\n  <li>Replace <code>T</code> by largest node in left subtree</li>\\n  <li>Replace <code>T</code> by smallest node in right subtree</li>\\n</ol>\\nLet\\'s choose 2nd option. </br>We find smallest node in right subtree by <b>going right once and then as left as possible</b></br>It is then replaced with node to be deleted. But again, we need to take care of its right child</br>For this, we <b>update child pointer of parent of the <code>smallest node</code> to the right child of <code>smallest node</code></b></br></br>In image example, we update left child pointer of <code>12</code> point to <code>11</code> which is child node of smallest node-<code>10</code>\\n</td>\\n</tr>\\n<tr></tr>\\n</table>\\n\\nLet\\'s put the above logic into code -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        TreeNode* iter = root, *par = nullptr;\\n\\t\\t// search for key node & keep a pointer to current node\\'s parent\\n        while(iter && iter -> val != key) {                              \\n            par = iter;\\n            if(iter -> val < key) iter = iter -> right;\\n            else iter = iter -> left;\\n        }\\n        if(!iter) return root;                                           // node not found  => Case:1\\n        // iter is the node to be deleted\\n        \\n        // node found with less than two children  => Case-2/3/4 combined\\n        if(!iter -> left or !iter -> right) {\\n            auto child = iter -> left ? iter -> left : iter -> right;    // find child node of iter if it exists\\n            if(!par) root = child;                                       // iter is root node. Update root as child of iter\\n            else if(par -> left == iter) par -> left = child;            // iter is left child. Update its parent\\'s left pointer as iter\\'s child\\n            else par -> right = child;                                   // Else update parent\\'s right pointer as iter\\'s child\\n        }\\n        // node found with both children => Case-5\\n        else {\\n            auto cur = iter;                                              // cur maintains a reference to the node to be deleted\\n            par = iter, iter = iter -> right;                             // go to right subtree \\n            while(iter -> left) par = iter, iter = iter -> left;          // and find smallest node in that right subtree\\n            cur -> val = iter -> val;                                     // delete by replacing with smallest node found\\n\\t\\t\\t// smallest node replaced from right subtree may have a right child. \\n\\t\\t\\t// So update that node\\'s parent to hold the right child\\n            if(par -> left == iter) par -> left = iter -> right;          \\n            else par -> right = iter -> right;\\n        }\\n\\t\\t// dont show the interviewer that you are a leaker :)\\n        delete iter;        // free the memory\\t\\t\\n        return root;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><i>Clean code (without Comments)</i></summary>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        TreeNode* iter = root, *par = nullptr;\\n        while(iter && iter -> val != key) {                              \\n            par = iter;\\n            iter = iter -> val < key ? iter -> right : iter -> left;\\n        }\\n        if(!iter) return root;\\n        if(!iter -> left or !iter -> right) {\\n            auto child = iter -> left ? iter -> left : iter -> right;\\n            if(!par) root = child;\\n            else if(par -> left == iter) par -> left = child;\\n            else par -> right = child;\\n        }\\n        else {\\n            auto cur = iter;                                              \\n            par = iter, iter = iter -> right;                             \\n            while(iter -> left) par = iter, iter = iter -> left;          \\n            cur -> val = iter -> val;                                     \\n            if(par -> left == iter) par -> left = iter -> right;          \\n            else par -> right = iter -> right;\\n        }\\n        delete iter;\\t\\t\\n        return root;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n\\n***Time Complexity :*** `O(H)`, where `H` is the height of BST. It can be `O(logN)` in case of complete BST or `O(N)` in case of skewed BST, where `N` is the number of nodes in BST. We search a node in `O(H)` time. After that deleting the node is `O(1)` for cases 2/3/4. For case-5, we need to traverse down the right subtree which takes `O(H)` in worst case. Thus, overall time is `O(H)`.\\n***Space Complexity :*** `O(1)`, only constant extra space is used.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive)***\\n\\nThe above logic can also be implemented recursively. For me, I found the iterative version more intuitive which is why I mentioned it first above. But for anyone looking for recursive implementation of it, here goes -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n\\t\\t// search for key node\\n        if(root -> val < key) root -> right = deleteNode(root -> right, key);\\n        else if(root -> val > key) root -> left = deleteNode(root -> left, key);\\n        else { // root -> val == key\\n            auto toDelete = root;\\n            if(!root -> left || !root -> right) \\n                root = root -> left ? root -> left : root -> right;\\n            else {\\n\\t\\t\\t\\tauto cur = root, par = root;\\n                root = root -> right;\\n                while(root -> left) par = root, root = root -> left;  // finding smallest in right subtree\\n                cur -> val = root -> val;                             // replace node to be deleted- cur with value of smallest node found\\n\\t\\t\\t\\t// take care of child node...same as above\\n                if(par -> left == root) par -> left = root -> right;\\n                else par -> right = root -> right;\\n\\t\\t\\t\\ttoDelete = root;\\n                root = cur;\\n            }\\n            delete toDelete;            \\t\\t\\t\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><i>Slightly Different Implementation</i></summary>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n        if(root -> val < key) root -> right = deleteNode(root -> right, key);\\n        else if(root -> val > key) root -> left = deleteNode(root -> left, key);\\n        else \\n            if(!root -> left || !root -> right) \\n                root = root -> left ? root -> left : root -> right;\\n            else {\\n\\t\\t\\t\\tauto tmp = root -> right;\\n                while(tmp -> left) tmp = tmp -> left;\\n                root -> val = tmp -> val;                      \\n                root -> right = deleteNode(root -> right, root -> val); // recurse to delete replaced node\\n            }      \\n        return root;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n\\n***Time Complexity :*** `O(H)`, where `H` is the height of BST. It can be `O(logN)` in case of complete BST or `O(N)` in case of skewed BST, where `N` is the number of nodes in BST.\\n***Space Complexity :*** `O(H)`, for recursive stack\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        TreeNode* iter = root, *par = nullptr;\\n\\t\\t// search for key node & keep a pointer to current node\\'s parent\\n        while(iter && iter -> val != key) {                              \\n            par = iter;\\n            if(iter -> val < key) iter = iter -> right;\\n            else iter = iter -> left;\\n        }\\n        if(!iter) return root;                                           // node not found  => Case:1\\n        // iter is the node to be deleted\\n        \\n        // node found with less than two children  => Case-2/3/4 combined\\n        if(!iter -> left or !iter -> right) {\\n            auto child = iter -> left ? iter -> left : iter -> right;    // find child node of iter if it exists\\n            if(!par) root = child;                                       // iter is root node. Update root as child of iter\\n            else if(par -> left == iter) par -> left = child;            // iter is left child. Update its parent\\'s left pointer as iter\\'s child\\n            else par -> right = child;                                   // Else update parent\\'s right pointer as iter\\'s child\\n        }\\n        // node found with both children => Case-5\\n        else {\\n            auto cur = iter;                                              // cur maintains a reference to the node to be deleted\\n            par = iter, iter = iter -> right;                             // go to right subtree \\n            while(iter -> left) par = iter, iter = iter -> left;          // and find smallest node in that right subtree\\n            cur -> val = iter -> val;                                     // delete by replacing with smallest node found\\n\\t\\t\\t// smallest node replaced from right subtree may have a right child. \\n\\t\\t\\t// So update that node\\'s parent to hold the right child\\n            if(par -> left == iter) par -> left = iter -> right;          \\n            else par -> right = iter -> right;\\n        }\\n\\t\\t// dont show the interviewer that you are a leaker :)\\n        delete iter;        // free the memory\\t\\t\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        TreeNode* iter = root, *par = nullptr;\\n        while(iter && iter -> val != key) {                              \\n            par = iter;\\n            iter = iter -> val < key ? iter -> right : iter -> left;\\n        }\\n        if(!iter) return root;\\n        if(!iter -> left or !iter -> right) {\\n            auto child = iter -> left ? iter -> left : iter -> right;\\n            if(!par) root = child;\\n            else if(par -> left == iter) par -> left = child;\\n            else par -> right = child;\\n        }\\n        else {\\n            auto cur = iter;                                              \\n            par = iter, iter = iter -> right;                             \\n            while(iter -> left) par = iter, iter = iter -> left;          \\n            cur -> val = iter -> val;                                     \\n            if(par -> left == iter) par -> left = iter -> right;          \\n            else par -> right = iter -> right;\\n        }\\n        delete iter;\\t\\t\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n\\t\\t// search for key node\\n        if(root -> val < key) root -> right = deleteNode(root -> right, key);\\n        else if(root -> val > key) root -> left = deleteNode(root -> left, key);\\n        else { // root -> val == key\\n            auto toDelete = root;\\n            if(!root -> left || !root -> right) \\n                root = root -> left ? root -> left : root -> right;\\n            else {\\n\\t\\t\\t\\tauto cur = root, par = root;\\n                root = root -> right;\\n                while(root -> left) par = root, root = root -> left;  // finding smallest in right subtree\\n                cur -> val = root -> val;                             // replace node to be deleted- cur with value of smallest node found\\n\\t\\t\\t\\t// take care of child node...same as above\\n                if(par -> left == root) par -> left = root -> right;\\n                else par -> right = root -> right;\\n\\t\\t\\t\\ttoDelete = root;\\n                root = cur;\\n            }\\n            delete toDelete;            \\t\\t\\t\\n        }\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n        if(root -> val < key) root -> right = deleteNode(root -> right, key);\\n        else if(root -> val > key) root -> left = deleteNode(root -> left, key);\\n        else \\n            if(!root -> left || !root -> right) \\n                root = root -> left ? root -> left : root -> right;\\n            else {\\n\\t\\t\\t\\tauto tmp = root -> right;\\n                while(tmp -> left) tmp = tmp -> left;\\n                root -> val = tmp -> val;                      \\n                root -> right = deleteNode(root -> right, root -> val); // recurse to delete replaced node\\n            }      \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213685,
                "title": "clean-python-3-with-comments-in-details",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return\\n        \\n        # we always want to delete the node when it is the root of a subtree,\\n        # so we handle left or right according to the val.\\n        # if the node does not exist, we will hit the very first if statement and return None.\\n        if key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n            \\n        elif key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        \\n        # now the key is the root of a subtree\\n        else:\\n            # if the subtree does not have a left child, we just return its right child\\n            # to its father, and they will be connected on the higher level recursion.\\n            if not root.left:\\n                return root.right\\n            \\n            # if it has a left child, we want to find the max val on the left subtree to \\n            # replace the node we want to delete.\\n            else:\\n                # try to find the max value on the left subtree\\n                tmp = root.left\\n                while tmp.right:\\n                    tmp = tmp.right\\n                    \\n                # replace\\n                root.val = tmp.val\\n                \\n                # since we have replaced the node we want to delete with the tmp, now we don\\'t\\n                # want to keep the tmp on this tree, so we just use our function to delete it.\\n                # pass the val of tmp to the left subtree and repeat the whole approach.\\n                root.left = self.deleteNode(root.left, tmp.val)\\n        \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return\\n        \\n        # we always want to delete the node when it is the root of a subtree,\\n        # so we handle left or right according to the val.\\n        # if the node does not exist, we will hit the very first if statement and return None.\\n        if key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n            \\n        elif key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        \\n        # now the key is the root of a subtree\\n        else:\\n            # if the subtree does not have a left child, we just return its right child\\n            # to its father, and they will be connected on the higher level recursion.\\n            if not root.left:\\n                return root.right\\n            \\n            # if it has a left child, we want to find the max val on the left subtree to \\n            # replace the node we want to delete.\\n            else:\\n                # try to find the max value on the left subtree\\n                tmp = root.left\\n                while tmp.right:\\n                    tmp = tmp.right\\n                    \\n                # replace\\n                root.val = tmp.val\\n                \\n                # since we have replaced the node we want to delete with the tmp, now we don\\'t\\n                # want to keep the tmp on this tree, so we just use our function to delete it.\\n                # pass the val of tmp to the left subtree and repeat the whole approach.\\n                root.left = self.deleteNode(root.left, tmp.val)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590868,
                "title": "java-recursive-most-intutive-proper-explanation-using-image",
                "content": "**Intution:** Use the BST property to search the node and then delete if found the required node.\\n\\n* So if the traget node has value less than root then we will surely get it in the left subtree...so just call ur recursive function for the left subtree.\\n* If the traget node has value greater than root then we will surely get it in the right subtree...so just call ur recursive function for the right subtree.\\n* And now comes the case when u have to do your work that is root itself is the required node to be deleted. Here again comes three cases:\\n\\t1. \\tIf left of root is null and u also have to delete the root node...then just simply return the right subtree.\\n\\t2. \\tIf right of root is null and u also have to delete the root node...then just simply return the left subtree.\\n\\t3. \\tBoth are not null then you have to not just delete the node but also maintain the BST structure.\\nSo now you have to think if you delete the root node then which node can optimally replace it so that all the nodes on left are still small and on right are larger.\\n**So that node will be the node just greater than the largest node in the left subtree which is the smallest node in the right subtree**\\n![image](https://assets.leetcode.com/users/images/e876a47d-fe1f-46db-97c4-fbf2b3d9567b_1637549476.0494304.jpeg)\\n\\n\\t\\t* So point your pointer on the right subtree and then move it to the left most node of this subtree that will be your required node and so now replace the value of your root with this node value which will ensure that the key which u wanted to delete is deleted and the value there is  the right value.\\n\\t\\t* Now you have to delete that node whose value is already present in the root...so now that work will be done by the recursion so now just pass that right subtree in which the value is present with that nodes value which will be now the target\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        \\n        if(key<root.val){                            \\n            root.left = deleteNode(root.left,key);\\n            return root;\\n        }\\n        \\n        else if(key>root.val){\\n            root.right = deleteNode(root.right,key);\\n            return root;\\n        }\\n        \\n        else{\\n            if(root.left==null){\\n                return root.right;\\n            }\\n            else if(root.right==null){\\n                return root.left;\\n            }\\n            else{\\n                TreeNode min = root.right;\\n                while(min.left!=null){\\n                    min = min.left;\\n                }\\n                \\n                root.val = min.val;\\n                root.right = deleteNode(root.right,min.val);\\n                return root;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        \\n        if(key<root.val){                            \\n            root.left = deleteNode(root.left,key);\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 93328,
                "title": "java-easy-to-understand-solution",
                "content": "```\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return root;\\n        if (root.val > key) root.left = deleteNode(root.left, key);\\n        else if (root.val < key) root.right = deleteNode(root.right, key);\\n        else { // found node to be deleted\\n            if (root.left == null) return root.right;\\n            else if (root.right == null) return root.left;\\n            // node with two children, replace with the inOrder successor(minVal) in the right subtree\\n            root.val = getMin(root.right);\\n            root.right = deleteNode(root.right, root.val);\\n        }\\n        return root;\\n    }\\n    private int getMin(TreeNode root) {\\n        while (root.left != null) {root = root.left;}\\n        return root.val;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return root;\\n        if (root.val > key) root.left = deleteNode(root.left, key);\\n        else if (root.val < key) root.right = deleteNode(root.right, key);\\n        else { // found node to be deleted\\n            if (root.left == null) return root.right;\\n            else if (root.right == null) return root.left;\\n            // node with two children, replace with the inOrder successor(minVal) in the right subtree\\n            root.val = getMin(root.right);\\n            root.right = deleteNode(root.right, root.val);\\n        }\\n        return root;\\n    }\\n    private int getMin(TreeNode root) {\\n        while (root.left != null) {root = root.left;}\\n        return root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152449,
                "title": "c-easiest-solution-with-recursive-beats-98-88",
                "content": "Idea: - Keep traversing a BST in usual way until found the val you are searching for. \\nCase 1 - the node found with key is the leaf node. \\nCase 2 - the node found with key has only 1 child. \\nCase 3 - the node found has both childs - tricky case. \\nIn case 3 find the smallest (hence leftmost) node in the right subtree of the found node and copy the value in the node found with key. \\nthen again delete that smallest node from the rightsubtree. (this time during deletion of this smallest node will have only 1 child or 0 child). \\nFor reference can watch below video till 9:00 mark and then code yourself. \\nhttps://www.youtube.com/watch?v=gcULXE7ViZw&vl=en\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int val) {\\n        if (!root) return root;\\n        \\n        if (val < root->val) {\\n            root->left = deleteNode(root->left, val);\\n        } else if (val > root->val) {\\n            root->right = deleteNode(root->right, val);\\n        } else {\\n            /* Leaf node case */\\n            if (!root->left && !root->right) {\\n                delete(root);\\n                return NULL;\\n            }\\n            /* 1 child case */\\n            if (!root->left || !root->right) {\\n                TreeNode *ret = root->left ? root->left : root->right;\\n                delete(root);\\n                return ret;\\n            }\\n            /* 2 child case */\\n            if (root->left && root->right) {\\n                TreeNode *tmp = root->right;\\n                while (tmp->left) {\\n                    tmp = tmp->left;\\n                }\\n                root->val = tmp->val;\\n                root->right = deleteNode(root->right, root->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int val) {\\n        if (!root) return root;\\n        \\n        if (val < root->val) {\\n            root->left = deleteNode(root->left, val);\\n        } else if (val > root->val) {\\n            root->right = deleteNode(root->right, val);\\n        } else {\\n            /* Leaf node case */\\n            if (!root->left && !root->right) {\\n                delete(root);\\n                return NULL;\\n            }\\n            /* 1 child case */\\n            if (!root->left || !root->right) {\\n                TreeNode *ret = root->left ? root->left : root->right;\\n                delete(root);\\n                return ret;\\n            }\\n            /* 2 child case */\\n            if (root->left && root->right) {\\n                TreeNode *tmp = root->right;\\n                while (tmp->left) {\\n                    tmp = tmp->left;\\n                }\\n                root->val = tmp->val;\\n                root->right = deleteNode(root->right, root->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93351,
                "title": "bottom-up-recursive-python-solution-o-log-n-time",
                "content": "Idea:\\n1. When found the node, put right child of the node to the right of the right most leaf node of left child. That way the values are still in order.\\n2. Return the left child of the node(skip root, a.k.a delete it). If the node doesn't have left child, return right child.\\n3. Otherwise do binary search. If key < root.val, change left child to the returned new root. Do right child if key > root.val.\\n\\nThis solution always runs in O(log(n)) time since when it finds the node to delete, it goes to the right most leaf of the left sub-tree to put right sub-tree of the node there.\\n\\n```Python\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root: return None\\n        \\n        if root.val == key:\\n            if root.left:\\n                # Find the right most leaf of the left sub-tree\\n                left_right_most = root.left\\n                while left_right_most.right:\\n                    left_right_most = left_right_most.right\\n                # Attach right child to the right of that leaf\\n                left_right_most.right = root.right\\n                # Return left child instead of root, a.k.a delete root\\n                return root.left\\n            else:\\n                return root.right\\n        # If left or right child got deleted, the returned root is the child of the deleted node.\\n        elif root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n            \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```Python\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root: return None\\n        \\n        if root.val == key:\\n            if root.left:\\n                # Find the right most leaf of the left sub-tree\\n                left_right_most = root.left\\n                while left_right_most.right:\\n                    left_right_most = left_right_most.right\\n                # Attach right child to the right of that leaf\\n                left_right_most.right = root.right\\n                # Return left child instead of root, a.k.a delete root\\n                return root.left\\n            else:\\n                return root.right\\n        # If left or right child got deleted, the returned root is the child of the deleted node.\\n        elif root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887303,
                "title": "python-3-97-55-faster-explanation-added",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nKey Learnings for me:\\n1. First find the node that we need to delete.\\n2. After it\\'s found, think about ways to keep the tree BST after deleting the node. \\n\\t1. If there\\'s no left or right subtree, we found the leaf. Delete this node without any further traversing.\\n\\t2. If it\\'s not a leaf node, what node we can use from the subtree that can replace the delete node and still maintain the BST property? We can either replace the delete node with the minimum from the right subtree (if right exists) or we can replace the delete node with the maximum from the left subtree (if left exists).\\n\\n```\\ndef deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n\\tif not root:\\n\\t\\treturn None\\n\\n\\tif key > root.val:\\n\\t\\troot.right = self.deleteNode(root.right, key)\\n\\telif key < root.val:\\n\\t\\troot.left = self.deleteNode(root.left, key)\\n\\telse:\\n\\t\\tif not root.left and not root.right:\\n\\t\\t\\troot = None\\n\\t\\telif root.right:\\n\\t\\t\\troot.val = self.successor(root)\\n\\t\\t\\troot.right = self.deleteNode(root.right, root.val)\\n\\t\\telse:\\n\\t\\t\\troot.val = self.predecessor(root)\\n\\t\\t\\troot.left = self.deleteNode(root.left, root.val)\\n\\treturn root\\n\\ndef successor(self, root: TreeNode) -> TreeNode:\\n\\troot = root.right\\n\\twhile root.left:\\n\\t\\troot = root.left\\n\\treturn root.val\\n\\ndef predecessor(self, root: TreeNode) -> TreeNode:\\n\\troot = root.left\\n\\twhile root.right:\\n\\t\\troot = root.right\\n\\treturn root.val\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n\\tif not root:\\n\\t\\treturn None\\n\\n\\tif key > root.val:\\n\\t\\troot.right = self.deleteNode(root.right, key)\\n\\telif key < root.val:\\n\\t\\troot.left = self.deleteNode(root.left, key)\\n\\telse:\\n\\t\\tif not root.left and not root.right:\\n\\t\\t\\troot = None\\n\\t\\telif root.right:\\n\\t\\t\\troot.val = self.successor(root)\\n\\t\\t\\troot.right = self.deleteNode(root.right, root.val)\\n\\t\\telse:\\n\\t\\t\\troot.val = self.predecessor(root)\\n\\t\\t\\troot.left = self.deleteNode(root.left, root.val)\\n\\treturn root\\n\\ndef successor(self, root: TreeNode) -> TreeNode:\\n\\troot = root.right\\n\\twhile root.left:\\n\\t\\troot = root.left\\n\\treturn root.val\\n\\ndef predecessor(self, root: TreeNode) -> TreeNode:\\n\\troot = root.left\\n\\twhile root.right:\\n\\t\\troot = root.right\\n\\treturn root.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1030765,
                "title": "recursive-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int findminfromright(TreeNode* root){\\n        while(root->left!=nullptr)\\n            root=root->left;\\n        return root->val;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==nullptr) return root;\\n        else if(root->val>key) root->left=deleteNode(root->left,key);\\n        else if(root->val<key) root->right=deleteNode(root->right,key);\\n        else{\\n            if(root->right==nullptr){\\n                return root->left;\\n            }else if(root->left==nullptr){\\n                return root->right;\\n            }else{\\n\\t\\t\\t    //replace the root value by find the minimum val from right side \\n                root->val=findminfromright(root->right);\\n                root->right = deleteNode(root->right, root->val);\\n            }\\n        }\\n        return root;\\n    }\\n   \\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findminfromright(TreeNode* root){\\n        while(root->left!=nullptr)\\n            root=root->left;\\n        return root->val;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==nullptr) return root;\\n        else if(root->val>key) root->left=deleteNode(root->left,key);\\n        else if(root->val<key) root->right=deleteNode(root->right,key);\\n        else{\\n            if(root->right==nullptr){\\n                return root->left;\\n            }else if(root->left==nullptr){\\n                return root->right;\\n            }else{\\n\\t\\t\\t    //replace the root value by find the minimum val from right side \\n                root->val=findminfromright(root->right);\\n                root->right = deleteNode(root->right, root->val);\\n            }\\n        }\\n        return root;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93378,
                "title": "an-easy-understanding-o-h-time-o-1-space-java-solution",
                "content": "*If the node is found, delete the node.*\\nWe need a function `deleteRoot` to delete the root from a BST.\\n* If `root==null`, then return `null`\\n* If `root.right==null`, then return `root.left`\\n* If `root.right!=null`, the the new root of the BST is root.right; And what we should do is to put root.left into this new BST. As all nodes in root.left is smaller than the new tree, we just need to find the *left-most* node.\\n\\n\\n```\\npublic class Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root==null || root.val==key) return deleteRoot(root);\\n        TreeNode p=root;\\n        \\n        while (true) { // search the node\\n            if (key>p.val) {\\n                if (p.right==null || p.right.val==key) {\\n                    p.right=deleteRoot(p.right);\\n                    break;\\n                }\\n                p=p.right;\\n            }\\n            else {\\n                if (p.left==null || p.left.val==key) {\\n                    p.left=deleteRoot(p.left);\\n                    break;\\n                }\\n                p=p.left;\\n            }\\n        }\\n        return root;\\n    }\\n\\n    private TreeNode deleteRoot(TreeNode root) {\\n        if (root==null) return null;\\n        if (root.right==null) return root.left;\\n        TreeNode x=root.right; // root.right should be the new root\\n        while (x.left!=null) x=x.left; // find the left-most node\\n        x.left=root.left;\\n        return root.right;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root==null || root.val==key) return deleteRoot(root);\\n        TreeNode p=root;\\n        \\n        while (true) { // search the node\\n            if (key>p.val) {\\n                if (p.right==null || p.right.val==key) {\\n                    p.right=deleteRoot(p.right);\\n                    break;\\n                }\\n                p=p.right;\\n            }\\n            else {\\n                if (p.left==null || p.left.val==key) {\\n                    p.left=deleteRoot(p.left);\\n                    break;\\n                }\\n                p=p.left;\\n            }\\n        }\\n        return root;\\n    }\\n\\n    private TreeNode deleteRoot(TreeNode root) {\\n        if (root==null) return null;\\n        if (root.right==null) return root.left;\\n        TreeNode x=root.right; // root.right should be the new root\\n        while (x.left!=null) x=x.left; // find the left-most node\\n        x.left=root.left;\\n        return root.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93394,
                "title": "concise-and-clear-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return root;    \\n        if (root->val > key)\\n            root->left = deleteNode(root->left, key);\\n        else if (root->val < key)\\n            root->right = deleteNode(root->right, key);\\n        else {\\n            if (!root->left) {\\n                TreeNode* right = root->right;\\n                delete root;\\n                return right;\\n            }\\n            else if (!root->right) {\\n                TreeNode* left = root->left;\\n                delete root;\\n                return left;\\n            }\\n            else {\\n                TreeNode* successor = findMinNode(root->right); // find the inorder successor (the minimal node in right subtree)\\n                root->val = successor->val;\\n                root->right = deleteNode(root->right, successor->val);\\n            }\\n        }\\n        return root;\\n    }\\nprivate:\\n    TreeNode* findMinNode(TreeNode* root) {\\n        if (root->left) return findMinNode(root->left);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return root;    \\n        if (root->val > key)\\n            root->left = deleteNode(root->left, key);\\n        else if (root->val < key)\\n            root->right = deleteNode(root->right, key);\\n        else {\\n            if (!root->left) {\\n                TreeNode* right = root->right;\\n                delete root;\\n                return right;\\n            }\\n            else if (!root->right) {\\n                TreeNode* left = root->left;\\n                delete root;\\n                return left;\\n            }\\n            else {\\n                TreeNode* successor = findMinNode(root->right); // find the inorder successor (the minimal node in right subtree)\\n                root->val = successor->val;\\n                root->right = deleteNode(root->right, successor->val);\\n            }\\n        }\\n        return root;\\n    }\\nprivate:\\n    TreeNode* findMinNode(TreeNode* root) {\\n        if (root->left) return findMinNode(root->left);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193706,
                "title": "java-solution-beats-100-percent-all-test-cases-detailed-explaination",
                "content": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution \\n{\\n    public TreeNode deleteNode(TreeNode root, int key) \\n    {\\n        \\n        TreeNode target = root, parent = null;\\n        \\n        //Search Node\\n        while (target != null && target.val != key) \\n        {\\n            parent = target;\\n            if (key > target.val) target = target.right;\\n            else target = target.left;\\n        }\\n        \\n        if (target == null) return root;  // not found\\n        \\n        \\n        // Case 1 : No children\\n        if(target.left==null && target.right==null)\\n        {\\n            if (parent == null) return null;\\n            if(target==parent.left) parent.left=null;\\n            else parent.right=null;\\n            return root;\\n        }\\n        \\n        // Case 2 : One Child\\n        \\n            // Case 2.1 : No right child\\n        if(target.right==null)\\n        {\\n            if (parent == null) return target.left; //If target node is root itself\\n            if (target == parent.left) parent.left = target.left;\\n            else parent.right = target.left;\\n            return root;\\n        }\\n        \\n            // Case 2.2 : No left child\\n        if(target.left==null)\\n        {\\n            if (parent == null) return target.right;\\n            if (target == parent.left) parent.left = target.right;\\n            else parent.right = target.right;\\n            return root;\\n        }\\n        \\n        // Case 3 : Both the child nodes present\\n        {\\n            /* Whenever we delete a node with two child then we replace that node with the \\n\\t\\t\\t   leftmost element from the right subtree because to hold the property of BST  \\n\\t\\t\\t   all the element to the right of the new node will be greater than it and all the \\n\\t\\t\\t   left ones will be lesser than it\\n            */\\n            // Trace to the leftmost element in Right subtree\\n            TreeNode prev = target, p = target.right;\\n            while (p.left != null) \\n            {\\n                prev = p;\\n                p = p.left;\\n            }\\n            \\n            target.val = p.val;\\n            if (p == prev.left) prev.left = p.right;\\n            else prev.right = p.right;\\n            return root;\\n        }\\n   }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution \\n{\\n    public TreeNode deleteNode(TreeNode root, int key) \\n    {\\n        \\n        TreeNode target = root, parent = null;\\n        \\n        //Search Node\\n        while (target != null && target.val != key) \\n        {\\n            parent = target;\\n            if (key > target.val) target = target.right;\\n            else target = target.left;\\n        }\\n        \\n        if (target == null) return root;  // not found\\n        \\n        \\n        // Case 1 : No children\\n        if(target.left==null && target.right==null)\\n        {\\n            if (parent == null) return null;\\n            if(target==parent.left) parent.left=null;\\n            else parent.right=null;\\n            return root;\\n        }\\n        \\n        // Case 2 : One Child\\n        \\n            // Case 2.1 : No right child\\n        if(target.right==null)\\n        {\\n            if (parent == null) return target.left; //If target node is root itself\\n            if (target == parent.left) parent.left = target.left;\\n            else parent.right = target.left;\\n            return root;\\n        }\\n        \\n            // Case 2.2 : No left child\\n        if(target.left==null)\\n        {\\n            if (parent == null) return target.right;\\n            if (target == parent.left) parent.left = target.right;\\n            else parent.right = target.right;\\n            return root;\\n        }\\n        \\n        // Case 3 : Both the child nodes present\\n        {\\n            /* Whenever we delete a node with two child then we replace that node with the \\n\\t\\t\\t   leftmost element from the right subtree because to hold the property of BST  \\n\\t\\t\\t   all the element to the right of the new node will be greater than it and all the \\n\\t\\t\\t   left ones will be lesser than it\\n            */\\n            // Trace to the leftmost element in Right subtree\\n            TreeNode prev = target, p = target.right;\\n            while (p.left != null) \\n            {\\n                prev = p;\\n                p = p.left;\\n            }\\n            \\n            target.val = p.val;\\n            if (p == prev.left) prev.left = p.right;\\n            else prev.right = p.right;\\n            return root;\\n        }\\n   }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821861,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=i2s4Tyw3_dY)\\nhttps://www.youtube.com/watch?v=i2s4Tyw3_dY\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def findmin(self, root):\\n        current = root\\n        while current.left:\\n            current = current.left\\n        return current\\n    \\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        if not root:\\n            return root\\n        \\n        elif key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        \\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        \\n        else:\\n            #leaf\\n            if not root.left and not root.right:\\n                root = None\\n            \\n            # 1 child\\n            elif not root.left:\\n                root = root.right\\n            \\n            elif not root.right:\\n                root = root.left\\n            \\n            else:\\n                temp = self.findmin(root.right)\\n                root.val = temp.val\\n                root.right = self.deleteNode(root.right, temp.val)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def findmin(self, root):\\n        current = root\\n        while current.left:\\n            current = current.left\\n        return current\\n    \\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        if not root:\\n            return root\\n        \\n        elif key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        \\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        \\n        else:\\n            #leaf\\n            if not root.left and not root.right:\\n                root = None\\n            \\n            # 1 child\\n            elif not root.left:\\n                root = root.right\\n            \\n            elif not root.right:\\n                root = root.left\\n            \\n            else:\\n                temp = self.findmin(root.right)\\n                root.val = temp.val\\n                root.right = self.deleteNode(root.right, temp.val)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590757,
                "title": "c-short-and-simple-recursive-solution-detailed-explanation",
                "content": "**Explanation:**\\nFirst, we iterate recursively through the tree to find the desired node.\\nNow, we have three cases when we want to delete a node:\\n1. It\\'s a leaf\\n2. It has one child\\n3. It has two children\\n\\nSo the way we solve the problem for each case is:\\n1. A leaf - simplest, just point parent to NULL.\\n2. One child - make a bypass and point the parent to the child.\\n3. This case is a bit complicated. We need to make sure we keep the BST rules.\\nThe algorithm is, we find either the smallest number larger than `key` or the largest number smaller than `key`. That way, if we replace the key with it, the BST won\\'t break.\\nSo I chose to find the smallest node larger than `key`. To get that, we go to the right child -> larger, then we go down to the leftmost leaf -> smallest in subtree.\\nWe replace the original value with the value we found and then delete the node that we found (It has to have maximum one child because we went all the way down to the leftmost).\\nWe call `deleteNode` recursively and now we have one of the easy cases.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* leftmost(TreeNode* node) {\\n        while (node && node->left) node = node->left;\\n        return node;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return NULL;\\n        \\n        if (key < root->val) root->left = deleteNode(root->left, key);\\n        else if (key > root->val) root->right = deleteNode(root->right, key);\\n        \\n        else {\\n            if (root->left == NULL) {\\n                TreeNode* tmp = root->right;\\n                delete root;\\n                return tmp;\\n            }\\n            \\n            else if (root->right == NULL) {\\n                TreeNode* tmp = root->left;\\n                delete root;\\n                return tmp;\\n            }\\n            \\n            else {\\n                TreeNode* tmp = leftmost(root->right);\\n                root->val = tmp->val;\\n                root->right = deleteNode(root->right, tmp->val);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* leftmost(TreeNode* node) {\\n        while (node && node->left) node = node->left;\\n        return node;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return NULL;\\n        \\n        if (key < root->val) root->left = deleteNode(root->left, key);\\n        else if (key > root->val) root->right = deleteNode(root->right, key);\\n        \\n        else {\\n            if (root->left == NULL) {\\n                TreeNode* tmp = root->right;\\n                delete root;\\n                return tmp;\\n            }\\n            \\n            else if (root->right == NULL) {\\n                TreeNode* tmp = root->left;\\n                delete root;\\n                return tmp;\\n            }\\n            \\n            else {\\n                TreeNode* tmp = leftmost(root->right);\\n                root->val = tmp->val;\\n                root->right = deleteNode(root->right, tmp->val);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543124,
                "title": "python-o-h-with-bst-property-85-w-comment",
                "content": "Python O( h ) with BST property. \\n\\n---\\n\\n```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        \\n        if not root:\\n            return None\\n            \\n        if root.val > key:\\n\\t\\t    # Target node is smaller than currnet node, search left subtree\\n\\t\\t\\t\\n            root.left = self.deleteNode( root.left, key )\\n\\n        elif root.val < key:\\n\\t\\t    # Target node is larger than currnet node, search right subtree\\n\\t\\t\\t\\n            root.right = self.deleteNode( root.right, key )\\n\\n        else:\\n            # Current node is target node\\n\\t\\t\\t\\n            if (not root.left) or (not root.right):\\n                # At least one child is empty\\n                # Target node is replaced by either non-empty child or None\\n                root = root.left if root.left else root.right\\n\\n            else:\\n                # Both two childs exist\\n                # Target node is replaced by smallest element of right subtree\\n                cur = root.right\\n\\n                while cur.left:\\n                    cur = cur.left\\n\\n                root.val = cur.val\\n                root.right = self.deleteNode( root.right, cur.val )\\n                    \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        \\n        if not root:\\n            return None\\n            \\n        if root.val > key:\\n\\t\\t    # Target node is smaller than currnet node, search left subtree\\n\\t\\t\\t\\n            root.left = self.deleteNode( root.left, key )\\n\\n        elif root.val < key:\\n\\t\\t    # Target node is larger than currnet node, search right subtree\\n\\t\\t\\t\\n            root.right = self.deleteNode( root.right, key )\\n\\n        else:\\n            # Current node is target node\\n\\t\\t\\t\\n            if (not root.left) or (not root.right):\\n                # At least one child is empty\\n                # Target node is replaced by either non-empty child or None\\n                root = root.left if root.left else root.right\\n\\n            else:\\n                # Both two childs exist\\n                # Target node is replaced by smallest element of right subtree\\n                cur = root.right\\n\\n                while cur.left:\\n                    cur = cur.left\\n\\n                root.val = cur.val\\n                root.right = self.deleteNode( root.right, cur.val )\\n                    \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590768,
                "title": "c-recursive-iterative-detailed-and-simple-solution",
                "content": "We need to find the node with the provided key_value and then remove that very node from the BST.... and all the values in the tree are unique, so there will always be only one node with the given key !!\\n        \\n        || search the node, if not found then simply return NULL ...\\n        \\n        || if found --->> these are going to be the conditions ...\\n            #it can have no children (leaf node)\\n            #it can have only one children\\n            #it can have both children(relatively complicated case)\\n            \\n    //DOING IT ITERATIVELY \\n    \\n   TreeNode* deleteNode(TreeNode* root, int key) {\\n        \\n        TreeNode* target = root;\\n        TreeNode* parent = NULL;\\n        \\n        //Search Node\\n        while (target != NULL && target->val != key) \\n        {\\n            parent = target;\\n            if (key > target->val) target = target->right;\\n            else target = target->left;\\n        }\\n        \\n        if (target == NULL) return root;  // not found\\n        \\n        \\n        // Case 1 : No children\\n        if(target->left==NULL && target->right==NULL)\\n        {\\n            if (parent == NULL) return NULL;\\n            if(target==parent->left) parent->left=NULL;\\n            else parent->right=NULL;\\n            return root;\\n        }\\n        \\n        // Case 2 : One Child\\n        \\n            // Case 2.1 : No right child\\n        if(target->right==NULL)\\n        {\\n            if (parent == NULL) return target->left; //If target node is root itself\\n            if (target == parent->left) parent->left = target->left;\\n            else parent->right = target->left;\\n            return root;\\n        }\\n        \\n            // Case 2.2 : No left child\\n        if(target->left==NULL)\\n        {\\n            if (parent == NULL) return target->right;\\n            if (target == parent->left) parent->left = target->right;\\n            else parent->right = target->right;\\n            return root;\\n        }\\n        \\n        // Case 3 : Both the child nodes present\\n        \\n            /* Whenever we delete a node with two child then we replace that node with the \\n\\t\\t\\t   leftmost element from the right subtree because to hold the property of BST  \\n\\t\\t\\t   all the element to the right of the new node will be greater than it and all the \\n\\t\\t\\t   left ones will be lesser than it*/\\n            \\n        \\n            // Trace to the leftmost element in Right subtree\\n            TreeNode* prev = target;\\n            TreeNode* p = target->right;\\n            while (p->left != NULL) \\n            {\\n                prev = p;\\n                p = p->left;\\n            }\\n            \\n            target->val = p->val;\\n            if (p == prev->left) prev->left = p->right;\\n            else prev->right = p->right;\\n            return root;\\n        \\n    }\\n    \\n    //DOING IT RECURSIVELY (More intuitive, once you understand how things work)\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        \\n        \\n        if (!root) return root;\\n        \\n        if (key < root->val) {\\n            root->left = deleteNode(root->left, val);\\n        } else if (key > root->val) {\\n            root->right = deleteNode(root->right, val);\\n        } else {\\n            // Leaf node case \\n            if (!root->left && !root->right) {\\n                delete(root);\\n                return NULL;\\n            }\\n            // 1 child case \\n            if (!root->left || !root->right) {\\n                TreeNode *ret = root->left ? root->left : root->right;\\n                delete(root);\\n                return ret;\\n            }\\n            // 2 child case \\n            if (root->left && root->right) {\\n                TreeNode *tmp = root->right;\\n                while (tmp->left) {\\n                    tmp = tmp->left;\\n                }\\n                root->val = tmp->val;\\n                root->right = deleteNode(root->right, root->val);\\n            }\\n        }\\n        return root;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "We need to find the node with the provided key_value and then remove that very node from the BST.... and all the values in the tree are unique, so there will always be only one node with the given key !!\\n        \\n        || search the node, if not found then simply return NULL ...\\n        \\n        || if found --->> these are going to be the conditions ...\\n            #it can have no children (leaf node)\\n            #it can have only one children\\n            #it can have both children(relatively complicated case)\\n            \\n    //DOING IT ITERATIVELY \\n    \\n   TreeNode* deleteNode(TreeNode* root, int key) {\\n        \\n        TreeNode* target = root;\\n        TreeNode* parent = NULL;\\n        \\n        //Search Node\\n        while (target != NULL && target->val != key) \\n        {\\n            parent = target;\\n            if (key > target->val) target = target->right;\\n            else target = target->left;\\n        }\\n        \\n        if (target == NULL) return root;  // not found\\n        \\n        \\n        // Case 1 : No children\\n        if(target->left==NULL && target->right==NULL)\\n        {\\n            if (parent == NULL) return NULL;\\n            if(target==parent->left) parent->left=NULL;\\n            else parent->right=NULL;\\n            return root;\\n        }\\n        \\n        // Case 2 : One Child\\n        \\n            // Case 2.1 : No right child\\n        if(target->right==NULL)\\n        {\\n            if (parent == NULL) return target->left; //If target node is root itself\\n            if (target == parent->left) parent->left = target->left;\\n            else parent->right = target->left;\\n            return root;\\n        }\\n        \\n            // Case 2.2 : No left child\\n        if(target->left==NULL)\\n        {\\n            if (parent == NULL) return target->right;\\n            if (target == parent->left) parent->left = target->right;\\n            else parent->right = target->right;\\n            return root;\\n        }\\n        \\n        // Case 3 : Both the child nodes present\\n        \\n            /* Whenever we delete a node with two child then we replace that node with the \\n\\t\\t\\t   leftmost element from the right subtree because to hold the property of BST  \\n\\t\\t\\t   all the element to the right of the new node will be greater than it and all the \\n\\t\\t\\t   left ones will be lesser than it*/\\n            \\n        \\n            // Trace to the leftmost element in Right subtree\\n            TreeNode* prev = target;\\n            TreeNode* p = target->right;\\n            while (p->left != NULL) \\n            {\\n                prev = p;\\n                p = p->left;\\n            }\\n            \\n            target->val = p->val;\\n            if (p == prev->left) prev->left = p->right;\\n            else prev->right = p->right;\\n            return root;\\n        \\n    }\\n    \\n    //DOING IT RECURSIVELY (More intuitive, once you understand how things work)\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        \\n        \\n        if (!root) return root;\\n        \\n        if (key < root->val) {\\n            root->left = deleteNode(root->left, val);\\n        } else if (key > root->val) {\\n            root->right = deleteNode(root->right, val);\\n        } else {\\n            // Leaf node case \\n            if (!root->left && !root->right) {\\n                delete(root);\\n                return NULL;\\n            }\\n            // 1 child case \\n            if (!root->left || !root->right) {\\n                TreeNode *ret = root->left ? root->left : root->right;\\n                delete(root);\\n                return ret;\\n            }\\n            // 2 child case \\n            if (root->left && root->right) {\\n                TreeNode *tmp = root->right;\\n                while (tmp->left) {\\n                    tmp = tmp->left;\\n                }\\n                root->val = tmp->val;\\n                root->right = deleteNode(root->right, root->val);\\n            }\\n        }\\n        return root;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 650562,
                "title": "java-0ms-beats-100-in-time",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null)\\n            return root;\\n        if(root.val==key){\\n           root = delete(root,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            root.left=deleteNode(root.left,key);\\n        }\\n        return root;\\n    }\\n    private TreeNode delete(TreeNode root,int key){\\n        if(root.left==null && root.right==null)\\n            return null;\\n        if(root.left==null)\\n            return root.right;\\n        if(root.right==null)\\n            return root.left;\\n        TreeNode helper=root.right;\\n        while(helper.left!=null)\\n            helper=helper.left;\\n        helper.left=root.left;\\n        return root.right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null)\\n            return root;\\n        if(root.val==key){\\n           root = delete(root,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            root.left=deleteNode(root.left,key);\\n        }\\n        return root;\\n    }\\n    private TreeNode delete(TreeNode root,int key){\\n        if(root.left==null && root.right==null)\\n            return null;\\n        if(root.left==null)\\n            return root.right;\\n        if(root.right==null)\\n            return root.left;\\n        TreeNode helper=root.right;\\n        while(helper.left!=null)\\n            helper=helper.left;\\n        helper.left=root.left;\\n        return root.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824161,
                "title": "javascript-short-clean-and-intuitive-recursive-solution",
                "content": "```javascript\\nvar deleteNode = function(root, key) {\\n    \\n    function callDFS(node) {\\n        if(!node) return null;\\n        if(node.val === key) {\\n            if(!node.left) return node.right;\\n            if(!node.right) return node.left;\\n            let curr = node.right;\\n            while(curr.left) curr = curr.left;\\n            curr.left = node.left;\\n            return node.right;\\n        }\\n        if(key > node.val) node.right = callDFS(node.right);\\n        else node.left = callDFS(node.left);\\n        return node;\\n    }\\n    return callDFS(root)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar deleteNode = function(root, key) {\\n    \\n    function callDFS(node) {\\n        if(!node) return null;\\n        if(node.val === key) {\\n            if(!node.left) return node.right;\\n            if(!node.right) return node.left;\\n            let curr = node.right;\\n            while(curr.left) curr = curr.left;\\n            curr.left = node.left;\\n            return node.right;\\n        }\\n        if(key > node.val) node.right = callDFS(node.right);\\n        else node.left = callDFS(node.left);\\n        return node;\\n    }\\n    return callDFS(root)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467512,
                "title": "python-simple-clean-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root: return root\\n\\n        if root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        elif root.val < key:\\n            root.right = self.deleteNode(root.right, key)\\n        else:\\n            if not root.left: return root.right\\n            if not root.right: return root.left\\n\\n            if root.left and root.right:\\n                temp = root.right\\n                while temp.left: temp = temp.left\\n                root.val = temp.val\\n                root.right = self.deleteNode(root.right, root.val)\\n        \\n        return root  \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root: return root\\n\\n        if root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        elif root.val < key:\\n            root.right = self.deleteNode(root.right, key)\\n        else:\\n            if not root.left: return root.right\\n            if not root.right: return root.left\\n\\n            if root.left and root.right:\\n                temp = root.right\\n                while temp.left: temp = temp.left\\n                root.val = temp.val\\n                root.right = self.deleteNode(root.right, root.val)\\n        \\n        return root  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077559,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n        root->left=deleteNode(root->left, key);\\n        else if(key>root->val)\\n        root->right=deleteNode(root->right, key);\\n        else\\n        {\\n            if(!root->left && !root->right)\\n            return NULL;\\n            if(!root->left || !root->right)\\n            {\\n                if(root->left)\\n                return root->left;\\n                return root->right;\\n            }\\n            else\\n            {\\n                TreeNode* t=root->left;\\n                while(t->right)\\n                t=t->right;\\n                root->val=t->val;\\n                root->left=deleteNode(root->left, t->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n        root->left=deleteNode(root->left, key);\\n        else if(key>root->val)\\n        root->right=deleteNode(root->right, key);\\n        else\\n        {\\n            if(!root->left && !root->right)\\n            return NULL;\\n            if(!root->left || !root->right)\\n            {\\n                if(root->left)\\n                return root->left;\\n                return root->right;\\n            }\\n            else\\n            {\\n                TreeNode* t=root->left;\\n                while(t->right)\\n                t=t->right;\\n                root->val=t->val;\\n                root->left=deleteNode(root->left, t->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590815,
                "title": "javasscript-clean-easy-to-understand-heavily-commented-solution",
                "content": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} key\\n * @return {TreeNode}\\n */\\nvar deleteNode = function(root, key) {\\n    // T: O(log(n)), S: O(1) (not counting stack frames for recursion)\\n    // being n the amount of nodes in the tree\\n\\n    // T: O(h), S: O(h) (counting h stack frames for recursion)\\n    // being h the height of the tree (max elements of the bst = n = 2^h)\\n\\n    if (null === root) { return null; }\\n\\n    if (root.val === key) {\\n        // to delete a leaf node (no children) we can just return null\\n        if (null === root.left && null === root.right) { return null; }\\n\\n        // at this point we need to delete the current node. so, we need to return a different one\\n        // we need to pick either the left or the right node\\n\\n        if (null !== root.left && null !== root.right) {\\n            // this a complicated edge case that we can\\'t solve right away\\n            //\\n            // we could pick the root.left node, but what if (root.left.right !== null)? where\\n            // are we going to attach our root.right subtree without overwriting any existing\\n            // reference?\\n            //\\n            // also, we could pick the root.right node, but what if (root.right.left !== null) too?\\n            //\\n            // so, these are our two possible (and equivalent) options:\\n            //      1) pick our root.right node as the root node, and find the minimum node in \\n            //         the right subtree that has no left pointer, and assign the root.left node to it.\\n            //\\n            //      2) pick our root.left node as the root node, and find the maximum node in\\n            //         the left subtree that has no right pointer, and assign the root.right node to it.\\n            // \\n\\t\\t\\t// here\\'s an example of deleting node with val=5 without breaking the BST choosing option (1)\\n            //\\n            //                  5                     8\\n            //               /     \\\\                 / \\\\\\n            //              3*      8               7   9\\n            //             / \\\\     / \\\\    --->     /\\n            //            2   4   7   9           6\\n            //                   /               /\\n            //                  6               3*\\n            //                                 / \\\\\\n            //                                2   4\\n            //\\n            // we\\'ll choose option (1) and we\\'ll find the minimum number in the right subtree that \\n            // has no left pointer\\n            // that one is going to be the node that will link to the left subtree of the current\\n            // -soon to be deleted- node. by doing that we\\'ll preserve the structure of the BST\\n            // (nodes to the left of a node should be smaller, and numbers to the\\n            // right should be greater).\\n            let curr = root.right;\\n            while (curr.left) { curr = curr.left; }\\n            curr.left = root.left;\\n            return root.right;\\n        }\\n        \\n        // if left/right is null, then we can safely pick the one that is not null without \\n        // breaking the BST\\n        if (null === root.left) { return root.right; }\\n        if (null === root.right) { return root.left; }\\n    }\\n    \\n    if (key < root.val) {\\n        // look for our target node in the left subtree\\n        root.left = deleteNode(root.left, key);\\n    } else {\\n        // look for our target node in the right subtree\\n        root.right = deleteNode(root.right, key);\\n    }\\n\\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} key\\n * @return {TreeNode}\\n */\\nvar deleteNode = function(root, key) {\\n    // T: O(log(n)), S: O(1) (not counting stack frames for recursion)\\n    // being n the amount of nodes in the tree\\n\\n    // T: O(h), S: O(h) (counting h stack frames for recursion)\\n    // being h the height of the tree (max elements of the bst = n = 2^h)\\n\\n    if (null === root) { return null; }\\n\\n    if (root.val === key) {\\n        // to delete a leaf node (no children) we can just return null\\n        if (null === root.left && null === root.right) { return null; }\\n\\n        // at this point we need to delete the current node. so, we need to return a different one\\n        // we need to pick either the left or the right node\\n\\n        if (null !== root.left && null !== root.right) {\\n            // this a complicated edge case that we can\\'t solve right away\\n            //\\n            // we could pick the root.left node, but what if (root.left.right !== null)? where\\n            // are we going to attach our root.right subtree without overwriting any existing\\n            // reference?\\n            //\\n            // also, we could pick the root.right node, but what if (root.right.left !== null) too?\\n            //\\n            // so, these are our two possible (and equivalent) options:\\n            //      1) pick our root.right node as the root node, and find the minimum node in \\n            //         the right subtree that has no left pointer, and assign the root.left node to it.\\n            //\\n            //      2) pick our root.left node as the root node, and find the maximum node in\\n            //         the left subtree that has no right pointer, and assign the root.right node to it.\\n            // \\n\\t\\t\\t// here\\'s an example of deleting node with val=5 without breaking the BST choosing option (1)\\n            //\\n            //                  5                     8\\n            //               /     \\\\                 / \\\\\\n            //              3*      8               7   9\\n            //             / \\\\     / \\\\    --->     /\\n            //            2   4   7   9           6\\n            //                   /               /\\n            //                  6               3*\\n            //                                 / \\\\\\n            //                                2   4\\n            //\\n            // we\\'ll choose option (1) and we\\'ll find the minimum number in the right subtree that \\n            // has no left pointer\\n            // that one is going to be the node that will link to the left subtree of the current\\n            // -soon to be deleted- node. by doing that we\\'ll preserve the structure of the BST\\n            // (nodes to the left of a node should be smaller, and numbers to the\\n            // right should be greater).\\n            let curr = root.right;\\n            while (curr.left) { curr = curr.left; }\\n            curr.left = root.left;\\n            return root.right;\\n        }\\n        \\n        // if left/right is null, then we can safely pick the one that is not null without \\n        // breaking the BST\\n        if (null === root.left) { return root.right; }\\n        if (null === root.right) { return root.left; }\\n    }\\n    \\n    if (key < root.val) {\\n        // look for our target node in the left subtree\\n        root.left = deleteNode(root.left, key);\\n    } else {\\n        // look for our target node in the right subtree\\n        root.right = deleteNode(root.right, key);\\n    }\\n\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122576,
                "title": "python-with-comments",
                "content": "```\\nclass Solution:\\n    \\n    def findMin(self, root):\\n        current = root\\n        while current.left:\\n            current = current.left\\n        return current\\n    \\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        if not root:\\n            return root\\n        \\n        #we want to get to a place where what we want to delete is root (==key), and everything less is on left and everything greater is on the right \\n        elif key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        \\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        \\n        else: # now we\\'re at that point where root == key.val    \\n            \\n            #if what we want to delete is a leaf node\\n            if not root.left and not root.right:\\n                root = None #just make it none\\n            \\n            #it has one leaf node\\n            \\n            elif not root.left: #if there\\'s right \\n                root = root.right #make root equal to it\\'s right. essentially deleting root\\n\\n            elif not root.right: # similarly\\n                root = root.left\\n\\n            else: #now it has two leaf nodes. we can either replace root\\'s val with min of right, or max of left and still maintain bst property\\n                temp = self.findMin(root.right) #find min of right\\n                root.val = temp.val #change root\\'s val to min of right\\'s val\\n                root.right = self.deleteNode(root.right, temp.val) #delete that temp.val from right subtree. \\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def findMin(self, root):\\n        current = root\\n        while current.left:\\n            current = current.left\\n        return current\\n    \\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        if not root:\\n            return root\\n        \\n        #we want to get to a place where what we want to delete is root (==key), and everything less is on left and everything greater is on the right \\n        elif key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        \\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        \\n        else: # now we\\'re at that point where root == key.val    \\n            \\n            #if what we want to delete is a leaf node\\n            if not root.left and not root.right:\\n                root = None #just make it none\\n            \\n            #it has one leaf node\\n            \\n            elif not root.left: #if there\\'s right \\n                root = root.right #make root equal to it\\'s right. essentially deleting root\\n\\n            elif not root.right: # similarly\\n                root = root.left\\n\\n            else: #now it has two leaf nodes. we can either replace root\\'s val with min of right, or max of left and still maintain bst property\\n                temp = self.findMin(root.right) #find min of right\\n                root.val = temp.val #change root\\'s val to min of right\\'s val\\n                root.right = self.deleteNode(root.right, temp.val) #delete that temp.val from right subtree. \\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821308,
                "title": "c-c-short-simple-efficient-explained-recursive-solution",
                "content": "**Like it? Please upvote...**\\n```\\n// help function to find following number\\nstruct TreeNode* minValueNode(struct TreeNode * node)\\n{\\n\\tstruct TreeNode * current = node;\\n    while (current && current->left != NULL)\\n        current = current->left;\\n \\n    return current;\\n}\\n\\nstruct TreeNode* deleteNode(struct TreeNode* root, int key)\\n{\\n\\tif (!root)\\n\\t\\treturn root;\\n \\n    // find node to remove\\n    if (key < root->val)\\n        root->left = deleteNode(root->left, key);\\n\\n  \\telse if (key > root->val)\\n        root->right = deleteNode(root->right, key);\\n\\n    // node found\\n    else\\n    {\\n        if (root->left == NULL) // no left child\\n        {\\n            struct TreeNode *temp = root->right;\\n            free(root);\\n            return temp;\\n        }\\n        else if (root->right == NULL) // no right child\\n        {\\n    \\t\\tstruct TreeNode *temp = root->left;\\n    \\t\\tfree(root);\\n    \\t\\treturn temp;\\n        }\\n        \\n        // if there are two children:\\n        // find successor, exchange values and remove the one we exchanged\\n        struct TreeNode * temp = minValueNode(root->right);\\n        root->val = temp->val;\\n \\n        root->right = deleteNode(root->right, temp->val);\\n    }\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// help function to find following number\\nstruct TreeNode* minValueNode(struct TreeNode * node)\\n{\\n\\tstruct TreeNode * current = node;\\n    while (current && current->left != NULL)\\n        current = current->left;\\n \\n    return current;\\n}\\n\\nstruct TreeNode* deleteNode(struct TreeNode* root, int key)\\n{\\n\\tif (!root)\\n\\t\\treturn root;\\n \\n    // find node to remove\\n    if (key < root->val)\\n        root->left = deleteNode(root->left, key);\\n\\n  \\telse if (key > root->val)\\n        root->right = deleteNode(root->right, key);\\n\\n    // node found\\n    else\\n    {\\n        if (root->left == NULL) // no left child\\n        {\\n            struct TreeNode *temp = root->right;\\n            free(root);\\n            return temp;\\n        }\\n        else if (root->right == NULL) // no right child\\n        {\\n    \\t\\tstruct TreeNode *temp = root->left;\\n    \\t\\tfree(root);\\n    \\t\\treturn temp;\\n        }\\n        \\n        // if there are two children:\\n        // find successor, exchange values and remove the one we exchanged\\n        struct TreeNode * temp = minValueNode(root->right);\\n        root->val = temp->val;\\n \\n        root->right = deleteNode(root->right, temp->val);\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274735,
                "title": "450-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. If the root is None, return None.\\n2. If the key to be deleted is less than the root\\'s key, then recursively call the function with the left subtree as the new root.\\n3. If the key to be deleted is greater than the root\\'s key, then recursively call the function with the right subtree as the new root.\\n4. If the key to be deleted is equal to the root\\'s key:\\n    1. If the root has no child or only one child, replace the root with its child (if any).\\n    2. If the root has two children, find the inorder successor of the root (i.e., the smallest value in the right subtree). Set the value of the root to be the value of the inorder successor. Recursively call the function to delete the inorder successor from the right subtree.\\n5. Return the modified root.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        \\n        # If the root is None, return None\\n        if not root:\\n            return None\\n        \\n        # If the key to be deleted is less than the root\\'s key,\\n        # then the function is recursively called with the left subtree\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        # If the key to be deleted is greater than the root\\'s key,\\n        # then the function is recursively called with the right subtree\\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        else:\\n            # If the root has no child or only one child, then the root is replaced with its child\\n            if not root.left:\\n                return root.right\\n            elif not root.right:\\n                return root.left\\n            # If the root has two children, then the inorder successor of the root is found\\n            else:\\n                node = root.right\\n                while node.left:\\n                    node = node.left\\n                # The value of the inorder successor is copied to the root\\n                root.val = node.val\\n                # The inorder successor is then deleted from the right subtree of the root\\n                root.right = self.deleteNode(root.right, node.val)\\n        \\n        return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        \\n        # If the root is None, return None\\n        if not root:\\n            return None\\n        \\n        # If the key to be deleted is less than the root\\'s key,\\n        # then the function is recursively called with the left subtree\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        # If the key to be deleted is greater than the root\\'s key,\\n        # then the function is recursively called with the right subtree\\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        else:\\n            # If the root has no child or only one child, then the root is replaced with its child\\n            if not root.left:\\n                return root.right\\n            elif not root.right:\\n                return root.left\\n            # If the root has two children, then the inorder successor of the root is found\\n            else:\\n                node = root.right\\n                while node.left:\\n                    node = node.left\\n                # The value of the inorder successor is copied to the root\\n                root.val = node.val\\n                # The inorder successor is then deleted from the right subtree of the root\\n                root.right = self.deleteNode(root.right, node.val)\\n        \\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167397,
                "title": "intuitive-approach",
                "content": "Given a BST, comparing key to the value of current node, we can exclude a subtree. That keeps reducing the problem until `root.val == key`.\\n\\nTo delete a node in a BST, there are 3 cases (please note that the return value of the function deleteNode is the root of the tree after deletion):\\n- Node to be removed has no children, return null.\\n- Node to be removed has one child, return root.right if root.left is null, or return root.left if root.right is null.\\n- Node to be removed has two children, \\n ```\\n Take the BST below for example, T1 and T2 are two subtrees of x (they are also BSTs), and we are about to delete x,\\n    x\\n  /   \\\\\\n T1   T2\\n \\n ```\\n Assuming **the minimum node** of T2 is `y`, we should replce`x` with `y`. So set `x.val = y.val`.\\n \\n The problem reduces to **delete y in T2**, which will return the root of T2 after deletion, `z`.\\n \\n Lastly, `x.right = z` will make a BST.\\n \\n To get **the minimum node** of T2, we trace down to the leftmost node.\\n\\n\\n**Code**\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        if (root.val == key) {\\n            if (root.left == null && root.right == null) {\\n                return null;\\n            } else if (root.left == null) {\\n                return root.right;\\n            } else if (root.right == null) {\\n                return root.left;\\n            } else {\\n                TreeNode minNode = getMinNode(root.right);\\n                root.val = minNode.val;\\n                root.right = deleteNode(root.right, minNode.val);\\n            }\\n        } else if (root.val > key) {\\n            root.left = deleteNode(root.left, key);\\n        } else {\\n            root.right = deleteNode(root.right, key);\\n        }\\n        return root;\\n    }\\n    \\n    private TreeNode getMinNode(TreeNode root) {\\n        TreeNode minNode = root;\\n        while (minNode.left != null) {\\n            minNode = minNode.left;\\n        }\\n        return minNode;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n Take the BST below for example, T1 and T2 are two subtrees of x (they are also BSTs), and we are about to delete x,\\n    x\\n  /   \\\\\\n T1   T2\\n \\n ```\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        if (root.val == key) {\\n            if (root.left == null && root.right == null) {\\n                return null;\\n            } else if (root.left == null) {\\n                return root.right;\\n            } else if (root.right == null) {\\n                return root.left;\\n            } else {\\n                TreeNode minNode = getMinNode(root.right);\\n                root.val = minNode.val;\\n                root.right = deleteNode(root.right, minNode.val);\\n            }\\n        } else if (root.val > key) {\\n            root.left = deleteNode(root.left, key);\\n        } else {\\n            root.right = deleteNode(root.right, key);\\n        }\\n        return root;\\n    }\\n    \\n    private TreeNode getMinNode(TreeNode root) {\\n        TreeNode minNode = root;\\n        while (minNode.left != null) {\\n            minNode = minNode.left;\\n        }\\n        return minNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385366,
                "title": "very-easy-to-understand",
                "content": "**\\u82E5\\u8981\\u5220\\u9664\\u7684\\u5F53\\u524D\\u8282\\u70B9\\u4E3A\\u672C\\u8EAB\\u4E14\\u4E3A\\u53F6\\u5B50\\u8282\\u70B9\\uFF0C\\u53EF\\u4EE5\\u5C06\\u81EA\\u8EAB\\u7F6E\\u4E3A\\u7A7A\\u3002**\\n**\\u82E5\\u8981\\u5220\\u9664\\u7684\\u5F53\\u524D\\u8282\\u70B9\\u5176\\u53EA\\u6709\\u4E00\\u68F5\\u5B50\\u6811\\uFF08\\u5DE6\\u5B50\\u6811\\u6216\\u53F3\\u5B50\\u6811\\uFF09\\uFF0C\\u5219\\u5C06\\u5F53\\u524D\\u8282\\u70B9\\u6307\\u5411\\u90A3\\u4E00\\u68F5\\u5B50\\u6811\\uFF08\\u5DE6\\u5B50\\u6811\\u6216\\u53F3\\u5B50\\u6811\\uFF09**\\n**\\u82E5\\u8981\\u5220\\u9664\\u7684\\u5F53\\u524D\\u8282\\u70B9\\u7684\\u5DE6\\u53F3\\u5B50\\u6811\\u90FD\\u5B58\\u5728\\uFF0C\\u5219\\u5C06\\u53F3\\u5B50\\u6811\\u7684\\u6700\\u5DE6\\u8282\\u70B9\\u7684\\u503C\\u8D4B\\u503C\\u7ED9\\u5F53\\u524D\\u8282\\u70B9\\uFF08\\u5373\\u53F3\\u5B50\\u6811\\u7684\\u6700\\u5DE6\\u8282\\u70B9\\u505A\\u4E3A\\u6839\\uFF09\\uFF0C\\u6216\\u8005\\u662F\\u5C06\\u5DE6\\u5B50\\u6811\\u7684\\u6700\\u53F3\\u8282\\u70B9\\u7684\\u503C\\u8D4B\\u503C\\u7ED9\\u5F53\\u524D\\u8282\\u70B9\\uFF08\\u5373\\u5DE6\\u5B50\\u6811\\u7684\\u6700\\u53F3\\u8282\\u70B9\\u505A\\u4E3A\\u6839\\uFF09\\uFF0C\\u6B64\\u65F6\\u518D\\u5220\\u9664\\u53F3\\u5B50\\u6811\\u7684\\u6700\\u5DE6\\u8282\\u70B9\\u6216\\u5DE6\\u5B50\\u6811\\u7684\\u6700\\u53F3\\u8282\\u70B9\\u3002**\\n\\n```java\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        if(root.val > key) {root.left=deleteNode(root.left,key);}\\n        else if(root.val < key) {root.right=deleteNode(root.right,key);}\\n        else {\\n            if(root.left==null || root.right==null){//\\u5DE6\\u8282\\u70B9\\u6216\\u53F3\\u8282\\u70B9\\u4E3A\\u7A7A\\uFF0C\\u6216\\u4E3A\\u53F6\\u5B50\\u8282\\u70B9\\n                root=(root.left==null) ? root.right : root.left;\\n            }else{//\\u5DE6\\u3001\\u53F3\\u8282\\u70B9\\u90FD\\u4E0D\\u4E3A\\u7A7A\\u7684\\u60C5\\u51B5\\u4E0B\\uFF0C\\u5BFB\\u627E\\u53F3\\u5B50\\u6811\\u7684\\u6700\\u5DE6\\u8282\\u70B9\\u8D4B\\u503C\\u7ED9\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u518D\\u5C06\\u53F3\\u5B50\\u6811\\u7684\\u6700\\u5DE6\\u8282\\u70B9\\u5220\\u9664\\n                TreeNode curNode=root.right;\\n                while(curNode.left!=null) curNode=curNode.left;\\n                root.val=curNode.val;\\n                root.right=deleteNode(root.right,curNode.val);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        if(root.val > key) {root.left=deleteNode(root.left,key);}\\n        else if(root.val < key) {root.right=deleteNode(root.right,key);}\\n        else {\\n            if(root.left==null || root.right==null){//\\u5DE6\\u8282\\u70B9\\u6216\\u53F3\\u8282\\u70B9\\u4E3A\\u7A7A\\uFF0C\\u6216\\u4E3A\\u53F6\\u5B50\\u8282\\u70B9\\n                root=(root.left==null) ? root.right : root.left;\\n            }else{//\\u5DE6\\u3001\\u53F3\\u8282\\u70B9\\u90FD\\u4E0D\\u4E3A\\u7A7A\\u7684\\u60C5\\u51B5\\u4E0B\\uFF0C\\u5BFB\\u627E\\u53F3\\u5B50\\u6811\\u7684\\u6700\\u5DE6\\u8282\\u70B9\\u8D4B\\u503C\\u7ED9\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u518D\\u5C06\\u53F3\\u5B50\\u6811\\u7684\\u6700\\u5DE6\\u8282\\u70B9\\u5220\\u9664\\n                TreeNode curNode=root.right;\\n                while(curNode.left!=null) curNode=curNode.left;\\n                root.val=curNode.val;\\n                root.right=deleteNode(root.right,curNode.val);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662566,
                "title": "easy-explained-java-100-recursion",
                "content": "# Intuition\\nAs we know that in a `BST(Binary Search Tree)`, all elements in the left are smaller than root & all elements in the right are bigger than root, we follow this approach.\\n\\n# Approach\\n1. If the root is null, it means the tree is empty, so we return null as there is nothing to delete.\\n2. If the key we want to delete is less than the root\\'s value, we recursively call the deleteNode function on the left subtree. This ensures that we traverse the left side of the tree to find the node with the key to be deleted.\\n3. If the key is greater than the root\\'s value, we recursively call the deleteNode function on the right subtree. This ensures that we traverse the right side of the tree to find the node with the key to be deleted.\\n4. If the key is equal to the root\\'s value, we have found the node to be deleted. We handle three cases:\\n- If the node has no left child, we return its right child, effectively replacing the node with its right child.\\n- If the node has no right child, we return its left child, effectively replacing the node with its left child.\\n- If the node has both left and right children, we find the minimum value in its right subtree (the leftmost node in the right subtree) and replace the value of the current node with that minimum value. Then, we recursively delete that minimum node from the right subtree.\\n5. Finally, we return the root of the modified tree.\\n\\n# Complexity\\n- Time complexity: `O(log N)`\\nThe time complexity of the given code is O(log N) on average for a balanced binary search tree (BST), and O(N) in the worst case for a skewed tree.\\n\\n- Space complexity: `O(log N)`\\nThe space complexity is O(log N) on average for the recursive calls, and O(N) in the worst case for a skewed tree.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(key < root.val)\\n            root.left = deleteNode(root.left, key);\\n        else if(key > root.val)\\n            root.right = deleteNode(root.right, key);\\n        else{\\n            if(root.left==null) return root.right;\\n            else if(root.right==null) return root.left;\\n            root.val = minVal(root.right);\\n            root.right = deleteNode(root.right, root.val);\\n        }\\n        return root;\\n    }\\n\\n    public int minVal(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }return min;\\n    }\\n}\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/18d7fc91-b551-47c9-8721-eed3875dc88c_1687281601.63096.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(key < root.val)\\n            root.left = deleteNode(root.left, key);\\n        else if(key > root.val)\\n            root.right = deleteNode(root.right, key);\\n        else{\\n            if(root.left==null) return root.right;\\n            else if(root.right==null) return root.left;\\n            root.val = minVal(root.right);\\n            root.right = deleteNode(root.right, root.val);\\n        }\\n        return root;\\n    }\\n\\n    public int minVal(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618511,
                "title": "c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursively search for node to be deleted.\\n\\nOnce we find the node to be deleted, \\n\\n- If the root is a leaf node, then return NULL. (Base Case).\\n- Else if the root has only the left child, then we delete the root node and return its left child.\\n- Else if the root has only the right child, then we delete the root node and return its right child.\\n- Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(H)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(H)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int val) {\\n        if (!root) return root;\\n        \\n        if (val < root->val) {\\n            root->left = deleteNode(root->left, val);\\n        } else if (val > root->val) {\\n            root->right = deleteNode(root->right, val);\\n        } else {\\n            if (!root->left && !root->right) {\\n                delete(root);\\n                return NULL;\\n            }\\n            if (!root->left || !root->right) {\\n                TreeNode *ret = root->left ? root->left : root->right;\\n                delete(root);\\n                return ret;\\n            }\\n            if (root->left && root->right) {\\n                TreeNode *tmp = root->right;\\n                while (tmp->left) {\\n                    tmp = tmp->left;\\n                }\\n                root->val = tmp->val;\\n                // Here we call again to delete inorder successor\\n                root->right = deleteNode(root->right, tmp->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.**\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int val) {\\n        if (!root) return root;\\n        \\n        if (val < root->val) {\\n            root->left = deleteNode(root->left, val);\\n        } else if (val > root->val) {\\n            root->right = deleteNode(root->right, val);\\n        } else {\\n            if (!root->left && !root->right) {\\n                delete(root);\\n                return NULL;\\n            }\\n            if (!root->left || !root->right) {\\n                TreeNode *ret = root->left ? root->left : root->right;\\n                delete(root);\\n                return ret;\\n            }\\n            if (root->left && root->right) {\\n                TreeNode *tmp = root->right;\\n                while (tmp->left) {\\n                    tmp = tmp->left;\\n                }\\n                root->val = tmp->val;\\n                // Here we call again to delete inorder successor\\n                root->right = deleteNode(root->right, tmp->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569785,
                "title": "recursion-c-full-optimized-bst-well-explained",
                "content": "# Dont Afraid Its Easy \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee what we did :-\\n- if root is NULL then return NULL.ok!\\n- if key found then there will be 4 cases,lets see\\n  - it is the leaf node as left and right are null both\\n  - left node has value but right is null\\n  - right node has value but left is null\\n  - last one both has value !\\n- now just do the recussion as if key is smaller than node search in left and if bigger the in right \\n- **DONE!!!**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int maz(TreeNode*root)\\n    {\\n    \\n    \\n        while(root->right!=nullptr)\\n        {\\n            root=root->right;\\n\\n        }\\n        return root->val;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        if(root->val==key)\\n        {\\n            if(root->left==NULL&&root->right==NULL)\\n            {\\n                return NULL;\\n            }\\n            else if(root->left!=NULL&&root->right==NULL)\\n            {\\n                TreeNode*child=root->left;\\n                return child;\\n            }\\n            else if(root->right!=NULL&&root->left==NULL)\\n            {\\n                TreeNode*child=root->right;\\n                return child;\\n            }\\n            else\\n            {\\n                int leftmax=maz(root->left);\\n                \\n                root->val=leftmax;\\n                root->left=deleteNode(root->left,leftmax);\\n                return root;\\n            }\\n        }\\n        else if(root->val>key)\\n        {\\n            root->left=deleteNode(root->left,key);\\n        }\\n        else if(root->val<key)\\n        {\\n            root->right=deleteNode(root->right,key);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/0250d814-22d9-4081-bb6f-28a94bbbe700_1685223573.1419146.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maz(TreeNode*root)\\n    {\\n    \\n    \\n        while(root->right!=nullptr)\\n        {\\n            root=root->right;\\n\\n        }\\n        return root->val;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        if(root->val==key)\\n        {\\n            if(root->left==NULL&&root->right==NULL)\\n            {\\n                return NULL;\\n            }\\n            else if(root->left!=NULL&&root->right==NULL)\\n            {\\n                TreeNode*child=root->left;\\n                return child;\\n            }\\n            else if(root->right!=NULL&&root->left==NULL)\\n            {\\n                TreeNode*child=root->right;\\n                return child;\\n            }\\n            else\\n            {\\n                int leftmax=maz(root->left);\\n                \\n                root->val=leftmax;\\n                root->left=deleteNode(root->left,leftmax);\\n                return root;\\n            }\\n        }\\n        else if(root->val>key)\\n        {\\n            root->left=deleteNode(root->left,key);\\n        }\\n        else if(root->val<key)\\n        {\\n            root->right=deleteNode(root->right,key);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421600,
                "title": "java-100-faster-easiest-till-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) where h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/735f6394-f04c-4b44-9820-279d903d13cd_1681614531.367072.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        // Base case: if the root is null, the key is not found in the tree\\n        if(root == null){\\n            return root;\\n        }\\n    \\n        // Recursively search for the key in the left subtree if it is less than the root value\\n        if(key < root.val){\\n            root.left = deleteNode(root.left, key);\\n        }\\n\\n        // Recursively search for the key in the right subtree if it is greater than the root value\\n        else if(key > root.val){\\n            root.right = deleteNode(root.right, key);\\n        }\\n\\n        // If the key is equal to the root value, we have found the node to be deleted\\n        else{\\n\\n            // Case 1: If the node has no children, we simply set the root to null\\n            if(root.left == null && root.right == null){\\n                root = null;\\n            }\\n\\n            // Case 2: If the node has only one child, we replace the root with the child\\n            else if(root.left == null){\\n                root = root.right;\\n            }\\n\\n            else if(root.right == null){\\n                root = root.left;\\n            }\\n            \\n            // Case 3: If the node has two children, we find the inorder successor of the node, \\n            // which is the node with the smallest value in the right subtree. We then replace \\n            // the value of the root with the value of the inorder successor, and recursively \\n            // delete the inorder successor node from the right subtree.\\n            else{\\n                TreeNode successor = findMin(root.right);\\n                root.val = successor.val;\\n                root.right = deleteNode(root.right, successor.val);\\n            }\\n        }\\n        // Return the updated root of the subtree\\n        return root;\\n    }\\n\\n    // Helper method to find the node with the minimum value in the subtree rooted at \"node\"\\n    private TreeNode findMin(TreeNode node){\\n        \\n        // Traverse down the left subtree until we reach a leaf node with no left child\\n        while(node.left != null){\\n            node = node.left;\\n        }\\n        // Return the node with the smallest value in the subtree\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        // Base case: if the root is null, the key is not found in the tree\\n        if(root == null){\\n            return root;\\n        }\\n    \\n        // Recursively search for the key in the left subtree if it is less than the root value\\n        if(key < root.val){\\n            root.left = deleteNode(root.left, key);\\n        }\\n\\n        // Recursively search for the key in the right subtree if it is greater than the root value\\n        else if(key > root.val){\\n            root.right = deleteNode(root.right, key);\\n        }\\n\\n        // If the key is equal to the root value, we have found the node to be deleted\\n        else{\\n\\n            // Case 1: If the node has no children, we simply set the root to null\\n            if(root.left == null && root.right == null){\\n                root = null;\\n            }\\n\\n            // Case 2: If the node has only one child, we replace the root with the child\\n            else if(root.left == null){\\n                root = root.right;\\n            }\\n\\n            else if(root.right == null){\\n                root = root.left;\\n            }\\n            \\n            // Case 3: If the node has two children, we find the inorder successor of the node, \\n            // which is the node with the smallest value in the right subtree. We then replace \\n            // the value of the root with the value of the inorder successor, and recursively \\n            // delete the inorder successor node from the right subtree.\\n            else{\\n                TreeNode successor = findMin(root.right);\\n                root.val = successor.val;\\n                root.right = deleteNode(root.right, successor.val);\\n            }\\n        }\\n        // Return the updated root of the subtree\\n        return root;\\n    }\\n\\n    // Helper method to find the node with the minimum value in the subtree rooted at \"node\"\\n    private TreeNode findMin(TreeNode node){\\n        \\n        // Traverse down the left subtree until we reach a leaf node with no left child\\n        while(node.left != null){\\n            node = node.left;\\n        }\\n        // Return the node with the smallest value in the subtree\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495729,
                "title": "python-dfs-o-h-clean-concise",
                "content": "**Idea**\\n- To solve binary tree problems, we should think `dfs` approach first.\\n- In this problem, it\\'s a BST, so:\\n\\t- All values in the left subtree are less than `root.val`\\n\\t- All values in the right subtree are greater than `root.val`\\n\\t- The left subtree is a BST.\\n\\t- The right subtree is also a BST.\\n- So if `key < root.val` then we recursive call `self.deleteNode(root.left, key)` while updating `root.left` point to new node (if have) as well.\\n- If `key > root.val` then we recursive call `self.deleteNode(root.right, key)` while updating `root.right` point to new node (if have) as well.\\n- Else `key == root.val` then\\n\\t- If `root.left == None` we replace `root` with `root.right`\\n\\t- Else if `root.right == None` we replace `root` with `root.left`.\\n\\t- Else, we need to replace with a successor or a predecessor of `root` node, here I choose to replace with a successor node, so\\n\\t\\t- `successor = self.findMinNode(root.right)`\\n\\t\\t- `root.val = successor.val` // Copy value of `successor` node to `root` node.\\n\\t\\t- `root.right = self.deleteNode(root.right, successor.val)` // Find and delete `successor` node.\\n```python\\nclass Solution:\\n    def findMinNode(self, root):\\n        while root.left != None:\\n            root = root.left\\n        return root\\n\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root == None: return None\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        else:\\n            # now, root.val == key\\n            if root.left == None:\\n                return root.right\\n            if root.right == None:\\n                return root.left\\n\\n            successor = self.findMinNode(root.right)\\n            root.val = successor.val\\n            root.right = self.deleteNode(root.right, successor.val)\\n        return root\\n```\\n**Complexity**\\n- Time: `O(H)`, where `H` is the height of the binary tree.\\n- Space: `O(H)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMinNode(self, root):\\n        while root.left != None:\\n            root = root.left\\n        return root\\n\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root == None: return None\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right, key)\\n        else:\\n            # now, root.val == key\\n            if root.left == None:\\n                return root.right\\n            if root.right == None:\\n                return root.left\\n\\n            successor = self.findMinNode(root.right)\\n            root.val = successor.val\\n            root.right = self.deleteNode(root.right, successor.val)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821532,
                "title": "delete-node-in-a-bst-java-0ms-beats-100-all-cases-with-explanation",
                "content": "Please do ask in comments if there is anything that you need help in. Will be more than happy to help. Do also post a better solution for the community, if someone does have (But please with explanation).\\n\\nWould request people to not be feared by seeing the number of lines, i have written extra lines of comments to be able to explain properly to all audiences in detail. Just give good 5-10 mins, you will get it, else i am always there to help.\\n\\n```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        return searchAndDeleteNode (root, key);\\n        \\n    }\\n    \\n    public TreeNode searchAndDeleteNode (TreeNode root, int key) {\\n        \\n        // If root node is null, return null;\\n        if (root == null)\\n            return null;\\n        \\n        // If root\\'s val is greater than key than search in the left tree.\\n        if (root.val > key) {\\n            \\n            root.left = searchAndDeleteNode (root.left, key);\\n            return root;\\n            \\n        // If root\\'s val is smaller than key than search in the right tree.\\n        } else if (root.val < key) {\\n            \\n            root.right = searchAndDeleteNode (root.right, key);\\n            return root;\\n        \\n        // If root\\'s val is the key to be deleted.\\n        } else {\\n            \\n            // If both left and right node of root is null, then simply delete this node.\\n            // We are in traversal of root node, we can delete it by returning null instead of root node.\\n            // Effectively having no more reference to this node in the tree.\\n            if (root.right == null && root.left == null)\\n                return null;\\n            \\n            // If there is some sub-tree or node on the left but nothing on the right, then we can return\\n            // root.left instead of root as root.left will be the next bigger element in the tree.\\n            // Or in other words root.left is the smallest element in the sub-tree of root, which deserves\\n            // to be put in root\\'s place after root is removed.\\n            if (root.right == null) {\\n              \\n                return root.left;\\n            \\n            // If right node of root is not null.\\n            // We have to handle case for if left is also null and if left is not null.\\n            } else {\\n                \\n                // If left node of right is null.\\n                // We know root.right is the next bigger element in the sub-tree\\n                // of root, so we have to return this instead of returning root. (Property of BST)\\n                // BUT, before returning we have to take care of left node of root, so we set root.left to\\n                // root.right.left, which initially null.\\n                if (root.right.left == null) {\\n                    \\n                    root.right.left = root.left;\\n                    return root.right;\\n                \\n                // If left node of right is not null.\\n                // We can get the next bigger element in the sub-tree of root by going to the extreme left\\n                // node from root.right.\\n                // Now we have delete this new possible Node from it\\'s current reference position\\n                // And create a new node with this val as newRoot and refer root.left and root.right to\\n                // this newRoot.\\n                } else {\\n                \\n                    TreeNode current = root.right;\\n                    TreeNode parent = current;  // To delete the left node of parent and setting reference.\\n\\n\\t\\t\\t\\t\\t// Keep going to the left till we find the extreme left node.\\n                    while (current.left != null) {\\n\\n                        parent = current;\\n                        current = current.left;\\n\\n                    }\\n                    \\n                    // Reference to parent.left by recursively deleting this new possible node.\\n                    parent.left = searchAndDeleteNode (current, current.val);\\n\\n                    // New Root creation with current.val.\\n                    TreeNode newRoot = new TreeNode (current.val);\\n                    newRoot.left = root.left;\\n                    newRoot.right = root.right;\\n\\n                    return newRoot;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n```\\n\\nGood Test Cases :\\n[5,3,7,2,4,6,8,null,null,null,null]\\n3\\n[5,3,7,2,4,6,8,null,null,null,null]\\n5\\n[5,3,6,2,4,null,7]\\n3\\n[5,3,6,2,4,null,7]\\n5\\n[5,3,15,2,4,10,20,null,null,null,null,6,null,null,null,null,9,7]\\n5\\n[5,3,15,2,4,10,20,null,null,null,null,6,null,null,null,null,8,7]\\n5",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        return searchAndDeleteNode (root, key);\\n        \\n    }\\n    \\n    public TreeNode searchAndDeleteNode (TreeNode root, int key) {\\n        \\n        // If root node is null, return null;\\n        if (root == null)\\n            return null;\\n        \\n        // If root\\'s val is greater than key than search in the left tree.\\n        if (root.val > key) {\\n            \\n            root.left = searchAndDeleteNode (root.left, key);\\n            return root;\\n            \\n        // If root\\'s val is smaller than key than search in the right tree.\\n        } else if (root.val < key) {\\n            \\n            root.right = searchAndDeleteNode (root.right, key);\\n            return root;\\n        \\n        // If root\\'s val is the key to be deleted.\\n        } else {\\n            \\n            // If both left and right node of root is null, then simply delete this node.\\n            // We are in traversal of root node, we can delete it by returning null instead of root node.\\n            // Effectively having no more reference to this node in the tree.\\n            if (root.right == null && root.left == null)\\n                return null;\\n            \\n            // If there is some sub-tree or node on the left but nothing on the right, then we can return\\n            // root.left instead of root as root.left will be the next bigger element in the tree.\\n            // Or in other words root.left is the smallest element in the sub-tree of root, which deserves\\n            // to be put in root\\'s place after root is removed.\\n            if (root.right == null) {\\n              \\n                return root.left;\\n            \\n            // If right node of root is not null.\\n            // We have to handle case for if left is also null and if left is not null.\\n            } else {\\n                \\n                // If left node of right is null.\\n                // We know root.right is the next bigger element in the sub-tree\\n                // of root, so we have to return this instead of returning root. (Property of BST)\\n                // BUT, before returning we have to take care of left node of root, so we set root.left to\\n                // root.right.left, which initially null.\\n                if (root.right.left == null) {\\n                    \\n                    root.right.left = root.left;\\n                    return root.right;\\n                \\n                // If left node of right is not null.\\n                // We can get the next bigger element in the sub-tree of root by going to the extreme left\\n                // node from root.right.\\n                // Now we have delete this new possible Node from it\\'s current reference position\\n                // And create a new node with this val as newRoot and refer root.left and root.right to\\n                // this newRoot.\\n                } else {\\n                \\n                    TreeNode current = root.right;\\n                    TreeNode parent = current;  // To delete the left node of parent and setting reference.\\n\\n\\t\\t\\t\\t\\t// Keep going to the left till we find the extreme left node.\\n                    while (current.left != null) {\\n\\n                        parent = current;\\n                        current = current.left;\\n\\n                    }\\n                    \\n                    // Reference to parent.left by recursively deleting this new possible node.\\n                    parent.left = searchAndDeleteNode (current, current.val);\\n\\n                    // New Root creation with current.val.\\n                    TreeNode newRoot = new TreeNode (current.val);\\n                    newRoot.left = root.left;\\n                    newRoot.right = root.right;\\n\\n                    return newRoot;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586152,
                "title": "c-compact-recursive-solution-without-switching-values",
                "content": "I just merged subtrees - it means to use one of the subtrees instead of the node we just deleted.\\nThen find a proper place in that subtree to connect there the root of the second subtree.\\nFor example, we want to delete the node with value 5:\\n```\\n        1        ->          1          ->            1          ->            1\\n      /   \\\\                /   \\\\                    /   \\\\                    /   \\\\\\n    0      5              0                        0     7                  0     7\\n         /   \\\\                                          / \\\\                      / \\\\\\n        3     7            3        7            3     6   8                    6   8\\n       / \\\\   / \\\\          / \\\\      / \\\\          / \\\\                            /\\n      2   4 6   8        2   4    6   8        2   4                          3\\n                                                                             / \\\\\\n                                                                            2   4\\n```\\n\\nBetter approach is to find a successor value, swap the value and delete the successor.\\nLike this example (remove 5 from the same tree):\\nMake one step to the right from the node we are going to delete and then go till the leftmost leaf. Swap this leftmost node with node we are going to delete and delete it on the place of the leftmost leaf.\\n```\\n        1        ->          1        ->          1        ->          1\\n      /   \\\\                /   \\\\                /   \\\\                /   \\\\\\n    0      5              0     5              0     6              0     6\\n         /   \\\\                / \\u2191 \\\\                / \\u2191 \\\\                /   \\\\\\n        3     7              3     7              3     7              3     7\\n       / \\\\   / \\\\            / \\\\   / \\\\            / \\\\   / \\\\            / \\\\     \\\\\\n      2   4 6   8          2   4 6   8          2   4 5   8          2   4     8\\n                                 \\u2191                    \\u2191\\n```\\n\\nSecond approach is better in practice in terms of balancing trees.\\nBut it is a bit more tricky in realization so I decided to stick with the first approach in this task:\\n\\n```\\n    public TreeNode DeleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        if (root.val == key) return MergeTrees(root.right, root.left);\\n        \\n        if (key < root.val) root.left = DeleteNode(root.left, key);\\n        if (key > root.val) root.right = DeleteNode(root.right, key);\\n        return root;\\n    }\\n    \\n    private static TreeNode MergeTrees(TreeNode root, TreeNode node) {\\n        if (root == null || node == null) return root ?? node;\\n        \\n        if (node.val < root.val) root.left = MergeTrees(root.left, node);\\n        if (node.val > root.val) root.right = MergeTrees(root.right, node);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n        1        ->          1          ->            1          ->            1\\n      /   \\\\                /   \\\\                    /   \\\\                    /   \\\\\\n    0      5              0                        0     7                  0     7\\n         /   \\\\                                          / \\\\                      / \\\\\\n        3     7            3        7            3     6   8                    6   8\\n       / \\\\   / \\\\          / \\\\      / \\\\          / \\\\                            /\\n      2   4 6   8        2   4    6   8        2   4                          3\\n                                                                             / \\\\\\n                                                                            2   4\\n```\n```\\n        1        ->          1        ->          1        ->          1\\n      /   \\\\                /   \\\\                /   \\\\                /   \\\\\\n    0      5              0     5              0     6              0     6\\n         /   \\\\                / \\u2191 \\\\                / \\u2191 \\\\                /   \\\\\\n        3     7              3     7              3     7              3     7\\n       / \\\\   / \\\\            / \\\\   / \\\\            / \\\\   / \\\\            / \\\\     \\\\\\n      2   4 6   8          2   4 6   8          2   4 5   8          2   4     8\\n                                 \\u2191                    \\u2191\\n```\n```\\n    public TreeNode DeleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        if (root.val == key) return MergeTrees(root.right, root.left);\\n        \\n        if (key < root.val) root.left = DeleteNode(root.left, key);\\n        if (key > root.val) root.right = DeleteNode(root.right, key);\\n        return root;\\n    }\\n    \\n    private static TreeNode MergeTrees(TreeNode root, TreeNode node) {\\n        if (root == null || node == null) return root ?? node;\\n        \\n        if (node.val < root.val) root.left = MergeTrees(root.left, node);\\n        if (node.val > root.val) root.right = MergeTrees(root.right, node);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644338,
                "title": "easy-intuitive-solution-using-cases",
                "content": "# Intuition\\nWhen we delete a node, three cases may arise:\\n\\nNode to be deleted is leaf: Simply remove from the tree.\\n\\nNode to be deleted has only one child: Copy the child to the node and delete the child\\n \\nNode to be deleted has two children: Find inorder successor of the node. Copy contents of the inorder successor to the node and delete the inorder successor. Note that inorder predecessor can also be used.\\n\\n# Approach\\nfor the first two cases it is quiet easy to handle the cases , for a node with two childs we find the successor and replaces it with the node to be deleted , a successor can be found by going right once  and the leftmost child in the bst.\\n\\n# Complexity\\n- Time complexity:\\no(height of bst)\\n\\n- Space complexity:\\no(h) -> recursive space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getsuccessor(TreeNode* curr){\\n        curr= curr->right;\\n        while(curr && curr->left){\\n            curr= curr->left;\\n        }\\n        return curr;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if( root==NULL){\\n            return root;\\n        }\\n        if( root-> val > key){\\n            root-> left = deleteNode(root->left,key);\\n        }\\n        else if ( root-> val< key){\\n            root-> right = deleteNode(root->right,key);\\n        }\\n        else{\\n        if(root->left==NULL){\\n            TreeNode *temp=root->right;\\n            delete root;\\n            return temp;\\n        }\\n        else if(root->right==NULL){\\n            TreeNode *temp=root->left;\\n            delete root;\\n            return temp;\\n        }\\n        else{\\n            TreeNode *succ=getsuccessor(root);\\n            root->val=succ->val;\\n            root->right=deleteNode(root->right,succ->val);\\n        }\\n    }\\n    return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getsuccessor(TreeNode* curr){\\n        curr= curr->right;\\n        while(curr && curr->left){\\n            curr= curr->left;\\n        }\\n        return curr;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if( root==NULL){\\n            return root;\\n        }\\n        if( root-> val > key){\\n            root-> left = deleteNode(root->left,key);\\n        }\\n        else if ( root-> val< key){\\n            root-> right = deleteNode(root->right,key);\\n        }\\n        else{\\n        if(root->left==NULL){\\n            TreeNode *temp=root->right;\\n            delete root;\\n            return temp;\\n        }\\n        else if(root->right==NULL){\\n            TreeNode *temp=root->left;\\n            delete root;\\n            return temp;\\n        }\\n        else{\\n            TreeNode *succ=getsuccessor(root);\\n            root->val=succ->val;\\n            root->right=deleteNode(root->right,succ->val);\\n        }\\n    }\\n    return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698367,
                "title": "recursive-0ms-java-solution-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode inorderSuccessor(TreeNode root) {\\n        while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root;\\n    }\\n        \\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) {\\n            return null;\\n        }\\n        if(root.val > key) {\\n            root.left = deleteNode(root.left, key);\\n        } else if(root.val < key) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            // Case 1 -> No child, Delete Node, return null to parent\\n            if(root.left == null && root.right == null) {\\n                return null;\\n            } \\n            // Case 2 -> 1 child, Delete Node and replace with child node\\n            if(root.left == null) {\\n                return root.right;\\n            } else if(root.right == null) {\\n                return root.left;\\n            }\\n            // Case 3 -> 2 child, Replace value with inorder successor(leftmost node in right subtree), Delete the node for inorder successor\\n            TreeNode InorderSuccessor = inorderSuccessor(root.right);\\n            root.val = InorderSuccessor.val;\\n            root.right = deleteNode(root.right, InorderSuccessor.val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode inorderSuccessor(TreeNode root) {\\n        while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root;\\n    }\\n        \\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) {\\n            return null;\\n        }\\n        if(root.val > key) {\\n            root.left = deleteNode(root.left, key);\\n        } else if(root.val < key) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            // Case 1 -> No child, Delete Node, return null to parent\\n            if(root.left == null && root.right == null) {\\n                return null;\\n            } \\n            // Case 2 -> 1 child, Delete Node and replace with child node\\n            if(root.left == null) {\\n                return root.right;\\n            } else if(root.right == null) {\\n                return root.left;\\n            }\\n            // Case 3 -> 2 child, Replace value with inorder successor(leftmost node in right subtree), Delete the node for inorder successor\\n            TreeNode InorderSuccessor = inorderSuccessor(root.right);\\n            root.val = InorderSuccessor.val;\\n            root.right = deleteNode(root.right, InorderSuccessor.val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397990,
                "title": "faster-than-99-75-easy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n//we will move continuously to right for max value, from the left the of node having value equal to key value,    \\n    int max_val(TreeNode*root)\\n    {\\n        if(root->right==NULL)\\n            return root->val;\\n        return max_val(root->right);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val<key)\\n            root->right=deleteNode(root->right,key);\\n        else if(root->val>key)\\n            root->left=deleteNode(root->left,key);\\n        else \\n        {\\n\\t\\t//NODE WITH KEY VALUE FOUNDED.\\n            //node with key value have no childs.\\n            if(root->left==nullptr && root->right==nullptr)\\n                return NULL;\\n            \\n            else if(root->right!=nullptr && root->left!=nullptr)\\n            {\\n                //node with key value having both left and right child.\\n                //node having both childs will be replaced by the the max value of its left sub tree,\\n                //bcz, in the left subtree max value will have no right child.\\n                //and it will be easy to remove the nodes with zero or 1 child.\\n\\t\\t\\t\\t//YOU CAN ALSO GO WITH MINIMUM VALUE OF RIGHT SUB TREE.\\n\\t\\t\\t\\t\\n                int mx=max_val(root->left);\\n                root->val=mx;\\n                cout<<mx;\\n                root->left=deleteNode(root->left,mx);\\n                return root;\\n            }\\n            else\\n            {\\n                //node with key value having either left or right child only.\\n                if(root->right!=nullptr)\\n                    return root->right;\\n                else if(root->left!=nullptr)\\n                    return root->left;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//we will move continuously to right for max value, from the left the of node having value equal to key value,    \\n    int max_val(TreeNode*root)\\n    {\\n        if(root->right==NULL)\\n            return root->val;\\n        return max_val(root->right);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val<key)\\n            root->right=deleteNode(root->right,key);\\n        else if(root->val>key)\\n            root->left=deleteNode(root->left,key);\\n        else \\n        {\\n\\t\\t//NODE WITH KEY VALUE FOUNDED.\\n            //node with key value have no childs.\\n            if(root->left==nullptr && root->right==nullptr)\\n                return NULL;\\n            \\n            else if(root->right!=nullptr && root->left!=nullptr)\\n            {\\n                //node with key value having both left and right child.\\n                //node having both childs will be replaced by the the max value of its left sub tree,\\n                //bcz, in the left subtree max value will have no right child.\\n                //and it will be easy to remove the nodes with zero or 1 child.\\n\\t\\t\\t\\t//YOU CAN ALSO GO WITH MINIMUM VALUE OF RIGHT SUB TREE.\\n\\t\\t\\t\\t\\n                int mx=max_val(root->left);\\n                root->val=mx;\\n                cout<<mx;\\n                root->left=deleteNode(root->left,mx);\\n                return root;\\n            }\\n            else\\n            {\\n                //node with key value having either left or right child only.\\n                if(root->right!=nullptr)\\n                    return root->right;\\n                else if(root->left!=nullptr)\\n                    return root->left;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1048220,
                "title": "simple-java-iterative-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return null;        \\n        TreeNode curr = root, parent = null;\\n        \\n        // 1. Search the key\\n        while(curr != null && curr.val != key){\\n            parent = curr;\\n            if(key < curr.val) curr = curr.left;\\n            else curr = curr.right;            \\n        }\\n        \\n        // 2. Perform deletion\\n\\t\\t// When node to delete is root node\\n        if(parent == null) return delete(curr);\\n        \\n\\t\\t// When node to delete is the left child of parent\\n\\t\\tif(parent.left == curr) parent.left = delete(curr);\\n\\t\\t// When node to delete is the right child of parent\\t\\t\\n        else parent.right = delete(curr);\\n\\t\\t\\n        return root;\\n    }\\n    \\n    private TreeNode delete(TreeNode nodeToDelete){\\n\\t\\t// When there is no node-to-delete\\n        if(nodeToDelete == null) return null;\\n\\t\\t\\n\\t\\t// When node-to-delete has no left child then return right child\\n        if(nodeToDelete.left == null) return nodeToDelete.right;\\n\\n\\t\\t// When node-to-delete has no right child then return left child \\n        if(nodeToDelete.right == null) return nodeToDelete.left;\\n        \\n\\t\\t// When node-to-delete has both children, return the in-order successor\\n        TreeNode successor = nodeToDelete.right;\\n        TreeNode parent = null;\\n        while(successor.left != null){\\n            parent = successor;\\n            successor = successor.left;\\n        }\\n        // Assign left child of in-order successor to left child of node-to-delete\\n        successor.left = nodeToDelete.left; \\n        \\n\\t\\t// When in-order successor is not the immediate right child of node-to-delete, then we need to re-assign the in-order successor\\'s right child to its parent. \\n\\t\\t// Also assign right child of in-order successor to right child of node-to-delete\\n        if (successor != nodeToDelete.right){\\n            parent.left = successor.right;\\n            successor.right = nodeToDelete.right;\\n        }\\n        return successor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return null;        \\n        TreeNode curr = root, parent = null;\\n        \\n        // 1. Search the key\\n        while(curr != null && curr.val != key){\\n            parent = curr;\\n            if(key < curr.val) curr = curr.left;\\n            else curr = curr.right;            \\n        }\\n        \\n        // 2. Perform deletion\\n\\t\\t// When node to delete is root node\\n        if(parent == null) return delete(curr);\\n        \\n\\t\\t// When node to delete is the left child of parent\\n\\t\\tif(parent.left == curr) parent.left = delete(curr);\\n\\t\\t// When node to delete is the right child of parent\\t\\t\\n        else parent.right = delete(curr);\\n\\t\\t\\n        return root;\\n    }\\n    \\n    private TreeNode delete(TreeNode nodeToDelete){\\n\\t\\t// When there is no node-to-delete\\n        if(nodeToDelete == null) return null;\\n\\t\\t\\n\\t\\t// When node-to-delete has no left child then return right child\\n        if(nodeToDelete.left == null) return nodeToDelete.right;\\n\\n\\t\\t// When node-to-delete has no right child then return left child \\n        if(nodeToDelete.right == null) return nodeToDelete.left;\\n        \\n\\t\\t// When node-to-delete has both children, return the in-order successor\\n        TreeNode successor = nodeToDelete.right;\\n        TreeNode parent = null;\\n        while(successor.left != null){\\n            parent = successor;\\n            successor = successor.left;\\n        }\\n        // Assign left child of in-order successor to left child of node-to-delete\\n        successor.left = nodeToDelete.left; \\n        \\n\\t\\t// When in-order successor is not the immediate right child of node-to-delete, then we need to re-assign the in-order successor\\'s right child to its parent. \\n\\t\\t// Also assign right child of in-order successor to right child of node-to-delete\\n        if (successor != nodeToDelete.right){\\n            parent.left = successor.right;\\n            successor.right = nodeToDelete.right;\\n        }\\n        return successor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822263,
                "title": "python3-iterative-recursive",
                "content": "I see lots of people posting recursive solution which in my opinion is the right way to go. Just for fun, here is an iterative version which is way more cumbersome than a recursive implementation. \\n\\n```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        # search for node\\n        node = root\\n        parent = left = None\\n        while node:\\n            if node.val < key: parent, node, left = node, node.right, False\\n            elif node.val > key: parent, node, left = node, node.left, True\\n            else: break # found \\n        \\n        # delete the node \\n        if node: # if found \\n            if not node.left or not node.right: \\n                if parent: \\n                    if left: parent.left = node.left or node.right\\n                    else: parent.right = node.left or node.right\\n                else: return node.left or node.right\\n            else: \\n                temp = parent = node\\n                node = node.left \\n                if not node.right: parent.left = node.left\\n                else: \\n                    while node.right: parent, node = node, node.right\\n                    parent.right = node.left\\n                temp.val = node.val\\n        return root \\n```\\n\\n```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root: \\n            if root.val < key: root.right = self.deleteNode(root.right, key)\\n            elif root.val == key: \\n                if not root.left or not root.right: return root.left or root.right \\n                node = root.right \\n                while node.left: node = node.left \\n                root.val = node.val \\n                root.right = self.deleteNode(root.right, node.val)\\n            else: root.left = self.deleteNode(root.left, key)\\n        return root \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        # search for node\\n        node = root\\n        parent = left = None\\n        while node:\\n            if node.val < key: parent, node, left = node, node.right, False\\n            elif node.val > key: parent, node, left = node, node.left, True\\n            else: break # found \\n        \\n        # delete the node \\n        if node: # if found \\n            if not node.left or not node.right: \\n                if parent: \\n                    if left: parent.left = node.left or node.right\\n                    else: parent.right = node.left or node.right\\n                else: return node.left or node.right\\n            else: \\n                temp = parent = node\\n                node = node.left \\n                if not node.right: parent.left = node.left\\n                else: \\n                    while node.right: parent, node = node, node.right\\n                    parent.right = node.left\\n                temp.val = node.val\\n        return root \\n```\n```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root: \\n            if root.val < key: root.right = self.deleteNode(root.right, key)\\n            elif root.val == key: \\n                if not root.left or not root.right: return root.left or root.right \\n                node = root.right \\n                while node.left: node = node.left \\n                root.val = node.val \\n                root.right = self.deleteNode(root.right, node.val)\\n            else: root.left = self.deleteNode(root.left, key)\\n        return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271250,
                "title": "best-o-logn-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == key)\\n            return helper(root);\\n        TreeNode* curr = root;\\n        while (curr != NULL) {\\n            if (curr->val > key) {\\n                if (curr->left != NULL && curr->left->val == key) {\\n                    curr->left = helper(curr->left);\\n                    break;\\n                } else {\\n                    curr = curr->left;\\n                }\\n            } else {\\n                if (curr->right != NULL && curr->right->val == key) {\\n                    curr->right = helper(curr->right);\\n                    break;\\n                } else {\\n                    curr = curr->right;\\n                }\\n            }\\n        }    \\n        return root;\\n    }\\n\\n    TreeNode* helper(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL) \\n            return NULL;   \\n        if (root->left == NULL)\\n            return root->right;\\n        if (root->right == NULL)\\n            return root->left;\\n        TreeNode* rightChild = root->right;\\n        TreeNode* lastRight = findLastRight(root->left);\\n        lastRight->right = rightChild;\\n        return root->left;        \\n    }\\n\\n    TreeNode* findLastRight(TreeNode* root) {\\n        while (root->right != NULL)\\n            root = root->right;\\n        return root;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == key)\\n            return helper(root);\\n        TreeNode* curr = root;\\n        while (curr != NULL) {\\n            if (curr->val > key) {\\n                if (curr->left != NULL && curr->left->val == key) {\\n                    curr->left = helper(curr->left);\\n                    break;\\n                } else {\\n                    curr = curr->left;\\n                }\\n            } else {\\n                if (curr->right != NULL && curr->right->val == key) {\\n                    curr->right = helper(curr->right);\\n                    break;\\n                } else {\\n                    curr = curr->right;\\n                }\\n            }\\n        }    \\n        return root;\\n    }\\n\\n    TreeNode* helper(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL) \\n            return NULL;   \\n        if (root->left == NULL)\\n            return root->right;\\n        if (root->right == NULL)\\n            return root->left;\\n        TreeNode* rightChild = root->right;\\n        TreeNode* lastRight = findLastRight(root->left);\\n        lastRight->right = rightChild;\\n        return root->left;        \\n    }\\n\\n    TreeNode* findLastRight(TreeNode* root) {\\n        while (root->right != NULL)\\n            root = root->right;\\n        return root;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193859,
                "title": "6-line-very-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The first check is for an empty tree. If the root is NULL, indicating an empty tree, the function simply returns NULL since there are no nodes to delete.\\n\\nIf the key is smaller than the value of the current node (root->val < key), it means the node to delete must be in the right subtree. So, the deleteNode function is recursively called on the right subtree (root->right = deleteNode(root->right, key)).\\n\\nIf the key is larger than the value of the current node (root->val > key), it means the node to delete must be in the left subtree. So, the deleteNode function is recursively called on the left subtree (root->left = deleteNode(root->left, key)).\\n\\nIf the above conditions are not met, it means the current node\\'s value is equal to the key we want to delete. In this case, we check three scenarios:\\n\\na. Case 1: No child nodes (leaf node): If both the left and right children are NULL, we simply return NULL, indicating the node should be removed from the tree.\\n\\nb. Case 2: One child node: If one of the child nodes is NULL, we return the non-null child node, effectively replacing the current node with its child.\\n\\nc. Case 3: Two children nodes: If the node to be deleted has two children, we need to find a replacement node from the right subtree. We start by assigning the right child of the current node to a temporary variable temp.\\n\\nThen, we find the leftmost node in the right subtree of the current node by traversing down the left child of temp until we reach the leftmost node (while (temp->left)).\\nOnce we find the leftmost node, we assign the left child of the current node to the left child of temp, effectively connecting the left subtree of the current node to the left subtree of the replacement node.\\nFinally, we return the right child of the current node, replacing the current node with the replacement node.\\nThe function returns the updated root node of the BST after the deletion.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n       if( !root ) return NULL;\\n        if( root->val < key ) root->right = deleteNode(root->right, key);\\n        else if( root->val > key ) root->left = deleteNode(root->left, key);\\n        else{\\n            if( !root->right && !root->left ) return NULL;\\n            else if( !root->right ) return root->left;\\n            else if( !root->left ) return root->right;\\n            else{\\n                TreeNode* temp = root->right;\\n                while( temp->left ) temp = temp->left;\\n                temp->left = root->left;\\n                return root->right;\\n            }\\n        }\\n        return root;\\n           }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n       if( !root ) return NULL;\\n        if( root->val < key ) root->right = deleteNode(root->right, key);\\n        else if( root->val > key ) root->left = deleteNode(root->left, key);\\n        else{\\n            if( !root->right && !root->left ) return NULL;\\n            else if( !root->right ) return root->left;\\n            else if( !root->left ) return root->right;\\n            else{\\n                TreeNode* temp = root->right;\\n                while( temp->left ) temp = temp->left;\\n                temp->left = root->left;\\n                return root->right;\\n            }\\n        }\\n        return root;\\n           }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133570,
                "title": "c-java-recursive-solution-with-visualization-beginner-friendly",
                "content": "\\nThe problem is quite simple. \\nintuition - Just we need to is -:\\n1. Traverse in bst as we generally do if we found the key is greater than the root value then we need to move towards left and if we found the key is smaller than the root value then we need to move towards  right of the root.\\n2. Now If we found our key then either we shift right subtree of the key to the Rightmost node of the left subtree or we can shift the left subtree of the key to the Leftmost node of the right subtree and delete our current node.\\nHere we are doing the first one (If we found our key then we shift right subtree of the key to the Rightmost node of the left subtree and remove our current node).\\n\\n\\nTime Complexity - O(h)  where h is height of the tree\\nSpace Complexity  - O(1) \\n \\n\\n\\n\\nC++ code ->\\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n          if(root==NULL) return root;\\n          if(root->val==key) return getnode(root);\\n        \\n         TreeNode*curr = root;\\n         \\n         while(root!=NULL){\\n             \\n             if(root->val>key){\\n                 if(root->left!=NULL && root->left->val==key){\\n                     root->left = getnode(root->left);\\n                     break;\\n                 }\\n                 else{\\n                     root=root->left;\\n                 }\\n             }\\n             \\n             else{\\n                 if(root->right!=NULL && root->right->val==key){\\n                     root->right = getnode(root->right);\\n                     break;\\n                 }\\n                 else{\\n                     root=root->right;\\n                 }\\n             }\\n         }\\n        return curr;\\n    }\\n    \\n    TreeNode* getnode(TreeNode* root){\\n        if(root->left==NULL){\\n            return root->right;\\n        }\\n        if(root->right==NULL){\\n            return root->left;\\n        }\\n        \\n        TreeNode* rightChild = root->right;\\n        TreeNode* lastRight = getRightmostofleft(root->left);\\n        lastRight -> right = rightChild;\\n        \\n        return root->left;\\n        \\n    }\\n    \\n    TreeNode* getRightmostofleft(TreeNode* root){\\n        if(root->right==NULL){\\n            return root;\\n        }\\n        return getRightmostofleft(root->right);\\n    }\\n};\\n```\\n\\nJava Code -> \\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return root;\\n        if (root.val == key) return getNode(root);\\n\\n        TreeNode curr = root;\\n\\n        while (root != null) {\\n            if (root.val > key) {\\n                if (root.left != null && root.left.val == key) {\\n                    root.left = getNode(root.left);\\n                    break;\\n                } else {\\n                    root = root.left;\\n                }\\n            } else {\\n                if (root.right != null && root.right.val == key) {\\n                    root.right = getNode(root.right);\\n                    break;\\n                } else {\\n                    root = root.right;\\n                }\\n            }\\n        }\\n        return curr;\\n    }\\n\\n    public TreeNode getNode(TreeNode root) {\\n        if (root.left == null) {\\n            return root.right;\\n        }\\n        if (root.right == null) {\\n            return root.left;\\n        }\\n\\n        TreeNode rightChild = root.right;\\n        TreeNode lastRight = getRightmostOfLeft(root.left);\\n        lastRight.right = rightChild;\\n\\n        return root.left;\\n    }\\n\\n    public TreeNode getRightmostOfLeft(TreeNode root) {\\n        if (root.right == null) {\\n            return root;\\n        }\\n        return getRightmostOfLeft(root.right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n          if(root==NULL) return root;\\n          if(root->val==key) return getnode(root);\\n        \\n         TreeNode*curr = root;\\n         \\n         while(root!=NULL){\\n             \\n             if(root->val>key){\\n                 if(root->left!=NULL && root->left->val==key){\\n                     root->left = getnode(root->left);\\n                     break;\\n                 }\\n                 else{\\n                     root=root->left;\\n                 }\\n             }\\n             \\n             else{\\n                 if(root->right!=NULL && root->right->val==key){\\n                     root->right = getnode(root->right);\\n                     break;\\n                 }\\n                 else{\\n                     root=root->right;\\n                 }\\n             }\\n         }\\n        return curr;\\n    }\\n    \\n    TreeNode* getnode(TreeNode* root){\\n        if(root->left==NULL){\\n            return root->right;\\n        }\\n        if(root->right==NULL){\\n            return root->left;\\n        }\\n        \\n        TreeNode* rightChild = root->right;\\n        TreeNode* lastRight = getRightmostofleft(root->left);\\n        lastRight -> right = rightChild;\\n        \\n        return root->left;\\n        \\n    }\\n    \\n    TreeNode* getRightmostofleft(TreeNode* root){\\n        if(root->right==NULL){\\n            return root;\\n        }\\n        return getRightmostofleft(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return root;\\n        if (root.val == key) return getNode(root);\\n\\n        TreeNode curr = root;\\n\\n        while (root != null) {\\n            if (root.val > key) {\\n                if (root.left != null && root.left.val == key) {\\n                    root.left = getNode(root.left);\\n                    break;\\n                } else {\\n                    root = root.left;\\n                }\\n            } else {\\n                if (root.right != null && root.right.val == key) {\\n                    root.right = getNode(root.right);\\n                    break;\\n                } else {\\n                    root = root.right;\\n                }\\n            }\\n        }\\n        return curr;\\n    }\\n\\n    public TreeNode getNode(TreeNode root) {\\n        if (root.left == null) {\\n            return root.right;\\n        }\\n        if (root.right == null) {\\n            return root.left;\\n        }\\n\\n        TreeNode rightChild = root.right;\\n        TreeNode lastRight = getRightmostOfLeft(root.left);\\n        lastRight.right = rightChild;\\n\\n        return root.left;\\n    }\\n\\n    public TreeNode getRightmostOfLeft(TreeNode root) {\\n        if (root.right == null) {\\n            return root;\\n        }\\n        return getRightmostOfLeft(root.right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194187,
                "title": "c-recursive-bst-inorder",
                "content": "# Delete an node in a BST\\n* ## *Approach :*\\n1. search the key in BST. If the key is not there simply return root.\\n2. If key is present then we have 3 cases. They are\\n\\t1. \\tIf key has **no childs** (Leaf Node) then delete that node i.e  ` return NULL `.\\n\\t2. \\tIf key has **One child** then delete that node and replace with child node.\\n\\t\\t ` if(root->left==NULL) return root->right; `\\n\\t\\t ` if(root->right==NULL) return root->left; `\\n\\t3. If key has **Two childs** (Difficult and IMP) then replace with inorder successor and delete that node for inorder successor. Inorder Successor means left most node in right subtree.\\n\\n* ## *Code :*\\n```\\nTreeNode* inordersuccessor(TreeNode* root){\\n        if(root->left==NULL) return root;\\n        return inordersuccessor(root->left);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL) return root;\\n        if(root->val > key){\\n            root->left = deleteNode(root->left,key);\\n        }\\n        else if(root->val < key){\\n            root->right = deleteNode(root->right,key);\\n        }\\n        else{\\n            if(root->left==NULL && root->right==NULL){\\n                return NULL;\\n            }\\n            if(root->left==NULL) return root->right;\\n            else if(root->right==NULL) return root->left;\\n            \\n            TreeNode* inSucc=inordersuccessor(root->right);\\n            root->val = inSucc->val;\\n            root->right = deleteNode(root->right,inSucc->val);\\n        }\\n        return root;\\n    }\\n```\\n\\n* ## *Result :*\\n\\t85% Faster\\n## *Please Upvote if you like, comment if you have any suggestions. Thank You -_-*",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* inordersuccessor(TreeNode* root){\\n        if(root->left==NULL) return root;\\n        return inordersuccessor(root->left);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL) return root;\\n        if(root->val > key){\\n            root->left = deleteNode(root->left,key);\\n        }\\n        else if(root->val < key){\\n            root->right = deleteNode(root->right,key);\\n        }\\n        else{\\n            if(root->left==NULL && root->right==NULL){\\n                return NULL;\\n            }\\n            if(root->left==NULL) return root->right;\\n            else if(root->right==NULL) return root->left;\\n            \\n            TreeNode* inSucc=inordersuccessor(root->right);\\n            root->val = inSucc->val;\\n            root->right = deleteNode(root->right,inSucc->val);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1738496,
                "title": "python-iterative-recursive-beat-99-40-time-explained",
                "content": "There are five possible scenarios if the tree is not empty: \\n1.We can\\'t find such a node that has a value of `key` -> return root\\nIf we find the node, then we need to delete it ( let\\'s call it `node` for now)  and rearrange its subtree:\\n\\t 2. If both of its left and right child nodes are empty -> return `None`\\n\\t 3. If its left child node is empty and its right child is not -> use its right child node as the root of this new subtree -> return `node.right` \\n\\t 4. If its left child node is not empty and its right child is empty -> use its left child node as the root of this new subtree -> return `node.left` \\n\\t 5. If both of its left and right child nodes are not empty. The case is a little bit more complecated. Let me explain it:\\n\\t\\t From the definition of Binary Search Tree, we know that a `root` node\\'s value is larger than any nodes on its left subtree and smaller than any nodes on its right subtree. Also, a root node\\'s left child `root.left` is the largest of the root\\'s left subtree, and it is smaller than the smallest node of the root\\'s right subtree. The node with the smallest value on the right subtree is its leftmost leaf node. \\n\\t\\t Therefore, we should find the leftmost leaf node of the right subtree of the root (call it `cur`), and move the left subtree to be the left subtree of this node -> `cur.left = root.left`. Finally to delete the `node`, we return its right child node `node.right`.\\n\\t\\t \\nHere\\'s my code.\\n**Iterative**\\n```\\nclass Solution:\\n\\t#  remove the root of a tree\\n \\xA0 \\xA0def deleteCur(self, root):\\n\\t    # if it has no child nodes\\n \\xA0 \\xA0 \\xA0 \\xA0if not (root.right or root.left):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return None\\n\\t\\t# if it only has left child\\n \\xA0 \\xA0 \\xA0 \\xA0elif root.left and not root.right:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return root.left\\n\\t\\t# if it only has right child\\n \\xA0 \\xA0 \\xA0 \\xA0elif not root.left and root.right:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return root.right\\n\\t\\t# if it has both child nodes\\n \\xA0 \\xA0 \\xA0 \\xA0else:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0newRoot = cur = root.right\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0while cur.left:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur = cur.left\\n\\t\\t\\t# move the left subtree to be the left child of \\n\\t\\t\\t# the leftmost leaf node of the right subtree\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur.left = root.left\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return newRoot\\n\\t\\t\\t\\n \\xA0 \\xA0def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n \\xA0 \\xA0 \\xA0 \\xA0if not root:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return root\\n \\xA0 \\xA0 \\xA0 \\xA0elif root.val == key:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return self.deleteCur(root)\\n\\t\\t\\n\\t\\t# need two pointers to find \\n\\t\\t# the node to be deleted and its parent node.\\n \\xA0 \\xA0 \\xA0 \\xA0cur, prev = root, None\\n \\xA0 \\xA0 \\xA0 \\xA0while cur:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if cur.val > key:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev = cur\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur = cur.left\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0elif cur.val < key:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev = cur\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur = cur.right\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if prev.val > cur.val:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev.left = self.deleteCur(cur)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev.right = self.deleteCur(cur)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break\\n \\xA0 \\xA0 \\xA0 \\xA0return root\\n```\\n\\n\\n\\nRecursive:\\n```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root:\\n            return root\\n        \\n        if root.val == key:\\n            if not (root.right or root.left):\\n                del root\\n                return None\\n            \\n            elif root.left and not root.right:\\n                return root.left\\n            \\n            elif not root.left and root.right:\\n                return root.right\\n           \\n            else:\\n                NewRoot = cur = root.right\\n                while cur.left:\\n                    cur = cur.left\\n                cur.left = root.left\\n                \\n                return NewRoot\\n            \\n        if root.val > key: \\n            root.left = self.deleteNode(root.left,key)  # Recursion on left subtree\\n        if root.val < key: \\n            root.right = self.deleteNode(root.right,key)  # Recursion on right subtree\\n        return root\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n\\t#  remove the root of a tree\\n \\xA0 \\xA0def deleteCur(self, root):\\n\\t    # if it has no child nodes\\n \\xA0 \\xA0 \\xA0 \\xA0if not (root.right or root.left):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return None\\n\\t\\t# if it only has left child\\n \\xA0 \\xA0 \\xA0 \\xA0elif root.left and not root.right:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return root.left\\n\\t\\t# if it only has right child\\n \\xA0 \\xA0 \\xA0 \\xA0elif not root.left and root.right:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return root.right\\n\\t\\t# if it has both child nodes\\n \\xA0 \\xA0 \\xA0 \\xA0else:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0newRoot = cur = root.right\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0while cur.left:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur = cur.left\\n\\t\\t\\t# move the left subtree to be the left child of \\n\\t\\t\\t# the leftmost leaf node of the right subtree\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur.left = root.left\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return newRoot\\n\\t\\t\\t\\n \\xA0 \\xA0def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n \\xA0 \\xA0 \\xA0 \\xA0if not root:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return root\\n \\xA0 \\xA0 \\xA0 \\xA0elif root.val == key:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return self.deleteCur(root)\\n\\t\\t\\n\\t\\t# need two pointers to find \\n\\t\\t# the node to be deleted and its parent node.\\n \\xA0 \\xA0 \\xA0 \\xA0cur, prev = root, None\\n \\xA0 \\xA0 \\xA0 \\xA0while cur:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if cur.val > key:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev = cur\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur = cur.left\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0elif cur.val < key:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev = cur\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0cur = cur.right\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if prev.val > cur.val:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev.left = self.deleteCur(cur)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0else:\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0prev.right = self.deleteCur(cur)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break\\n \\xA0 \\xA0 \\xA0 \\xA0return root\\n```\n```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root:\\n            return root\\n        \\n        if root.val == key:\\n            if not (root.right or root.left):\\n                del root\\n                return None\\n            \\n            elif root.left and not root.right:\\n                return root.left\\n            \\n            elif not root.left and root.right:\\n                return root.right\\n           \\n            else:\\n                NewRoot = cur = root.right\\n                while cur.left:\\n                    cur = cur.left\\n                cur.left = root.left\\n                \\n                return NewRoot\\n            \\n        if root.val > key: \\n            root.left = self.deleteNode(root.left,key)  # Recursion on left subtree\\n        if root.val < key: \\n            root.right = self.deleteNode(root.right,key)  # Recursion on right subtree\\n        return root\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370320,
                "title": "98-faster",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-**\\n1. Search for the node to be deleted inside the tree.\\n2. If the node has no child , simply remove it.\\n3. If the node has only one child either to its left or right , its child will take its place and the node will be removed.\\n4. If the node has two children , then we have two options :-\\n(a) Find the maximum from its left subtree.\\n(b) Find the minimum from its right subtree.\\n5. Here , we will find the maximum from the left subtree and replace it with node value and delete it.\\n```\\nclass Solution {\\npublic:\\n    int find_max(TreeNode* root)\\n    {\\n        if(root -> right == NULL)\\n        {\\n            return root -> val;\\n        }\\n        else\\n        {\\n            return find_max(root -> right);\\n        }\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == NULL)\\n        {\\n            return NULL;\\n        }\\n        if(root -> val > key)\\n        {\\n           root -> left = deleteNode(root -> left , key);\\n        }\\n        else if(root -> val < key)\\n        {\\n            root -> right = deleteNode(root -> right , key);\\n        }\\n        else\\n        {\\n            if(root -> left == NULL && root -> right == NULL)\\n            {\\n                return NULL;\\n            }\\n            else if(root -> left != NULL && root -> right != NULL)\\n            {\\n                int ma = find_max(root -> left);\\n                root -> val = ma;\\n                root -> left = deleteNode(root -> left , ma);\\n                return root;\\n            }\\n            else if(root -> left != NULL)\\n            {\\n                return root -> left;\\n            }\\n            else if(root -> right != NULL)\\n            {\\n                return root -> right;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_max(TreeNode* root)\\n    {\\n        if(root -> right == NULL)\\n        {\\n            return root -> val;\\n        }\\n        else\\n        {\\n            return find_max(root -> right);\\n        }\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == NULL)\\n        {\\n            return NULL;\\n        }\\n        if(root -> val > key)\\n        {\\n           root -> left = deleteNode(root -> left , key);\\n        }\\n        else if(root -> val < key)\\n        {\\n            root -> right = deleteNode(root -> right , key);\\n        }\\n        else\\n        {\\n            if(root -> left == NULL && root -> right == NULL)\\n            {\\n                return NULL;\\n            }\\n            else if(root -> left != NULL && root -> right != NULL)\\n            {\\n                int ma = find_max(root -> left);\\n                root -> val = ma;\\n                root -> left = deleteNode(root -> left , ma);\\n                return root;\\n            }\\n            else if(root -> left != NULL)\\n            {\\n                return root -> left;\\n            }\\n            else if(root -> right != NULL)\\n            {\\n                return root -> right;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124875,
                "title": "100-faster-java-recursive-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null)return root;\\n        else if(root.val>key){\\n            root.left=deleteNode(root.left,key);\\n            \\n        }else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }else{\\n        //case1 leafnode\\n            if(root.right==null && root.left==null){\\n                root=null;\\n                return root;\\n            }\\n            // single sided node\\n            else if(root.right==null){\\n                TreeNode temp=root.left;\\n                root=null;\\n                return temp ;\\n            }else if(root.left==null){\\n                TreeNode temp=root.right;\\n                root=null;\\n                return temp;\\n            //sub complete bst\\n            }else{\\n               TreeNode temp=findmin(root.right);//we can also find for max in left sub tree\\n               root.val=temp.val;\\n               root.right=deleteNode(root.right,temp.val);\\n                \\n                \\n            }         \\n            \\n        }\\n        return root;\\n    }\\n    \\n    public TreeNode findmin(TreeNode root){\\n        while(root.left!=null){\\n            root=root.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null)return root;\\n        else if(root.val>key){\\n            root.left=deleteNode(root.left,key);\\n            \\n        }else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }else{\\n        //case1 leafnode\\n            if(root.right==null && root.left==null){\\n                root=null;\\n                return root;\\n            }\\n            // single sided node\\n            else if(root.right==null){\\n                TreeNode temp=root.left;\\n                root=null;\\n                return temp ;\\n            }else if(root.left==null){\\n                TreeNode temp=root.right;\\n                root=null;\\n                return temp;\\n            //sub complete bst\\n            }else{\\n               TreeNode temp=findmin(root.right);//we can also find for max in left sub tree\\n               root.val=temp.val;\\n               root.right=deleteNode(root.right,temp.val);\\n                \\n                \\n            }         \\n            \\n        }\\n        return root;\\n    }\\n    \\n    public TreeNode findmin(TreeNode root){\\n        while(root.left!=null){\\n            root=root.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821441,
                "title": "c-recursive-solution-o-height-of-tree-explained",
                "content": "After deleting a particular node in the BST, we have to make changes to left and right part of that node and add it to the upper nodes. That is what I have done, firstly we need to find the node which is to be deleted, after we find it, we have two options -\\n1) We can add the right part of the node(which is to be deleted, lets say it is A) at the rightmost node of the left part of A. or\\n2) We can add the left part of node A to leftmost node of right part of A.\\n\\nAfter we do any one of this we can return the modified node and reconstruct the tree. In the following implementation, I did the first option in the function Modify_node ,you can do the other way too by some small changes .\\nSince we move only to left or right, the time complexity is oviously O(height of tree).\\n```\\nclass Solution {\\npublic:\\n    TreeNode *Modify_node(TreeNode * &left, TreeNode *&right){\\n        if(left == nullptr)\\n            return right;\\n        left->right = Modify_node(left->right, right);\\n        return left;\\n    }\\n    TreeNode* deleteNode(TreeNode* &root, int key) {\\n        if(root == nullptr)\\n            return nullptr;\\n       if(root->val == key){\\n           return Modify_node(root->left, root->right);\\n       } \\n        if(root->val > key){\\n            root->left = deleteNode(root->left, key);\\n        }\\n        else\\n            root->right = deleteNode(root->right, key);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *Modify_node(TreeNode * &left, TreeNode *&right){\\n        if(left == nullptr)\\n            return right;\\n        left->right = Modify_node(left->right, right);\\n        return left;\\n    }\\n    TreeNode* deleteNode(TreeNode* &root, int key) {\\n        if(root == nullptr)\\n            return nullptr;\\n       if(root->val == key){\\n           return Modify_node(root->left, root->right);\\n       } \\n        if(root->val > key){\\n            root->left = deleteNode(root->left, key);\\n        }\\n        else\\n            root->right = deleteNode(root->right, key);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488800,
                "title": "javascript-95",
                "content": "```\\nvar deleteNode = function(root, key) {\\n    if (!root)\\n        return root;\\n    \\n    if (root.val === key){\\n        if (!root.left && !root.right){\\n            return null;\\n        } \\n        if (!root.right){\\n            return root.left;\\n        }\\n        const succ = inOrderSuccessor(root.right);\\n        root.val = succ.val;\\n        root.right = deleteNode(root.right, succ.val);\\n        return root;\\n    }\\n    \\n    if (key < root.val)\\n        root.left = deleteNode(root.left, key);\\n    if (key > root.val)\\n        root.right = deleteNode(root.right, key);\\n\\n    return root;\\n};\\n\\nconst inOrderSuccessor = (node) => {\\n    while(node.left) {\\n        node = node.left;\\n    }\\n    return node;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar deleteNode = function(root, key) {\\n    if (!root)\\n        return root;\\n    \\n    if (root.val === key){\\n        if (!root.left && !root.right){\\n            return null;\\n        } \\n        if (!root.right){\\n            return root.left;\\n        }\\n        const succ = inOrderSuccessor(root.right);\\n        root.val = succ.val;\\n        root.right = deleteNode(root.right, succ.val);\\n        return root;\\n    }\\n    \\n    if (key < root.val)\\n        root.left = deleteNode(root.left, key);\\n    if (key > root.val)\\n        root.right = deleteNode(root.right, key);\\n\\n    return root;\\n};\\n\\nconst inOrderSuccessor = (node) => {\\n    while(node.left) {\\n        node = node.left;\\n    }\\n    return node;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273890,
                "title": "concise-java-solution-easy-to-understand",
                "content": "```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n      if(root == null){\\n            return null;\\n        }\\n        \\n      if(root.val == key){\\n            if(root.right != null){\\n                TreeNode temp = root.right;\\n                  while(temp.left != null){\\n                      temp = temp.left;\\n                  }\\n                temp.left = root.left;\\n            }\\n            return root.right != null ? root.right : root.left;\\n        }else if(root.val > key){\\n            root.left = deleteNode(root.left, key);\\n        }else{\\n            root.right =  deleteNode(root.right, key);\\n        }\\n        return root;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n      if(root == null){\\n            return null;\\n        }\\n        \\n      if(root.val == key){\\n            if(root.right != null){\\n                TreeNode temp = root.right;\\n                  while(temp.left != null){\\n                      temp = temp.left;\\n                  }\\n                temp.left = root.left;\\n            }\\n            return root.right != null ? root.right : root.left;\\n        }else if(root.val > key){\\n            root.left = deleteNode(root.left, key);\\n        }else{\\n            root.right =  deleteNode(root.right, key);\\n        }\\n        return root;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93344,
                "title": "simplify-corner-cases-via-a-dummy-parent-of-the-root",
                "content": "We can quite simplify the logic by adding a dummy parent of the root. See the following concise iterative solution.\\n\\n```java\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n    TreeNode dummyRoot = new TreeNode(0), x = root, p = dummyRoot;\\n    dummyRoot.left = root;\\n\\n    while(x != null && x.val != key) {\\n        p = x;\\n        if (key < x.val) x = x.left;\\n        else x = x.right;\\n    }\\n    if (x != null && x.val == key) {\\n        if (x.left != null && x.right != null) {\\n            p = x;\\n            TreeNode y = x.right;\\n            for(; y.left != null; p = y, y = y.left); // empty for-body\\n            x.val = y.val;\\n            x = y; // Instead of deleting x, we delete y.\\n        }\\n\\n        // Now, at least one child of x must be null.\\n        TreeNode child = x.left != null ? x.left : x.right;\\n        if (p.left == x) p.left = child;\\n        else p.right = child;\\n    }\\n    return dummyRoot.left;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n    TreeNode dummyRoot = new TreeNode(0), x = root, p = dummyRoot;\\n    dummyRoot.left = root;\\n\\n    while(x != null && x.val != key) {\\n        p = x;\\n        if (key < x.val) x = x.left;\\n        else x = x.right;\\n    }\\n    if (x != null && x.val == key) {\\n        if (x.left != null && x.right != null) {\\n            p = x;\\n            TreeNode y = x.right;\\n            for(; y.left != null; p = y, y = y.left); // empty for-body\\n            x.val = y.val;\\n            x = y; // Instead of deleting x, we delete y.\\n        }\\n\\n        // Now, at least one child of x must be null.\\n        TreeNode child = x.left != null ? x.left : x.right;\\n        if (p.left == x) p.left = child;\\n        else p.right = child;\\n    }\\n    return dummyRoot.left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3361064,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nTreeNode* helper(TreeNode* root){\\n    if(root->left==NULL){\\n        return root->right;\\n    }\\n    else if(root->right==NULL){\\n        return root->left;\\n    }\\n    else{\\n    TreeNode* rightchild = root->right;\\n    TreeNode* lastright = find(root->left);\\n    lastright->right = rightchild;\\n    return root->left;\\n    } \\n}\\nTreeNode* find(TreeNode* root){\\n    if(root->right==NULL){\\n        return root;\\n    }\\n    return find(root->right);\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL){\\n            return root;\\n        }\\n        if(root->val==key){\\n            return helper(root);\\n        }\\n        TreeNode* cur = root;\\n        while(root!=NULL){\\n            if(root->val > key){\\n                if(root->left!=NULL && root->left->val==key){\\n                    root->left = helper(root->left);\\n                    break;\\n                }\\n                else{\\n                    root= root->left;\\n                }\\n            }\\n            else{\\n                if(root->right!=NULL && root->right->val==key){\\n                    root->right = helper(root->right);\\n                    break;\\n                }\\n                else{\\n                    root= root->right;\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        \\n        if key < root.val:\\n            root.left = self.deleteNode(root.left,key)\\n        \\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right,key)\\n        \\n        else:\\n            if root.left == None and root.right == None:\\n                return None\\n            \\n            if root.left == None:\\n                temp = root.right\\n                root = None\\n                return temp\\n\\n            if root.right == None:\\n                temp = root.left\\n                root = None\\n                return temp\\n            \\n            temp = self.minNode(root.right)\\n            root.val = temp.val\\n            root.right = self.deleteNode(root.right,temp.val)\\n\\n        return root\\n    \\n    def minNode(self,node):\\n        curr = node\\n\\n        while curr.left != None:\\n            curr = curr.left\\n\\n        return curr\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(key<root.val){\\n            root.left=deleteNode(root.left,key);\\n        }\\n        else if(key>root.val){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.left==null) return root.right;\\n            if(root.right==null) return root.left;\\n\\n            root.val=minvalue(root.right);//to find inorder succesor\\n\\n            root.right=deleteNode(root.right,root.val);\\n        }\\n        return root;\\n    }\\n    public int minvalue(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }\\n        return min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nTreeNode* helper(TreeNode* root){\\n    if(root->left==NULL){\\n        return root->right;\\n    }\\n    else if(root->right==NULL){\\n        return root->left;\\n    }\\n    else{\\n    TreeNode* rightchild = root->right;\\n    TreeNode* lastright = find(root->left);\\n    lastright->right = rightchild;\\n    return root->left;\\n    } \\n}\\nTreeNode* find(TreeNode* root){\\n    if(root->right==NULL){\\n        return root;\\n    }\\n    return find(root->right);\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL){\\n            return root;\\n        }\\n        if(root->val==key){\\n            return helper(root);\\n        }\\n        TreeNode* cur = root;\\n        while(root!=NULL){\\n            if(root->val > key){\\n                if(root->left!=NULL && root->left->val==key){\\n                    root->left = helper(root->left);\\n                    break;\\n                }\\n                else{\\n                    root= root->left;\\n                }\\n            }\\n            else{\\n                if(root->right!=NULL && root->right->val==key){\\n                    root->right = helper(root->right);\\n                    break;\\n                }\\n                else{\\n                    root= root->right;\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        \\n        if key < root.val:\\n            root.left = self.deleteNode(root.left,key)\\n        \\n        elif key > root.val:\\n            root.right = self.deleteNode(root.right,key)\\n        \\n        else:\\n            if root.left == None and root.right == None:\\n                return None\\n            \\n            if root.left == None:\\n                temp = root.right\\n                root = None\\n                return temp\\n\\n            if root.right == None:\\n                temp = root.left\\n                root = None\\n                return temp\\n            \\n            temp = self.minNode(root.right)\\n            root.val = temp.val\\n            root.right = self.deleteNode(root.right,temp.val)\\n\\n        return root\\n    \\n    def minNode(self,node):\\n        curr = node\\n\\n        while curr.left != None:\\n            curr = curr.left\\n\\n        return curr\\n```\n```Java []\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(key<root.val){\\n            root.left=deleteNode(root.left,key);\\n        }\\n        else if(key>root.val){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.left==null) return root.right;\\n            if(root.right==null) return root.left;\\n\\n            root.val=minvalue(root.right);//to find inorder succesor\\n\\n            root.right=deleteNode(root.right,root.val);\\n        }\\n        return root;\\n    }\\n    public int minvalue(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254593,
                "title": "simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* ExtremeRight(TreeNode* root){\\n        if(root->right == nullptr)\\n            return root;\\n        return ExtremeRight(root->right);\\n\\n    }\\n    TreeNode* helper(TreeNode* root){\\n        if(root->left == nullptr)\\n            return root->right;\\n        else if(root->right == nullptr)\\n            return root->left;\\n        \\n        TreeNode * rightChild = root->right;\\n        TreeNode* ErightChild = ExtremeRight(root->left);\\n        ErightChild ->right = rightChild ;\\n\\n        return root->left;\\n\\n    }\\n\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        TreeNode* dummy = root;\\n        if(root == nullptr){\\n            return root;\\n        }\\n        if(root->val == key){\\n            return helper(root);\\n        }\\n        while(root != nullptr){\\n            if(root->val < key){\\n                if(root->right != nullptr && root->right->val == key){\\n                    root->right = helper(root->right);\\n                    break;\\n            }\\n                else\\n                    root=root->right;\\n            }\\n            else{\\n                if(root->left != nullptr && root->left->val == key){\\n                    root->left = helper(root->left);\\n                    break;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n        return dummy;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* ExtremeRight(TreeNode* root){\\n        if(root->right == nullptr)\\n            return root;\\n        return ExtremeRight(root->right);\\n\\n    }\\n    TreeNode* helper(TreeNode* root){\\n        if(root->left == nullptr)\\n            return root->right;\\n        else if(root->right == nullptr)\\n            return root->left;\\n        \\n        TreeNode * rightChild = root->right;\\n        TreeNode* ErightChild = ExtremeRight(root->left);\\n        ErightChild ->right = rightChild ;\\n\\n        return root->left;\\n\\n    }\\n\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        TreeNode* dummy = root;\\n        if(root == nullptr){\\n            return root;\\n        }\\n        if(root->val == key){\\n            return helper(root);\\n        }\\n        while(root != nullptr){\\n            if(root->val < key){\\n                if(root->right != nullptr && root->right->val == key){\\n                    root->right = helper(root->right);\\n                    break;\\n            }\\n                else\\n                    root=root->right;\\n            }\\n            else{\\n                if(root->left != nullptr && root->left->val == key){\\n                    root->left = helper(root->left);\\n                    break;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n        return dummy;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113197,
                "title": "create-a-new-bst-without-considering-that-node-which-we-have-to-delete",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\n TreeNode* exe(vector<int> &nums, int i , int j){\\n    if(i>j)\\n    return NULL;\\nint mid=(i+j)/2;\\n   TreeNode* root= new TreeNode(nums[mid]); \\nroot->left=exe(nums,i,mid-1);\\nroot->right=exe(nums,mid+1,j);\\n\\nreturn root;\\n}\\n\\n vector<int> inorder(vector<int>& nums,TreeNode* root,int key) {\\n       if(root==NULL)\\n           return nums;\\n      inorder(nums,root->left,key);\\n      if(root->val !=key)\\n      nums.push_back(root->val);\\n      inorder(nums,root->right,key);\\n\\n      return nums;     \\n    } \\n TreeNode* deleteNode(TreeNode* root, int key) {\\n  if(root==NULL)\\n  return NULL;\\n     vector<int> nums;\\n     inorder(nums,root,key);\\n         return exe(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\n TreeNode* exe(vector<int> &nums, int i , int j){\\n    if(i>j)\\n    return NULL;\\nint mid=(i+j)/2;\\n   TreeNode* root= new TreeNode(nums[mid]); \\nroot->left=exe(nums,i,mid-1);\\nroot->right=exe(nums,mid+1,j);\\n\\nreturn root;\\n}\\n\\n vector<int> inorder(vector<int>& nums,TreeNode* root,int key) {\\n       if(root==NULL)\\n           return nums;\\n      inorder(nums,root->left,key);\\n      if(root->val !=key)\\n      nums.push_back(root->val);\\n      inorder(nums,root->right,key);\\n\\n      return nums;     \\n    } \\n TreeNode* deleteNode(TreeNode* root, int key) {\\n  if(root==NULL)\\n  return NULL;\\n     vector<int> nums;\\n     inorder(nums,root,key);\\n         return exe(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626908,
                "title": "java-100-faster-o-height-of-tree",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        // key not in tree\\n        if(root == null)\\n            return root;\\n        \\n        if(root.val > key)\\n            root.left = deleteNode(root.left , key);\\n        \\n        else if(root.val < key)\\n            root.right = deleteNode(root.right , key);\\n        \\n        // node with key , found\\n        else{\\n            // case1 - leaf node\\n            if(root.left == null && root.right == null)\\n                return null;\\n            \\n            // case2 - 1 child\\n            if(root.left == null)\\n                return root.right;\\n            \\n            else if(root.right == null)\\n                return root.left;\\n            \\n            // case3 - 2 child\\n            TreeNode next = nextInorderNode(root.right);\\n            root.val = next.val;\\n            root.right = deleteNode(root.right , next.val);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    static TreeNode nextInorderNode(TreeNode node){\\n        // find leftmost node \\n        \\n        while(node.left != null)\\n            node = node.left;\\n        \\n        return node;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        // key not in tree\\n        if(root == null)\\n            return root;\\n        \\n        if(root.val > key)\\n            root.left = deleteNode(root.left , key);\\n        \\n        else if(root.val < key)\\n            root.right = deleteNode(root.right , key);\\n        \\n        // node with key , found\\n        else{\\n            // case1 - leaf node\\n            if(root.left == null && root.right == null)\\n                return null;\\n            \\n            // case2 - 1 child\\n            if(root.left == null)\\n                return root.right;\\n            \\n            else if(root.right == null)\\n                return root.left;\\n            \\n            // case3 - 2 child\\n            TreeNode next = nextInorderNode(root.right);\\n            root.val = next.val;\\n            root.right = deleteNode(root.right , next.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2429211,
                "title": "simple-c-recursive-solution",
                "content": "```\\nclass Solution {\\n    int inorder_predecessor(TreeNode* root) {\\n        root = root->left;\\n        while(root->right) root = root->right;\\n        return root->val;\\n    }\\n    int inorder_successor(TreeNode* root) {\\n        root = root->right;\\n        while(root->left) root = root->left;\\n        return root->val;\\n    }\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n      if(!root) return root;\\n      if(key < root->val) root->left = deleteNode(root->left, key);\\n      else if(key > root->val) root->right = deleteNode(root->right, key);\\n      else {\\n          if(!root->left && !root->right) root = nullptr;\\n          else if(root->left){\\n              root->val = inorder_predecessor(root);   //Find inorder predecessor\\n              root->left = deleteNode(root->left, root->val);\\n          } else {\\n              root->val = inorder_successor(root);     //Find inorder successor\\n              root->right = deleteNode(root->right, root->val);\\n          }\\n       }\\n      return root;      \\n    }\\n};\\n```\\n**Please Upvote\\nthank you!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int inorder_predecessor(TreeNode* root) {\\n        root = root->left;\\n        while(root->right) root = root->right;\\n        return root->val;\\n    }\\n    int inorder_successor(TreeNode* root) {\\n        root = root->right;\\n        while(root->left) root = root->left;\\n        return root->val;\\n    }\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n      if(!root) return root;\\n      if(key < root->val) root->left = deleteNode(root->left, key);\\n      else if(key > root->val) root->right = deleteNode(root->right, key);\\n      else {\\n          if(!root->left && !root->right) root = nullptr;\\n          else if(root->left){\\n              root->val = inorder_predecessor(root);   //Find inorder predecessor\\n              root->left = deleteNode(root->left, root->val);\\n          } else {\\n              root->val = inorder_successor(root);     //Find inorder successor\\n              root->right = deleteNode(root->right, root->val);\\n          }\\n       }\\n      return root;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613038,
                "title": "c-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n      int max(TreeNode* root) {\\n  if (root->right != NULL) {\\n    return max(root->right);\\n  }\\n          else\\n          {\\n              return root->val;\\n          }\\n \\n} \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n     if(root == NULL)\\n     {\\n         return NULL;\\n     }\\n        if(key>root->val)\\n           {\\n               root->right = deleteNode(root->right,key);\\n           }\\n         else if(key<root->val)\\n           {\\n               root->left = deleteNode(root->left,key);\\n           }\\n        else\\n        {\\n            if(root->left != NULL && root->right != NULL)\\n            {\\n                int lmax = max(root->left);\\n                root->val = lmax;\\n                root->left = deleteNode(root->left,lmax);\\n                return root;\\n                    \\n            }\\n            else if(root->left != NULL)\\n            {\\n                return root->left;\\n            }\\n            else if(root->right != NULL)\\n            {\\n             return root->right;   \\n            }\\n            else\\n            {\\n                return NULL;\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n      int max(TreeNode* root) {\\n  if (root->right != NULL) {\\n    return max(root->right);\\n  }\\n          else\\n          {\\n              return root->val;\\n          }\\n \\n} \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n     if(root == NULL)\\n     {\\n         return NULL;\\n     }\\n        if(key>root->val)\\n           {\\n               root->right = deleteNode(root->right,key);\\n           }\\n         else if(key<root->val)\\n           {\\n               root->left = deleteNode(root->left,key);\\n           }\\n        else\\n        {\\n            if(root->left != NULL && root->right != NULL)\\n            {\\n                int lmax = max(root->left);\\n                root->val = lmax;\\n                root->left = deleteNode(root->left,lmax);\\n                return root;\\n                    \\n            }\\n            else if(root->left != NULL)\\n            {\\n                return root->left;\\n            }\\n            else if(root->right != NULL)\\n            {\\n             return root->right;   \\n            }\\n            else\\n            {\\n                return NULL;\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591048,
                "title": "python-solution-without-predecessor-and-successor",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root:\\n            return None\\n        left = root.left\\n        right = root.right\\n        if root.val == key:\\n            if right is None:\\n                root = left\\n                return root\\n            if left is None:\\n                root = right\\n                return root\\n            left_r = left\\n            while left_r.right:\\n                left_r = left_r.right\\n            left_r.right = right\\n            root = left\\n            return root\\n        if root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root:\\n            return None\\n        left = root.left\\n        right = root.right\\n        if root.val == key:\\n            if right is None:\\n                root = left\\n                return root\\n            if left is None:\\n                root = right\\n                return root\\n            left_r = left\\n            while left_r.right:\\n                left_r = left_r.right\\n            left_r.right = right\\n            root = left\\n            return root\\n        if root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590941,
                "title": "java-recursion-no-value-overwrite-node-swap-only",
                "content": "Thought I would add this just because I saw people asking about a swap-only solution (no value overwrite).\\n\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        \\n        if (root.val == key) {\\n            if (root.left == null) return root.right;\\n            if (root.right == null) return root.left;\\n            \\n            TreeNode tmp = root.left;\\n            root = root.right;\\n            \\n            TreeNode leftmost = root;\\n            while (leftmost.left != null) {\\n                leftmost = leftmost.left;\\n            }\\n            leftmost.left = tmp;\\n            return root;\\n        } else if (key < root.val) {\\n            root.left = deleteNode(root.left, key);    \\n        } else if (key > root.val) {\\n            root.right = deleteNode(root.right, key);    \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        \\n        if (root.val == key) {\\n            if (root.left == null) return root.right;\\n            if (root.right == null) return root.left;\\n            \\n            TreeNode tmp = root.left;\\n            root = root.right;\\n            \\n            TreeNode leftmost = root;\\n            while (leftmost.left != null) {\\n                leftmost = leftmost.left;\\n            }\\n            leftmost.left = tmp;\\n            return root;\\n        } else if (key < root.val) {\\n            root.left = deleteNode(root.left, key);    \\n        } else if (key > root.val) {\\n            root.right = deleteNode(root.right, key);    \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339739,
                "title": "c-solution-with-explanation",
                "content": "Please upvote if you understood .\\n\\n**Explanation :-\\nIn a Binary Search Tree Node Deletion we can\\'t simply delete the node directly . After finding the node and deleting it we need to maintain the BST property .\\nHere I am explaining the steps which is coded below :-\\n\\nS.1-> First compare the root value with that of the given Node to be deleted .\\n       - If the node value is less than root value then recursively go to left until node is found .\\n\\t   - If the node value is more than root value then recursively go to right until node is found.\\n\\nS.2 -> When the node to be deleted is found then :-\\n\\t\\t  - If the node don\\'t have any left subtree and right subtree or if the node is a leaf node than \\n\\t\\t    delete it directly .\\n\\t\\t  - If the node don\\'t have any left subtree then simply replace the right subtree with that \\n\\t\\t    node .\\n\\t\\t - If the node don\\'t have any right subtree then simply replace the left subtree with that node .\\n\\t\\t - Now if the node has both left and right subtree then\\n\\t\\t - Find the minimum value of the right subtree because we need to replace the right subtree as it is always suitable for the replacement in both the left and right side .\\n\\t\\t - Store the minimum value of the right subtree in the node and then recursively arrange all the child nodes of right subtree to that particular node .\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* findMin(TreeNode* root)\\n    {\\n        if(!root->left) \\n            return root;\\n        return findMin(root->left);\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n        if(!root) \\n            return NULL;\\n        if(root->val < key)\\n        {\\n            root->right = deleteNode(root->right, key);\\n        }\\n        else if(root->val > key)\\n        {\\n            root->left = deleteNode(root->left, key);\\n        }\\n        else\\n        {\\n            \\n            if(!root->left && !root->right)\\n            {\\n                delete root;\\n                root = NULL;\\n            }\\n            else if(!root->left)\\n            {\\n                TreeNode* temp = root;\\n                root = root->right;\\n                delete(temp);\\n            }\\n            else if(!root->right)\\n            {\\n                TreeNode* temp = root;\\n                root=root->left;\\n                delete temp;\\n            }\\n            else\\n            {\\n                TreeNode *temp = findMin(root->right); \\n                root->val = temp->val; \\n                root->right = deleteNode(root->right, temp->val); \\n            }\\n            \\n        }\\n        return root;\\n    }\\n};\\n```\\n  \\n\\n**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* findMin(TreeNode* root)\\n    {\\n        if(!root->left) \\n            return root;\\n        return findMin(root->left);\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n        if(!root) \\n            return NULL;\\n        if(root->val < key)\\n        {\\n            root->right = deleteNode(root->right, key);\\n        }\\n        else if(root->val > key)\\n        {\\n            root->left = deleteNode(root->left, key);\\n        }\\n        else\\n        {\\n            \\n            if(!root->left && !root->right)\\n            {\\n                delete root;\\n                root = NULL;\\n            }\\n            else if(!root->left)\\n            {\\n                TreeNode* temp = root;\\n                root = root->right;\\n                delete(temp);\\n            }\\n            else if(!root->right)\\n            {\\n                TreeNode* temp = root;\\n                root=root->left;\\n                delete temp;\\n            }\\n            else\\n            {\\n                TreeNode *temp = findMin(root->right); \\n                root->val = temp->val; \\n                root->right = deleteNode(root->right, temp->val); \\n            }\\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065282,
                "title": "easy-to-understand-recursive-c-solution-without-swapping-data",
                "content": "```\\n    TreeNode* getRightMostNode(TreeNode* root)\\n\\t{\\n         if(!root->right) { return root;  }\\n         return getRightMostNode(root->right);\\n    }\\n        \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) {  return root;   }\\n        if(root->val==key && !root->left && !root->right){   // only one node \\n            return NULL;\\n        }\\n        if(root->val>key){                        \\n            root->left = deleteNode(root->left,key);\\n        }\\n        else if(root->val<key){\\n            root->right = deleteNode(root->right,key);\\n        }\\n        else{                                    // means we have got the node\\n           if(!root->left) {  return root->right;  }\\n           else if(!root->right) {  return root->left;  }\\n           else{                                // means the node has both children     \\n              TreeNode* lst = root->left;\\n              TreeNode* rst = root->right;\\n              root->left=NULL,root->right=NULL;\\n              TreeNode* rightMostInLst = getRightMostNode(lst);   // finding maximum in left subtree\\n              rightMostInLst->right = rst; \\n              return lst;     \\n           } \\n        }\\n        return root;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n    TreeNode* getRightMostNode(TreeNode* root)\\n\\t{\\n         if(!root->right) { return root;  }\\n         return getRightMostNode(root->right);\\n    }\\n        \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) {  return root;   }\\n        if(root->val==key && !root->left && !root->right){   // only one node \\n            return NULL;\\n        }\\n        if(root->val>key){                        \\n            root->left = deleteNode(root->left,key);\\n        }\\n        else if(root->val<key){\\n            root->right = deleteNode(root->right,key);\\n        }\\n        else{                                    // means we have got the node\\n           if(!root->left) {  return root->right;  }\\n           else if(!root->right) {  return root->left;  }\\n           else{                                // means the node has both children     \\n              TreeNode* lst = root->left;\\n              TreeNode* rst = root->right;\\n              root->left=NULL,root->right=NULL;\\n              TreeNode* rightMostInLst = getRightMostNode(lst);   // finding maximum in left subtree\\n              rightMostInLst->right = rst; \\n              return lst;     \\n           } \\n        }\\n        return root;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 821770,
                "title": "c-o-h-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (root==NULL) return NULL;\\n        \\n        if (root->val == key){\\n            if(root->left == NULL)  return root->right;\\n            if(root->right == NULL) return root->left;\\n            if(root->right!=NULL && root->left!=NULL){\\n                TreeNode *temp = root->right;\\n                while(temp->left!=NULL) temp = temp->left;\\n                root->val = temp->val;\\n                root->right = deleteNode(root->right,root->val);\\n                \\n            }\\n        }\\n        else{\\n            if (root->val>key)  root->left = deleteNode(root->left,key);\\n            else    root->right = deleteNode(root->right,key);\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (root==NULL) return NULL;\\n        \\n        if (root->val == key){\\n            if(root->left == NULL)  return root->right;\\n            if(root->right == NULL) return root->left;\\n            if(root->right!=NULL && root->left!=NULL){\\n                TreeNode *temp = root->right;\\n                while(temp->left!=NULL) temp = temp->left;\\n                root->val = temp->val;\\n                root->right = deleteNode(root->right,root->val);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 549732,
                "title": "java-recursion-dfs",
                "content": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;  // critical corner case\\n        if (key < root.val) {\\n            root.left = deleteNode(root.left, key);\\n        } else if (key > root.val) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            if (root.left == null) return root.right;\\n            else if (root.right == null) return root.left;\\n            else {\\n                TreeNode minNode = findMin(root.right);\\n                root.val = minNode.val;\\n                root.right = deleteNode(root.right, minNode.val);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    private TreeNode findMin(TreeNode node) {\\n        while (node.left != null) {\\n            node = node.left;\\n        }\\n        return node;\\n    }\\n}\\n```\\nhttps://leetcode.com/problems/delete-node-in-a-bst/discuss/93296/Recursive-Easy-to-Understand-Java-Solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;  // critical corner case\\n        if (key < root.val) {\\n            root.left = deleteNode(root.left, key);\\n        } else if (key > root.val) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            if (root.left == null) return root.right;\\n            else if (root.right == null) return root.left;\\n            else {\\n                TreeNode minNode = findMin(root.right);\\n                root.val = minNode.val;\\n                root.right = deleteNode(root.right, minNode.val);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    private TreeNode findMin(TreeNode node) {\\n        while (node.left != null) {\\n            node = node.left;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338242,
                "title": "very-simple-javascript-solution-with-recursion",
                "content": "```javascript\\nvar deleteNode = function(root, key) {\\n    if (!root) return null\\n    if (key > root.val) {\\n        root.right = deleteNode(root.right, key)\\n    } else if (key < root.val) {\\n        root.left = deleteNode(root.left, key)\\n    } else {\\n        if (!root.right) return root.left\\n        if (!root.left) return root.right\\n        let n = root.right\\n        while (n.left) n = n.left\\n        n.left = root.left\\n        return root.right\\n    }\\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar deleteNode = function(root, key) {\\n    if (!root) return null\\n    if (key > root.val) {\\n        root.right = deleteNode(root.right, key)\\n    } else if (key < root.val) {\\n        root.left = deleteNode(root.left, key)\\n    } else {\\n        if (!root.right) return root.left\\n        if (!root.left) return root.right\\n        let n = root.right\\n        while (n.left) n = n.left\\n        n.left = root.left\\n        return root.right\\n    }\\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 322682,
                "title": "c-clear-solution-helper-function-to-delete-root",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root)\\n            return NULL;\\n        TreeNode* node = root, *parent = NULL;\\n        while(node){\\n            if(node->val == key)\\n                break;\\n            if(node->val < key){\\n                parent = node;\\n                node = node->right;\\n            }else{\\n                parent = node;\\n                node = node->left;\\n            }\\n        }\\n        if(!node)\\n            return root;\\n        else if(!parent){\\n            return delRoot(root);\\n        }else if(parent->left == node){\\n            parent->left = delRoot(node);\\n        }else{\\n            parent->right = delRoot(node);\\n        }\\n        return root;\\n    }\\n    \\n\\t//function to delete root\\n    TreeNode* delRoot(TreeNode* root){\\n        if(!root)\\n            return NULL;\\n        else if(!root->left && !root->right)\\n            return NULL;\\n        else if(!root->left){\\n            return root->right;\\n        }\\n        else if(!root->right){\\n            return root->left;\\n        }else{\\n            TreeNode* parent = root;\\n            TreeNode* node = root->left;\\n            while(node->right){\\n                parent = node;\\n                node = node->right;\\n            }\\n            swap(root->val, node->val);\\n            if(parent->right == node){\\n                parent->right = node->left;\\n            }else{\\n                parent->left = node->left;\\n            }\\n            return root;\\n        }\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root)\\n            return NULL;\\n        TreeNode* node = root, *parent = NULL;\\n        while(node){\\n            if(node->val == key)\\n                break;\\n            if(node->val < key){\\n                parent = node;\\n                node = node->right;\\n            }else{\\n                parent = node;\\n                node = node->left;\\n            }\\n        }\\n        if(!node)\\n            return root;\\n        else if(!parent){\\n            return delRoot(root);\\n        }else if(parent->left == node){\\n            parent->left = delRoot(node);\\n        }else{\\n            parent->right = delRoot(node);\\n        }\\n        return root;\\n    }\\n    \\n\\t//function to delete root\\n    TreeNode* delRoot(TreeNode* root){\\n        if(!root)\\n            return NULL;\\n        else if(!root->left && !root->right)\\n            return NULL;\\n        else if(!root->left){\\n            return root->right;\\n        }\\n        else if(!root->right){\\n            return root->left;\\n        }else{\\n            TreeNode* parent = root;\\n            TreeNode* node = root->left;\\n            while(node->right){\\n                parent = node;\\n                node = node->right;\\n            }\\n            swap(root->val, node->val);\\n            if(parent->right == node){\\n                parent->right = node->left;\\n            }else{\\n                parent->left = node->left;\\n            }\\n            return root;\\n        }\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222383,
                "title": "python-intuitive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\'\\'\\'\\n        find the node, which val equals to key, and the smallest node in the right child, use this child\\'s node replace the key node.\\n        \\'\\'\\'\\n        if root is None:\\n            return root\\n        \\n        if root.val == key:\\n            if root.left is None and root.right is None:\\n                return None\\n            \\n            \\n            if root.left and root.right:\\n                p = root.right\\n                if p.left is None:\\n                    p.left = root.left\\n                    return p\\n                q = p.left\\n                while q.left:\\n                    p = q\\n                    q = q.left\\n                p.left = q.right\\n                \\n                q.left = root.left\\n                q.right = root.right\\n                return q\\n            \\n            if root.left is None:\\n                return root.right\\n            if root.right is None:\\n                return root.left\\n                \\n        \\n        root.left = self.deleteNode(root.left, key)\\n        root.right = self.deleteNode(root.right, key)\\n        \\n        return root\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\'\\'\\'\\n        find the node, which val equals to key, and the smallest node in the right child, use this child\\'s node replace the key node.\\n        \\'\\'\\'\\n        if root is None:\\n            return root\\n        \\n        if root.val == key:\\n            if root.left is None and root.right is None:\\n                return None\\n            \\n            \\n            if root.left and root.right:\\n                p = root.right\\n                if p.left is None:\\n                    p.left = root.left\\n                    return p\\n                q = p.left\\n                while q.left:\\n                    p = q\\n                    q = q.left\\n                p.left = q.right\\n                \\n                q.left = root.left\\n                q.right = root.right\\n                return q\\n            \\n            if root.left is None:\\n                return root.right\\n            if root.right is None:\\n                return root.left\\n                \\n        \\n        root.left = self.deleteNode(root.left, key)\\n        root.right = self.deleteNode(root.right, key)\\n        \\n        return root\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 177366,
                "title": "simple-c-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode *minValueNode(struct TreeNode *node) \\n{\\n    struct TreeNode *current = node;\\n    \\n    while(current->left != NULL){\\n        current = current->left;\\n    }\\n    \\n    return current;\\n    \\n}\\n\\n\\nstruct TreeNode* deleteNode(struct TreeNode* root, int key) \\n{\\n    if(root == NULL)\\n        return root;\\n    else {\\n        if(root->val < key) {         // Go root right\\n            root->right = deleteNode(root->right, key);\\n        } else if (root->val > key) { // Go root left\\n            root->left = deleteNode(root->left, key);\\n        } else {                      // Same as root key\\n            if (root->left == NULL) {\\n                struct TreeNode *temp = root->right;\\n                free(root);\\n                return temp;\\n            } else if (root->right == NULL){\\n                struct TreeNode *temp = root->left;\\n                free(root);\\n                return temp;\\n            } \\n            \\n            struct TreeNode *temp = minValueNode(root->right);\\n            root->val = temp->val;\\n            root->right = deleteNode(root->right, temp->val);         \\n        }\\n   \\n    }\\n    \\n    return root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode *minValueNode(struct TreeNode *node) \\n{\\n    struct TreeNode *current = node;\\n    \\n    while(current->left != NULL){\\n        current = current->left;\\n    }\\n    \\n    return current;\\n    \\n}\\n\\n\\nstruct TreeNode* deleteNode(struct TreeNode* root, int key) \\n{\\n    if(root == NULL)\\n        return root;\\n    else {\\n        if(root->val < key) {         // Go root right\\n            root->right = deleteNode(root->right, key);\\n        } else if (root->val > key) { // Go root left\\n            root->left = deleteNode(root->left, key);\\n        } else {                      // Same as root key\\n            if (root->left == NULL) {\\n                struct TreeNode *temp = root->right;\\n                free(root);\\n                return temp;\\n            } else if (root->right == NULL){\\n                struct TreeNode *temp = root->left;\\n                free(root);\\n                return temp;\\n            } \\n            \\n            struct TreeNode *temp = minValueNode(root->right);\\n            root->val = temp->val;\\n            root->right = deleteNode(root->right, temp->val);         \\n        }\\n   \\n    }\\n    \\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042957,
                "title": "delete-node-in-a-bst-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* findminval(TreeNode* root){\\n    if(root==NULL)return root;\\n    while(root->left!=NULL){\\n        root=root->left;\\n    }\\n    return root;\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)return NULL;\\n        if(root->val==key){\\n            if(root->left==NULL && root->right==NULL){\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left!=NULL && root->right==NULL){\\n                TreeNode* temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left==NULL){\\n                TreeNode* temp=root->right;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left!=NULL){\\n                int minimum= findminval(root->right)->val;\\n                root->val=minimum;\\n                root->right=deleteNode(root->right,minimum);\\n                return root;\\n            }\\n        }\\n        else if(root->val>key){\\n        root->left=deleteNode(root->left,key);\\n        return root;\\n    }\\n    else{\\n        root->right=deleteNode(root->right,key);\\n        return root;\\n    }\\n    return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* findminval(TreeNode* root){\\n    if(root==NULL)return root;\\n    while(root->left!=NULL){\\n        root=root->left;\\n    }\\n    return root;\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)return NULL;\\n        if(root->val==key){\\n            if(root->left==NULL && root->right==NULL){\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left!=NULL && root->right==NULL){\\n                TreeNode* temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left==NULL){\\n                TreeNode* temp=root->right;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left!=NULL){\\n                int minimum= findminval(root->right)->val;\\n                root->val=minimum;\\n                root->right=deleteNode(root->right,minimum);\\n                return root;\\n            }\\n        }\\n        else if(root->val>key){\\n        root->left=deleteNode(root->left,key);\\n        return root;\\n    }\\n    else{\\n        root->right=deleteNode(root->right,key);\\n        return root;\\n    }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971052,
                "title": "2-best-c-solutions-recursive-and-iterative-approach-explained-beats-100",
                "content": "\\n\\n# Code\\n```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root != NULL){\\n            // If key is smaller than root->val, go left\\n            if(key < root->val) \\n                root->left = deleteNode(root->left, key);\\n            // If key is larger than root->val, go right  \\n            else if(key > root->val) \\n                root->right = deleteNode(root->right, key);  \\n            // If key == root->val     \\n            else{\\n                // For 0 child/ root is leaf node, return NULL\\n                if(root->left == NULL && root->right == NULL) \\n                    return NULL; \\n                // For 1 child, return the child present\\n                if (root->left == NULL || root->right == NULL)\\n                    return root->left ? root->left : root->right; \\n                // For 2 children, find minimum of right side or maximum of left side\\n                // and put that value in root\\n                TreeNode* temp = root->left;\\n                while(temp->right != NULL) \\n                    temp = temp->right; \\n                root->val = temp->val;     \\n                root->left = deleteNode(root->left, temp->val); \\n            }\\n        }\\n        return root;\\n    }   \\n};\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* helper(TreeNode* root){\\n        // Only right child present\\n        if(root->left == NULL){\\n            return root->right;\\n        }\\n        // Only left child present\\n        else if(root->right == NULL){\\n            return root->left;\\n        }\\n        // Both child present so find minimum of right side or maximum of left side\\n        // Here, we are finding maximum of left side\\n        else{\\n            TreeNode* rightchild = root->right;\\n            TreeNode* lastright = find(root->left); \\n            lastright->right = rightchild;\\n            return root->left;\\n        }\\n    }\\n\\n    TreeNode* find(TreeNode* root){\\n        while(root->right != NULL)\\n            root = root->right;\\n        return root;\\n    }\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        if(root->val == key){\\n            return helper(root);\\n        }\\n\\n        // Find node with value key\\n        TreeNode *cur = root;\\n        while(root != NULL){\\n            if(root->val > key){\\n                if(root->left != NULL && root->left->val == key){\\n                    root->left = helper(root->left);\\n                    break;\\n                }\\n                else{\\n                    root = root->left;\\n                }\\n            }\\n            else{\\n                if(root->right != NULL && root->right->val == key){\\n                    root->right = helper(root->right);\\n                    break;\\n                }\\n                else{\\n                    root = root->right;\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root != NULL){\\n            // If key is smaller than root->val, go left\\n            if(key < root->val) \\n                root->left = deleteNode(root->left, key);\\n            // If key is larger than root->val, go right  \\n            else if(key > root->val) \\n                root->right = deleteNode(root->right, key);  \\n            // If key == root->val     \\n            else{\\n                // For 0 child/ root is leaf node, return NULL\\n                if(root->left == NULL && root->right == NULL) \\n                    return NULL; \\n                // For 1 child, return the child present\\n                if (root->left == NULL || root->right == NULL)\\n                    return root->left ? root->left : root->right; \\n                // For 2 children, find minimum of right side or maximum of left side\\n                // and put that value in root\\n                TreeNode* temp = root->left;\\n                while(temp->right != NULL) \\n                    temp = temp->right; \\n                root->val = temp->val;     \\n                root->left = deleteNode(root->left, temp->val); \\n            }\\n        }\\n        return root;\\n    }   \\n};\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* helper(TreeNode* root){\\n        // Only right child present\\n        if(root->left == NULL){\\n            return root->right;\\n        }\\n        // Only left child present\\n        else if(root->right == NULL){\\n            return root->left;\\n        }\\n        // Both child present so find minimum of right side or maximum of left side\\n        // Here, we are finding maximum of left side\\n        else{\\n            TreeNode* rightchild = root->right;\\n            TreeNode* lastright = find(root->left); \\n            lastright->right = rightchild;\\n            return root->left;\\n        }\\n    }\\n\\n    TreeNode* find(TreeNode* root){\\n        while(root->right != NULL)\\n            root = root->right;\\n        return root;\\n    }\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        if(root->val == key){\\n            return helper(root);\\n        }\\n\\n        // Find node with value key\\n        TreeNode *cur = root;\\n        while(root != NULL){\\n            if(root->val > key){\\n                if(root->left != NULL && root->left->val == key){\\n                    root->left = helper(root->left);\\n                    break;\\n                }\\n                else{\\n                    root = root->left;\\n                }\\n            }\\n            else{\\n                if(root->right != NULL && root->right->val == key){\\n                    root->right = helper(root->right);\\n                    break;\\n                }\\n                else{\\n                    root = root->right;\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717015,
                "title": "java-deleting-replacing-beats-100-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return null;\\n        if(root.val == key) {\\n            return getReplacement(root);\\n        }\\n        root.left = deleteNode(root.left, key);\\n        root.right = deleteNode(root.right, key);\\n        return root;\\n    }\\n    public TreeNode getReplacement(TreeNode root) {\\n        if(root.right == null && root.left == null) return null;\\n        if(root.right == null) return root.left;\\n        if(root.left == null) return root.right;\\n        TreeNode replacement = root.right;\\n        if(replacement.left == null) {\\n            replacement.left = root.left;\\n        } else {\\n            TreeNode parent = root;\\n            while(replacement.left != null) {\\n                parent = replacement;\\n                replacement = replacement.left;\\n            }\\n            parent.left = replacement.right;\\n            replacement.right = root.right;\\n            replacement.left = root.left;\\n        }\\n        return replacement; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return null;\\n        if(root.val == key) {\\n            return getReplacement(root);\\n        }\\n        root.left = deleteNode(root.left, key);\\n        root.right = deleteNode(root.right, key);\\n        return root;\\n    }\\n    public TreeNode getReplacement(TreeNode root) {\\n        if(root.right == null && root.left == null) return null;\\n        if(root.right == null) return root.left;\\n        if(root.left == null) return root.right;\\n        TreeNode replacement = root.right;\\n        if(replacement.left == null) {\\n            replacement.left = root.left;\\n        } else {\\n            TreeNode parent = root;\\n            while(replacement.left != null) {\\n                parent = replacement;\\n                replacement = replacement.left;\\n            }\\n            parent.left = replacement.right;\\n            replacement.right = root.right;\\n            replacement.left = root.left;\\n        }\\n        return replacement; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622542,
                "title": "easy-c-approach-to-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* findminval(TreeNode* root){\\n    if(root==NULL)return root;\\n    while(root->left!=NULL){\\n        root=root->left;\\n    }\\n    return root;\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)return NULL;\\n        if(root->val==key){\\n            if(root->left==NULL && root->right==NULL){\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left!=NULL && root->right==NULL){\\n                TreeNode* temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left==NULL){\\n                TreeNode* temp=root->right;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left!=NULL){\\n                int minimum= findminval(root->right)->val;\\n                root->val=minimum;\\n                root->right=deleteNode(root->right,minimum);\\n                return root;\\n            }\\n        }\\n        else if(root->val>key){\\n        root->left=deleteNode(root->left,key);\\n        return root;\\n    }\\n    else{\\n        root->right=deleteNode(root->right,key);\\n        return root;\\n    }\\n    return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* findminval(TreeNode* root){\\n    if(root==NULL)return root;\\n    while(root->left!=NULL){\\n        root=root->left;\\n    }\\n    return root;\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)return NULL;\\n        if(root->val==key){\\n            if(root->left==NULL && root->right==NULL){\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left!=NULL && root->right==NULL){\\n                TreeNode* temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left==NULL){\\n                TreeNode* temp=root->right;\\n                delete root;\\n                return temp;\\n            }\\n            if(root->right!=NULL && root->left!=NULL){\\n                int minimum= findminval(root->right)->val;\\n                root->val=minimum;\\n                root->right=deleteNode(root->right,minimum);\\n                return root;\\n            }\\n        }\\n        else if(root->val>key){\\n        root->left=deleteNode(root->left,key);\\n        return root;\\n    }\\n    else{\\n        root->right=deleteNode(root->right,key);\\n        return root;\\n    }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083629,
                "title": "java",
                "content": "\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null ){\\n            return root;\\n        }\\n\\n       \\n        if(root.val == key){\\n            if (root.left == null && root.right == null){\\n                root = null;\\n            } \\n            else if (root.right != null) {\\n                root.val = slightlyBigger(root);\\n                root.right = deleteNode(root.right, root.val);\\n            }     \\n            else {\\n                root.val = slightlySmaller(root);\\n                root.left = deleteNode(root.left, root.val);\\n            }\\n        }\\n        else if(root.val<key){\\n            root.right = deleteNode(root.right, key);\\n        }\\n        else if(root.val>key){\\n            root.left = deleteNode(root.left, key);\\n        }\\n\\n        return root;\\n    }\\n\\n    public int slightlyBigger(TreeNode root) {\\n        root = root.right;\\n        while (root.left != null){\\n            root = root.left;\\n        } \\n        return root.val;\\n    }\\n\\n    public int slightlySmaller(TreeNode root) {\\n        root = root.left;\\n        while (root.right != null){\\n            root = root.right;\\n        } \\n        return root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null ){\\n            return root;\\n        }\\n\\n       \\n        if(root.val == key){\\n            if (root.left == null && root.right == null){\\n                root = null;\\n            } \\n            else if (root.right != null) {\\n                root.val = slightlyBigger(root);\\n                root.right = deleteNode(root.right, root.val);\\n            }     \\n            else {\\n                root.val = slightlySmaller(root);\\n                root.left = deleteNode(root.left, root.val);\\n            }\\n        }\\n        else if(root.val<key){\\n            root.right = deleteNode(root.right, key);\\n        }\\n        else if(root.val>key){\\n            root.left = deleteNode(root.left, key);\\n        }\\n\\n        return root;\\n    }\\n\\n    public int slightlyBigger(TreeNode root) {\\n        root = root.right;\\n        while (root.left != null){\\n            root = root.left;\\n        } \\n        return root.val;\\n    }\\n\\n    public int slightlySmaller(TreeNode root) {\\n        root = root.left;\\n        while (root.right != null){\\n            root = root.right;\\n        } \\n        return root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871058,
                "title": "python-easy-solution-with-explanation-o-h",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\uD83D\\uDCCDsearch the node\\n\\uD83D\\uDCCDdelete the node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nevery node is a root if we consider the tree starting from that `node`.\\nso we will focus on the case where we will find the `key == root.val`\\n\\nas we know in BST all nodes of the right subtree will be smaller than all nodes of the right subtree, that is gretest node of left root will be smaller than smallest node of right subtree \\n\\nso now we will have two cases \\n1) if `root.right` exists \\n2) if it doesn\\u2019t \\n\\nif it does then, we will find the smallest node of right subtree (left most node in right subtree) and then we will point `right_smallest.left = root_of_left subtree`\\n\\nif it doesn\\u2019t then, return the `root of left subtree`\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root and root.val == key:\\n            right = root.right\\n            if right:\\n                while right.left:\\n                    right = right.left\\n                right.left = root.left\\n                return root.right\\n            else:\\n                return root.left\\n        elif root and root.val > key and root.left:\\n            root.left = self.deleteNode(root.left, key)\\n        elif root and root.val < key and root.right:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root and root.val == key:\\n            right = root.right\\n            if right:\\n                while right.left:\\n                    right = right.left\\n                right.left = root.left\\n                return root.right\\n            else:\\n                return root.left\\n        elif root and root.val > key and root.left:\\n            root.left = self.deleteNode(root.left, key)\\n        elif root and root.val < key and root.right:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790788,
                "title": "c-solution-delete-node-in-a-bst",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* minVal(TreeNode *root){\\n        TreeNode *temp = root;\\n        while(temp->left != NULL){\\n            temp = temp->left;\\n        }\\n        return temp;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case 1\\n        if(root == NULL)\\n            return NULL;\\n    \\n        //base case 2\\n        if(root->val == key){\\n            //0 child\\n            if(root->left == NULL && root->right == NULL){\\n                delete root;\\n                return NULL;\\n            }\\n\\n            //1 child\\n            //node has a left child\\n            if(root->left != NULL && root->right == NULL){\\n                TreeNode *temp = root->left;\\n                delete root;\\n                return temp;\\n            }\\n\\n            //node has a right child\\n            if(root->left == NULL && root->right != NULL){\\n                TreeNode *temp = root->right;\\n                delete root;\\n                return temp;\\n            }\\n\\n            //2 child - replace either with max of left subtree or min of right subtree\\n            if(root->left != NULL && root->right != NULL){\\n                int mini = minVal(root->right) -> val;\\n                root->val = mini;\\n                root->right = deleteNode(root->right , mini);\\n                return root;\\n            }\\n        }\\n\\n        else if(root->val > key){\\n            root->left = deleteNode(root->left , key);\\n            return root;\\n        }\\n        else{\\n            root->right = deleteNode(root->right , key);\\n            return root;\\n        }\\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* minVal(TreeNode *root){\\n        TreeNode *temp = root;\\n        while(temp->left != NULL){\\n            temp = temp->left;\\n        }\\n        return temp;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case 1\\n        if(root == NULL)\\n            return NULL;\\n    \\n        //base case 2\\n        if(root->val == key){\\n            //0 child\\n            if(root->left == NULL && root->right == NULL){\\n                delete root;\\n                return NULL;\\n            }\\n\\n            //1 child\\n            //node has a left child\\n            if(root->left != NULL && root->right == NULL){\\n                TreeNode *temp = root->left;\\n                delete root;\\n                return temp;\\n            }\\n\\n            //node has a right child\\n            if(root->left == NULL && root->right != NULL){\\n                TreeNode *temp = root->right;\\n                delete root;\\n                return temp;\\n            }\\n\\n            //2 child - replace either with max of left subtree or min of right subtree\\n            if(root->left != NULL && root->right != NULL){\\n                int mini = minVal(root->right) -> val;\\n                root->val = mini;\\n                root->right = deleteNode(root->right , mini);\\n                return root;\\n            }\\n        }\\n\\n        else if(root->val > key){\\n            root->left = deleteNode(root->left , key);\\n            return root;\\n        }\\n        else{\\n            root->right = deleteNode(root->right , key);\\n            return root;\\n        }\\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215057,
                "title": "java-beats-java-submissions-0-ms",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n```\\nclass Solution {\\n    \\n    public static int min(TreeNode node){\\n        \\n        if(node.left==null||node==null){\\n            return node.val;\\n        }\\n        else{\\n            return min(node.left);\\n        }\\n    }\\n    \\n    public TreeNode deleteNode(TreeNode node, int data) {\\n        if(node==null){//conner case\\n            return null;\\n        }\\n        \\n        if(node.val>data){\\n            node.left=deleteNode(node.left,data);\\n        }\\n        else if(node.val<data){\\n            node.right=deleteNode(node.right,data);\\n            \\n        }\\n        else{\\n            \\n            if( node.left==null&&node.right==null){\\n                return null;\\n            }\\n            else if(node.right==null){\\n                return node.left;\\n            }\\n            else if(node.left==null){\\n                return node.right;\\n            }\\n            else{\\n                int rmin= min(node.right);\\n                node.val=rmin;\\n                node.right=deleteNode(node.right,rmin);\\n                \\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int min(TreeNode node){\\n        \\n        if(node.left==null||node==null){\\n            return node.val;\\n        }\\n        else{\\n            return min(node.left);\\n        }\\n    }\\n    \\n    public TreeNode deleteNode(TreeNode node, int data) {\\n        if(node==null){//conner case\\n            return null;\\n        }\\n        \\n        if(node.val>data){\\n            node.left=deleteNode(node.left,data);\\n        }\\n        else if(node.val<data){\\n            node.right=deleteNode(node.right,data);\\n            \\n        }\\n        else{\\n            \\n            if( node.left==null&&node.right==null){\\n                return null;\\n            }\\n            else if(node.right==null){\\n                return node.left;\\n            }\\n            else if(node.left==null){\\n                return node.right;\\n            }\\n            else{\\n                int rmin= min(node.right);\\n                node.val=rmin;\\n                node.right=deleteNode(node.right,rmin);\\n                \\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093695,
                "title": "c-solution",
                "content": "```csharp\\npublic TreeNode DeleteNode(TreeNode root, int key)\\n{\\n\\tif (root == null) return root;\\n\\n\\tif (key < root.val)\\n\\t\\troot.left = DeleteNode(root.left, key);\\n\\telse if (key > root.val)\\n\\t\\troot.right = DeleteNode(root.right, key);\\n\\telse // root.val == key\\n\\t{\\n\\t\\tif (root.left == null)\\n\\t\\t\\treturn root.right;\\n\\t\\tif (root.right == null)\\n\\t\\t\\treturn root.left;\\n\\n\\t\\t// root.left & root.right != null\\n\\t\\tTreeNode node = root.right;\\n\\n\\t\\twhile (node.left != null)\\n\\t\\t\\tnode = node.left;\\n\\n\\t\\troot.val = node.val;\\n\\t\\troot.right = DeleteNode(root.right, node.val);\\n\\t}\\n\\n\\treturn root;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic TreeNode DeleteNode(TreeNode root, int key)\\n{\\n\\tif (root == null) return root;\\n\\n\\tif (key < root.val)\\n\\t\\troot.left = DeleteNode(root.left, key);\\n\\telse if (key > root.val)\\n\\t\\troot.right = DeleteNode(root.right, key);\\n\\telse // root.val == key\\n\\t{\\n\\t\\tif (root.left == null)\\n\\t\\t\\treturn root.right;\\n\\t\\tif (root.right == null)\\n\\t\\t\\treturn root.left;\\n\\n\\t\\t// root.left & root.right != null\\n\\t\\tTreeNode node = root.right;\\n\\n\\t\\twhile (node.left != null)\\n\\t\\t\\tnode = node.left;\\n\\n\\t\\troot.val = node.val;\\n\\t\\troot.right = DeleteNode(root.right, node.val);\\n\\t}\\n\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1927765,
                "title": "easy-explanation-straightforward-approach-in-c",
                "content": "Deletion in BST:\\nCase 1: If Node is a **leaf** ---> Directly point it to **NULL**\\nCase 2.1: If Node has **right child**---> Point Node to its **right child**\\nCase 2.2: If Node has **left child**---> Point Node to its **left child**\\nCsae 3: If Node has **both children**---> \\n\\t\\t\\tFirst find **minimum(minNode) node** in the Node\\'s(node to be deleted) **right subtree** and **copy the contents of that minNode to Node\\'s val field**. Then **delete that minNode** from BST.\\n\\t\\t\\tSimilar can be done in the Node\\'s left subtree by finding maxNode.\\n\\t\\t\\t\\n\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* minNode(TreeNode* root){\\n        while(root->left!=NULL){\\n            root = root->left;\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL){\\n//             if node not found then return NULL\\n            return NULL;\\n        }\\n        \\n        if(root->val < key){\\n//             search for the node in right subtree\\n            root->right = deleteNode(root->right, key);\\n        }\\n        else if(root->val > key){\\n//             search for the node in left subtree\\n            root->left = deleteNode(root->left, key);\\n        }\\n        else{\\n//             if node is found\\n            \\n            \\n//     Case 1:         if root is the leaf node\\n            if(root->left==NULL && root->right==NULL){\\n                root=NULL;\\n            }\\n//     Case 2.1:         if root has only right child\\n            else if(root->left==NULL){\\n                root = root->right;\\n            }\\n//     Case 2.2:         if root has only left child\\n            else if(root->right==NULL){\\n                root = root->left;\\n            }\\n//     Case 3:     if root has both children\\n            else{\\n                TreeNode* Node;\\n//                 find min node in right subtree of current(root) node\\n                Node = minNode(root->right);\\n//                 copy value of that node into root node\\n                root->val = Node->val;\\n//                 delete that minNode found in right subtree\\n                root->right = deleteNode(root->right,Node->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* minNode(TreeNode* root){\\n        while(root->left!=NULL){\\n            root = root->left;\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL){\\n//             if node not found then return NULL\\n            return NULL;\\n        }\\n        \\n        if(root->val < key){\\n//             search for the node in right subtree\\n            root->right = deleteNode(root->right, key);\\n        }\\n        else if(root->val > key){\\n//             search for the node in left subtree\\n            root->left = deleteNode(root->left, key);\\n        }\\n        else{\\n//             if node is found\\n            \\n            \\n//     Case 1:         if root is the leaf node\\n            if(root->left==NULL && root->right==NULL){\\n                root=NULL;\\n            }\\n//     Case 2.1:         if root has only right child\\n            else if(root->left==NULL){\\n                root = root->right;\\n            }\\n//     Case 2.2:         if root has only left child\\n            else if(root->right==NULL){\\n                root = root->left;\\n            }\\n//     Case 3:     if root has both children\\n            else{\\n                TreeNode* Node;\\n//                 find min node in right subtree of current(root) node\\n                Node = minNode(root->right);\\n//                 copy value of that node into root node\\n                root->val = Node->val;\\n//                 delete that minNode found in right subtree\\n                root->right = deleteNode(root->right,Node->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857289,
                "title": "python-easy-recursive-solution",
                "content": "\\tclass Solution:\\n\\t\\t@staticmethod\\n\\t\\tdef nextval(node):    \\'\\'\\'Finds inorder successor\\'\\'\\'\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\treturn Solution.nextval(node.left)\\n\\t\\t\\treturn node.val\\n\\n\\t\\tdef deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn root\\n\\t\\t\\tif root.val == key:\\n\\t\\t\\t\\tif not root.left:\\n\\t\\t\\t\\t\\treturn root.right\\n\\t\\t\\t\\tif not root.right:\\n\\t\\t\\t\\t\\treturn root.left\\n\\t\\t\\t\\troot.val = Solution.nextval(root.right)     \\'\\'\\'Copying inorder successor value\\'\\'\\'\\n\\t\\t\\t\\troot.right = self.deleteNode(root.right,root.val)  \\n\\t\\t\\t\\treturn root\\n\\t\\t\\tif root.val > key:\\n\\t\\t\\t\\troot.left = self.deleteNode(root.left,key)\\n\\t\\t\\telse:\\n\\t\\t\\t\\troot.right = self.deleteNode(root.right,key)\\n\\t\\t\\treturn root\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\'If any doubt regarding solution please ask in comment section \\n\\t\\t\\t  if you like it please upvote \\'\\'\\'",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\t@staticmethod\\n\\t\\tdef nextval(node):    \\'\\'\\'Finds inorder successor\\'\\'\\'\\n\\t\\t\\tif node.left:\\n\\t\\t\\t\\treturn Solution.nextval(node.left)\\n\\t\\t\\treturn node.val\\n\\n\\t\\tdef deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn root\\n\\t\\t\\tif root.val == key:\\n\\t\\t\\t\\tif not root.left:\\n\\t\\t\\t\\t\\treturn root.right\\n\\t\\t\\t\\tif not root.right:\\n\\t\\t\\t\\t\\treturn root.left\\n\\t\\t\\t\\troot.val = Solution.nextval(root.right)     \\'\\'\\'Copying inorder successor value\\'\\'\\'\\n\\t\\t\\t\\troot.right = self.deleteNode(root.right,root.val)  \\n\\t\\t\\t\\treturn root\\n\\t\\t\\tif root.val > key:\\n\\t\\t\\t\\troot.left = self.deleteNode(root.left,key)\\n\\t\\t\\telse:\\n\\t\\t\\t\\troot.right = self.deleteNode(root.right,key)\\n\\t\\t\\treturn root\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\'If any doubt regarding solution please ask in comment section \\n\\t\\t\\t  if you like it please upvote \\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1846747,
                "title": "c-easy-solution-w-comments",
                "content": "***DO*** \\u2B06\\uFE0F **UPVOTE IF IT WAS HELPFUL**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint max(TreeNode *root){\\n\\t\\t\\tTreeNode *curr=root;\\n\\t\\t\\twhile(curr->left){\\n\\t\\t\\t\\tcurr=curr->left;\\n\\t\\t\\t}\\n\\t\\t\\treturn curr->val;\\n\\t\\t}\\n\\t\\tTreeNode* deleteNode(TreeNode* root, int key) {\\n\\t\\t\\t   if(!root) return root;\\n\\t\\t\\t   if(root->val==key){\\n\\t\\t\\t\\t\\t // leaf node\\n\\t\\t\\t\\t\\t  if(!root->left && !root->right){\\n\\t\\t\\t\\t\\t\\t   return nullptr;\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t // one child node\\n\\t\\t\\t\\t\\t else if(root->left && !root->right) return root->left;\\n\\t\\t\\t\\t\\t else if(!root->left && root->right) return root->right;\\n\\t\\t\\t\\t\\t //two child node\\n\\t\\t\\t\\t\\t else{\\n\\t\\t\\t\\t\\t\\t //take min value from right subtree or you can take max from left\\n\\t\\t\\t\\t\\t\\t int t=max(root->right);\\n\\t\\t\\t\\t\\t\\t root->val=t;\\n\\t\\t\\t\\t\\t\\t root->right=deleteNode(root->right,t);\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t   }\\n\\t\\t\\t   if(key<root->val)\\n\\t\\t\\t\\t root->left=deleteNode(root->left,key);\\n\\t\\t\\t   else root->right=deleteNode(root->right,key);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint max(TreeNode *root){\\n\\t\\t\\tTreeNode *curr=root;\\n\\t\\t\\twhile(curr->left){\\n\\t\\t\\t\\tcurr=curr->left;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1682086,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int getMax(TreeNode node){\\n        if(node.right!=null){\\n           return   getMax(node.right);\\n        }\\n            return node.val;\\n        \\n    }\\n    public TreeNode deleteNode(TreeNode root, int key){\\n        if(root==null) return null;\\n        if(root.val>key){\\n            root.left=deleteNode(root.left,key);\\n        }else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }else{\\n            if(root.left!=null && root.right!=null){\\n                int leftMax=getMax(root.left);\\n                root.val=leftMax;\\n                root.left=deleteNode(root.left,leftMax);\\n                return root;\\n            }else if(root.left!=null){\\n                return root.left;\\n            }else if(root.right!=null){\\n                return root.right;\\n            }else{\\n                return null;\\n            }\\n        }\\n      return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMax(TreeNode node){\\n        if(node.right!=null){\\n           return   getMax(node.right);\\n        }\\n            return node.val;\\n        \\n    }\\n    public TreeNode deleteNode(TreeNode root, int key){\\n        if(root==null) return null;\\n        if(root.val>key){\\n            root.left=deleteNode(root.left,key);\\n        }else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }else{\\n            if(root.left!=null && root.right!=null){\\n                int leftMax=getMax(root.left);\\n                root.val=leftMax;\\n                root.left=deleteNode(root.left,leftMax);\\n                return root;\\n            }else if(root.left!=null){\\n                return root.left;\\n            }else if(root.right!=null){\\n                return root.right;\\n            }else{\\n                return null;\\n            }\\n        }\\n      return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605264,
                "title": "recursive-solution-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        def get_minimum_val(node):\\n            while node.left:\\n                node = node.left\\n            return node.val\\n        \\n        def get_maximum_val(node):\\n            while node.right:\\n                node = node.right\\n            return node.val\\n        \\n        def rec(node, key):\\n            if not node:\\n                return None\\n            \\n            if key < node.val:\\n                node.left = rec(node.left, key)\\n                return node\\n            \\n            if node.val < key:\\n                node.right = rec(node.right, key)\\n                return node\\n            \\n            if node.right:\\n                succ_val = get_minimum_val(node.right)\\n                node.val = succ_val\\n                node.right = rec(node.right, succ_val)\\n                return node\\n            elif node.left:\\n                pred_val = get_maximum_val(node.left)\\n                node.val = pred_val\\n                node.left = rec(node.left, pred_val)\\n                return node\\n            else:\\n                return None\\n            \\n        return rec(root, key)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        def get_minimum_val(node):\\n            while node.left:\\n                node = node.left\\n            return node.val\\n        \\n        def get_maximum_val(node):\\n            while node.right:\\n                node = node.right\\n            return node.val\\n        \\n        def rec(node, key):\\n            if not node:\\n                return None\\n            \\n            if key < node.val:\\n                node.left = rec(node.left, key)\\n                return node\\n            \\n            if node.val < key:\\n                node.right = rec(node.right, key)\\n                return node\\n            \\n            if node.right:\\n                succ_val = get_minimum_val(node.right)\\n                node.val = succ_val\\n                node.right = rec(node.right, succ_val)\\n                return node\\n            elif node.left:\\n                pred_val = get_maximum_val(node.left)\\n                node.val = pred_val\\n                node.left = rec(node.left, pred_val)\\n                return node\\n            else:\\n                return None\\n            \\n        return rec(root, key)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591642,
                "title": "java-commented-very-simple-to-understand-beats-100",
                "content": "Thanks @user6720z  for the optimization tip!\\n```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n\\tif(root==null) return null; //if root is null just return null\\n\\tif(root.val==key) //if current node is to be deleted\\n\\t{\\n\\t\\tif(root.right==null) return root.left; //there is no right subtree\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//simply return left subtree\\n\\n\\t\\tTreeNode runner = root.right;         //right subtree exists\\n\\t\\tTreeNode attach = root.right; //keep a pointer to right subtree, will need it\\n\\n\\t\\t//find leftmost node of right subtree\\n\\t\\t//why? all values in left subtree are smaller than the\\n\\t\\t//smallest value in the right subtree\\n\\n\\t\\twhile(runner.left!=null) \\n\\t\\t\\trunner=runner.left;  //finding smallest node in right subtree\\n\\n\\t\\trunner.left = root.left;  //attach left subtree to smallest node in right\\n\\t\\treturn attach;              //return the right node of deleted node\\n\\t}\\n\\telse{\\n\\t\\t//key not found here? check for it in left and right subtree\\n\\t\\t//since its a BST we can choose in which subtree to look \\n        if (root.val > key) root.left = deleteNode(root.left, key); \\n        else root.right = deleteNode(root.right, key);\\n\\t\\treturn  root;\\n\\t}\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode deleteNode(TreeNode root, int key) {\\n\\tif(root==null) return null; //if root is null just return null\\n\\tif(root.val==key) //if current node is to be deleted\\n\\t{\\n\\t\\tif(root.right==null) return root.left; //there is no right subtree\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//simply return left subtree\\n\\n\\t\\tTreeNode runner = root.right;         //right subtree exists\\n\\t\\tTreeNode attach = root.right; //keep a pointer to right subtree, will need it\\n\\n\\t\\t//find leftmost node of right subtree\\n\\t\\t//why? all values in left subtree are smaller than the\\n\\t\\t//smallest value in the right subtree\\n\\n\\t\\twhile(runner.left!=null) \\n\\t\\t\\trunner=runner.left;  //finding smallest node in right subtree\\n\\n\\t\\trunner.left = root.left;  //attach left subtree to smallest node in right\\n\\t\\treturn attach;              //return the right node of deleted node\\n\\t}\\n\\telse{\\n\\t\\t//key not found here? check for it in left and right subtree\\n\\t\\t//since its a BST we can choose in which subtree to look \\n        if (root.val > key) root.left = deleteNode(root.left, key); \\n        else root.right = deleteNode(root.right, key);\\n\\t\\treturn  root;\\n\\t}\\n}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590935,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        auto node = root;\\n        if(!node) return NULL;\\n        \\n        if(key > node->val) node->right = deleteNode(node->right, key);\\n        else if(key < node->val) node->left = deleteNode(node->left, key);\\n        \\n        //Now, when we have to delete the root i.e. when root->val == key\\n        else{\\n            if(!node -> left && !node->right) return NULL;\\n            if(!node -> left) return node->right;\\n            else if(!node -> right) return node->left;\\n            \\n            //when both left and right exist -> find minimum (mini) on right and attach root->left subtree to mini->left and return root->right.\\n            else{\\n                auto mini = node -> right;\\n                while(mini->left) mini = mini -> left;\\n                \\n                mini->left = node->left;\\n                return node->right;\\n            }\\n        }\\n        return node;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        auto node = root;\\n        if(!node) return NULL;\\n        \\n        if(key > node->val) node->right = deleteNode(node->right, key);\\n        else if(key < node->val) node->left = deleteNode(node->left, key);\\n        \\n        //Now, when we have to delete the root i.e. when root->val == key\\n        else{\\n            if(!node -> left && !node->right) return NULL;\\n            if(!node -> left) return node->right;\\n            else if(!node -> right) return node->left;\\n            \\n            //when both left and right exist -> find minimum (mini) on right and attach root->left subtree to mini->left and return root->right.\\n            else{\\n                auto mini = node -> right;\\n                while(mini->left) mini = mini -> left;\\n                \\n                mini->left = node->left;\\n                return node->right;\\n            }\\n        }\\n        return node;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583492,
                "title": "c-91-faster-recursive-solution",
                "content": "```\\nTreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return NULL;\\n\\n        if(key > root->val) {root->right = deleteNode(root->right, key); return root;}\\n        else if(key < root->val) {root->left = deleteNode(root->left, key); return root;}\\n\\t\\t\\n        else if(key == root->val) {\\n            if(!root->left && !root->right) return NULL;\\n            else if(!root->left && root->right) return root->right;\\n            else if(!root->right && root->left) return root->left;\\n            else {\\n                TreeNode *after = root->left;\\n                while(after && after->right) {after = after->right;}\\n                after->right = root->right;\\n                return root->left;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return NULL;\\n\\n        if(key > root->val) {root->right = deleteNode(root->right, key); return root;}\\n        else if(key < root->val) {root->left = deleteNode(root->left, key); return root;}\\n\\t\\t\\n        else if(key == root->val) {\\n            if(!root->left && !root->right) return NULL;\\n            else if(!root->left && root->right) return root->right;\\n            else if(!root->right && root->left) return root->left;\\n            else {\\n                TreeNode *after = root->left;\\n                while(after && after->right) {after = after->right;}\\n                after->right = root->right;\\n                return root->left;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1485515,
                "title": "easy-to-understand-90-faster-javascript-code",
                "content": "Check depth first search and if node.val is equal to the key, then do below\\nIf node has right nodes, then search for its leftMost node if any present and replace the current node with leftmost node val and then recursively delete node.right part with leftmost search value.\\nIf node doesn\\'t have right then replace node with node.left\\n\\n```\\nfunction getLeftMost (node) {\\n    let left = node;\\n    while(node.left) {\\n        left = node.left;\\n        node = left;\\n    }\\n    return left;\\n}\\n\\nvar deleteNode = function(root, key) {\\n    function rec(node) {\\n        if(!node)\\n            return node;\\n        \\n        if(node.val == key) {\\n            if(node.right !== null) {\\n                let left = getLeftMost(node.right, node);\\n                node.val = left.val;\\n                node.right = deleteNode(node.right, left.val);\\n            } else {\\n                node = node.left;\\n            }\\n            return node;\\n        } if (key < node.val) {\\n            node.left = rec(node.left);\\n        } else {\\n            node.right = rec(node.right);\\n        }\\n        return node;\\n    }\\n    return rec(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction getLeftMost (node) {\\n    let left = node;\\n    while(node.left) {\\n        left = node.left;\\n        node = left;\\n    }\\n    return left;\\n}\\n\\nvar deleteNode = function(root, key) {\\n    function rec(node) {\\n        if(!node)\\n            return node;\\n        \\n        if(node.val == key) {\\n            if(node.right !== null) {\\n                let left = getLeftMost(node.right, node);\\n                node.val = left.val;\\n                node.right = deleteNode(node.right, left.val);\\n            } else {\\n                node = node.left;\\n            }\\n            return node;\\n        } if (key < node.val) {\\n            node.left = rec(node.left);\\n        } else {\\n            node.right = rec(node.right);\\n        }\\n        return node;\\n    }\\n    return rec(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391233,
                "title": "simple-concise-easy-to-understand-faster-than-100-solution",
                "content": "Simple intuition says:\\n1. Recursively find the node to be deleted, while returning the nodes as left and right while coming up.\\n2. When node is found, if root.right exists then it can be replaced with the current node, but if left also exists then it must be the least in the new node, which is root.right. So, send root.left to the max left of root.right and replace root with root.right.\\n3. Also, if root.right does not exist, just return root.left.\\n\\n**JAVA**\\n```\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        if(root == null) return root;\\n        \\n        if(key < root.val) root.left = deleteNode(root.left, key);\\n        else if(key > root.val) root.right = deleteNode(root.right, key);\\n        \\n        if(root.val == key){\\n            \\n            if(root.right != null){\\n                \\n                if(root.left != null){\\n                    \\n                    TreeNode left = root.right;\\n\\n                    while(left.left != null){\\n\\n                        left = left.left;\\n\\n                    }\\n\\n                    left.left = root.left;\\n                \\n                }\\n                return root.right;\\n                \\n            }\\n            \\n            return root.left;\\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n\\n```\\n\\n**CPP**\\n\\n```\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        \\n        if(root == NULL) return root;\\n        \\n        if(key < root->val) root->left = deleteNode(root->left, key);\\n        else if(key > root->val) root->right = deleteNode(root->right, key);\\n        \\n        if(root->val == key){\\n            \\n            if(root->right != NULL){\\n                \\n                if(root -> left != NULL){\\n                    \\n                    TreeNode* left = root->right;\\n\\n                    while(left->left != NULL){\\n\\n                        left = left->left;\\n\\n                    }\\n\\n                    left->left = root->left;\\n                \\n                }\\n                return root->right;\\n                \\n            }\\n            \\n            return root->left;\\n            \\n        }\\n        \\n        return root;\\n\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        \\n        if(root == null) return root;\\n        \\n        if(key < root.val) root.left = deleteNode(root.left, key);\\n        else if(key > root.val) root.right = deleteNode(root.right, key);\\n        \\n        if(root.val == key){\\n            \\n            if(root.right != null){\\n                \\n                if(root.left != null){\\n                    \\n                    TreeNode left = root.right;\\n\\n                    while(left.left != null){\\n\\n                        left = left.left;\\n\\n                    }\\n\\n                    left.left = root.left;\\n                \\n                }\\n                return root.right;\\n                \\n            }\\n            \\n            return root.left;\\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n\\n```\n```\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        \\n        if(root == NULL) return root;\\n        \\n        if(key < root->val) root->left = deleteNode(root->left, key);\\n        else if(key > root->val) root->right = deleteNode(root->right, key);\\n        \\n        if(root->val == key){\\n            \\n            if(root->right != NULL){\\n                \\n                if(root -> left != NULL){\\n                    \\n                    TreeNode* left = root->right;\\n\\n                    while(left->left != NULL){\\n\\n                        left = left->left;\\n\\n                    }\\n\\n                    left->left = root->left;\\n                \\n                }\\n                return root->right;\\n                \\n            }\\n            \\n            return root->left;\\n            \\n        }\\n        \\n        return root;\\n\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230117,
                "title": "c-with-comments-easy-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n\\t//first we will find the node with the given key\\n        TreeNode* searchNode=search(root,key);\\n        //If we don\\'t find the node.\\n        if(searchNode==NULL)\\n            return root;\\n        //In case of leaf Node just delete the Node \\n        else if(searchNode->left==NULL && searchNode->right==NULL)\\n             return delLeafNode(root,searchNode);\\n        //In case of single child node rest of the successor is added to parent node\\n        else if(searchNode->left==NULL || searchNode->right==NULL)\\n            return deleteSingleChildNode(root,searchNode);\\n        //Incase of double child we will find the rightmost node of left child\\n        else\\n        {\\n            TreeNode* maxLeft=maxInLeftSubTree(searchNode->left);\\n            int x=maxLeft->val;\\n            //if left child has no right node then it becomes the case of single child \\n            if(maxLeft->right==NULL)\\n                deleteSingleChildNode(root,maxLeft);\\n            //If left child has right node then we will copy that data to the node which is to be deleted and delete the rightmost node (it will be a leaf node)\\n            else\\n                delLeafNode(root,maxLeft);\\n            searchNode->val=x;\\n            return root;\\n        }\\n        return root;\\n    }\\n    TreeNode* search(TreeNode* root,int key)\\n    {\\n        if(root==NULL || root->val==key)\\n            return root;\\n        else if(key>root->val)\\n            return search(root->right,key);\\n        else\\n            return search(root->left,key);\\n    }\\n    TreeNode* delLeafNode(TreeNode* root,TreeNode* searchNode)\\n    {\\n        if(root==NULL || root==searchNode)\\n            return NULL;\\n        else if(searchNode->val>root->val)\\n            root->right=delLeafNode(root->right,searchNode);\\n        else\\n            root->left=delLeafNode(root->left,searchNode);\\n        return root;\\n    }\\n    TreeNode* deleteSingleChildNode(TreeNode* root,TreeNode* searchNode)\\n    {\\n        if(root==NULL)\\n            return NULL;\\n        else if(searchNode->val==root->val)\\n        {\\n            if(root->left)\\n                return root->left;\\n            return root->right;\\n        }\\n        else if(searchNode->val>root->val)\\n            root->right=deleteSingleChildNode(root->right,searchNode);\\n        else\\n            root->left=deleteSingleChildNode(root->left,searchNode);\\n        return root;\\n    }\\n    TreeNode* maxInLeftSubTree(TreeNode* root)\\n    {\\n        if(root->right)\\n             return maxInLeftSubTree(root->right);\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n\\t//first we will find the node with the given key\\n        TreeNode* searchNode=search(root,key);\\n        //If we don\\'t find the node.\\n        if(searchNode==NULL)\\n            return root;\\n        //In case of leaf Node just delete the Node \\n        else if(searchNode->left==NULL && searchNode->right==NULL)\\n             return delLeafNode(root,searchNode);\\n        //In case of single child node rest of the successor is added to parent node\\n        else if(searchNode->left==NULL || searchNode->right==NULL)\\n            return deleteSingleChildNode(root,searchNode);\\n        //Incase of double child we will find the rightmost node of left child\\n        else\\n        {\\n            TreeNode* maxLeft=maxInLeftSubTree(searchNode->left);\\n            int x=maxLeft->val;\\n            //if left child has no right node then it becomes the case of single child \\n            if(maxLeft->right==NULL)\\n                deleteSingleChildNode(root,maxLeft);\\n            //If left child has right node then we will copy that data to the node which is to be deleted and delete the rightmost node (it will be a leaf node)\\n            else\\n                delLeafNode(root,maxLeft);\\n            searchNode->val=x;\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1193715,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn delete_node(\\n        mut root: Option<Rc<RefCell<TreeNode>>>,\\n        key: i32,\\n    ) -> Option<Rc<RefCell<TreeNode>>> {\\n        root.delete(key);\\n        root\\n    }\\n}\\n\\ntrait Insertable<T> {\\n    fn insert(&mut self, item: T);\\n}\\n\\nimpl Insertable<Rc<RefCell<TreeNode>>> for TreeNode {\\n    fn insert(&mut self, other: Rc<RefCell<TreeNode>>) {\\n        if other.borrow().val >= self.val {\\n            let right = self.right.take();\\n            if let Some(node) = right {\\n                node.borrow_mut().insert(other);\\n                self.right = Some(node);\\n            } else {\\n                self.right = Some(other);\\n            }\\n        } else {\\n            let left = self.left.take();\\n            if let Some(node) = left {\\n                node.borrow_mut().insert(other);\\n                self.left = Some(node);\\n            } else {\\n                self.left = Some(other);\\n            }\\n        }\\n    }\\n}\\n\\ntrait Deletable<T> {\\n    fn delete(&mut self, key: T);\\n}\\n\\nimpl Deletable<i32> for Option<Rc<RefCell<TreeNode>>> {\\n    fn delete(&mut self, key: i32) {\\n        if let Some(node) = self.take() {\\n            let val = node.borrow().val;\\n            match val.cmp(&key) {\\n                std::cmp::Ordering::Equal => {\\n                    let left = node.borrow_mut().left.take();\\n                    let right = node.borrow_mut().right.take();\\n                    match (left, right) {\\n                        (None, None) => {\\n                            *self = None;\\n                        }\\n                        (Some(left), None) => {\\n                            *self = Some(left);\\n                        }\\n                        (None, Some(right)) => {\\n                            *self = Some(right);\\n                        }\\n                        (Some(left), Some(right)) => {\\n                            right.borrow_mut().insert(left);\\n                            *self = Some(right);\\n                        }\\n                    }\\n                }\\n                std::cmp::Ordering::Greater => {\\n                    node.borrow_mut().left.delete(key);\\n                    *self = Some(node);\\n                }\\n                std::cmp::Ordering::Less => {\\n                    node.borrow_mut().right.delete(key);\\n                    *self = Some(node);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn delete_node(\\n        mut root: Option<Rc<RefCell<TreeNode>>>,\\n        key: i32,\\n    ) -> Option<Rc<RefCell<TreeNode>>> {\\n        root.delete(key);\\n        root\\n    }\\n}\\n\\ntrait Insertable<T> {\\n    fn insert(&mut self, item: T);\\n}\\n\\nimpl Insertable<Rc<RefCell<TreeNode>>> for TreeNode {\\n    fn insert(&mut self, other: Rc<RefCell<TreeNode>>) {\\n        if other.borrow().val >= self.val {\\n            let right = self.right.take();\\n            if let Some(node) = right {\\n                node.borrow_mut().insert(other);\\n                self.right = Some(node);\\n            } else {\\n                self.right = Some(other);\\n            }\\n        } else {\\n            let left = self.left.take();\\n            if let Some(node) = left {\\n                node.borrow_mut().insert(other);\\n                self.left = Some(node);\\n            } else {\\n                self.left = Some(other);\\n            }\\n        }\\n    }\\n}\\n\\ntrait Deletable<T> {\\n    fn delete(&mut self, key: T);\\n}\\n\\nimpl Deletable<i32> for Option<Rc<RefCell<TreeNode>>> {\\n    fn delete(&mut self, key: i32) {\\n        if let Some(node) = self.take() {\\n            let val = node.borrow().val;\\n            match val.cmp(&key) {\\n                std::cmp::Ordering::Equal => {\\n                    let left = node.borrow_mut().left.take();\\n                    let right = node.borrow_mut().right.take();\\n                    match (left, right) {\\n                        (None, None) => {\\n                            *self = None;\\n                        }\\n                        (Some(left), None) => {\\n                            *self = Some(left);\\n                        }\\n                        (None, Some(right)) => {\\n                            *self = Some(right);\\n                        }\\n                        (Some(left), Some(right)) => {\\n                            right.borrow_mut().insert(left);\\n                            *self = Some(right);\\n                        }\\n                    }\\n                }\\n                std::cmp::Ordering::Greater => {\\n                    node.borrow_mut().left.delete(key);\\n                    *self = Some(node);\\n                }\\n                std::cmp::Ordering::Less => {\\n                    node.borrow_mut().right.delete(key);\\n                    *self = Some(node);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181655,
                "title": "javascript-iteration-recursion",
                "content": "iteration\\n```\\nvar deleteNode = function(root, key) {\\n    if(!root) return root;\\n    var cur = root;\\n    var pre;\\n    while(cur) {\\n        if(cur.val === key) break;\\n        pre = cur;\\n        if(key < cur.val) cur = cur.left;\\n        else cur = cur.right;\\n    }\\n    if(!pre) return deleteOneNode(cur);\\n    if(pre.left && pre.left.val === key) pre.left = deleteOneNode(cur);\\n    if(pre.right && pre.right.val === key) pre.right = deleteOneNode(cur);\\n    return root;\\n};\\n\\nvar deleteOneNode = function(node) {\\n    if(!node) return node;\\n    if(node.right === null) return node.left;\\n    if(node.left === null) return node.right;\\n    var rightChild = node.right;\\n    while(rightChild.left) rightChild = rightChild.left;\\n    rightChild.left = node.left;\\n    return node.right;\\n}\\n```\\nrecursion\\n```\\nvar deleteNode = function(root, key) {\\n    if(!root) return root;\\n    if(root.val < key) root.right = deleteNode(root.right, key);\\n    else if(root.val > key) root.left = deleteNode(root.left, key);\\n    else {\\n        if(root.left === null) return root.right;\\n        else if(root.right === null) return root.left;\\n        else {\\n            var cur = root.right;\\n            while(cur.left) cur = cur.left;\\n            cur.left = root.left;\\n            return root.right;\\n        }\\n    }\\n    return root;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteNode = function(root, key) {\\n    if(!root) return root;\\n    var cur = root;\\n    var pre;\\n    while(cur) {\\n        if(cur.val === key) break;\\n        pre = cur;\\n        if(key < cur.val) cur = cur.left;\\n        else cur = cur.right;\\n    }\\n    if(!pre) return deleteOneNode(cur);\\n    if(pre.left && pre.left.val === key) pre.left = deleteOneNode(cur);\\n    if(pre.right && pre.right.val === key) pre.right = deleteOneNode(cur);\\n    return root;\\n};\\n\\nvar deleteOneNode = function(node) {\\n    if(!node) return node;\\n    if(node.right === null) return node.left;\\n    if(node.left === null) return node.right;\\n    var rightChild = node.right;\\n    while(rightChild.left) rightChild = rightChild.left;\\n    rightChild.left = node.left;\\n    return node.right;\\n}\\n```\n```\\nvar deleteNode = function(root, key) {\\n    if(!root) return root;\\n    if(root.val < key) root.right = deleteNode(root.right, key);\\n    else if(root.val > key) root.left = deleteNode(root.left, key);\\n    else {\\n        if(root.left === null) return root.right;\\n        else if(root.right === null) return root.left;\\n        else {\\n            var cur = root.right;\\n            while(cur.left) cur = cur.left;\\n            cur.left = root.left;\\n            return root.right;\\n        }\\n    }\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1068423,
                "title": "simple-c-solution-96-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int find(TreeNode* root){\\n        if(!root) return INT_MAX;\\n        while(root->left){\\n            root=root->left;\\n        }\\n        return root->val;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n        if(root->val==key){\\n            if(!root->left && !root->right) return nullptr;\\n            else if(root->left && root->right){\\n                root->val=find(root->right);\\n                root->right=deleteNode(root->right,root->val);\\n            }else{\\n                if(root->left) return root->left;\\n                else return root->right;\\n            }\\n        }\\n        \\n        if(key < root->val) root->left=deleteNode(root->left,key);\\n        else root->right=deleteNode(root->right,key); \\n        return root;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int find(TreeNode* root){\\n        if(!root) return INT_MAX;\\n        while(root->left){\\n            root=root->left;\\n        }\\n        return root->val;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n        if(root->val==key){\\n            if(!root->left && !root->right) return nullptr;\\n            else if(root->left && root->right){\\n                root->val=find(root->right);\\n                root->right=deleteNode(root->right,root->val);\\n            }else{\\n                if(root->left) return root->left;\\n                else return root->right;\\n            }\\n        }\\n        \\n        if(key < root->val) root->left=deleteNode(root->left,key);\\n        else root->right=deleteNode(root->right,key); \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006325,
                "title": "golang-simple-recursive-solution",
                "content": "```golang\\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if key > root.Val {\\n        root.Right = deleteNode(root.Right, key)\\n        return root\\n    }\\n    \\n    if key < root.Val {\\n        root.Left = deleteNode(root.Left, key)\\n        return root\\n    }\\n    \\n    root = join(root.Left, root.Right)\\n    \\n    return root\\n}\\n\\nfunc join(left, right *TreeNode) *TreeNode {\\n    if left == nil {\\n        return right\\n    }\\n    \\n    if left.Right == nil {\\n        left.Right = right\\n        return left\\n    }\\n    \\n    left.Right = join(left.Right, right)\\n    \\n    return left\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if key > root.Val {\\n        root.Right = deleteNode(root.Right, key)\\n        return root\\n    }\\n    \\n    if key < root.Val {\\n        root.Left = deleteNode(root.Left, key)\\n        return root\\n    }\\n    \\n    root = join(root.Left, root.Right)\\n    \\n    return root\\n}\\n\\nfunc join(left, right *TreeNode) *TreeNode {\\n    if left == nil {\\n        return right\\n    }\\n    \\n    if left.Right == nil {\\n        left.Right = right\\n        return left\\n    }\\n    \\n    left.Right = join(left.Right, right)\\n    \\n    return left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 916478,
                "title": "easy-c",
                "content": "```\\n\\nclass Solution {\\n    \\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n    \\n        if(!root)\\n            return NULL;\\n        \\n        if(root->val > key)\\n            root->left = deleteNode(root->left, key);\\n        \\n        else if(root->val < key)\\n            root->right = deleteNode(root->right, key);\\n        \\n        // found key\\n        else{\\n            \\n           // 0 child\\n           if(!root->left && !root->right){\\n               delete(root);\\n               return NULL;\\n           }\\n            \\n            // 1 child\\n            if(!root->left || !root->right){\\n                TreeNode *child = root->left? root->left : root->right;\\n                delete(root);\\n                return child;\\n            }\\n            \\n            // 2 child\\n            TreeNode * left = root->left;\\n            TreeNode * right = root->right;\\n            root = root->left;\\n            \\n            while(root->right){\\n                root = root->right;\\n            }\\n            \\n            root->right = right;\\n            return left;\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n    \\n        if(!root)\\n            return NULL;\\n        \\n        if(root->val > key)\\n            root->left = deleteNode(root->left, key);\\n        \\n        else if(root->val < key)\\n            root->right = deleteNode(root->right, key);\\n        \\n        // found key\\n        else{\\n            \\n           // 0 child\\n           if(!root->left && !root->right){\\n               delete(root);\\n               return NULL;\\n           }\\n            \\n            // 1 child\\n            if(!root->left || !root->right){\\n                TreeNode *child = root->left? root->left : root->right;\\n                delete(root);\\n                return child;\\n            }\\n            \\n            // 2 child\\n            TreeNode * left = root->left;\\n            TreeNode * right = root->right;\\n            root = root->left;\\n            \\n            while(root->right){\\n                root = root->right;\\n            }\\n            \\n            root->right = right;\\n            return left;\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782257,
                "title": "c-a-simple-solution-with-deleting-the-memory",
                "content": "* free the memory \\n\\n```c++\\n\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n        if(key > root->val) {\\n            root->right = deleteNode(root->right, key);\\n        } else if(key < root->val) {\\n            root->left= deleteNode(root->left, key);\\n        } else {\\n            // the node has only one child. delete the node and return its child\\n            if(!root->left || !root->right) {\\n                TreeNode* ret = !root->left ? root->right : root->left;\\n                delete root;\\n                return ret;\\n            }\\n            // the node to be deleted has two children\\n            TreeNode* to_delete = root;\\n            root = rightMin(root->right);\\n            root->right= delRightMin(to_delete->right);\\n            root->left = to_delete->left;\\n            delete to_delete;\\n        }\\n        return root;\\n    }\\n    TreeNode* rightMin(TreeNode* root) {\\n        while(root->left) {\\n            root = root->left;\\n        }\\n        return root;\\n    }\\n    TreeNode* delRightMin(TreeNode* root) {\\n        if(!root->left) {\\n            return root->right;\\n        }\\n        root->left = delRightMin(root->left);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return nullptr;\\n        if(key > root->val) {\\n            root->right = deleteNode(root->right, key);\\n        } else if(key < root->val) {\\n            root->left= deleteNode(root->left, key);\\n        } else {\\n            // the node has only one child. delete the node and return its child\\n            if(!root->left || !root->right) {\\n                TreeNode* ret = !root->left ? root->right : root->left;\\n                delete root;\\n                return ret;\\n            }\\n            // the node to be deleted has two children\\n            TreeNode* to_delete = root;\\n            root = rightMin(root->right);\\n            root->right= delRightMin(to_delete->right);\\n            root->left = to_delete->left;\\n            delete to_delete;\\n        }\\n        return root;\\n    }\\n    TreeNode* rightMin(TreeNode* root) {\\n        while(root->left) {\\n            root = root->left;\\n        }\\n        return root;\\n    }\\n    TreeNode* delRightMin(TreeNode* root) {\\n        if(!root->left) {\\n            return root->right;\\n        }\\n        root->left = delRightMin(root->left);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726635,
                "title": "python-solution-explained",
                "content": "```\\nclass Solution:\\n    \\n    def solve(self,root,key):\\n        if root is None: return\\n        \\n        #found node\\n        if root.val == key:\\n            \\n            #case when both left and right root are there\\n            #Idea is to find inorder successor of root and then assign left child of root to its inorder successor\\n            if root.right and root.left:\\n                \\n                #Finding inorder successor of current node\\n                right = root.right\\n                while right.left:right = right.left\\n                    \\n                #assigning left child of root to inorder successor\\n                right.left = root.left\\n                \\n                return root.right\\n            \\n            #No right children\\n            elif root.left:return root.left\\n            \\n            #No left children\\n            elif root.right:return root.right\\n            \\n            #leaf node\\n            else:return None\\n\\n        elif key<root.val:\\n            root.left = self.solve(root.left,key)\\n        else:\\n            root.right = self.solve(root.right,key)\\n\\n        return root\\n\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        return self.solve(root,key)\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def solve(self,root,key):\\n        if root is None: return\\n        \\n        #found node\\n        if root.val == key:\\n            \\n            #case when both left and right root are there\\n            #Idea is to find inorder successor of root and then assign left child of root to its inorder successor\\n            if root.right and root.left:\\n                \\n                #Finding inorder successor of current node\\n                right = root.right\\n                while right.left:right = right.left\\n                    \\n                #assigning left child of root to inorder successor\\n                right.left = root.left\\n                \\n                return root.right\\n            \\n            #No right children\\n            elif root.left:return root.left\\n            \\n            #No left children\\n            elif root.right:return root.right\\n            \\n            #leaf node\\n            else:return None\\n\\n        elif key<root.val:\\n            root.left = self.solve(root.left,key)\\n        else:\\n            root.right = self.solve(root.right,key)\\n\\n        return root\\n\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        return self.solve(root,key)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 667503,
                "title": "error-in-testcase-root-3-1-4-null-2-key-3",
                "content": "For test case root = [3,1,4,null,2] key = 3, I am getting the result as [1,2,4] which also seems correct. But the leetcode is not accepting this as answer and showing [4,1,null,null,2] as correct answer.\\n\\nBelow is my code.\\n```\\ndef find(root,prev):\\n            if root == None:\\n                return root\\n            if root.val == key:\\n                # if prev == None:\\n                #     return None\\n                t = root\\n                c = None\\n                while t.left!=None:\\n                    t.val = t.left.val\\n                    if c == None:\\n                        c = t\\n                    else:\\n                        c = c.left\\n                    t = t.left\\n                if c == None and prev!=None:\\n                    if prev.left!=None and prev.left.val == key:\\n                        prev.left = None\\n                    else:\\n                        prev.right = None\\n                elif c == None and prev == None:\\n                    root = root.right\\n                else:\\n                    c.left = t.right\\n                return root\\n            find(root.left,root)\\n            find(root.right,root)\\n            return root\\n        return find(root,None)\\n```",
                "solutionTags": [],
                "code": "```\\ndef find(root,prev):\\n            if root == None:\\n                return root\\n            if root.val == key:\\n                # if prev == None:\\n                #     return None\\n                t = root\\n                c = None\\n                while t.left!=None:\\n                    t.val = t.left.val\\n                    if c == None:\\n                        c = t\\n                    else:\\n                        c = c.left\\n                    t = t.left\\n                if c == None and prev!=None:\\n                    if prev.left!=None and prev.left.val == key:\\n                        prev.left = None\\n                    else:\\n                        prev.right = None\\n                elif c == None and prev == None:\\n                    root = root.right\\n                else:\\n                    c.left = t.right\\n                return root\\n            find(root.left,root)\\n            find(root.right,root)\\n            return root\\n        return find(root,None)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 556767,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        if root == None:\\n            return root\\n        # Find node\\n        if key < root.val :\\n            root.left = self.deleteNode(root.left,key)\\n        elif key > root.val :\\n            root.right = self.deleteNode(root.right,key)\\n                \\n        else: # Node to delete\\n            # Case 1: No childs.\\n            if root.left == None and root.right == None:\\n                root = None\\n                \\n            # Case 2: One child\\n            elif root.left == None and root.right != None :\\n                root = root.right\\n            elif root.right == None and root.left != None :\\n                root = root.left\\n                \\n            # Case 3: 2 children\\n            else:\\n                minRoot = self.findMinNode(root.right)\\n                root.val = minRoot.val\\n                root.right = self.deleteNode(root.right,root.val)\\n                \\n        return root\\n\\n    def findMinNode(self, root: TreeNode) -> TreeNode:\\n        current = root \\n  \\n        # loop down to find the lefmost leaf \\n        while(current.left is not None): \\n            current = current.left \\n\\n        return current \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\\n        if root == None:\\n            return root\\n        # Find node\\n        if key < root.val :\\n            root.left = self.deleteNode(root.left,key)\\n        elif key > root.val :\\n            root.right = self.deleteNode(root.right,key)\\n                \\n        else: # Node to delete\\n            # Case 1: No childs.\\n            if root.left == None and root.right == None:\\n                root = None\\n                \\n            # Case 2: One child\\n            elif root.left == None and root.right != None :\\n                root = root.right\\n            elif root.right == None and root.left != None :\\n                root = root.left\\n                \\n            # Case 3: 2 children\\n            else:\\n                minRoot = self.findMinNode(root.right)\\n                root.val = minRoot.val\\n                root.right = self.deleteNode(root.right,root.val)\\n                \\n        return root\\n\\n    def findMinNode(self, root: TreeNode) -> TreeNode:\\n        current = root \\n  \\n        # loop down to find the lefmost leaf \\n        while(current.left is not None): \\n            current = current.left \\n\\n        return current \\n```",
                "codeTag": "Java"
            },
            {
                "id": 505634,
                "title": "java-simple-clear-algorithm",
                "content": "Once you find the node, there are 3 possible cases: 0, 1, or 2 children. We have to embed the find (rather than using a separate function) since we don\\'t have a parent pointer.  See below for a helpful YouTube link.\\n\\n```\\n    // return : either the node given, \\n\\t// or what we are replacing it with.\\n\\t//\\n\\tpublic TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        if (key < root.val) {\\n            root.left = deleteNode(root.left, key);\\n            return root;\\n        }\\n        if (key > root.val) {\\n            root.right = deleteNode(root.right, key);\\n            return root;\\n        }\\n        // root.val == key : it\\'s this node.\\n\\n        //  no children\\n        if (root.left == null && root.right == null) return null;\\n\\n        //  one child\\n        if (root.left == null) return root.right;\\n        if (root.right == null) return root.left;\\n\\n\\n        //   two children: splice in predecessor\\n        TreeNode prev=root.left;\\n        while (prev.right != null) prev = prev.right;\\n\\n        deleteNode(root, prev.val);\\n        prev.right = root.right;\\n        prev.left = root.left;\\n        return prev;\\n    }\\n```\\nI found this explanation quite helpful: https://youtu.be/7sF8c-HUsMY?list=PL2jykFOD1AWYKZIOoVAzEJOq3JQ_7sbLf&t=855\\n\\n",
                "solutionTags": [],
                "code": "```\\n    // return : either the node given, \\n\\t// or what we are replacing it with.\\n\\t//\\n\\tpublic TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        if (key < root.val) {\\n            root.left = deleteNode(root.left, key);\\n            return root;\\n        }\\n        if (key > root.val) {\\n            root.right = deleteNode(root.right, key);\\n            return root;\\n        }\\n        // root.val == key : it\\'s this node.\\n\\n        //  no children\\n        if (root.left == null && root.right == null) return null;\\n\\n        //  one child\\n        if (root.left == null) return root.right;\\n        if (root.right == null) return root.left;\\n\\n\\n        //   two children: splice in predecessor\\n        TreeNode prev=root.left;\\n        while (prev.right != null) prev = prev.right;\\n\\n        deleteNode(root, prev.val);\\n        prev.right = root.right;\\n        prev.left = root.left;\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427791,
                "title": "c-easy-to-understand-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* deleteNode(TreeNode* root, int key) {\\n\\t\\t\\tif(not root) return root;\\n\\t\\t\\tif(root->val>key){\\n\\t\\t\\t\\troot->left=deleteNode(root->left,key);\\n\\t\\t\\t}\\n\\t\\t\\telse if(root->val<key){\\n\\t\\t\\t\\troot->right=deleteNode(root->right,key);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(not root->left){\\n\\t\\t\\t\\t\\treturn root->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(not root->right){\\n\\t\\t\\t\\t\\treturn root->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tTreeNode* tem=root->right;\\n\\t\\t\\t\\t\\twhile(tem->left){\\n\\t\\t\\t\\t\\t\\ttem=tem->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\troot->val=tem->val;\\n\\t\\t\\t\\t\\troot->right=deleteNode(root->right,tem->val);\\n\\t\\t\\t\\t}       \\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* deleteNode(TreeNode* root, int key) {\\n\\t\\t\\tif(not root) return root;\\n\\t\\t\\tif(root->val>key){\\n\\t\\t\\t\\troot->left=deleteNode(root->left,key);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 337153,
                "title": "concise-clear-java-solution-different-way-w-o-swap-values",
                "content": "```\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        if (root.val == key) {\\n            if (root.left == null) return root.right;\\n            if (root.right == null) return root.left;\\n            TreeNode p = root.right;\\n            while (p.left != null) p = p.left;\\n            p.left = root.left;     // this is the difference\\n            return root.right;\\n        }\\n        \\n        if (root.val < key) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            root.left = deleteNode(root.left, key);\\n        }\\n        return root;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) return null;\\n        if (root.val == key) {\\n            if (root.left == null) return root.right;\\n            if (root.right == null) return root.left;\\n            TreeNode p = root.right;\\n            while (p.left != null) p = p.left;\\n            p.left = root.left;     // this is the difference\\n            return root.right;\\n        }\\n        \\n        if (root.val < key) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            root.left = deleteNode(root.left, key);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258853,
                "title": "straightforward-c-iterative-solution-no-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n  TreeNode* deleteNode( TreeNode* root, int key ) {\\n    if ( !root ) {\\n      return root;\\n    }\\n\\n    TreeNode dummy( 0 );\\n    dummy.left     = root;\\n    TreeNode *head = root, *prev = &dummy;\\n    bool      bleft = true;\\n    while ( head && head->val != key ) {\\n      prev = head;\\n      head = ( bleft = key < head->val ) ? head->left : head->right;\\n    }\\n    if ( !head ) {\\n      return root;  // not found\\n    }\\n\\n    if ( head->right ) {\\n      // head has right child; use the two-pointer method to find successor\\n      TreeNode *slow = head->right, *fast = slow->left;\\n      if ( fast ) {\\n        while ( fast->left ) {\\n          slow = slow->left;\\n          fast = fast->left;\\n        }\\n        // fast is the successor of head; slow is fast\\'s parent\\n        head->val  = fast->val;\\n        slow->left = fast->right;\\n        delete fast;\\n      } else {\\n        // slow is already the successor of head\\n        head->val   = slow->val;\\n        head->right = slow->right;\\n        delete slow;\\n      }\\n    } else {\\n      // head has no right child\\n      TreeNode*& prevchild = bleft ? prev->left : prev->right;\\n      prevchild            = head->left;\\n      delete head;\\n    }\\n    return dummy.left;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  TreeNode* deleteNode( TreeNode* root, int key ) {\\n    if ( !root ) {\\n      return root;\\n    }\\n\\n    TreeNode dummy( 0 );\\n    dummy.left     = root;\\n    TreeNode *head = root, *prev = &dummy;\\n    bool      bleft = true;\\n    while ( head && head->val != key ) {\\n      prev = head;\\n      head = ( bleft = key < head->val ) ? head->left : head->right;\\n    }\\n    if ( !head ) {\\n      return root;  // not found\\n    }\\n\\n    if ( head->right ) {\\n      // head has right child; use the two-pointer method to find successor\\n      TreeNode *slow = head->right, *fast = slow->left;\\n      if ( fast ) {\\n        while ( fast->left ) {\\n          slow = slow->left;\\n          fast = fast->left;\\n        }\\n        // fast is the successor of head; slow is fast\\'s parent\\n        head->val  = fast->val;\\n        slow->left = fast->right;\\n        delete fast;\\n      } else {\\n        // slow is already the successor of head\\n        head->val   = slow->val;\\n        head->right = slow->right;\\n        delete slow;\\n      }\\n    } else {\\n      // head has no right child\\n      TreeNode*& prevchild = bleft ? prev->left : prev->right;\\n      prevchild            = head->left;\\n      delete head;\\n    }\\n    return dummy.left;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254235,
                "title": "python-recursion-hibbard-deletion",
                "content": "Iteration might be more tricky since we need to track the pointer to parent node. So I solved it by recursion.\\n\\nConsidering it\\'s a BST, we can easiy locate the target node to delete. E.g. if current root\\'s val is larger than the key, the target node is in the left tree so we just **delete** the left subtree recursively.\\n\\nOnce we find the target node, we need to reconstruct the current sub tree. There are generally two cases:\\n1. There is only one branch or no branch, then we just replace current node with the existed branch or null (in Python, return node.left or node.right).\\n2. Both left and right branches exist, then we replace the curent node with the node **X** with the \\'closest\\' value and delete that node **X**. In my solution, I used **findClosest** to find the closest larger node which is the most left node in the right branch. Then I just used the main function to delete **X**. In this time, it will fall in case 1 since **X** has no left branch.\\n```\\ndef deleteNode(root, key):\\n\\tif not root: return None\\n\\tif root.val > key: \\n\\t\\troot.left = deleteNode(root.left, key)\\n\\telif root.val < key: \\n\\t\\troot.right = deleteNode(root.right, key)\\n\\telse:\\n\\t\\tif not (root.left and root.right): \\n\\t\\t\\treturn root.left or root.right\\n\\t\\troot.val = findClosest(root.right).val\\n\\t\\troot.right = deleteNode(root.right, root.val)\\n\\treturn root\\n\\ndef findClosest(node):\\n\\twhile node.left:\\n\\t\\tnode = node.left\\n\\treturn node\\n```\\nThe recursive(main) + iterative (findClosest) depth won\\'t exceed the height of tree since both always go down. So time complexity is O(h).\\n\\nAnd inspired by [algs4](https://algs4.cs.princeton.edu/lectures/keynote/32BinarySearchTrees.pdf), implement another pure recursive way to do Hibbard deletion.\\n```\\ndef deleteNode(root, key):\\n\\tif not root:\\n\\t\\treturn None\\n\\tif key < root.val:\\n\\t\\troot.left = deleteNode(root.left, key)\\n\\telif key > root.val:\\n\\t\\troot.right = deleteNode(root.right, key)\\n\\telif not (root.left and root.right):\\n\\t\\treturn root.left or root.right\\n\\telse:\\n\\t\\troot.right, root.val = delete_min(root.right)\\n\\treturn root\\n\\ndef delete_min(node):\\n\\tif node.left:\\n\\t\\tnode.left, min_val = delete_min(node.left)\\n\\t\\treturn node, min_val\\n\\treturn node.right, node.val\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef deleteNode(root, key):\\n\\tif not root: return None\\n\\tif root.val > key: \\n\\t\\troot.left = deleteNode(root.left, key)\\n\\telif root.val < key: \\n\\t\\troot.right = deleteNode(root.right, key)\\n\\telse:\\n\\t\\tif not (root.left and root.right): \\n\\t\\t\\treturn root.left or root.right\\n\\t\\troot.val = findClosest(root.right).val\\n\\t\\troot.right = deleteNode(root.right, root.val)\\n\\treturn root\\n\\ndef findClosest(node):\\n\\twhile node.left:\\n\\t\\tnode = node.left\\n\\treturn node\\n```\n```\\ndef deleteNode(root, key):\\n\\tif not root:\\n\\t\\treturn None\\n\\tif key < root.val:\\n\\t\\troot.left = deleteNode(root.left, key)\\n\\telif key > root.val:\\n\\t\\troot.right = deleteNode(root.right, key)\\n\\telif not (root.left and root.right):\\n\\t\\treturn root.left or root.right\\n\\telse:\\n\\t\\troot.right, root.val = delete_min(root.right)\\n\\treturn root\\n\\ndef delete_min(node):\\n\\tif node.left:\\n\\t\\tnode.left, min_val = delete_min(node.left)\\n\\t\\treturn node, min_val\\n\\treturn node.right, node.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 241184,
                "title": "python-2-recursive-bottom-up-solutions",
                "content": "I basically followed this standford\\'s lecture for the question\\nhttps://www.youtube.com/watch?v=tT9-aCWD1Ag\\n\\nAccording to marty, if your target node have 2 children, you can either replace your target node with its predecessor and successor, they both work\\n\\n**predecessor**\\n```python\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        Time\\t\\tO(h) height of tree\\n        Space\\t\\tO(h) recursion\\n        56 ms, faster than 99.87%\\n        21feb2019 updated\\n        \"\"\"\\n        if root == None:\\n            return None\\n        if root.val == key:\\n            if root.left == None and root.right == None:\\n                return None\\n            elif root.left == None:\\n                return root.right\\n            elif root.right == None:\\n                return root.left\\n            pre = self.findMaxFromLeft(root)\\n            root.val = pre.val\\n            root.left = self.deleteNode(root.left, pre.val)\\n            return root\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n\\n    def findMaxFromLeft(self, node):\\n        pre = node.left\\n        while pre.right != None:\\n            pre = pre.right\\n        return pre\\n```\\n\\n**successor**\\n```\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        Time\\t\\tO(h) height of tree\\n        Space\\t\\tO(h) recursion\\n        56 ms, faster than 99.87%\\n        21feb2019 updated\\n        \"\"\"\\n        if root == None:\\n            return None\\n        if root.val == key:\\n            if root.left == None and root.right == None:\\n                return None\\n            elif root.left == None:\\n                return root.right\\n            elif root.right == None:\\n                return root.left\\n            suc = self.findMinFromRight(root)\\n            root.val = suc.val\\n            root.right = self.deleteNode(root.right, suc.val)\\n            return root\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n\\n    def findMinFromRight(self, node):\\n        suc = node.right\\n        while suc.left != None:\\n            suc = suc.left\\n        return suc\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        Time\\t\\tO(h) height of tree\\n        Space\\t\\tO(h) recursion\\n        56 ms, faster than 99.87%\\n        21feb2019 updated\\n        \"\"\"\\n        if root == None:\\n            return None\\n        if root.val == key:\\n            if root.left == None and root.right == None:\\n                return None\\n            elif root.left == None:\\n                return root.right\\n            elif root.right == None:\\n                return root.left\\n            pre = self.findMaxFromLeft(root)\\n            root.val = pre.val\\n            root.left = self.deleteNode(root.left, pre.val)\\n            return root\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n\\n    def findMaxFromLeft(self, node):\\n        pre = node.left\\n        while pre.right != None:\\n            pre = pre.right\\n        return pre\\n```\n```\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        Time\\t\\tO(h) height of tree\\n        Space\\t\\tO(h) recursion\\n        56 ms, faster than 99.87%\\n        21feb2019 updated\\n        \"\"\"\\n        if root == None:\\n            return None\\n        if root.val == key:\\n            if root.left == None and root.right == None:\\n                return None\\n            elif root.left == None:\\n                return root.right\\n            elif root.right == None:\\n                return root.left\\n            suc = self.findMinFromRight(root)\\n            root.val = suc.val\\n            root.right = self.deleteNode(root.right, suc.val)\\n            return root\\n        if key < root.val:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n\\n    def findMinFromRight(self, node):\\n        suc = node.right\\n        while suc.left != None:\\n            suc = suc.left\\n        return suc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216914,
                "title": "c-recursive",
                "content": "1. Using properties of BST(i.e. ```left<root<right```) to find the node to delete.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return NULL;\\n        if (root->val > key) {\\n            root->left = deleteNode(root->left, key);\\n        } else if (root->val < key){\\n            root->right = deleteNode(root->right, key);\\n        } else {\\n            if (!root->left || !root->right) {\\n                root = (root->left) ? root->left : root->right;\\n            } else {\\n                TreeNode* rightMin = root->right;\\n                while (rightMin->left) rightMin = rightMin->left;\\n                root->val = rightMin->val;\\n                root->right = deleteNode(root->right, rightMin->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n2. Without using properties of BST: traversal all nodes, delete node with the same value as ```key```.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return NULL;\\n        if (root->val == key) {\\n            if (!root->right) return root->left;\\n            else {\\n                TreeNode* rightMin = root->right;\\n                while (rightMin->left) rightMin = rightMin->left;\\n                swap(root->val, rightMin->val);\\n            }\\n        }\\n        root->left = deleteNode(root->left, key);\\n        root->right = deleteNode(root->right, key);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```left<root<right```\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return NULL;\\n        if (root->val > key) {\\n            root->left = deleteNode(root->left, key);\\n        } else if (root->val < key){\\n            root->right = deleteNode(root->right, key);\\n        } else {\\n            if (!root->left || !root->right) {\\n                root = (root->left) ? root->left : root->right;\\n            } else {\\n                TreeNode* rightMin = root->right;\\n                while (rightMin->left) rightMin = rightMin->left;\\n                root->val = rightMin->val;\\n                root->right = deleteNode(root->right, rightMin->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```key```\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return NULL;\\n        if (root->val == key) {\\n            if (!root->right) return root->left;\\n            else {\\n                TreeNode* rightMin = root->right;\\n                while (rightMin->left) rightMin = rightMin->left;\\n                swap(root->val, rightMin->val);\\n            }\\n        }\\n        root->left = deleteNode(root->left, key);\\n        root->right = deleteNode(root->right, key);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144937,
                "title": "java-divide-and-conquor-solution-beats-100",
                "content": "When find the node to delete, always find the least number which is greater than the value to delete, which is in the right sub tree of the current node. if one of the sub tree of this current node is null, then directly return the other sub tree. Use findMin(node) to find the value to be replaced, then delete the leaf node.\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return root;\\n        if(key < root.val) root.left = deleteNode(root.left, key);\\n        else if(key > root.val) root.right = deleteNode(root.right, key);\\n        else {\\n            if(root.left == null) return root.right;\\n            else if(root.right == null) return root.left;\\n            else {\\n                int val = findMin(root.right);\\n                root.val = val;\\n                root.right = deleteNode(root.right, val);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    private int findMin(TreeNode root) {\\n        while(root.left != null) root = root.left;\\n        return root.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return root;\\n        if(key < root.val) root.left = deleteNode(root.left, key);\\n        else if(key > root.val) root.right = deleteNode(root.right, key);\\n        else {\\n            if(root.left == null) return root.right;\\n            else if(root.right == null) return root.left;\\n            else {\\n                int val = findMin(root.right);\\n                root.val = val;\\n                root.right = deleteNode(root.right, val);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    private int findMin(TreeNode root) {\\n        while(root.left != null) root = root.left;\\n        return root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93316,
                "title": "swift-solution-dfs",
                "content": "```\\nclass Solution {\\n    func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {\\n        guard let root = root else {\\n            return nil\\n        }\\n        \\n        if key < root.val {\\n            root.left = deleteNode(root.left, key)\\n        } else if key > root.val {\\n            root.right = deleteNode(root.right, key)\\n        } else {\\n            if root.left == nil {\\n                return root.right\\n            } else if root.right == nil {\\n                return root.left\\n            } else {\\n                let minNode = findMin(root.right!)\\n                root.val = minNode.val\\n                root.right = deleteNode(root.right, root.val)\\n            }\\n        }\\n        \\n        return root\\n    }\\n    \\n    func findMin(_ root: TreeNode) -> TreeNode {\\n        var root = root\\n        \\n        while let leftNode = root.left {\\n            root = leftNode\\n        }\\n        \\n        return root\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {\\n        guard let root = root else {\\n            return nil\\n        }\\n        \\n        if key < root.val {\\n            root.left = deleteNode(root.left, key)\\n        } else if key > root.val {\\n            root.right = deleteNode(root.right, key)\\n        } else {\\n            if root.left == nil {\\n                return root.right\\n            } else if root.right == nil {\\n                return root.left\\n            } else {\\n                let minNode = findMin(root.right!)\\n                root.val = minNode.val\\n                root.right = deleteNode(root.right, root.val)\\n            }\\n        }\\n        \\n        return root\\n    }\\n    \\n    func findMin(_ root: TreeNode) -> TreeNode {\\n        var root = root\\n        \\n        while let leftNode = root.left {\\n            root = leftNode\\n        }\\n        \\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93323,
                "title": "python-recursive-o-h",
                "content": "Keep in mind ```key``` might not be in the ```BST```. Then just do recursively checks to find the target node. Here I used ```left``` and ```right``` to represent the target node's left and right subtrees. If ```left``` exists, we make the left child of ```target``` be our new ```target```  and make ```right``` be the right subtree of the right most child of new ```target```. When ```left == None```, we can just make ```right``` be the new target.\\n```\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root: return root\\n        if root.val == key:\\n            left, right = root.left, root.right\\n            if left:\\n                root = p = left\\n                while p.right: p = p.right\\n                p.right = right\\n            else:\\n                root = right\\n        elif root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```key```\n```BST```\n```left```\n```right```\n```left```\n```target```\n```target```\n```right```\n```target```\n```left == None```\n```right```\n```\\nclass Solution(object):\\n    def deleteNode(self, root, key):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type key: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root: return root\\n        if root.val == key:\\n            left, right = root.left, root.right\\n            if left:\\n                root = p = left\\n                while p.right: p = p.right\\n                p.right = right\\n            else:\\n                root = right\\n        elif root.val > key:\\n            root.left = self.deleteNode(root.left, key)\\n        else:\\n            root.right = self.deleteNode(root.right, key)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93367,
                "title": "c-iterative",
                "content": "\\n```\\n    public TreeNode DeleteNode(TreeNode root, int key) \\n    {\\n        TreeNode parent = null;\\n        TreeNode node = root;\\n\\n        // find node and track parent\\n        while (node != null && node.val != key)\\n        {\\n            parent = node;\\n            node = key < node.val ? node.left : node.right;\\n        }\\n        \\n        // not found\\n        if (node == null) return root;\\n\\n        // build replacement - left tree with right tree appended to it's rightmost leaf\\n        TreeNode replacement = Combine(node.left, node.right);        \\n        if (parent == null)\\n        {\\n            // no parent replacing root\\n            return replacement;\\n        }\\n        else\\n        {\\n            if (parent.left == node) parent.left = replacement;\\n            if (parent.right == node) parent.right = replacement;\\n            return root;\\n        }\\n    }\\n    \\n    public TreeNode Combine(TreeNode left, TreeNode right)\\n    {\\n        if (left == null && right == null) return null;\\n        if (left == null) return right;\\n        if (right == null) return left;\\n        \\n        TreeNode head = left;\\n        while (left.right != null) left = left.right;\\n        left.right = right;\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode DeleteNode(TreeNode root, int key) \\n    {\\n        TreeNode parent = null;\\n        TreeNode node = root;\\n\\n        // find node and track parent\\n        while (node != null && node.val != key)\\n        {\\n            parent = node;\\n            node = key < node.val ? node.left : node.right;\\n        }\\n        \\n        // not found\\n        if (node == null) return root;\\n\\n        // build replacement - left tree with right tree appended to it's rightmost leaf\\n        TreeNode replacement = Combine(node.left, node.right);        \\n        if (parent == null)\\n        {\\n            // no parent replacing root\\n            return replacement;\\n        }\\n        else\\n        {\\n            if (parent.left == node) parent.left = replacement;\\n            if (parent.right == node) parent.right = replacement;\\n            return root;\\n        }\\n    }\\n    \\n    public TreeNode Combine(TreeNode left, TreeNode right)\\n    {\\n        if (left == null && right == null) return null;\\n        if (left == null) return right;\\n        if (right == null) return left;\\n        \\n        TreeNode head = left;\\n        while (left.right != null) left = left.right;\\n        left.right = right;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93388,
                "title": "python-recursive-solution",
                "content": "```python\\ndef deleteNode(self, root, key):\\n    \"\"\"\\n    :type root: TreeNode\\n    :type key: int\\n    :rtype: TreeNode\\n    \"\"\"\\n    if root is None: return\\n    if root.val == key:\\n        if root.right and root.left:\\n            right = root.right\\n            while right is not None and right.left is not None: right = right.left\\n            right.left = root.left\\n            return root.right\\n        else:\\n            if root.left:\\n                return root.left\\n            elif root.right:\\n                return root.right\\n            else:\\n                return None\\n\\n    elif key > root.val:\\n        root.right = self.deleteNode(root.right, key)\\n    else:\\n        root.left = self.deleteNode(root.left, key)\\n\\n    return root\\n```\\n\\nCould probably condense further.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef deleteNode(self, root, key):\\n    \"\"\"\\n    :type root: TreeNode\\n    :type key: int\\n    :rtype: TreeNode\\n    \"\"\"\\n    if root is None: return\\n    if root.val == key:\\n        if root.right and root.left:\\n            right = root.right\\n            while right is not None and right.left is not None: right = right.left\\n            right.left = root.left\\n            return root.right\\n        else:\\n            if root.left:\\n                return root.left\\n            elif root.right:\\n                return root.right\\n            else:\\n                return None\\n\\n    elif key > root.val:\\n        root.right = self.deleteNode(root.right, key)\\n    else:\\n        root.left = self.deleteNode(root.left, key)\\n\\n    return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3990204,
                "title": "simplest-iterative-c-code-by-actually-modifying-links-not-by-changing-values-beats-96",
                "content": "Note that you can make the solution modular by breaking the search part into a separate functions but I wanted you to understand the code in a flow.\\n\\n**Time** - $$O(H)$$, H is the height of the BST.\\n**Space** - $$O(1)$$, since it\\'s iterative, no stack space is used.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // helper contains the core deletion logic, once we\\'ve found the node to be deleted\\n// we also need to keep a track of its parent to make the link modifications after deletion\\n    void helper (TreeNode* par, TreeNode* child, bool right, TreeNode* &head) {\\n        if (!child->left) {\\n            TreeNode* temp = child->right;\\n            delete child;\\n            if (!par) {head = temp; return;} //we handle this case separately in each part\\n                                            //if the node to be deleted is the root node, our head changes to the temp node\\n            if (right) par->right = temp;\\n            else par->left = temp;\\n        }\\n        else if (!child->right) {\\n            TreeNode* temp = child->left;\\n            delete child;\\n            if (!par) {head = temp; return;}\\n            if (right) par->right = temp;\\n            else par->left = temp;\\n        }\\n    // if both right and left child exist\\n        else {\\n            TreeNode* temp = child->left, *newchild = child->left;\\n            while (temp->right) temp=temp->right;\\n            temp->right = child->right;\\n            delete child;\\n            if (!par) {head = newchild; return;}\\n            if (right) par->right = newchild;\\n            else par->left = newchild;\\n        }\\n    }\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return nullptr;\\n        TreeNode* par = nullptr, *child = root;\\n        bool right = true;\\n        while (child) {\\n            if (child->val == key) {\\n                break; //break out, since we found the node to be deleted\\n            }\\n            else if (child->val > key) {\\n                par = child;\\n                child = child->left;\\n                right = false; // \"right\" simply indicates whether the child is the right child of the parent. if it is left, right==false\\n            }\\n            else {\\n                par = child;\\n                child = child->right;\\n                right = true;\\n            }\\n        }\\n        if (!child) return root; //if key not found,  return the root as it is.\\n        TreeNode* head = root;\\n        helper(par, child, right, head);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // helper contains the core deletion logic, once we\\'ve found the node to be deleted\\n// we also need to keep a track of its parent to make the link modifications after deletion\\n    void helper (TreeNode* par, TreeNode* child, bool right, TreeNode* &head) {\\n        if (!child->left) {\\n            TreeNode* temp = child->right;\\n            delete child;\\n            if (!par) {head = temp; return;} //we handle this case separately in each part\\n                                            //if the node to be deleted is the root node, our head changes to the temp node\\n            if (right) par->right = temp;\\n            else par->left = temp;\\n        }\\n        else if (!child->right) {\\n            TreeNode* temp = child->left;\\n            delete child;\\n            if (!par) {head = temp; return;}\\n            if (right) par->right = temp;\\n            else par->left = temp;\\n        }\\n    // if both right and left child exist\\n        else {\\n            TreeNode* temp = child->left, *newchild = child->left;\\n            while (temp->right) temp=temp->right;\\n            temp->right = child->right;\\n            delete child;\\n            if (!par) {head = newchild; return;}\\n            if (right) par->right = newchild;\\n            else par->left = newchild;\\n        }\\n    }\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return nullptr;\\n        TreeNode* par = nullptr, *child = root;\\n        bool right = true;\\n        while (child) {\\n            if (child->val == key) {\\n                break; //break out, since we found the node to be deleted\\n            }\\n            else if (child->val > key) {\\n                par = child;\\n                child = child->left;\\n                right = false; // \"right\" simply indicates whether the child is the right child of the parent. if it is left, right==false\\n            }\\n            else {\\n                par = child;\\n                child = child->right;\\n                right = true;\\n            }\\n        }\\n        if (!child) return root; //if key not found,  return the root as it is.\\n        TreeNode* head = root;\\n        helper(par, child, right, head);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973631,
                "title": "very-hard-100-beats-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// TreeNode* minValue(TreeNode*root){\\n//     if(root==NULL){\\n//         return 0;\\n//     }\\n//     TreeNode*temp =root;\\n//     while(temp->left!=NULL){\\n//         temp= temp->left;\\n//     }\\n//     return temp;\\n// }\\nTreeNode* maxValue(TreeNode*root){\\n    if(root==NULL){\\n        return 0;\\n    }\\n    TreeNode*temp =root;\\n    while(temp->right!=NULL){\\n        temp= temp->right;\\n    }\\n    return temp;\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)\\n            return root;\\n        \\n        if(root->val ==key){\\n            // for 0 child\\n            if(root->left==NULL && root->right ==NULL){\\n                delete root;\\n                return NULL;\\n            }\\n            // for 1 child\\n            if(root->left!=NULL && root->right ==NULL){\\n                TreeNode*temp = root->left;\\n                delete root;\\n                return temp;\\n            }\\n             if(root->left==NULL && root->right !=NULL){\\n                TreeNode*temp = root->right;\\n                delete root;\\n                return temp;\\n            }\\n            // for 2 child\\n            if(root->left!=NULL && root->right!=NULL){\\n            int maxi = maxValue(root->left)->val;\\n              root->val = maxi;\\n              root->left =deleteNode(root->left,maxi);\\n              return root;\\n            }\\n        }\\n        else if(root->val >key){\\n            root->left= deleteNode(root->left,key);\\n            return root;\\n        }\\n        else{\\n            root->right = deleteNode(root->right,key);\\n            return root;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// TreeNode* minValue(TreeNode*root){\\n//     if(root==NULL){\\n//         return 0;\\n//     }\\n//     TreeNode*temp =root;\\n//     while(temp->left!=NULL){\\n//         temp= temp->left;\\n//     }\\n//     return temp;\\n// }\\nTreeNode* maxValue(TreeNode*root){\\n    if(root==NULL){\\n        return 0;\\n    }\\n    TreeNode*temp =root;\\n    while(temp->right!=NULL){\\n        temp= temp->right;\\n    }\\n    return temp;\\n}\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)\\n            return root;\\n        \\n        if(root->val ==key){\\n            // for 0 child\\n            if(root->left==NULL && root->right ==NULL){\\n                delete root;\\n                return NULL;\\n            }\\n            // for 1 child\\n            if(root->left!=NULL && root->right ==NULL){\\n                TreeNode*temp = root->left;\\n                delete root;\\n                return temp;\\n            }\\n             if(root->left==NULL && root->right !=NULL){\\n                TreeNode*temp = root->right;\\n                delete root;\\n                return temp;\\n            }\\n            // for 2 child\\n            if(root->left!=NULL && root->right!=NULL){\\n            int maxi = maxValue(root->left)->val;\\n              root->val = maxi;\\n              root->left =deleteNode(root->left,maxi);\\n              return root;\\n            }\\n        }\\n        else if(root->val >key){\\n            root->left= deleteNode(root->left,key);\\n            return root;\\n        }\\n        else{\\n            root->right = deleteNode(root->right,key);\\n            return root;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746554,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode inorderSuccessor(TreeNode root) {\\n        while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root;\\n    }\\n\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return root;\\n        if(root.val > key) {\\n            root.left = deleteNode(root.left, key);\\n        }\\n        else if(root.val < key) {\\n            root.right = deleteNode(root.right, key);\\n        }\\n        else { // key == root.data;\\n            //case 1  ---> while both node null\\n            if(root.left == null && root.right == null) {\\n                return null;\\n            }\\n\\n            //case - 2  -----> while a single node is null\\n            else if(root.left == null) {\\n                return root.right;\\n            }\\n            else if(root.right == null) {\\n                return root.left;\\n            }\\n\\n            //case - 3  -----> while it has both nodes\\n            else { \\n                TreeNode ios = inorderSuccessor(root.right);\\n                root.val = ios.val;\\n                root.right = deleteNode(root.right, ios.val);\\n            } \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode inorderSuccessor(TreeNode root) {\\n        while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root;\\n    }\\n\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null) return root;\\n        if(root.val > key) {\\n            root.left = deleteNode(root.left, key);\\n        }\\n        else if(root.val < key) {\\n            root.right = deleteNode(root.right, key);\\n        }\\n        else { // key == root.data;\\n            //case 1  ---> while both node null\\n            if(root.left == null && root.right == null) {\\n                return null;\\n            }\\n\\n            //case - 2  -----> while a single node is null\\n            else if(root.left == null) {\\n                return root.right;\\n            }\\n            else if(root.right == null) {\\n                return root.left;\\n            }\\n\\n            //case - 3  -----> while it has both nodes\\n            else { \\n                TreeNode ios = inorderSuccessor(root.right);\\n                root.val = ios.val;\\n                root.right = deleteNode(root.right, ios.val);\\n            } \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717984,
                "title": "easiest-explaination-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe function deleteNode() is used to delete a node with a given key from a binary search tree while maintaining the binary search tree property. The binary search tree property states that for any node, all the values in its left subtree are less than its value, and all the values in its right subtree are greater than its value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart with the root node of the binary search tree.\\nIf the root is NULL, return NULL indicating an empty tree.\\nIf the key is less than the value of the current node (key < root->val), recursively delete the node in the left subtree. Update the left child of the root by calling deleteNode() with the left child of the root and the key as arguments.\\nIf the key is greater than the value of the current node (key > root->val), recursively delete the node in the right subtree. Update the right child of the root by calling deleteNode() with the right child of the root and the key as arguments.\\nIf the key is equal to the value of the current node (key == root->val), it means we have found the node to delete.\\nIf the node has no children (root->left == NULL && root->right == NULL), it is a leaf node. In this case, we can simply return NULL to remove the node from the tree.\\nIf the node has only one child, either on the left or right (root->left != NULL || root->right != NULL), we can replace the node with its child. Update the parent node of the current node accordingly.\\nIf the node has both left and right children (root->left != NULL && root->right != NULL), we need to find either the in-order predecessor (largest value in the left subtree) or the in-order successor (smallest value in the right subtree) to replace the current node. We choose to find the in-order predecessor.\\nFind the in-order predecessor by traversing to the rightmost node in the left subtree (Inpre() function). Replace the value of the current node with the value of the in-order predecessor.\\nRecursively delete the in-order predecessor from the left subtree by calling deleteNode() with the left child of the root and the value of the in-order predecessor as arguments.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the deleteNode() function is O(log N) on average, where N is the number of nodes in the binary search tree. In the worst case, when the tree is skewed and has N nodes in a single branch, the time complexity is O(N).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(log N) on average due to the recursive calls, and O(N) in the worst case for a skewed tree.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int Height(TreeNode* p){\\n        int x,y;\\n        if(!p){\\n            return 0;\\n        }\\n        x=Height(p->left);\\n        y=Height(p->right);\\n        return x>y?x+1:y+1;\\n    }\\n    TreeNode* Inpre(TreeNode*root){\\n        while(root && root->right){\\n            root=root->right;\\n        }\\n        return root;\\n    }\\n    TreeNode* Insucc(TreeNode*root){\\n        while(root && root->left){\\n            root=root->left;\\n        }\\n        return root;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root){\\n            return NULL;\\n        }\\n        if(!root->left && !root->right){\\n            if(key==root->val){\\n                return NULL;\\n            }\\n            return root;\\n        }\\n        if(key<root->val){\\n            root->left= deleteNode(root->left,key);\\n        }\\n        else if(key>root->val){\\n            root->right=deleteNode(root->right,key);\\n        }\\n        else{\\n            if(Height(root->left)>Height(root->right)){\\n                TreeNode *q= Inpre(root->left);\\n                root->val=q->val;\\n                root->left=deleteNode(root->left,q->val);\\n            }\\n            else\\n            {\\n                TreeNode *q= Insucc(root->right);\\n                root->val=q->val;\\n                root->right=deleteNode(root->right,q->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int Height(TreeNode* p){\\n        int x,y;\\n        if(!p){\\n            return 0;\\n        }\\n        x=Height(p->left);\\n        y=Height(p->right);\\n        return x>y?x+1:y+1;\\n    }\\n    TreeNode* Inpre(TreeNode*root){\\n        while(root && root->right){\\n            root=root->right;\\n        }\\n        return root;\\n    }\\n    TreeNode* Insucc(TreeNode*root){\\n        while(root && root->left){\\n            root=root->left;\\n        }\\n        return root;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root){\\n            return NULL;\\n        }\\n        if(!root->left && !root->right){\\n            if(key==root->val){\\n                return NULL;\\n            }\\n            return root;\\n        }\\n        if(key<root->val){\\n            root->left= deleteNode(root->left,key);\\n        }\\n        else if(key>root->val){\\n            root->right=deleteNode(root->right,key);\\n        }\\n        else{\\n            if(Height(root->left)>Height(root->right)){\\n                TreeNode *q= Inpre(root->left);\\n                root->val=q->val;\\n                root->left=deleteNode(root->left,q->val);\\n            }\\n            else\\n            {\\n                TreeNode *q= Insucc(root->right);\\n                root->val=q->val;\\n                root->right=deleteNode(root->right,q->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604549,
                "title": "python-easy-iterative-solution",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root==None:\\n            return None\\n        if root.val==key:\\n            return self.delete(root)\\n        temp=root\\n        while root:\\n            if root.val>key:\\n                if root.left and root.left.val==key:\\n                    root.left=self.delete(root.left)\\n                    break\\n                else:\\n                    root=root.left\\n            else:\\n                if root.right and root.right.val==key:\\n                    root.right=self.delete(root.right)\\n                    break\\n                else:\\n                    root=root.right\\n        return temp\\n    \\n    def delete(self,root):\\n        if root.left==None:\\n            return root.right\\n        if root.right==None:\\n            return root.left\\n        rightChild=root.right\\n        lastRight=self.findLastRight(root.left)\\n        lastRight.right=rightChild\\n        return root.left\\n    \\n    def findLastRight(self,root):\\n        if root.right==None:\\n            return root\\n        return self.findLastRight(root.right)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if root==None:\\n            return None\\n        if root.val==key:\\n            return self.delete(root)\\n        temp=root\\n        while root:\\n            if root.val>key:\\n                if root.left and root.left.val==key:\\n                    root.left=self.delete(root.left)\\n                    break\\n                else:\\n                    root=root.left\\n            else:\\n                if root.right and root.right.val==key:\\n                    root.right=self.delete(root.right)\\n                    break\\n                else:\\n                    root=root.right\\n        return temp\\n    \\n    def delete(self,root):\\n        if root.left==None:\\n            return root.right\\n        if root.right==None:\\n            return root.left\\n        rightChild=root.right\\n        lastRight=self.findLastRight(root.left)\\n        lastRight.right=rightChild\\n        return root.left\\n    \\n    def findLastRight(self,root):\\n        if root.right==None:\\n            return root\\n        return self.findLastRight(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564018,
                "title": "easy-c-solution-using-helper",
                "content": "\\n# Code\\n```\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n       if(root==NULL) return NULL;\\n       if(root->val==key)\\n        { return helper(root);\\n        }        \\n        TreeNode* dummy=root;\\n        while(root!=NULL)\\n        {\\n            if(root->val>key)\\n            {\\n                if(root->left!=NULL&& root->left->val==key)\\n                {\\n                    root->left=helper(root->left);\\n                    break;\\n                }\\n                else\\n                {root=root->left;\\n                }\\n        }\\n        else\\n        {\\n            if(root->right!=NULL&& root->right->val==key)\\n            {\\n            root->right=helper(root->right);\\n            break;\\n            }\\n            else\\n            {\\n                root=root->right;\\n            } \\n        }\\n    }\\n    return dummy;\\n}\\nTreeNode* helper(TreeNode* root){\\n    if(root->left==NULL){return root->right;}\\n    else if(root->right==NULL){return root->left;}\\n     TreeNode* rightchild=root->right;\\n     TreeNode* lastright=lastrightchild(root->left);\\n     lastright->right=rightchild;\\n     return root->left;\\n}\\nTreeNode* lastrightchild(TreeNode* root){\\n    if(root->right==NULL){return root;}\\n  return lastrightchild(root->right);}\\n  };\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n       if(root==NULL) return NULL;\\n       if(root->val==key)\\n        { return helper(root);\\n        }        \\n        TreeNode* dummy=root;\\n        while(root!=NULL)\\n        {\\n            if(root->val>key)\\n            {\\n                if(root->left!=NULL&& root->left->val==key)\\n                {\\n                    root->left=helper(root->left);\\n                    break;\\n                }\\n                else\\n                {root=root->left;\\n                }\\n        }\\n        else\\n        {\\n            if(root->right!=NULL&& root->right->val==key)\\n            {\\n            root->right=helper(root->right);\\n            break;\\n            }\\n            else\\n            {\\n                root=root->right;\\n            } \\n        }\\n    }\\n    return dummy;\\n}\\nTreeNode* helper(TreeNode* root){\\n    if(root->left==NULL){return root->right;}\\n    else if(root->right==NULL){return root->left;}\\n     TreeNode* rightchild=root->right;\\n     TreeNode* lastright=lastrightchild(root->left);\\n     lastright->right=rightchild;\\n     return root->left;\\n}\\nTreeNode* lastrightchild(TreeNode* root){\\n    if(root->right==NULL){return root;}\\n  return lastrightchild(root->right);}\\n  };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555919,
                "title": "100-beats-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode InorderSuccessors(TreeNode root){\\n        while(root.left != null){\\n            root = root.left;\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n\\n        if(root == null){\\n            return null;\\n        }\\n\\n        if(root.val < key){\\n            root.right = deleteNode(root.right, key);\\n        }\\n        else if(root.val > key){\\n            root.left = deleteNode(root.left, key);\\n        }else{\\n\\n            if(root.left == null && root.right == null){\\n                return null;\\n            }\\n\\n            if(root.left == null){\\n                return root.right;\\n            }else if(root.right == null){\\n                 return root.left;\\n            }\\n\\n            TreeNode IS = InorderSuccessors(root.right);\\n            root.val = IS.val;\\n            root.right = deleteNode(root.right, IS.val);\\n            \\n            \\n            }\\n\\n  return root;   \\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode InorderSuccessors(TreeNode root){\\n        while(root.left != null){\\n            root = root.left;\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n\\n        if(root == null){\\n            return null;\\n        }\\n\\n        if(root.val < key){\\n            root.right = deleteNode(root.right, key);\\n        }\\n        else if(root.val > key){\\n            root.left = deleteNode(root.left, key);\\n        }else{\\n\\n            if(root.left == null && root.right == null){\\n                return null;\\n            }\\n\\n            if(root.left == null){\\n                return root.right;\\n            }else if(root.right == null){\\n                 return root.left;\\n            }\\n\\n            TreeNode IS = InorderSuccessors(root.right);\\n            root.val = IS.val;\\n            root.right = deleteNode(root.right, IS.val);\\n            \\n            \\n            }\\n\\n  return root;   \\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396524,
                "title": "delete-node-in-a-bst-java-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode solve(TreeNode root){\\n        if(root.left==null){\\n            return root.right;\\n        }\\n        else if(root.right==null){\\n            return root.left;\\n        }\\n        TreeNode rootRightTree = root.right;\\n        TreeNode leftLastRight = findLastRight(root.left);\\n        leftLastRight.right = rootRightTree;\\n        return root.left;\\n    }\\n    TreeNode findLastRight(TreeNode root){\\n        while(root.right!=null){\\n            root=root.right;\\n        }\\n        return root;\\n    }\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        if(root.val==key){\\n            return solve(root);\\n        }\\n        TreeNode curr = root;\\n        while(curr!=null){\\n            if(curr.val>key){\\n                if(curr.left!=null && curr.left.val==key){\\n                    curr.left = solve(curr.left);\\n                    break;\\n                }\\n                else{\\n                    curr = curr.left;\\n                }\\n            }\\n            else{\\n                if(curr.right!=null && curr.right.val==key){\\n                    curr.right = solve(curr.right);\\n                    break;\\n                }\\n                else{\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode solve(TreeNode root){\\n        if(root.left==null){\\n            return root.right;\\n        }\\n        else if(root.right==null){\\n            return root.left;\\n        }\\n        TreeNode rootRightTree = root.right;\\n        TreeNode leftLastRight = findLastRight(root.left);\\n        leftLastRight.right = rootRightTree;\\n        return root.left;\\n    }\\n    TreeNode findLastRight(TreeNode root){\\n        while(root.right!=null){\\n            root=root.right;\\n        }\\n        return root;\\n    }\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        if(root.val==key){\\n            return solve(root);\\n        }\\n        TreeNode curr = root;\\n        while(curr!=null){\\n            if(curr.val>key){\\n                if(curr.left!=null && curr.left.val==key){\\n                    curr.left = solve(curr.left);\\n                    break;\\n                }\\n                else{\\n                    curr = curr.left;\\n                }\\n            }\\n            else{\\n                if(curr.right!=null && curr.right.val==key){\\n                    curr.right = solve(curr.right);\\n                    break;\\n                }\\n                else{\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339845,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used recursive properties\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n            return root;\\n        }\\n        else if(root.val>key){\\n            root.left=deleteNode(root.left,key);\\n            return root;\\n        }\\n        else{\\n            //case 1:-No child ((leaf node))\\n            if(root.left==null && root.right==null){\\n                return null;\\n            }\\n            //case 2:- single child\\n            if(root.left==null){\\n                return root.right;\\n            }\\n            else if(root.right==null){\\n                return root.left;\\n            }\\n            //case 3=Two children\\n            else{\\n            TreeNode IS=root.right;\\n            while(IS.left!=null){\\n                IS=IS.left;\\n            }\\n            root.val=IS.val;\\n            root.right=deleteNode(root.right,IS.val);\\n            return root;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n            return root;\\n        }\\n        else if(root.val>key){\\n            root.left=deleteNode(root.left,key);\\n            return root;\\n        }\\n        else{\\n            //case 1:-No child ((leaf node))\\n            if(root.left==null && root.right==null){\\n                return null;\\n            }\\n            //case 2:- single child\\n            if(root.left==null){\\n                return root.right;\\n            }\\n            else if(root.right==null){\\n                return root.left;\\n            }\\n            //case 3=Two children\\n            else{\\n            TreeNode IS=root.right;\\n            while(IS.left!=null){\\n                IS=IS.left;\\n            }\\n            root.val=IS.val;\\n            root.right=deleteNode(root.right,IS.val);\\n            return root;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170998,
                "title": "c-binary-search-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode*inordersucc(TreeNode *root)\\n    {\\n        TreeNode *curr=root;\\n        while(curr && curr->left !=NULL)\\n        {\\n            curr=curr->left;\\n        }\\n        return curr;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        if(root->val>key)\\n        {\\n            root->left=deleteNode(root->left,key);\\n        }\\n        else if(root->val<key)\\n        {\\n            root->right=deleteNode(root->right,key);\\n        }\\n        else{\\n            if(root->left==NULL)\\n            {\\n                TreeNode *temp=root->right;\\n                delete root;\\n                return temp;\\n            }\\n            else if(root->right==NULL)\\n            {\\n                TreeNode *temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            TreeNode *temp=inordersucc(root->right);\\n            root->val=temp->val;\\n            root->right=deleteNode(root->right,temp->val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode*inordersucc(TreeNode *root)\\n    {\\n        TreeNode *curr=root;\\n        while(curr && curr->left !=NULL)\\n        {\\n            curr=curr->left;\\n        }\\n        return curr;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        if(root->val>key)\\n        {\\n            root->left=deleteNode(root->left,key);\\n        }\\n        else if(root->val<key)\\n        {\\n            root->right=deleteNode(root->right,key);\\n        }\\n        else{\\n            if(root->left==NULL)\\n            {\\n                TreeNode *temp=root->right;\\n                delete root;\\n                return temp;\\n            }\\n            else if(root->right==NULL)\\n            {\\n                TreeNode *temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            TreeNode *temp=inordersucc(root->right);\\n            root->val=temp->val;\\n            root->right=deleteNode(root->right,temp->val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081655,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(key<root.val){\\n            root.left=deleteNode(root.left,key);\\n        }\\n        else if(key>root.val){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.left==null) return root.right;\\n            if(root.right==null) return root.left;\\n\\n            root.val=minvalue(root.right);//to find inorder succesor\\n\\n            root.right=deleteNode(root.right,root.val);\\n        }\\n        return root;\\n    }\\n\\n    public int minvalue(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(key<root.val){\\n            root.left=deleteNode(root.left,key);\\n        }\\n        else if(key>root.val){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.left==null) return root.right;\\n            if(root.right==null) return root.left;\\n\\n            root.val=minvalue(root.right);//to find inorder succesor\\n\\n            root.right=deleteNode(root.right,root.val);\\n        }\\n        return root;\\n    }\\n\\n    public int minvalue(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079822,
                "title": "0ms-100-faster-java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n\\n        if(key<root.val){\\n            root.left=deleteNode(root.left,key);\\n        }\\n        else if(key>root.val){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.left==null) return root.right;\\n            if(root.right==null) return root.left;\\n\\n            root.val=minvalue(root.right);//to find inorder succesor\\n\\n            root.right=deleteNode(root.right,root.val);\\n        }\\n        return root;\\n    }\\n\\n    public int minvalue(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n\\n        if(key<root.val){\\n            root.left=deleteNode(root.left,key);\\n        }\\n        else if(key>root.val){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.left==null) return root.right;\\n            if(root.right==null) return root.left;\\n\\n            root.val=minvalue(root.right);//to find inorder succesor\\n\\n            root.right=deleteNode(root.right,root.val);\\n        }\\n        return root;\\n    }\\n\\n    public int minvalue(TreeNode root){\\n        int min=root.val;\\n        while(root.left!=null){\\n            min=root.left.val;\\n            root=root.left;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068955,
                "title": "delete-node-in-a-bst-golang",
                "content": "# Intuition\\nSearch first, then delete.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWhen the target node is in left subtree, root.Left = deleteNode(root.Left, val), if in right, root.Right = deleteNode(root.Right, val)\\n\\nWhen root to be deleted, 3 cases:\\n1. When this is a leave node, just return nil\\n2. When this only have one child, return the child\\n3. When this node has both child, find the smallest node in right subtree (or biggest in left subtree), get the smallest node in right subtree, delete the smallest node in the right sub tree. And treat this node as new root, it\\'s left and right subtree is the same as the previous root\\'s left right subtree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    if root.Val == key {\\n        // do delete operation\\n        \\n        // case 1: this is a leaf node, directly delete\\n        if root.Left == nil && root.Right == nil {\\n            return nil\\n        }\\n\\n        // case 2: it has only one child, let the one child to replace it\\n        if root.Left == nil && root.Right != nil {\\n            return root.Right\\n        }  \\n        if root.Left != nil && root.Right == nil {\\n            return root.Left\\n        }\\n\\n        // case 3: it has both left and right child\\n        if root.Left != nil && root.Right != nil {\\n            // Found the smallest node on the right to replace it\\n            minSubTreeNode := getMin(root.Right)\\n            leftSubTree := root.Left\\n            rightSubTree := deleteNode(root.Right, minSubTreeNode.Val)\\n            minSubTreeNode.Left = leftSubTree\\n            minSubTreeNode.Right = rightSubTree\\n            return minSubTreeNode\\n        }\\n    }\\n\\n    if root.Val > key {\\n        root.Left = deleteNode(root.Left, key)\\n    }\\n\\n    if root.Val < key {\\n        root.Right = deleteNode(root.Right, key)\\n    }\\n\\n    return root\\n}\\n\\nfunc getMin(root *TreeNode) *TreeNode {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    if root.Left == nil {\\n        return root\\n    }\\n\\n    return getMin(root.Left)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    if root.Val == key {\\n        // do delete operation\\n        \\n        // case 1: this is a leaf node, directly delete\\n        if root.Left == nil && root.Right == nil {\\n            return nil\\n        }\\n\\n        // case 2: it has only one child, let the one child to replace it\\n        if root.Left == nil && root.Right != nil {\\n            return root.Right\\n        }  \\n        if root.Left != nil && root.Right == nil {\\n            return root.Left\\n        }\\n\\n        // case 3: it has both left and right child\\n        if root.Left != nil && root.Right != nil {\\n            // Found the smallest node on the right to replace it\\n            minSubTreeNode := getMin(root.Right)\\n            leftSubTree := root.Left\\n            rightSubTree := deleteNode(root.Right, minSubTreeNode.Val)\\n            minSubTreeNode.Left = leftSubTree\\n            minSubTreeNode.Right = rightSubTree\\n            return minSubTreeNode\\n        }\\n    }\\n\\n    if root.Val > key {\\n        root.Left = deleteNode(root.Left, key)\\n    }\\n\\n    if root.Val < key {\\n        root.Right = deleteNode(root.Right, key)\\n    }\\n\\n    return root\\n}\\n\\nfunc getMin(root *TreeNode) *TreeNode {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    if root.Left == nil {\\n        return root\\n    }\\n\\n    return getMin(root.Left)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3064877,
                "title": "simple-clean-optimized-c-solution-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nclass Solution {\\npublic:\\n\\n    int get_minimum_on_right_subtree(TreeNode* root)\\n    {\\n        root = root->right;\\n        while(root->left != NULL) root = root->left;\\n        return root->val;\\n    }\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n        if(root == NULL) return NULL;\\n\\n        if(key > root->val)\\n        {\\n            root->right = deleteNode(root->right, key);\\n        }\\n        else if(key < root->val)\\n        {\\n            root->left = deleteNode(root->left, key);\\n        }\\n        else\\n        {\\n            // Key found\\n            // Either both child don\\'t exist or left child don\\'t exist\\n            if(root->left == NULL)\\n            {\\n                TreeNode* right_child = root->right;\\n                delete(root);\\n                return right_child;\\n            }\\n            // right child don\\'t exist\\n            else if(root->right == NULL)\\n            {\\n                TreeNode* left_child = root->left;\\n                delete(root);\\n                return left_child;\\n            } \\n            // Both children are present\\n            else\\n            {\\n                int replace = get_minimum_on_right_subtree(root);\\n                root->val = replace;\\n                root->right = deleteNode(root->right, replace);\\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int get_minimum_on_right_subtree(TreeNode* root)\\n    {\\n        root = root->right;\\n        while(root->left != NULL) root = root->left;\\n        return root->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3053747,
                "title": "java-simple-easy-and-100-faster-solution",
                "content": "Please upvote if understood \\n\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null){\\n            return root;\\n        }\\n\\t\\t// If target is found then attaching the left subtree to left leaf of right subtree \\n        if(root.val == key){\\n            TreeNode temp_left = root.left ;\\n            TreeNode temp_right = root.right;\\n            if(temp_right == null){\\n                return temp_left;\\n            }else{\\n                LeftLeaf(temp_right).left = temp_left;\\n                return temp_right;\\n            }\\n        }\\n        if(root.val >key){\\n            root.left = deleteNode(root.left,key);\\n        }else{\\n            root.right = deleteNode(root.right,key);\\n        }\\n        return root;\\n    }\\n    public TreeNode LeftLeaf(TreeNode root){\\n        if(root.left == null){\\n            return root ;\\n        }\\n        return LeftLeaf(root.left);\\n}",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "Please upvote if understood \\n\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null){\\n            return root;\\n        }\\n\\t\\t// If target is found then attaching the left subtree to left leaf of right subtree \\n        if(root.val == key){\\n            TreeNode temp_left = root.left ;\\n            TreeNode temp_right = root.right;\\n            if(temp_right == null){\\n                return temp_left;\\n            }else{\\n                LeftLeaf(temp_right).left = temp_left;\\n                return temp_right;\\n            }\\n        }\\n        if(root.val >key){\\n            root.left = deleteNode(root.left,key);\\n        }else{\\n            root.right = deleteNode(root.right,key);\\n        }\\n        return root;\\n    }\\n    public TreeNode LeftLeaf(TreeNode root){\\n        if(root.left == null){\\n            return root ;\\n        }\\n        return LeftLeaf(root.left);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3040882,
                "title": "easy-c-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Using recursion and inorder successor \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Leaf node: simply delete it\\n    2. Node with only one child: copy child to temp node and delete it.\\n    3. Node with two children: find inorder successor copy it to temp then delete it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(log N), Space used for recursion stack\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode *inorderSuccessor(struct TreeNode* root){\\n    struct TreeNode* curr=root;\\n    while(curr&&curr->left!=NULL) curr=curr->left;\\n    return curr;\\n}\\nstruct TreeNode* deleteNode(struct TreeNode* root, int key){\\n    if(root==NULL) return root;     //Base case\\n    if(key<(root->val)) root->left=deleteNode(root->left,key);\\n    else if(key>(root->val)) root->right=deleteNode(root->right,key);\\n    else{\\n        //node with one or no child\\n        if(root->left==NULL){\\n            struct TreeNode *temp=root->right;\\n            free(root);\\n            return temp;\\n        }\\n        if(root->right==NULL){\\n            struct TreeNode *temp=root->left;\\n            free(root);\\n            return temp;\\n        }\\n        //for node with 2 kids find inorder successor and delete it\\n        else{\\n            struct TreeNode *temp=inorderSuccessor(root->right);\\n            root->val=temp->val;\\n            root->right=deleteNode(root->right, temp->val);\\n        }\\n    }\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode *inorderSuccessor(struct TreeNode* root){\\n    struct TreeNode* curr=root;\\n    while(curr&&curr->left!=NULL) curr=curr->left;\\n    return curr;\\n}\\nstruct TreeNode* deleteNode(struct TreeNode* root, int key){\\n    if(root==NULL) return root;     //Base case\\n    if(key<(root->val)) root->left=deleteNode(root->left,key);\\n    else if(key>(root->val)) root->right=deleteNode(root->right,key);\\n    else{\\n        //node with one or no child\\n        if(root->left==NULL){\\n            struct TreeNode *temp=root->right;\\n            free(root);\\n            return temp;\\n        }\\n        if(root->right==NULL){\\n            struct TreeNode *temp=root->left;\\n            free(root);\\n            return temp;\\n        }\\n        //for node with 2 kids find inorder successor and delete it\\n        else{\\n            struct TreeNode *temp=inorderSuccessor(root->right);\\n            root->val=temp->val;\\n            root->right=deleteNode(root->right, temp->val);\\n        }\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2922776,
                "title": "javascript-2-fast-solutions-easy-to-follow",
                "content": "# Intuition\\nUse return value to rebuild.\\nIf you found any of these can be interesting, please upvote, that would encourage me to post and explain more solutions. Happy hacking!\\n\\n# Complexity & Space complexity\\nO(n)\\n\\n\\n# Code\\n```\\nvar deleteNode = function (root, key) {\\n  if (!root) return null;\\n  if (root.val === key) {\\n    if (!root.left && !root.right) {\\n      return null;\\n    } else if (root.left && !root.right) {\\n      return root.left;\\n    } else if (!root.left && root.right) {\\n      return root.right;\\n    } else {\\n//This is most complecated part. \\n//You can choose to return either left or right child node. \\n//If the right child is choosen to be returned, then left child\\n//should become the left child of the right child.\\n      let cur = root.right;\\n      while (cur.left) {\\n        cur = cur.left;\\n      }\\n      cur.left = root.left;\\n      return root.right;\\n    }\\n  }\\n  if (root.val > key) {\\n    root.left = deleteNode(root.left, key);\\n  }\\n  if (root.val < key) {\\n    root.right = deleteNode(root.right, key);\\n  }\\n  return root;\\n};\\n\\n```\\n\\n# Intuition\\nBuild a brand new tree. Very straight forward, but still pretty fast (Only submited once, beats around 85%). \\n\\n# Complexity & Space complexity\\nO(n)\\n\\n# Code\\n```\\nvar deleteNode = function (root, key) {\\n  const arr = [];\\n  DFSino(root);\\n  return build(arr);\\n  function DFSino(node) {\\n    if (!node) return;\\n    DFSino(node.left);\\n    node.val !== key && arr.push(node);\\n    DFSino(node.right);\\n  }\\n  function build(nodes) {\\n    if(!nodes.length) return null\\n    const idx = Math.floor(nodes.length / 2);\\n    nodes[idx].left = build(nodes.slice(0, idx));\\n    nodes[idx].right = build(nodes.slice(idx + 1));\\n    return nodes[idx];\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteNode = function (root, key) {\\n  if (!root) return null;\\n  if (root.val === key) {\\n    if (!root.left && !root.right) {\\n      return null;\\n    } else if (root.left && !root.right) {\\n      return root.left;\\n    } else if (!root.left && root.right) {\\n      return root.right;\\n    } else {\\n//This is most complecated part. \\n//You can choose to return either left or right child node. \\n//If the right child is choosen to be returned, then left child\\n//should become the left child of the right child.\\n      let cur = root.right;\\n      while (cur.left) {\\n        cur = cur.left;\\n      }\\n      cur.left = root.left;\\n      return root.right;\\n    }\\n  }\\n  if (root.val > key) {\\n    root.left = deleteNode(root.left, key);\\n  }\\n  if (root.val < key) {\\n    root.right = deleteNode(root.right, key);\\n  }\\n  return root;\\n};\\n\\n```\n```\\nvar deleteNode = function (root, key) {\\n  const arr = [];\\n  DFSino(root);\\n  return build(arr);\\n  function DFSino(node) {\\n    if (!node) return;\\n    DFSino(node.left);\\n    node.val !== key && arr.push(node);\\n    DFSino(node.right);\\n  }\\n  function build(nodes) {\\n    if(!nodes.length) return null\\n    const idx = Math.floor(nodes.length / 2);\\n    nodes[idx].left = build(nodes.slice(0, idx));\\n    nodes[idx].right = build(nodes.slice(idx + 1));\\n    return nodes[idx];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2914366,
                "title": "java-solution-with-comments",
                "content": "\\n\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) {\\n            return root;\\n        }\\n        if(root.val==key) {\\n            // no child\\n            if(root.left==null && root.right==null) {\\n                return null;\\n            } else if(root.right==null || root.left==null) {\\n                // 1 child\\n                return root.right==null?root.left:root.right;\\n            } else {\\n                // both child. find left most node of right child.\\n                TreeNode node =root;\\n                node=node.right;\\n                while(node.left!=null) {\\n                    node=node.left;\\n                }\\n                //update value\\n                root.val=node.val;\\n                //now delete the leaf node of right child.\\n                root.right=deleteNode(root.right,root.val);\\n            }\\n        } else if(root.val<key){\\n             root.right=deleteNode(root.right,key);\\n        } else {\\n             root.left=deleteNode(root.left,key);\\n        }\\n        return root;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) {\\n            return root;\\n        }\\n        if(root.val==key) {\\n            // no child\\n            if(root.left==null && root.right==null) {\\n                return null;\\n            } else if(root.right==null || root.left==null) {\\n                // 1 child\\n                return root.right==null?root.left:root.right;\\n            } else {\\n                // both child. find left most node of right child.\\n                TreeNode node =root;\\n                node=node.right;\\n                while(node.left!=null) {\\n                    node=node.left;\\n                }\\n                //update value\\n                root.val=node.val;\\n                //now delete the leaf node of right child.\\n                root.right=deleteNode(root.right,root.val);\\n            }\\n        } else if(root.val<key){\\n             root.right=deleteNode(root.right,key);\\n        } else {\\n             root.left=deleteNode(root.left,key);\\n        }\\n        return root;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750873,
                "title": "c-o-1-space-complexity-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL){return NULL;}\\n        if(root->val==key){return rmv(root);}\\n        TreeNode* r=root;\\n        while(r!=NULL){\\n            if(r->val>key){\\n                if(r->left!=NULL && r->left->val==key){\\n                    r->left=rmv(r->left);\\n                }\\n                else{r=r->left;}\\n            }\\n            else{\\n                if(r->right!=NULL && r->right->val==key){\\n                    r->right=rmv(r->right);\\n                }\\n                else{\\n                    r=r->right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n    TreeNode* rmv(TreeNode* node){\\n        if(node->left==NULL){return node->right;}\\n        if(node->right==NULL){return node->left;}\\n        TreeNode* rgt=node->right;\\n        TreeNode* lft=rgtmst(node->left);\\n        lft->right=rgt;\\n        return node->left;\\n    }\\n    TreeNode* rgtmst(TreeNode* rt){\\n        if(rt->right==NULL){return rt;}\\n        return rgtmst(rt->right);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root==NULL){return NULL;}",
                "codeTag": "Java"
            },
            {
                "id": 2705881,
                "title": "c-very-simple-cpp-non-recursive-very-simple-to-understand-98-beats-begninner-frinendly-code",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n\\t\\tTreeNode *deleteNode(TreeNode *root, int key)\\n\\t\\t{\\n\\t\\t\\tTreeNode *node = new TreeNode(key);\\n\\n\\t\\t\\treturn delete1(root, node);\\n\\t\\t}\\n\\t\\tTreeNode *delete1(TreeNode *root, TreeNode *node)\\n\\t\\t{\\n\\t\\t\\tif (root == NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//  return s;\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode *temp = root, *prev = temp;\\n\\t\\t\\twhile (temp != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (node->val < temp->val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tprev = temp;\\n\\t\\t\\t\\t\\ttemp = temp->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (node->val > temp->val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tprev = temp;\\n\\t\\t\\t\\t\\ttemp = temp->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (temp->val == node->val)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (temp->left == temp->right)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (prev == temp)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\troot = NULL;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tprev->right == temp ? prev->right = NULL : prev->left = NULL;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (temp->left == NULL)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (temp == prev)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\troot = temp->right;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tprev->right == temp ? prev->right = temp->right : prev->left = temp->right;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (temp->right == NULL)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (temp == prev)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\troot = temp->left;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tprev->right == temp ? prev->right = temp->left : prev->left = temp->left;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tTreeNode *t = temp->right, *pre = temp;\\n\\t\\t\\t\\t\\t\\twhile (t->left)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tpre = t;\\n\\t\\t\\t\\t\\t\\t\\tt = t->left;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (pre == temp)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (prev == temp)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tt->left = temp->left;\\n\\t\\t\\t\\t\\t\\t\\t\\troot = t;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tprev->left == temp ? prev->left = t : prev->right = t;\\n\\t\\t\\t\\t\\t\\t\\t\\tt->left = pre->left;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (prev == temp)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tt->left = temp->left;\\n\\t\\t\\t\\t\\t\\t\\t\\tpre->left = t->right;\\n\\t\\t\\t\\t\\t\\t\\t\\tt->right = temp->right;\\n\\t\\t\\t\\t\\t\\t\\t\\troot = t;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tprev->right == temp ? prev->right = t : prev->left = t;\\n\\t\\t\\t\\t\\t\\t\\t\\tpre->left = t->right;\\n\\t\\t\\t\\t\\t\\t\\t\\tt->left = temp->left;\\n\\t\\t\\t\\t\\t\\t\\t\\tt->right = temp->right;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n\\t\\tTreeNode *deleteNode(TreeNode *root, int key)\\n\\t\\t{\\n\\t\\t\\tTreeNode *node = new TreeNode(key);\\n\\n\\t\\t\\treturn delete1(root, node);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2693895,
                "title": "java-simple-solution-recurive",
                "content": "\\n```\\npublic class Solution {\\n    \\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) {\\n            return root;\\n        }\\n        TreeNode temp = null;\\n        if (key < root.val) {\\n            root.left = deleteNode(root.left, key);\\n        } else if (key > root.val) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            if (root.left == null) {\\n                temp = root.right;\\n                root.right = null;\\n                return temp;\\n            } else if (root.right == null) {\\n                temp = root.left;\\n                root.left = null;\\n                return temp;\\n            }\\n            temp = successor(root.right);\\n            root.val = temp.val;\\n            root.right = deleteNode(root.right, temp.val);\\n        }\\n        return root; \\n    }\\n    \\n    public static TreeNode successor(TreeNode cur) {\\n        while (cur.left != null) {\\n            cur = cur.left;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if (root == null) {\\n            return root;\\n        }\\n        TreeNode temp = null;\\n        if (key < root.val) {\\n            root.left = deleteNode(root.left, key);\\n        } else if (key > root.val) {\\n            root.right = deleteNode(root.right, key);\\n        } else {\\n            if (root.left == null) {\\n                temp = root.right;\\n                root.right = null;\\n                return temp;\\n            } else if (root.right == null) {\\n                temp = root.left;\\n                root.left = null;\\n                return temp;\\n            }\\n            temp = successor(root.right);\\n            root.val = temp.val;\\n            root.right = deleteNode(root.right, temp.val);\\n        }\\n        return root; \\n    }\\n    \\n    public static TreeNode successor(TreeNode cur) {\\n        while (cur.left != null) {\\n            cur = cur.left;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684592,
                "title": "simple-typescript-solution-using-recursion",
                "content": "The basic framework is the same as searching and inserting in BST. But the different part is we need to maintain the BST property after deletion.  There are three cases: (D is the node to be deleted)\\n1. D is a leave node, just delete it.\\n2. D has only one child node (left or right). Make the children to take over D\\u2019s place.\\n3. D has both left and right subtree. To maintain the property, we should find the largest node of the left subtree or the smallest of right subtree to take over D\\u2019s place.\\n```ts\\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\\n    if (!root) return null;\\n    \\n    // find the target\\n    if (root.val == key) {\\n        // case 1 & 2\\n        if (!root.left) return root.right;\\n        if (!root.right) return root.left;\\n        \\n        // case 3\\n        const minNode = getMin(root.right);\\n        // delete the min node first\\n        root.right = deleteNode(root.right, minNode.val);\\n        // swap the min node and root\\n        [minNode.left, minNode.right] = [root.left, root.right];\\n        root = minNode;\\n    } else if (root.val > key) {\\n        root.left = deleteNode(root.left, key); // to be deleted value is too larget, go left\\n    } else {\\n        root.right = deleteNode(root.right, key); // to be deleted value is too small, go right\\n    }\\n    \\n    return root;\\n};\\n\\n// the leftMost element in the subtree is the smallest\\nconst getMin = (root: TreeNode | null): TreeNode | null => {\\n    while (root.left !== null) {\\n        root = root.left\\n    }\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```ts\\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\\n    if (!root) return null;\\n    \\n    // find the target\\n    if (root.val == key) {\\n        // case 1 & 2\\n        if (!root.left) return root.right;\\n        if (!root.right) return root.left;\\n        \\n        // case 3\\n        const minNode = getMin(root.right);\\n        // delete the min node first\\n        root.right = deleteNode(root.right, minNode.val);\\n        // swap the min node and root\\n        [minNode.left, minNode.right] = [root.left, root.right];\\n        root = minNode;\\n    } else if (root.val > key) {\\n        root.left = deleteNode(root.left, key); // to be deleted value is too larget, go left\\n    } else {\\n        root.right = deleteNode(root.right, key); // to be deleted value is too small, go right\\n    }\\n    \\n    return root;\\n};\\n\\n// the leftMost element in the subtree is the smallest\\nconst getMin = (root: TreeNode | null): TreeNode | null => {\\n    while (root.left !== null) {\\n        root = root.left\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674582,
                "title": "c-easy-to-understand-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root) \\n            if(key < root->val) root->left = deleteNode(root->left, key);  \\n            else if(key > root->val) root->right = deleteNode(root->right, key);       \\n            else{\\n                if(!root->left && !root->right) return NULL;     \\n                if (!root->left || !root->right)\\n                    return root->left ? root->left : root->right;\\n\\t\\t\\t\\t\\t                                                \\n                TreeNode* temp = root->left;                        \\n                while(temp->right != NULL) temp = temp->right;    \\n                root->val = temp->val;\\n                root->left = deleteNode(root->left, temp->val);  \\n            }\\n        return root;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root) \\n            if(key < root->val) root->left = deleteNode(root->left, key);  \\n            else if(key > root->val) root->right = deleteNode(root->right, key);       \\n            else{\\n                if(!root->left && !root->right) return NULL;     \\n                if (!root->left || !root->right)\\n                    return root->left ? root->left : root->right;\\n\\t\\t\\t\\t\\t                                                \\n                TreeNode* temp = root->left;                        \\n                while(temp->right != NULL) temp = temp->right;    \\n                root->val = temp->val;\\n                root->left = deleteNode(root->left, temp->val);  \\n            }\\n        return root;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510782,
                "title": "python-easiest-solution",
                "content": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root:\\n            return None\\n        if root.val==key:\\n            if not root.left and not root.right:\\n                return None\\n            elif not root.left and root.right:\\n                return root.right\\n            elif root.left and  not root.right:\\n                return root.left\\n            dummy=root.right\\n            while dummy.left:\\n                dummy=dummy.left\\n            root.val=dummy.val\\n            root.right=self.deleteNode(root.right,root.val)\\n        if root.val>key:\\n            root.left=self.deleteNode(root.left,key)\\n        else:\\n            root.right=self.deleteNode(root.right,key)\\n        return root\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        if not root:\\n            return None\\n        if root.val==key:\\n            if not root.left and not root.right:\\n                return None\\n            elif not root.left and root.right:\\n                return root.right\\n            elif root.left and  not root.right:\\n                return root.left\\n            dummy=root.right\\n            while dummy.left:\\n                dummy=dummy.left\\n            root.val=dummy.val\\n            root.right=self.deleteNode(root.right,root.val)\\n        if root.val>key:\\n            root.left=self.deleteNode(root.left,key)\\n        else:\\n            root.right=self.deleteNode(root.right,key)\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447910,
                "title": "c-solution-with-explanation",
                "content": "This question can be divided into 3 cases:\\n1. No child\\n2. One Child\\n3. Children\\n\\n1>  If the node is a leaf node and we have to delete it then we can just null out the parent pointer of the leaf node and we are good to go.\\n\\n2> If the node that has to be deleted has only one child then we can simply null out the parent pointer first and then make a connection of the parrent to the only child of that node. \\n\\n3> We know the simple condition of a  BST i.e. L<N<R where N is the parent node and L and R are left and right child respectively. So by using that logic we can delete a node having two child and bring the minimum from the right subtree so that we get L<N<=R in a case where the minimum is the right child of the node. Then we can get rid of that minimum node in the left subtree by performing case 2. But we also have to note that we cannot take a node which is minimum and have a left subtree. \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* findMin(TreeNode* node){\\n        while(node->left!=NULL) node = node->left;\\n        return node;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == NULL) return root;\\n        if(root->val>key) root->left = deleteNode(root->left, key);\\n        else if(root->val<key) root->right = deleteNode(root->right, key);\\n        else {\\n            // 1. No Child\\n            if(root->left == NULL and root->right == NULL){\\n                delete root;\\n                root = NULL;\\n            }\\n            // 2. One Child\\n            else if(root->left == NULL){\\n                struct TreeNode* temp = root;\\n                root = root->right;\\n                delete temp;\\n            }\\n            else if(root->right == NULL){\\n                struct TreeNode* temp = root;\\n                root = root->left;\\n                delete temp;\\n            }\\n            // 3. Two Child\\n            else {\\n                struct TreeNode* temp = findMin(root->right);\\n                root->val = temp->val;\\n                root->right = deleteNode(root->right, temp->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* findMin(TreeNode* node){\\n        while(node->left!=NULL) node = node->left;\\n        return node;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == NULL) return root;\\n        if(root->val>key) root->left = deleteNode(root->left, key);\\n        else if(root->val<key) root->right = deleteNode(root->right, key);\\n        else {\\n            // 1. No Child\\n            if(root->left == NULL and root->right == NULL){\\n                delete root;\\n                root = NULL;\\n            }\\n            // 2. One Child\\n            else if(root->left == NULL){\\n                struct TreeNode* temp = root;\\n                root = root->right;\\n                delete temp;\\n            }\\n            else if(root->right == NULL){\\n                struct TreeNode* temp = root;\\n                root = root->left;\\n                delete temp;\\n            }\\n            // 3. Two Child\\n            else {\\n                struct TreeNode* temp = findMin(root->right);\\n                root->val = temp->val;\\n                root->right = deleteNode(root->right, temp->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195567,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int k) {\\n        if(root==null)\\n            return null;\\n        if(root.val==k)\\n        {\\n            root=task(root);\\n            return root;\\n        }\\n        TreeNode p=root;\\n        while(root!=null)\\n        {\\n            if(root.val>k)\\n            {\\n                if(root.left!=null&&root.left.val==k)\\n                {\\n                    root.left=task(root.left);\\n                }\\n                else\\n                    root=root.left;\\n            }\\n            else\\n            {\\n                if(root.right!=null&&root.right.val==k)\\n                {\\n                    root.right=task(root.right);\\n                }\\n                else\\n                    root=root.right;\\n            }\\n        }\\n        return p;\\n    }\\n    public TreeNode task(TreeNode root)\\n    {\\n        if(root.left==null)\\n            return root.right;\\n        else if(root.right==null)\\n            return root.left;\\n        TreeNode k=root.right;\\n        TreeNode f=task1(root.left);\\n        f.right=k;\\n        return root.left;\\n    }\\n    public TreeNode task1(TreeNode root)\\n    {\\n        if(root.right==null)\\n            return root;\\n        return task1(root.right);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode deleteNode(TreeNode root, int k) {\\n        if(root==null)\\n            return null;\\n        if(root.val==k)\\n        {\\n            root=task(root);\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2048072,
                "title": "c-easy-to-understand-solution-with-detailed-explanation-for-each-step",
                "content": "```\\nTreeNode* find(TreeNode* root)\\n    {\\n        if(root->right == NULL)\\n            return root;\\n        \\n        return find(root->right);\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //we have to delete the node if found. so if we keep searching for the node and we reach null, this means the node is not found and we return the original tree\\n        if(root == NULL)\\n            return root;\\n        //the node to be deleted is found\\n        else if(root->val == key)\\n        {\\n            //the node is a leaf node\\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            //if the node has both left and right child\\n            else if(root->left != NULL && root->right != NULL)\\n            {\\n                //go to the left subtree and find the largest element in the left subtree. This is done to maintain the property of BST. We can also go to the right subtree and find the smallest element in the right subtree and then similarly do the next steps\\n                TreeNode* temp = find(root->left);\\n                //replace the value of the node with this largest element found in the previous step\\n                root->val = temp->val;\\n                //call the deleteNode function to delete this largest element since it will be present 2 times\\n                root->left = deleteNode(root->left, root->val);\\n            }\\n            //node has only left child\\n            else if(root->left != NULL)\\n            {\\n                TreeNode* x = root->left;\\n                delete root;\\n                return x;\\n            }\\n            //node has only right child\\n            else\\n            {\\n                TreeNode* x = root->right;\\n                delete root;\\n                return x;\\n            }\\n            \\n        }\\n        //the node to be deleted is not found\\n        else\\n        {\\n            if(key < root->val)\\n                root->left = deleteNode(root->left, key);\\n            else\\n                root->right = deleteNode(root->right, key);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* find(TreeNode* root)\\n    {\\n        if(root->right == NULL)\\n            return root;\\n        \\n        return find(root->right);\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //we have to delete the node if found. so if we keep searching for the node and we reach null, this means the node is not found and we return the original tree\\n        if(root == NULL)\\n            return root;\\n        //the node to be deleted is found\\n        else if(root->val == key)\\n        {\\n            //the node is a leaf node\\n            if(root->left == NULL && root->right == NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            //if the node has both left and right child\\n            else if(root->left != NULL && root->right != NULL)\\n            {\\n                //go to the left subtree and find the largest element in the left subtree. This is done to maintain the property of BST. We can also go to the right subtree and find the smallest element in the right subtree and then similarly do the next steps\\n                TreeNode* temp = find(root->left);\\n                //replace the value of the node with this largest element found in the previous step\\n                root->val = temp->val;\\n                //call the deleteNode function to delete this largest element since it will be present 2 times\\n                root->left = deleteNode(root->left, root->val);\\n            }\\n            //node has only left child\\n            else if(root->left != NULL)\\n            {\\n                TreeNode* x = root->left;\\n                delete root;\\n                return x;\\n            }\\n            //node has only right child\\n            else\\n            {\\n                TreeNode* x = root->right;\\n                delete root;\\n                return x;\\n            }\\n            \\n        }\\n        //the node to be deleted is not found\\n        else\\n        {\\n            if(key < root->val)\\n                root->left = deleteNode(root->left, key);\\n            else\\n                root->right = deleteNode(root->right, key);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2037212,
                "title": "c-easy-well-commented-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //delete nth node recursion O(H)\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(!root){\\n            return NULL;\\n        }\\n        //cases: 1->key node is leaf node\\n            //   2->key node have only one child\\n            //   3->key node is parent have 2 childrens\\n        if(root->val > key){\\n            //move left\\n            root->left = deleteNode(root->left,key);\\n        }\\n        else if(root->val < key){\\n            //move right\\n            root->right = deleteNode(root->right,key);\\n        }\\n        else{\\n            //we have found the node which have val as key\\n            \\n            //1) if it is leaf node then just remove\\n            if(!root->left && !root->right){\\n                return NULL;\\n            }\\n            // if key node with one child\\n            else if(!root->left || !root->right){\\n                if(!root->left){\\n                    return root->right;\\n                }\\n                else{\\n                    return root->left;\\n                }\\n            }\\n            //now little tricky condition...\\n            //if key node have 2 children\\n            else{\\n                //In this case we need to replace the node with it\\'s inorder successor (The next node that comes in the inorder traversal) i.e; we need to replace it with either :\\n// 1. The greatest value node in it\\'s left subtree (or)\\n// 2. The smallest value node in it\\'s right subtree\\n// and return the root\\n                TreeNode* temp = root->left;\\n                //search max right for maxi\\n                while(temp->right){\\n                    temp = temp->right;\\n                }\\n                root->val = temp->val;\\n                root->left = deleteNode(root->left,temp->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //delete nth node recursion O(H)\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(!root){\\n            return NULL;\\n        }\\n        //cases: 1->key node is leaf node\\n            //   2->key node have only one child\\n            //   3->key node is parent have 2 childrens\\n        if(root->val > key){\\n            //move left\\n            root->left = deleteNode(root->left,key);\\n        }\\n        else if(root->val < key){\\n            //move right\\n            root->right = deleteNode(root->right,key);\\n        }\\n        else{\\n            //we have found the node which have val as key\\n            \\n            //1) if it is leaf node then just remove\\n            if(!root->left && !root->right){\\n                return NULL;\\n            }\\n            // if key node with one child\\n            else if(!root->left || !root->right){\\n                if(!root->left){\\n                    return root->right;\\n                }\\n                else{\\n                    return root->left;\\n                }\\n            }\\n            //now little tricky condition...\\n            //if key node have 2 children\\n            else{\\n                //In this case we need to replace the node with it\\'s inorder successor (The next node that comes in the inorder traversal) i.e; we need to replace it with either :\\n// 1. The greatest value node in it\\'s left subtree (or)\\n// 2. The smallest value node in it\\'s right subtree\\n// and return the root\\n                TreeNode* temp = root->left;\\n                //search max right for maxi\\n                while(temp->right){\\n                    temp = temp->right;\\n                }\\n                root->val = temp->val;\\n                root->left = deleteNode(root->left,temp->val);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992647,
                "title": "simple-java-solution-beats-100",
                "content": "The Simple **Java** recursive solution is faster than 100% of the solutions.\\n\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(root.val==key){\\n            if(root.right!=null){\\n                TreeNode node=root.right;\\n                while(node.left!=null){\\n                    node=node.left;\\n                }\\n                node.left=root.left;\\n            }\\n            if(root.right==null) return root.left;\\n            return root.right;\\n        }\\n        if(root.val>key) root.left=deleteNode(root.left,key);\\n        if(root.val<key) root.right=deleteNode(root.right,key);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return root;\\n        if(root.val==key){\\n            if(root.right!=null){\\n                TreeNode node=root.right;\\n                while(node.left!=null){\\n                    node=node.left;\\n                }\\n                node.left=root.left;\\n            }\\n            if(root.right==null) return root.left;\\n            return root.right;\\n        }\\n        if(root.val>key) root.left=deleteNode(root.left,key);\\n        if(root.val<key) root.right=deleteNode(root.right,key);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949263,
                "title": "beats-90-o-h-find-min-function-delete",
                "content": "```\\nTreeNode* findMin(TreeNode* root) {\\n        if(!root->left )return root;\\n        return findMin(root->left);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return root;\\n        \\n        if (root->val > key) root->left = deleteNode( root->left , key);\\n        \\n        else if (root->val < key) root->right = deleteNode( root->right , key);  \\n                \\n        else{\\n            if(!root->left && !root->right) return nullptr;\\n            else if (!root->left) return root->right;\\n            else if (!root->right) return root->left;\\n            else{\\n                TreeNode* minNode = findMin(root->right);\\n                root->val = minNode->val;\\n                root->right = deleteNode(root->right,minNode->val);\\n            }\\n            \\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nTreeNode* findMin(TreeNode* root) {\\n        if(!root->left )return root;\\n        return findMin(root->left);\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if (!root) return root;\\n        \\n        if (root->val > key) root->left = deleteNode( root->left , key);\\n        \\n        else if (root->val < key) root->right = deleteNode( root->right , key);  \\n                \\n        else{\\n            if(!root->left && !root->right) return nullptr;\\n            else if (!root->left) return root->right;\\n            else if (!root->right) return root->left;\\n            else{\\n                TreeNode* minNode = findMin(root->right);\\n                root->val = minNode->val;\\n                root->right = deleteNode(root->right,minNode->val);\\n            }\\n            \\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889328,
                "title": "java-0ms-100-fast-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        if(key<root.val){\\n            root.left = deleteNode(root.left, key);\\n        } \\n        else if(key > root.val){\\n            root.right = deleteNode(root.right, key);\\n        } else{\\n            if(root.left==null){\\n                TreeNode temp = root.right;\\n                return temp;\\n            } else if(root.right==null){\\n                TreeNode temp = root.left;\\n                return temp;\\n            } else{\\n                TreeNode temp = inordersucc(root.right);\\n                root.val = temp.val;\\n                root.right = deleteNode(root.right,temp.val);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n    public TreeNode inordersucc(TreeNode root){\\n        TreeNode temp = root;\\n        while(temp!=null && temp.left!=null){\\n            temp=temp.left;\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        if(key<root.val){\\n            root.left = deleteNode(root.left, key);\\n        } \\n        else if(key > root.val){\\n            root.right = deleteNode(root.right, key);\\n        } else{\\n            if(root.left==null){\\n                TreeNode temp = root.right;\\n                return temp;\\n            } else if(root.right==null){\\n                TreeNode temp = root.left;\\n                return temp;\\n            } else{\\n                TreeNode temp = inordersucc(root.right);\\n                root.val = temp.val;\\n                root.right = deleteNode(root.right,temp.val);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n    public TreeNode inordersucc(TreeNode root){\\n        TreeNode temp = root;\\n        while(temp!=null && temp.left!=null){\\n            temp=temp.left;\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846932,
                "title": "c-all-possible-solutions",
                "content": "Approach 1: Recursive. [Visualiztion Here](https://leetcode.com/problems/delete-node-in-a-bst/discuss/1590789/C%2B%2B-Shortest-Recursive-Solution-or-Detailed-Explanation-with-images)\\n**T.C -> O(logn), S.C -> O(logn)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == nullptr) return root;\\n        \\n        if(root->val < key) root->right = deleteNode(root->right, key);\\n        else if(root->val > key) root->left = deleteNode(root->left, key);\\n        \\n        // Found a match.(key found to delete)\\n        else {\\n            // Case 1: It\\'s a leaf node\\n            if(root->right == nullptr and root->left == nullptr) {\\n                delete root;\\n                return nullptr;\\n            }\\n            \\n            // Case 2: It has only one child\\n            if(root->right == nullptr || root->left == nullptr) {\\n                TreeNode* child = root->left != nullptr ? root->left : root->right;\\n                delete root;\\n                return child;\\n            }\\n            \\n            // Case 3: It has two children, (and their children may have their children)\\n            // Replace root-val with its inorder predecessor\\n            TreeNode* prev = root->left;\\n            while(prev->right)\\n                prev = prev->right;\\n            \\n            root->val = prev->val;\\n            \\n            // Now when you overwrite the value (root) by (prev), the node with value prev is still there.             \\n\\t\\t\\t// You need to delete that node because it\\'s supposed to take place of the node with value                 \\n\\t\\t\\t// root. The easiest way to delete is just to call deleteNode(root->left, prev->val).\\n            \\n            root->left = deleteNode(root->left, prev->val);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n\\nApproach 2: Iterative: **T.C -> O(logn), S.C -> O(logn)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteRoot(TreeNode* root) {\\n        if(root->left == nullptr) {\\n            TreeNode* temp = root->right;\\n            delete root;\\n            return temp;\\n        }\\n        if(root->right == nullptr) {\\n            TreeNode* temp = root->left;\\n            delete root;\\n            return temp;\\n        }\\n        \\n        // Deleting a root of BST is easy. Replace it with root\\'s left, but before doing that -> \\n        // Just connect inorder pred. of root to root\\'s right and then delete root.\\n        \\n        TreeNode* newRoot = root->left;\\n        TreeNode* prev = root->left;\\n        TreeNode* rightChild = root->right;\\n        while(prev->right)\\n            prev = prev->right;\\n        \\n        prev->right = rightChild;\\n        delete root;\\n        \\n        return newRoot;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == nullptr) return root;\\n        \\n        // If root is the one to delete.\\n        if(root->val == key)\\n            return deleteRoot(root);\\n        \\n        TreeNode* curr = root;\\n        while(curr) {\\n            if(curr->val > key) {\\n                if(curr->left and curr->left->val == key) {\\n                    curr->left = deleteRoot(curr->left);\\n                    break;\\n                } else {\\n                    curr = curr->left;\\n                }\\n            }\\n            \\n            else {\\n                if(curr->right and curr->right->val == key) {\\n                    curr->right = deleteRoot(curr->right);\\n                    break;\\n                } else {\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == nullptr) return root;\\n        \\n        if(root->val < key) root->right = deleteNode(root->right, key);\\n        else if(root->val > key) root->left = deleteNode(root->left, key);\\n        \\n        // Found a match.(key found to delete)\\n        else {\\n            // Case 1: It\\'s a leaf node\\n            if(root->right == nullptr and root->left == nullptr) {\\n                delete root;\\n                return nullptr;\\n            }\\n            \\n            // Case 2: It has only one child\\n            if(root->right == nullptr || root->left == nullptr) {\\n                TreeNode* child = root->left != nullptr ? root->left : root->right;\\n                delete root;\\n                return child;\\n            }\\n            \\n            // Case 3: It has two children, (and their children may have their children)\\n            // Replace root-val with its inorder predecessor\\n            TreeNode* prev = root->left;\\n            while(prev->right)\\n                prev = prev->right;\\n            \\n            root->val = prev->val;\\n            \\n            // Now when you overwrite the value (root) by (prev), the node with value prev is still there.             \\n\\t\\t\\t// You need to delete that node because it\\'s supposed to take place of the node with value                 \\n\\t\\t\\t// root. The easiest way to delete is just to call deleteNode(root->left, prev->val).\\n            \\n            root->left = deleteNode(root->left, prev->val);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* deleteRoot(TreeNode* root) {\\n        if(root->left == nullptr) {\\n            TreeNode* temp = root->right;\\n            delete root;\\n            return temp;\\n        }\\n        if(root->right == nullptr) {\\n            TreeNode* temp = root->left;\\n            delete root;\\n            return temp;\\n        }\\n        \\n        // Deleting a root of BST is easy. Replace it with root\\'s left, but before doing that -> \\n        // Just connect inorder pred. of root to root\\'s right and then delete root.\\n        \\n        TreeNode* newRoot = root->left;\\n        TreeNode* prev = root->left;\\n        TreeNode* rightChild = root->right;\\n        while(prev->right)\\n            prev = prev->right;\\n        \\n        prev->right = rightChild;\\n        delete root;\\n        \\n        return newRoot;\\n    }\\n    \\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(root == nullptr) return root;\\n        \\n        // If root is the one to delete.\\n        if(root->val == key)\\n            return deleteRoot(root);\\n        \\n        TreeNode* curr = root;\\n        while(curr) {\\n            if(curr->val > key) {\\n                if(curr->left and curr->left->val == key) {\\n                    curr->left = deleteRoot(curr->left);\\n                    break;\\n                } else {\\n                    curr = curr->left;\\n                }\\n            }\\n            \\n            else {\\n                if(curr->right and curr->right->val == key) {\\n                    curr->right = deleteRoot(curr->right);\\n                    break;\\n                } else {\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845656,
                "title": "java-solution-no-extra-space-o-logn",
                "content": "``` \\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null )  return null; // If the root is null\\n        \\n        if(root.val == key){  // IF our key value is the value of root node \\n           return helper(root);\\n        }\\n        \\n        TreeNode curr = root; \\n        \\n        while(curr != null){\\n            \\n            if(curr.val > key){ // the value of key is less the  curr node value\\n                if(curr.left != null && curr.left.val == key){ // If left node is not null and its value matches to the key value\\n                    TreeNode left= helper(curr.left);\\n                    curr.left = left;\\n                    break;\\n                }\\n                curr = curr.left;\\n            }\\n            \\n            \\n            else{\\n                if(curr.right != null && curr.right.val == key){\\n                    TreeNode right = helper(curr.right);\\n                    curr.right = right;\\n                    break;\\n                }\\n                curr = curr.right;\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }     \\n        private TreeNode helper(TreeNode node){\\n            \\n            if(node.left == null)\\n                return node.right;\\n            \\n            else if(node.right == null)\\n                return node.left;\\n            \\n            else\\n            {\\n                TreeNode RightMost = findRightMost(node.left);\\n                RightMost.right = node.right;  \\n            }\\n                \\n            return  node.left;\\n        }\\n        \\n        private TreeNode findRightMost(TreeNode node){\\n            if(node.right == null)\\n                return node;\\n            return findRightMost(node.right);\\n        }\\n}\\n```\\n\\nGive a star if You like the solution",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "``` \\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root == null )  return null; // If the root is null\\n        \\n        if(root.val == key){  // IF our key value is the value of root node \\n           return helper(root);\\n        }\\n        \\n        TreeNode curr = root; \\n        \\n        while(curr != null){\\n            \\n            if(curr.val > key){ // the value of key is less the  curr node value\\n                if(curr.left != null && curr.left.val == key){ // If left node is not null and its value matches to the key value\\n                    TreeNode left= helper(curr.left);\\n                    curr.left = left;\\n                    break;\\n                }\\n                curr = curr.left;\\n            }\\n            \\n            \\n            else{\\n                if(curr.right != null && curr.right.val == key){\\n                    TreeNode right = helper(curr.right);\\n                    curr.right = right;\\n                    break;\\n                }\\n                curr = curr.right;\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }     \\n        private TreeNode helper(TreeNode node){\\n            \\n            if(node.left == null)\\n                return node.right;\\n            \\n            else if(node.right == null)\\n                return node.left;\\n            \\n            else\\n            {\\n                TreeNode RightMost = findRightMost(node.left);\\n                RightMost.right = node.right;  \\n            }\\n                \\n            return  node.left;\\n        }\\n        \\n        private TreeNode findRightMost(TreeNode node){\\n            if(node.right == null)\\n                return node;\\n            return findRightMost(node.right);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832810,
                "title": "simple-easy-solution-cpp-easy-to-understand",
                "content": "First find the node which has to be deleted and then replace it with it\\'s ***inorder succesor***\\n\\n\\n```\\nTreeNode * solve(TreeNode *root,int key)\\n    {\\n        if(root==NULL) return root;\\n        if(root->val > key)\\n        {\\n            root->left=solve(root->left,key);\\n            return root;\\n        }\\n        if(root->val < key)\\n        {\\n            root->right=solve(root->right,key);\\n            return root;\\n        }\\n        \\n        if(root->left==NULL) return root->right;\\n        if(root->right==NULL) return root->left;\\n        else\\n        {\\n            // find inorder successor;\\n            TreeNode *parent=root;\\n            TreeNode *suc=root->right;\\n            while(suc->left)\\n            {\\n                parent=suc;\\n                suc=suc->left;\\n            }\\n            if(parent==root)\\n            {\\n                suc->left=root->left;\\n                return suc;\\n            }\\n            else\\n            {\\n                parent->left=suc->right;\\n                suc->left=root->left;\\n                suc->right=root->right;\\n                return suc;\\n            }\\n        }\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n        if(root==NULL) return root;\\n        return solve(root,key);\\n    }\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nTreeNode * solve(TreeNode *root,int key)\\n    {\\n        if(root==NULL) return root;\\n        if(root->val > key)\\n        {\\n            root->left=solve(root->left,key);\\n            return root;\\n        }\\n        if(root->val < key)\\n        {\\n            root->right=solve(root->right,key);\\n            return root;\\n        }\\n        \\n        if(root->left==NULL) return root->right;\\n        if(root->right==NULL) return root->left;\\n        else\\n        {\\n            // find inorder successor;\\n            TreeNode *parent=root;\\n            TreeNode *suc=root->right;\\n            while(suc->left)\\n            {\\n                parent=suc;\\n                suc=suc->left;\\n            }\\n            if(parent==root)\\n            {\\n                suc->left=root->left;\\n                return suc;\\n            }\\n            else\\n            {\\n                parent->left=suc->right;\\n                suc->left=root->left;\\n                suc->right=root->right;\\n                return suc;\\n            }\\n        }\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) \\n    {\\n        if(root==NULL) return root;\\n        return solve(root,key);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1613039,
                "title": "c-code-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int max(TreeNode*root)\\n    {\\n        if(root->right!=NULL)\\n        {\\n            return max(root->right);\\n        }\\n        \\n        else{\\n            return root->val;\\n        }\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        \\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        if(key>root->val)\\n        {\\n            root->right = deleteNode(root->right,key);\\n        }\\n        \\n        else if(key<root->val)\\n        {\\n            root->left = deleteNode(root->left,key);\\n        }\\n        \\n        else\\n        {\\n            // main work\\n            \\n            if(root->left!=NULL && root->right!=NULL)\\n            {\\n                int lmax = max(root->left);\\n                root->val = lmax;\\n                \\n                root->left = deleteNode(root->left,lmax);\\n                return root;\\n            }\\n            \\n            else if(root->left!=NULL)\\n            {\\n                return root->left;\\n            }\\n            \\n            else if(root->right!=NULL)\\n            {\\n                return root->right;\\n            }\\n            \\n            else{\\n                return NULL;\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int max(TreeNode*root)\\n    {\\n        if(root->right!=NULL)\\n        {\\n            return max(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1591393,
                "title": "c-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* maxValueInTree(TreeNode* root){\\n        if(root->right==NULL){\\n            return root;\\n        }else{\\n            return maxValueInTree(root->right);\\n        }\\n    }\\n   TreeNode* remove(TreeNode* root,int key){\\n        if(root==NULL){\\n            return root;\\n        }\\n       //binary search logic\\n       if(root->val<key){\\n            root->right=remove(root->right,key);\\n       }else if(root->val>key){\\n            root->left=remove(root->left,key);\\n       }else{\\n           //if val is found\\n           //4 cases\\n            //if both left nd right child are null\\n            //if left is null\\n            //if right is null\\n            //if none of the child is null\\n            if(root->left!=NULL && root->right!=NULL){\\n                //find max in leftsubtree\\n                TreeNode* lmax=maxValueInTree(root->left);\\n                //delete that max of the left subtree\\n                root->left=remove(root->left,lmax->val);\\n                //replace value with current node\\n                root->val=lmax->val;\\n            }else if(root->left!=NULL){\\n                return root->left;\\n            }else if(root->right!=NULL){\\n                return root->right;\\n            }else{\\n                return NULL;\\n            }\\n       }\\n       return root;\\n   }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        root=remove(root,key);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* maxValueInTree(TreeNode* root){\\n        if(root->right==NULL){\\n            return root;\\n        }else{\\n            return maxValueInTree(root->right);\\n        }\\n    }\\n   TreeNode* remove(TreeNode* root,int key){\\n        if(root==NULL){\\n            return root;\\n        }\\n       //binary search logic\\n       if(root->val<key){\\n            root->right=remove(root->right,key);\\n       }else if(root->val>key){\\n            root->left=remove(root->left,key);\\n       }else{\\n           //if val is found\\n           //4 cases\\n            //if both left nd right child are null\\n            //if left is null\\n            //if right is null\\n            //if none of the child is null\\n            if(root->left!=NULL && root->right!=NULL){\\n                //find max in leftsubtree\\n                TreeNode* lmax=maxValueInTree(root->left);\\n                //delete that max of the left subtree\\n                root->left=remove(root->left,lmax->val);\\n                //replace value with current node\\n                root->val=lmax->val;\\n            }else if(root->left!=NULL){\\n                return root->left;\\n            }else if(root->right!=NULL){\\n                return root->right;\\n            }else{\\n                return NULL;\\n            }\\n       }\\n       return root;\\n   }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        root=remove(root,key);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591367,
                "title": "java-code",
                "content": "```\\nclass Solution {\\n    // Searching a node in tree + Inorder Successor in Binary Search Tree\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){\\n            return root; // return null\\n        }\\n\\n        if(root.val <key){\\n            root.right = deleteNode(root.right, key);\\n            return root;\\n        } else if(root.val>key){\\n            root.left = deleteNode(root.left, key);\\n            return root;\\n        } else {\\n            // root.val == key\\n            // leaf node\\n            if(root.left == null && root.right ==null){\\n                return null;\\n            }\\n            if(root.left ==null){\\n                return root.right; // left child is null\\n            } else if(root.right == null){\\n                return root.left; // right child is null\\n            } else {\\n                // left child is not null and right child is not null\\n                TreeNode nextMinNode = root.right;\\n                while(nextMinNode.left !=null){\\n                    nextMinNode = nextMinNode.left;\\n                }\\n\\n                nextMinNode.left = root.left;\\n                return root.right;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Searching a node in tree + Inorder Successor in Binary Search Tree\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){\\n            return root; // return null\\n        }\\n\\n        if(root.val <key){\\n            root.right = deleteNode(root.right, key);\\n            return root;\\n        } else if(root.val>key){\\n            root.left = deleteNode(root.left, key);\\n            return root;\\n        } else {\\n            // root.val == key\\n            // leaf node\\n            if(root.left == null && root.right ==null){\\n                return null;\\n            }\\n            if(root.left ==null){\\n                return root.right; // left child is null\\n            } else if(root.right == null){\\n                return root.left; // right child is null\\n            } else {\\n                // left child is not null and right child is not null\\n                TreeNode nextMinNode = root.right;\\n                while(nextMinNode.left !=null){\\n                    nextMinNode = nextMinNode.left;\\n                }\\n\\n                nextMinNode.left = root.left;\\n                return root.right;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591316,
                "title": "c-explained-solution-recursive-approach",
                "content": "\\n ```\\nclass Solution {\\npublic:\\n    int getSufix(TreeNode*root){ // When you have to delete a node with both, left and right child !null\\n        while(root->left) root=root->left;\\n        return root->val;\\n    }\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root) return root;\\n        else if(root->val==key){ //When found the root\\n            if(!root->left) return root->right; // when left child not exist\\n            else if(!root->right) return root->left; // right child not exist\\n            else {\\n                root->val=getSufix(root->right); // get the suffix element \\n                root->right=deleteNode(root->right,root->val);// deleting the node of suffix \\n            }\\n        }\\n        else if(root->val>key){\\n            root->left=deleteNode(root->left,key);\\n        }\\n        else root->right=deleteNode(root->right,key);\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int getSufix(TreeNode*root){ // When you have to delete a node with both, left and right child !null\\n        while(root->left) root=root->left;\\n        return root->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1591075,
                "title": "well-coded-clean-concise-easy-to-understand",
                "content": "## IDEA :\\n* First search for the node which is having value as target value.\\n* Now we have to delete that Node. It means if we are not having left subtree then directly return the right subtree as well as vice-versa.\\n* But if we are having both subtree then we have to find the smallest Node in the right subtree which will be left most Node.\\n\\n* Now replace the value of root Node with the lowest right subtree and Delete that Node.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        \\n        if root is None:\\n            return \\n        \\n        if key<root.val:\\n            root.left = self.deleteNode(root.left,key)\\n        \\n        elif key>root.val:\\n            root.right = self.deleteNode(root.right,key)\\n        \\n        else:\\n            if root.left is None:\\n                return root.right\\n            \\n            if root.right is None:\\n                return root.left\\n            \\n            tmp = root.right\\n            mini= tmp.val\\n            while tmp.left!=None:\\n                tmp = tmp.left\\n                mini= tmp.val\\n            root.val = mini\\n            root.right = self.deleteNode(root.right,root.val)\\n        \\n        return root\\n\\n### Thanks & Upvote if you got any help or like the Idea!!\\u270C",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "## IDEA :\\n* First search for the node which is having value as target value.\\n* Now we have to delete that Node. It means if we are not having left subtree then directly return the right subtree as well as vice-versa.\\n* But if we are having both subtree then we have to find the smallest Node in the right subtree which will be left most Node.\\n\\n* Now replace the value of root Node with the lowest right subtree and Delete that Node.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\\n        \\n        if root is None:\\n            return \\n        \\n        if key<root.val:\\n            root.left = self.deleteNode(root.left,key)\\n        \\n        elif key>root.val:\\n            root.right = self.deleteNode(root.right,key)\\n        \\n        else:\\n            if root.left is None:\\n                return root.right\\n            \\n            if root.right is None:\\n                return root.left\\n            \\n            tmp = root.right\\n            mini= tmp.val\\n            while tmp.left!=None:\\n                tmp = tmp.left\\n                mini= tmp.val\\n            root.val = mini\\n            root.right = self.deleteNode(root.right,root.val)\\n        \\n        return root\\n\\n### Thanks & Upvote if you got any help or like the Idea!!\\u270C",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569115,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1565673,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1565310,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1568008,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1922481,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 2026042,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1987349,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1930860,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1573322,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1994688,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1569115,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1565673,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1565310,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1568008,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1922481,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 2026042,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1987349,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1930860,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1573322,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 1994688,
                "content": [
                    {
                        "username": "mmm713",
                        "content": "There could be multiple ways to solve. Why OJ only check one possibility?\\ne.g., 2,1,3 tree, delete 2, I can have 1,null,3,   &&   3,1\\nBoth solutions are valid. \\nI think OJ needs to check the result is BST and doesn't have key to delete.\\n\\nOne simple solution scheme is just to substitute the target node with the left child's right most node. But it cannot pass OJ"
                    },
                    {
                        "username": "Shevchenko_7",
                        "content": "Something went wrong in test case with input only \"[]\", should be both root and key."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/delete-node-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "linzhu1206",
                        "content": "To delete a node with both left and right children, one can either find the predecessor or the successor of that node, swap the values then delete the predecessor or successor. Apparently, the test cases only follow the successor way while using predecessor will give wrong answer, even visually still a BST after deletion. I had swtiched the solution then ACed.\n\nThe defective test cases start from the 81th."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The programmer urge to write _81th_ and not _81st_. "
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "Once we find the node to be deleted, \n\n-> If the root is a leaf node, then return NULL. (Base Case).\n-> Else if the root has only the left child, then we delete the root node and return its left child.\n-> Else if the root has only the right child, then we delete the root node and return its right child.\n-> Else, we find the inorder successor node, set the key of root with the key of the inorder successor, and delete the inorder successor. To find the inorder successor, we need to find the node with the minimum key in the right subtree. \n\nCheck out my solution which has Time Complexity :- O(H)\n[https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/)"
                    },
                    {
                        "username": "stanmozolevskiy",
                        "content": "This is pretty hard exercise. I would rate it as hard."
                    },
                    {
                        "username": "lexsusku",
                        "content": "More complex examples would really come in handy"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nWhy I am getting this Runtime errror can anybody plz tell me??\\n"
                    },
                    {
                        "username": "sai_kiran_r",
                        "content": "First, please check if you are using any global or static variables. They are Evil, period. If you must declare one, reset them in the first line of your called method or in the default constructor.\n\nWhy? Because the system executes all test cases using the same program instance, global/static variables affect the program state from one test case to another.\n\nPlease refer to this article if you still have any doubts : \n\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\n\nCheck out my optimal solution which has Time Complexity :- O(H)\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3618511/c-simple-recursive-solution-with-explanation-easy-to-understand-time-o-h/\n\nUpvote If my answer is helpful."
                    },
                    {
                        "username": "Xinjian2016",
                        "content": "Input [2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n33\\n\\n\\nThis is one test case but how can it be a BST?\\n\\n                                  ![image](https://assets.leetcode.com/users/xinjian2016/image_1578203605.png)\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Is there anyone else who also thinks of a brute force solution whenever a tree or linked list problem arises ?** 😅"
                    }
                ]
            },
            {
                "id": 2054788,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2054782,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2045079,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2015595,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2001956,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1971685,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1955999,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1919162,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1908329,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1779265,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "My codes has almost 120 lines, is there a better gentlemen way..?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I solve the problem by recording parent node, is that cheating?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "IMO the difficulty should be leveled to hard. It is possible to solve, but the problem is way harder that other medium problems related to trees."
                    },
                    {
                        "username": "ALBERTBOLT",
                        "content": "[2,0,33,null,1,25,40,null,null,11,31,34,45,10,18,29,32,null,36,43,46,4,null,12,24,26,30,null,null,35,39,42,44,null,48,3,9,null,14,22,null,null,27,null,null,null,null,38,null,41,null,null,null,47,49,null,null,5,null,13,15,21,23,null,28,37,null,null,null,null,null,null,null,null,8,null,null,null,17,19,null,null,null,null,null,null,null,7,null,16,null,null,20,6]\\n\\n33\\n\\nFor this my output is \\n\\n[2,0,25,null,1,11,40,null,null,10,18,34,45,4,null,12,24,null,36,43,46,3,9,null,14,22,null,35,39,42,44,null,48,null,null,5,null,13,15,21,23,null,null,38,null,41,null,null,null,47,49,null,8,null,null,null,17,19,null,null,null,37,null,null,null,null,null,null,null,7,null,16,null,null,20,null,null,6]\\n\\nThis looks like a proper output to me, can somebody let me know why this test case is failing\\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## I think this is an Easy problem mostly for the length of the tree \\nif the tree were more big we really need to use binary search and the problem get more complexity, or at least we have to take more in count.\\nHere [My Solution](https://leetcode.com/problems/delete-node-in-a-bst/solutions/3869638/beats-all-in-memory-100-classic-problem-about-pointers-in-linked-list/)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "You wrote no less than 63 lines of code for a leetcode problem and then say it should be rated easy \\uD83E\\uDD23"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "This can be code in two ways and both are correct ,they are checking only one way , That\\'s why some of might be getting wrong even if are approaching it in right way.  \\n What i mean is code critical point to to delete when key have both right and left child , then we can replace root with max_left or min_right.\\nhere they are checking for min_right to replace the deleted one.\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null){return null;}\\n        if(root.val>key){\\n           root.left= deleteNode(root.left,key);\\n        }\\n        else if(root.val<key){\\n            root.right=deleteNode(root.right,key);\\n        }\\n        else{\\n            if(root.right !=null && root.left != null){\\n                int rig_min=min(root.right);\\n                root.val=rig_min;\\n                root.right=deleteNode(root.right,rig_min);\\n                return root;\\n            }\\n            else if(root.left !=null){return root.left;}\\n            else if(root.right !=null){return root.right;}\\n            else{return null;}\\n        }\\n        return root;\\n    }\\n    static int min(TreeNode root){\\n         while(root.left != null) {\\n            root = root.left;\\n        }\\n        return root.val;\\n    }\\n}"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Logic Predecessor Inorder.\\n\\n# Approach\\n\\n1. The `del` function is defined to delete a node from the binary search tree. It takes a pointer to the node to be deleted (`temp`) as an argument and returns the modified tree.\\n\\n2. If the left child of `temp` is null, it means the node has no left child. In this case, the function returns the right child of `temp`, effectively replacing `temp` with its right child.\\n\\n3. If the right child of `temp` is null, it means the node has no right child. In this case, the function returns the left child of `temp`, effectively replacing `temp` with its left child.\\n\\n4. If both the left and right children of `temp` exist, the function finds the rightmost node (`p`) in the left subtree of `temp`. This node will have a value that is less than all the values in the right subtree and greater than all the values in the left subtree.\\n\\n5. The right child of `temp` is attached as the right child of `p`, effectively connecting the right subtree of `temp` to the rightmost node in the left subtree.\\n\\n6. The function returns the left child of `temp`, effectively replacing `temp` with its left child (the modified tree).\\n\\n7. The `deleteNode` function is defined to delete a node with a specific key (`key`) from the binary search tree. It takes a pointer to the root of the tree (`root`) and the key as arguments and returns the modified tree.\\n\\n8. If the root is null (empty tree), the function returns the root as is.\\n\\n9. Otherwise, a temporary pointer `temp` is set to the root.\\n\\n10. If the value of `temp` is equal to the key, it means the root node should be deleted. In this case, the function calls the `del` function to delete the root node and returns the modified tree.\\n\\n11. Otherwise, the function enters a loop that iterates until `temp` becomes null.\\n\\n12. If the value of `temp` is less than the key, it means the key may be present in the right subtree. If the right child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the right child and breaks the loop.\\n\\n13. If the value of `temp` is greater than or equal to the key, it means the key may be present in the left subtree. If the left child of `temp` exists and its value is equal to the key, the function calls the `del` function to delete the left child and breaks the loop.\\n\\n14. If none of the above conditions are met, the function updates the value of `temp` by traversing to the right or left child based on the comparison with the key.\\n\\n15. Finally, the function returns the modified tree.\\n\\n-----------------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(h) h=height of tree.in worst case skewed tree.\\n\\n- Space complexity:\\nS.C=O(1)\\n---------------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3717168/c-logic-predecessor-inorder/\\n"
                    },
                    {
                        "username": "CalCreate",
                        "content": "Yikes this was tough, also note that you\\'re allowed to modify the BST instead of just swapping node references in this problem."
                    },
                    {
                        "username": "Amansha",
                        "content": "Cases:\\n1. When the key to be deleted is the leaf node -> In this case simply delete the node\\n2. If it has only one child -> Replace it with that child\\n3. If it has two children -> Find the Inorder successor and delete the Inorder \\n    successor\\n\\n\\n\\nCheck out my solution which has Time Complexity :- O(H) and Auxiliary Space :-O(H)\\n\\nhttps://leetcode.com/problems/delete-node-in-a-bst/solutions/3570438/java-recursive-o-h-beats-100/\\n"
                    },
                    {
                        "username": "kanikasingla__",
                        "content": "class Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        //base case\\n        if(root==NULL)\\n        return NULL;\\n        if(key<root->val)\\n       root->left= deleteNode(root->left,key);\\n        \\n        else if(key>root->val)\\n        root->right=deleteNode(root->right,key);\\n        else\\n        {\\n            //four cases arise when key==root->info ist only left child presentt 2 right child only present 3 both presentm4 mot bothpresent\\n            if(root->left==NULL && root->right==NULL)\\n            {\\n                delete root;\\n                return NULL;\\n            }\\n            if(root->left==NULL && root->right!=NULL)\\n            {\\n                TreeNode * temp=root->right;\\n                delete root;\\n                return temp;\\n\\n            }\\n            if(root->right==NULL && root->left!=NULL)\\n            {\\n                TreeNode * temp=root->left;\\n                delete root;\\n                return temp;\\n            }\\n            else\\n            {\\n                //both not null\\n                TreeNode * temp=root->right;\\n                while(temp->left!=NULL)\\n                {\\n                    temp=temp->left;\\n                }\\n                root->val=temp->val;\\n              root->right=  deleteNode(root->right,temp->val);\\n            }\\n            \\n\\n            \\n        }\\n        return root;\\n\\n\\n       \\n        \\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sort Characters By Frequency",
        "question_content": "<p>Given a string <code>s</code>, sort it in <strong>decreasing order</strong> based on the <strong>frequency</strong> of the characters. The <strong>frequency</strong> of a character is the number of times it appears in the string.</p>\n\n<p>Return <em>the sorted string</em>. If there are multiple answers, return <em>any of them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;tree&quot;\n<strong>Output:</strong> &quot;eert&quot;\n<strong>Explanation:</strong> &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cccaaa&quot;\n<strong>Output:</strong> &quot;aaaccc&quot;\n<strong>Explanation:</strong> Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Aabb&quot;\n<strong>Output:</strong> &quot;bbAa&quot;\n<strong>Explanation:</strong> &quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.\nNote that &#39;A&#39; and &#39;a&#39; are treated as two different characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of uppercase and lowercase English letters and digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 93420,
                "title": "java-o-n-bucket-sort-solution-o-nlogm-priorityqueue-solution-easy-to-understand",
                "content": "\\n\\nThe logic is very similar to NO.347 and here we just use a map a count and according to the frequency to put it into the right bucket. Then we go through the bucket to get the most frequently character and append that to the final stringbuilder.\\n```\\npublic class Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) \\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t\\t\\t\\t\\n        List<Character> [] bucket = new List[s.length() + 1];\\n        for (char key : map.keySet()) {\\n            int frequency = map.get(key);\\n            if (bucket[frequency] == null) bucket[frequency] = new ArrayList<>();\\n            bucket[frequency].add(key);\\n        }\\n\\t\\t\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n        for (int pos = bucket.length - 1; pos >= 0; pos--)\\n            if (bucket[pos] != null)\\n                for (char c : bucket[pos])\\n                    for (int i = 0; i < pos; i++)\\n                        sb.append(c);\\n\\n        return sb.toString();\\n    }\\n}\\n\\n````\\n\\n\\nAnd we have normal way using PriorityQueue as follows:\\naccording to user \"orxanb\", O(n) ignore logm since m is the distinguish character, can be O(1) since only 26 letters. So the overall time complexity should be O(n), the same as the buck sort with less memory use.\\n\\n```\\npublic class Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t\\t\\t\\t\\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        pq.addAll(map.entrySet());\\n\\t\\t\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            Map.Entry e = pq.poll();\\n            for (int i = 0; i < (int)e.getValue(); i++) \\n                sb.append(e.getKey());\\n        }\\n        return sb.toString();\\n    }\\n}\\n````\\n\\nThere is a follow up if you are interested, when same frequency we need to maintain the same sequence as the character show in the original string, the solution is add a index as a secondary sort if the frequency is same, code as below:\\n\\n\\n\\n```\\n    public static String frequencySort(String s) {\\n        Map<Character, int[]> map = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!map.containsKey(c)) map.put(c, new int[]{1, i});\\n            else {\\n                int[] freqAndSeq = map.get(c);\\n                freqAndSeq[0]++;\\n                map.put(c, freqAndSeq);\\n            }\\n        }\\n\\n        PriorityQueue<Map.Entry<Character, int[]>> pq = new PriorityQueue<>((a, b) ->\\n                a.getValue()[0] == b.getValue()[0] ? a.getValue()[1] - b.getValue()[1] : b.getValue()[0] - a.getValue()[0]);\\n\\n        pq.addAll(map.entrySet());\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            Map.Entry<Character, int[]> e = pq.poll();\\n            for (int i = 0; i < e.getValue()[0]; i++)\\n                sb.append(e.getKey());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) \\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t\\t\\t\\t\\n        List<Character> [] bucket = new List[s.length() + 1];\\n        for (char key : map.keySet()) {\\n            int frequency = map.get(key);\\n            if (bucket[frequency] == null) bucket[frequency] = new ArrayList<>();\\n            bucket[frequency].add(key);\\n        }\\n\\t\\t\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n        for (int pos = bucket.length - 1; pos >= 0; pos--)\\n            if (bucket[pos] != null)\\n                for (char c : bucket[pos])\\n                    for (int i = 0; i < pos; i++)\\n                        sb.append(c);\\n\\n        return sb.toString();\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t\\t\\t\\t\\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        pq.addAll(map.entrySet());\\n\\t\\t\\t\\t\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            Map.Entry e = pq.poll();\\n            for (int i = 0; i < (int)e.getValue(); i++) \\n                sb.append(e.getKey());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\n    public static String frequencySort(String s) {\\n        Map<Character, int[]> map = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!map.containsKey(c)) map.put(c, new int[]{1, i});\\n            else {\\n                int[] freqAndSeq = map.get(c);\\n                freqAndSeq[0]++;\\n                map.put(c, freqAndSeq);\\n            }\\n        }\\n\\n        PriorityQueue<Map.Entry<Character, int[]>> pq = new PriorityQueue<>((a, b) ->\\n                a.getValue()[0] == b.getValue()[0] ? a.getValue()[1] - b.getValue()[1] : b.getValue()[0] - a.getValue()[0]);\\n\\n        pq.addAll(map.entrySet());\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            Map.Entry<Character, int[]> e = pq.poll();\\n            for (int i = 0; i < e.getValue()[0]; i++)\\n                sb.append(e.getKey());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93404,
                "title": "c-o-n-solution-without-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> freq;\\n        vector<string> bucket(s.size()+1, \"\");\\n        string res;\\n        \\n        //count frequency of each character\\n        for(char c:s) freq[c]++;\\n        //put character into frequency bucket\\n        for(auto& it:freq) {\\n            int n = it.second;\\n            char c = it.first;\\n            bucket[n].append(n, c);\\n        }\\n        //form descending sorted string\\n        for(int i=s.size(); i>0; i--) {\\n            if(!bucket[i].empty())\\n                res.append(bucket[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> freq;\\n        vector<string> bucket(s.size()+1, \"\");\\n        string res;\\n        \\n        //count frequency of each character\\n        for(char c:s) freq[c]++;\\n        //put character into frequency bucket\\n        for(auto& it:freq) {\\n            int n = it.second;\\n            char c = it.first;\\n            bucket[n].append(n, c);\\n        }\\n        //form descending sorted string\\n        for(int i=s.size(); i>0; i--) {\\n            if(!bucket[i].empty())\\n                res.append(bucket[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503201,
                "title": "c-python-3-solutions-sorting-bucket-sort-o-n-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Counter & Sorting String S**\\n<iframe src=\"https://leetcode.com/playground/YJYwQxwo/shared\" frameBorder=\"0\" width=\"100%\" height=\"260\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogN)`, where `N <= 5 * 10^5` is the length of string `s`.\\n- Space: \\n\\t- C++: `O(logN)` it\\'s the stack memory of introsort in C++.\\n\\t- Python: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Counter & Sorting Distinct Characters**\\n<iframe src=\"https://leetcode.com/playground/3VAT8YUT/shared\" frameBorder=\"0\" width=\"100%\" height=\"430\"></iframe>\\n\\n**Complexity**\\n- Time:  `O(N + KlogK)`, where  `N <= 5 * 10^5` is the length of string `s`, `K <= 62` is the number of distinct characters (include uppercase characters, lowercase characters and digits) in string `s`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Counter & Bucket Sort**\\n- Since `freq` values are in range `[0...n]`, so we can use Bucket Sort to achieve `O(N)` in Time Complexity.\\n\\n<iframe src=\"https://leetcode.com/playground/AYMyM2PN/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 5 * 10^5` is the length of string `s`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Counter & Sorting String S**\\n<iframe src=\"https://leetcode.com/playground/YJYwQxwo/shared\" frameBorder=\"0\" width=\"100%\" height=\"260\"></iframe>\\n\\n**Complexity**\\n- Time: `O(NlogN)`, where `N <= 5 * 10^5` is the length of string `s`.\\n- Space: \\n\\t- C++: `O(logN)` it\\'s the stack memory of introsort in C++.\\n\\t- Python: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Counter & Sorting Distinct Characters**\\n<iframe src=\"https://leetcode.com/playground/3VAT8YUT/shared\" frameBorder=\"0\" width=\"100%\" height=\"430\"></iframe>\\n\\n**Complexity**\\n- Time:  `O(N + KlogK)`, where  `N <= 5 * 10^5` is the length of string `s`, `K <= 62` is the number of distinct characters (include uppercase characters, lowercase characters and digits) in string `s`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Counter & Bucket Sort**\\n- Since `freq` values are in range `[0...n]`, so we can use Bucket Sort to achieve `O(N)` in Time Complexity.\\n\\n<iframe src=\"https://leetcode.com/playground/AYMyM2PN/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 5 * 10^5` is the length of string `s`.\\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 93409,
                "title": "concise-c-solution-using-stl-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        int counts[256] = {0};\\n        for (char ch : s)\\n            ++counts[ch];\\n        sort(s.begin(), s.end(), [&](char a, char b) { \\n            return counts[a] > counts[b] || (counts[a] == counts[b] && a < b); \\n        });\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        int counts[256] = {0};\\n        for (char ch : s)\\n            ++counts[ch];\\n        sort(s.begin(), s.end(), [&](char a, char b) { \\n            return counts[a] > counts[b] || (counts[a] == counts[b] && a < b); \\n        });\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645688,
                "title": "c-concise-7-lines-o-n-heap-no-custom-comparator",
                "content": "The idea is to use max heap with nodes containing a pair {frequency, character}. Since the first element of the pair is frequency, we don\\'t need to pass a custom comparator. Max heap will be constructed on the basis of frequency of characters, i.e. the root will contain the character with maximum frequency. \\n\\n**Time Complexity:** O(n)\\nO(26log(n)) = **O(log(n))** For Construction and extraction from heap\\n**O(n)** For storing the frequency in hashmap.\\n\\n\\n```\\nstring frequencySort(string s) {\\n        unordered_map<char,int> freq;           //for frequency of characters\\n        priority_queue<pair<int,char>> maxheap; //maxheap according to frequency of characters\\n        for(char c: s)\\n            freq[c]++;\\n        for(auto it: freq)\\n            maxheap.push({it.second,it.first}); //heap will be constructed on the basis of frequency\\n        s=\"\";   \\n        while(!maxheap.empty()){\\n            s+=string(maxheap.top().first,maxheap.top().second); //frequency times the character\\n            maxheap.pop();\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstring frequencySort(string s) {\\n        unordered_map<char,int> freq;           //for frequency of characters\\n        priority_queue<pair<int,char>> maxheap; //maxheap according to frequency of characters\\n        for(char c: s)\\n            freq[c]++;\\n        for(auto it: freq)\\n            maxheap.push({it.second,it.first}); //heap will be constructed on the basis of frequency\\n        s=\"\";   \\n        while(!maxheap.empty()){\\n            s+=string(maxheap.top().first,maxheap.top().second); //frequency times the character\\n            maxheap.pop();\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93410,
                "title": "1-line-python-code",
                "content": "```\\nclass Solution(object):\\n    def frequencySort(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join([char * times for char, times in collections.Counter(str).most_common()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def frequencySort(self, str):\\n        \"\"\"\\n        :type str: str\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join([char * times for char, times in collections.Counter(str).most_common()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365179,
                "title": "100-optimisation-38-ms-to-2ms-5-solution-explanations-optimisation-bonus-question",
                "content": "Hi, \\nI\\'ve tried hard to achieve the 2 ms speed. Though the fastest algo below (algo 5) was there in my mind initially but i tried through object, that caused lot of time 35ms. Later i did not use object and direclty jump to character. \\n\\n**Base Algorithm** : This base algorithm is pretty easy. \\nStep 1. Count the frequency of each character\\nStep 2. Sort the frequency in descending order {in last solution i did not sort}  \\nStep 3: Push a character from hightest freqency to lowest freqency, frequency number of times in output array. \\n\\n\\n**Solution 1**: Using Hashmap {for frequency calculation} and Frequency Object {to store tha character and frequency}\\n\\n<details>\\nRuntime: 38 ms, faster than 44.29% of Java online submissions for Sort Characters By Frequency.\\n Memory Usage: 39 MB, less than 85.19% of Java online submissions for Sort Characters By Frequency.\\n  Time: O(n) + O(m*log(m)) + (n) = O(n) since m = 256 at max so O(n) >>>> O(m*log(m)) \\n Space: O(n)\\n \\n```\\npublic String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n\\n        class Freq {\\n            char c;\\n            int freq;\\n\\n            public Freq(char c, int freq) {\\n                this.c = c;\\n                this.freq = freq;\\n            }\\n        }\\n\\n\\n        int n = s.length();\\n        Map<Character, Freq> freqMap = new HashMap<>();\\n\\n\\n        for (char c : s.toCharArray()) {\\n            if (!freqMap.containsKey(c))\\n                freqMap.put(c, new Freq(c, 1));\\n            else\\n                freqMap.get(c).freq++;\\n        }\\n\\n        List<Freq> values = new ArrayList<>(freqMap.values());\\n        Collections.sort(values, ((o1, o2) -> o2.freq - o1.freq));\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        for (Freq f : values) {\\n            int frequency = f.freq;\\n            while (frequency-- > 0)\\n                output[x++] = f.c;\\n        }\\n\\n        return new String(output);\\n    }\\n```\\n\\n</details>\\n\\n**Solution 2:** Removing the explicit object from above solution and use Map.Entry it self as object\\n\\n<details>\\nRuntime: 38 ms, faster than 44.29% of Java online submissions for Sort Characters By Frequency.\\nMemory Usage: 39 MB, less than 85.19% of Java online submissions for Sort Characters By Frequency.\\n  Time: O(n) + O(m*log(m)) + (n) = O(n) since m = 256 at max so O(n) >>>> O(m*log(m)) \\n Space: O(n)\\n \\n```\\n public String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        final ArrayList<Map.Entry<Character, Integer>> entries = new ArrayList<>(freqMap.entrySet());\\n        Collections.sort(entries, ((o1, o2) -> o2.getValue() - o1.getValue()));\\n\\n        for (Map.Entry<Character, Integer> entry : entries) {\\n\\n            char c = entry.getKey();\\n            int freq = entry.getValue();\\n\\n            while (freq-- > 0)\\n                output[x++] = c;\\n        }\\n\\n        return new String(output);\\n    }\\n```\\n\\n</details>\\n\\n**Solution 3:** Instead of sorting data manually, we use Priority Queue\\n\\n<details>\\n\\n Runtime: 38 ms, faster than 44.29% of Java online submissions for Sort Characters By Frequency.\\n Memory Usage: 39 MB, less than 85.19% of Java online submissions for Sort Characters By Frequency.\\n   Time: O(n) + O(m*log(m)) + (n) = O(n) since m = 256 at max so O(n) >>>> O(m*log(m)) \\n Space: O(n)\\n \\n```\\n public String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        final PriorityQueue<Map.Entry<Character, Integer>> entries = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        entries.addAll(freqMap.entrySet());\\n\\n        while (!entries.isEmpty()) {\\n            Map.Entry<Character, Integer> entry = entries.poll();\\n\\n            char c = entry.getKey();\\n            int freq = entry.getValue();\\n\\n            while (freq-- > 0)\\n                output[x++] = c;\\n        }\\n\\n        return new String(output);\\n    }\\n```\\n\\n\\n</details>\\n\\n**Solution 4:** So far, more or less we are sorting. The important observation is the limit of character is 256 only. So instead of explicit O(m * log(m)) sort we can use bucket sort to make it O(m).\\nWhich brings it down from 38ms to 13ms. Pretty good right\\n\\n<details>\\nRuntime: 13 ms, faster than 88.95% of Java online submissions for Sort Characters By Frequency.\\n Memory Usage: 37.2 MB, less than 100.00% of Java online submissions for Sort Characters By Frequency.\\nTime: O(n) + O(m) + (n) = O(n) since O(n) >>>> O(m) as m is 256 at max\\n  Space: O(n)\\n\\n```\\npublic String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n\\n        //O(n)\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n\\n        /**\\n         * Create buckets of each char; Each index will represent how many times a char occurred.\\n         * for index [i], is tell the length of the character at it. Since many character can have same frequency\\n         * so we need a list\\n         * O(n * 256 ) => O(n)\\n         */\\n\\n        List<Character>[] buckets = new List[s.length() + 1]; //as there will be a character whose frequency is 1\\n\\n        /**\\n         * Fill the buckets\\n         * O(n)\\n         */\\n        for (Character c : freqMap.keySet()) {\\n            int freq = freqMap.get(c);\\n\\n            if (buckets[freq] == null)\\n                buckets[freq] = new ArrayList<>();\\n\\n            buckets[freq].add(c);\\n        }\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n        int freq = 0;\\n        /**\\n         * Fill the output\\n         * O(n * 256 ) => O(n)\\n         */\\n        for (int i = buckets.length - 1; i >= 0; i--) {\\n\\n            if (buckets[i] != null) {\\n\\n                for (char c : buckets[i]) {\\n                    freq = freqMap.get(c);\\n\\n                    while (freq-- > 0)\\n                        output[x++] = c;\\n                }\\n            }\\n        }\\n\\n\\n        return new String(output);\\n    }\\n```\\n\\n</details>\\n\\n**Solution 5:** After observing above fact that we have at most 256 char only, we can totally remove both of the dependency; \\nBucketing : to reducing the memory consumption\\nKind a Sorting{bucketing is also a sort but in linear time}: With linear search \\n\\n**Runtime: 2 ms, faster than 100.00% of Java online submissions for Sort Characters By Frequency.\\n Memory Usage: 38.6 MB, less than 92.59% of Java online submissions for Sort Characters By Frequency.**\\n \\nTime: O(n) + O(m^2) + (n) = O(n) since O(n) >>>> O(m^2) as m is 256 at max\\n Space: O(n)\\n\\n```\\n public String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n\\n        int freq[] = new int[256];\\n\\n        for (char c : s.toCharArray())\\n            freq[(int) c]++;\\n\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        int max;\\n        int index;\\n        while (x < n) {\\n            max = 0;\\n            index = -1;\\n            for (int i = 0; i < freq.length; i++) {\\n\\n                if (max < freq[i]) {\\n                    max = freq[i];\\n                    index = i;\\n                }\\n            }\\n            //all elements are over\\n            if (max == 0) {\\n                return new String(output);\\n            }\\n            int temp = max;\\n            while (temp-- > 0)\\n                output[x++] = (char) index;\\n\\n            freq[index] = 0; //nullify this character as it used.\\n        }\\n\\n\\n        return new String(output);\\n    }\\n```\\n\\n\\n**Bonus Question:** In above question if the frequency of two character is same, then we put them in any order.\\nModify you code so that, first you sort based on Frequency(smaller to larger) and if frequency are same for two character then sort them lexical order\\nAsked in : **Intuit**\\nInput: helloworld\\noutput: [d, e, h, r, w, o, l]\\nSince: \\nd -> 1\\ne -> 1\\nh -> 1\\nr -> 1\\nw -> 1\\no -> 2\\nl -> 3\\n\\nSolution:\\n<details>\\n\\n```\\n private static List<Character> sortStringBasedOnFrequencyAndLexical(String str) {\\n\\n        if (str == null || str.isEmpty())\\n            return Collections.EMPTY_LIST;\\n\\n\\n        class FrequencyObj {\\n            int frequency;\\n            char c;\\n\\n            public FrequencyObj(int frequency, char c) {\\n                this.frequency = frequency;\\n                this.c = c;\\n            }\\n        }\\n\\n        final FrequencyObj freq[] = new FrequencyObj[256];\\n        for (int i = 0; i < 256; i++)\\n            freq[i] = new FrequencyObj(str.length() + 1, \\' \\');\\n\\n        for (char c : str.toCharArray()) {\\n            int x = (int) c;\\n\\n            if (freq[x].c == \\' \\') {\\n                freq[x].c = c;\\n                freq[x].frequency = 1;\\n            } else\\n                freq[x].frequency++;\\n        }\\n\\n        Arrays.sort(freq, new Comparator<FrequencyObj>() {\\n            @Override\\n            public int compare(FrequencyObj o1, FrequencyObj o2) {\\n\\n                if (o1.frequency == o2.frequency)\\n                    return o1.c - o2.c;\\n\\n                return o1.frequency - o2.frequency;\\n            }\\n        });\\n\\n        List<Character> output = new ArrayList<>();\\n\\n        for (int i = 0; i < 256; i++)\\n            if (freq[i] != null && freq[i].c != \\' \\') {\\n                \\n                output.add(freq[i].c);\\n            }\\n\\n        return output;\\n\\n    }\\n```\\n\\n<details>",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n\\n        class Freq {\\n            char c;\\n            int freq;\\n\\n            public Freq(char c, int freq) {\\n                this.c = c;\\n                this.freq = freq;\\n            }\\n        }\\n\\n\\n        int n = s.length();\\n        Map<Character, Freq> freqMap = new HashMap<>();\\n\\n\\n        for (char c : s.toCharArray()) {\\n            if (!freqMap.containsKey(c))\\n                freqMap.put(c, new Freq(c, 1));\\n            else\\n                freqMap.get(c).freq++;\\n        }\\n\\n        List<Freq> values = new ArrayList<>(freqMap.values());\\n        Collections.sort(values, ((o1, o2) -> o2.freq - o1.freq));\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        for (Freq f : values) {\\n            int frequency = f.freq;\\n            while (frequency-- > 0)\\n                output[x++] = f.c;\\n        }\\n\\n        return new String(output);\\n    }\\n```\n```\\n public String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        final ArrayList<Map.Entry<Character, Integer>> entries = new ArrayList<>(freqMap.entrySet());\\n        Collections.sort(entries, ((o1, o2) -> o2.getValue() - o1.getValue()));\\n\\n        for (Map.Entry<Character, Integer> entry : entries) {\\n\\n            char c = entry.getKey();\\n            int freq = entry.getValue();\\n\\n            while (freq-- > 0)\\n                output[x++] = c;\\n        }\\n\\n        return new String(output);\\n    }\\n```\n```\\n public String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        final PriorityQueue<Map.Entry<Character, Integer>> entries = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        entries.addAll(freqMap.entrySet());\\n\\n        while (!entries.isEmpty()) {\\n            Map.Entry<Character, Integer> entry = entries.poll();\\n\\n            char c = entry.getKey();\\n            int freq = entry.getValue();\\n\\n            while (freq-- > 0)\\n                output[x++] = c;\\n        }\\n\\n        return new String(output);\\n    }\\n```\n```\\npublic String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n        Map<Character, Integer> freqMap = new HashMap<>();\\n\\n\\n        //O(n)\\n        for (char c : s.toCharArray()) {\\n            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);\\n        }\\n\\n\\n        /**\\n         * Create buckets of each char; Each index will represent how many times a char occurred.\\n         * for index [i], is tell the length of the character at it. Since many character can have same frequency\\n         * so we need a list\\n         * O(n * 256 ) => O(n)\\n         */\\n\\n        List<Character>[] buckets = new List[s.length() + 1]; //as there will be a character whose frequency is 1\\n\\n        /**\\n         * Fill the buckets\\n         * O(n)\\n         */\\n        for (Character c : freqMap.keySet()) {\\n            int freq = freqMap.get(c);\\n\\n            if (buckets[freq] == null)\\n                buckets[freq] = new ArrayList<>();\\n\\n            buckets[freq].add(c);\\n        }\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n        int freq = 0;\\n        /**\\n         * Fill the output\\n         * O(n * 256 ) => O(n)\\n         */\\n        for (int i = buckets.length - 1; i >= 0; i--) {\\n\\n            if (buckets[i] != null) {\\n\\n                for (char c : buckets[i]) {\\n                    freq = freqMap.get(c);\\n\\n                    while (freq-- > 0)\\n                        output[x++] = c;\\n                }\\n            }\\n        }\\n\\n\\n        return new String(output);\\n    }\\n```\n```\\n public String frequencySort(String s) {\\n        if (s == null || s.isEmpty())\\n            return s;\\n        int n = s.length();\\n\\n        int freq[] = new int[256];\\n\\n        for (char c : s.toCharArray())\\n            freq[(int) c]++;\\n\\n\\n        char output[] = new char[n];\\n        int x = 0;\\n\\n        int max;\\n        int index;\\n        while (x < n) {\\n            max = 0;\\n            index = -1;\\n            for (int i = 0; i < freq.length; i++) {\\n\\n                if (max < freq[i]) {\\n                    max = freq[i];\\n                    index = i;\\n                }\\n            }\\n            //all elements are over\\n            if (max == 0) {\\n                return new String(output);\\n            }\\n            int temp = max;\\n            while (temp-- > 0)\\n                output[x++] = (char) index;\\n\\n            freq[index] = 0; //nullify this character as it used.\\n        }\\n\\n\\n        return new String(output);\\n    }\\n```\n```\\n private static List<Character> sortStringBasedOnFrequencyAndLexical(String str) {\\n\\n        if (str == null || str.isEmpty())\\n            return Collections.EMPTY_LIST;\\n\\n\\n        class FrequencyObj {\\n            int frequency;\\n            char c;\\n\\n            public FrequencyObj(int frequency, char c) {\\n                this.frequency = frequency;\\n                this.c = c;\\n            }\\n        }\\n\\n        final FrequencyObj freq[] = new FrequencyObj[256];\\n        for (int i = 0; i < 256; i++)\\n            freq[i] = new FrequencyObj(str.length() + 1, \\' \\');\\n\\n        for (char c : str.toCharArray()) {\\n            int x = (int) c;\\n\\n            if (freq[x].c == \\' \\') {\\n                freq[x].c = c;\\n                freq[x].frequency = 1;\\n            } else\\n                freq[x].frequency++;\\n        }\\n\\n        Arrays.sort(freq, new Comparator<FrequencyObj>() {\\n            @Override\\n            public int compare(FrequencyObj o1, FrequencyObj o2) {\\n\\n                if (o1.frequency == o2.frequency)\\n                    return o1.c - o2.c;\\n\\n                return o1.frequency - o2.frequency;\\n            }\\n        });\\n\\n        List<Character> output = new ArrayList<>();\\n\\n        for (int i = 0; i < 256; i++)\\n            if (freq[i] != null && freq[i].c != \\' \\') {\\n                \\n                output.add(freq[i].c);\\n            }\\n\\n        return output;\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615846,
                "title": "python-java-hashtable-heap-sort-easy-to-understand-and-detailed-explanation",
                "content": "I understand there are a tons of solution like mine, but here I offered a clean and detailed explanation on this kind of problem.\\n\\nFirst, the idea of solution as follows.\\n1. HashTable + Sort: We use HashTable to count the occurence and sort the entries based on the occurence, then build the string.\\n2. HashTable + Heap(Maxheap): We use HashTable to count the occurence and build the heap based on the occurence, then build the string.\\n\\n\\n**Java**\\n\\n1. HashTable + Sort:\\n```java\\npublic String frequencySort(String s) {\\n\\t// Count the occurence on each character\\n\\tHashMap<Character, Integer> cnt = new HashMap<>();\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tcnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n\\t}\\n\\t\\n\\t// Sorting\\n\\tList<Character> chars = new ArrayList(cnt.keySet());\\n\\tCollections.sort(chars, (a, b) -> (cnt.get(b) - cnt.get(a)));\\n\\n\\t// Build string\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (Object c : chars) {\\n\\t\\tfor (int i = 0; i < cnt.get(c); i++) {\\n\\t\\t\\tsb.append(c);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\n\\nTime Complexity: O(nlogn), since we sort the characters\\nSpace Complexity: O(n)\\n\\n2. HashTable + Heap:\\n```java\\npublic String frequencySort(String s) {\\n\\t// Count the occurence on each character\\n\\tHashMap<Character, Integer> cnt = new HashMap<>();\\n\\tfor (char c: s.toCharArray()) {\\n\\t\\tcnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n\\t}\\n\\n\\t// Build heap\\n\\tPriorityQueue<Character> heap = new PriorityQueue<>((a, b) -> (cnt.get(b) - cnt.get(a)));\\n\\theap.addAll(cnt.keySet());\\n\\n\\t// Build string\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile (!heap.isEmpty()) {\\n\\t\\tchar c = heap.poll();\\n\\t\\tfor (int i = 0; i < cnt.get(c); i++) {\\n\\t\\t\\tsb.append(c);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\\nTime Complexity: O(nlogk), where k is the number of distinct character.\\nSpace Complexity: O(n)\\n\\n**Python**\\n1. HashTable + Sort:\\n```python\\ndef frequencySort(self, s: str) -> str:\\n\\t# Count the occurence on each character\\n\\tcnt = collections.defaultdict(int)\\n\\tfor c in s:\\n\\t\\tcnt[c] += 1\\n\\t\\n\\t# Sort and Build string\\n\\tres = []\\n\\tfor k, v in sorted(cnt.items(), key = lambda x: -x[1]):\\n\\t\\tres += [k] * v\\n\\treturn \"\".join(res)\\n```\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)\\n\\nNote that we can optimize the first solution to O(n) by using `Counter()` in Python\\n```python\\ndef frequencySort(self, s: str) -> str:\\n\\t# Count the occurence on each character\\n\\tcnt = collections.Counter(s)\\n\\t\\n\\t# Build string\\n\\tres = []\\n\\tfor k, v in cnt.most_common():\\n\\t\\tres += [k] * v\\n\\treturn \"\".join(res)\\n```\\nTime Complexity: O(nlogk), we don\\'t need to sort here, the `most_common()` cost O(nlogk) based on source code. In fact, the `most_common` used `heapq` on th implementation. Thus, we can consider this solution is the same as solution 2.\\nSpace Complexity: O(n)\\n\\n2. HashTable + Heap:\\n```python\\ndef frequencySort(self, s: str) -> str:\\n\\t# Count the occurence on each character\\n\\tcnt = collections.Counter(s)\\n\\t\\n\\t# Build heap\\n\\theap = [(-v, k) for k, v in cnt.items()]\\n\\theapq.heapify(heap)\\n\\t\\n\\t# Build string\\n\\tres = []\\n\\twhile heap:\\n\\t\\tv, k = heapq.heappop(heap)\\n\\t\\tres += [k] * -v\\n\\treturn \\'\\'.join(res)\\n```\\nTime Complexity: O(nlogk), where k is the number of distinct character.\\nSpace Complexity: O(n)\\n\\nRemember that if you want to achieve `Heap` structure in **Python**, you can use `heapq` and `PriorityQueue` in **Java**\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\npublic String frequencySort(String s) {\\n\\t// Count the occurence on each character\\n\\tHashMap<Character, Integer> cnt = new HashMap<>();\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tcnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n\\t}\\n\\t\\n\\t// Sorting\\n\\tList<Character> chars = new ArrayList(cnt.keySet());\\n\\tCollections.sort(chars, (a, b) -> (cnt.get(b) - cnt.get(a)));\\n\\n\\t// Build string\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (Object c : chars) {\\n\\t\\tfor (int i = 0; i < cnt.get(c); i++) {\\n\\t\\t\\tsb.append(c);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\n```java\\npublic String frequencySort(String s) {\\n\\t// Count the occurence on each character\\n\\tHashMap<Character, Integer> cnt = new HashMap<>();\\n\\tfor (char c: s.toCharArray()) {\\n\\t\\tcnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n\\t}\\n\\n\\t// Build heap\\n\\tPriorityQueue<Character> heap = new PriorityQueue<>((a, b) -> (cnt.get(b) - cnt.get(a)));\\n\\theap.addAll(cnt.keySet());\\n\\n\\t// Build string\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile (!heap.isEmpty()) {\\n\\t\\tchar c = heap.poll();\\n\\t\\tfor (int i = 0; i < cnt.get(c); i++) {\\n\\t\\t\\tsb.append(c);\\n\\t\\t}\\n\\t}\\n\\treturn sb.toString();\\n}\\n```\n```python\\ndef frequencySort(self, s: str) -> str:\\n\\t# Count the occurence on each character\\n\\tcnt = collections.defaultdict(int)\\n\\tfor c in s:\\n\\t\\tcnt[c] += 1\\n\\t\\n\\t# Sort and Build string\\n\\tres = []\\n\\tfor k, v in sorted(cnt.items(), key = lambda x: -x[1]):\\n\\t\\tres += [k] * v\\n\\treturn \"\".join(res)\\n```\n```python\\ndef frequencySort(self, s: str) -> str:\\n\\t# Count the occurence on each character\\n\\tcnt = collections.Counter(s)\\n\\t\\n\\t# Build string\\n\\tres = []\\n\\tfor k, v in cnt.most_common():\\n\\t\\tres += [k] * v\\n\\treturn \"\".join(res)\\n```\n```python\\ndef frequencySort(self, s: str) -> str:\\n\\t# Count the occurence on each character\\n\\tcnt = collections.Counter(s)\\n\\t\\n\\t# Build heap\\n\\theap = [(-v, k) for k, v in cnt.items()]\\n\\theapq.heapify(heap)\\n\\t\\n\\t# Build string\\n\\tres = []\\n\\twhile heap:\\n\\t\\tv, k = heapq.heappop(heap)\\n\\t\\tres += [k] * -v\\n\\treturn \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 93445,
                "title": "o-n-easy-to-understand-java-solution",
                "content": "1. Build a map of characters to the number of times it occurs in the string\\n2. Create an array where the index of the array represents how many times that character occurred in the String\\n3. Iterate from the end of the array to the beginning, and at each index, append each character to the return string that number of times.\\n\\n```\\npublic String frequencySort(String s) {\\n    if (s == null) {\\n        return null;\\n    }\\n    Map<Character, Integer> map = new HashMap();\\n    char[] charArray = s.toCharArray();\\n    int max = 0;\\n    for (Character c : charArray) {\\n        if (!map.containsKey(c)) {\\n            map.put(c, 0);\\n        }\\n        map.put(c, map.get(c) + 1);\\n        max = Math.max(max, map.get(c));\\n    }\\n\\n    List<Character>[] array = buildArray(map, max);\\n\\n    return buildString(array);\\n}\\n\\nprivate List<Character>[] buildArray(Map<Character, Integer> map, int maxCount) {\\n    List<Character>[] array = new List[maxCount + 1];\\n    for (Character c : map.keySet()) {\\n        int count = map.get(c);\\n        if (array[count] == null) {\\n            array[count] = new ArrayList();\\n        }\\n        array[count].add(c);\\n    }\\n    return array;\\n}\\n\\nprivate String buildString(List<Character>[] array) {\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = array.length - 1; i > 0; i--) {\\n        List<Character> list = array[i];\\n        if (list != null) {\\n            for (Character c : list) {\\n                for (int j = 0; j < i; j++) {\\n                    sb.append(c);\\n                }\\n            }\\n        }\\n    }\\n    return sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String frequencySort(String s) {\\n    if (s == null) {\\n        return null;\\n    }\\n    Map<Character, Integer> map = new HashMap();\\n    char[] charArray = s.toCharArray();\\n    int max = 0;\\n    for (Character c : charArray) {\\n        if (!map.containsKey(c)) {\\n            map.put(c, 0);\\n        }\\n        map.put(c, map.get(c) + 1);\\n        max = Math.max(max, map.get(c));\\n    }\\n\\n    List<Character>[] array = buildArray(map, max);\\n\\n    return buildString(array);\\n}\\n\\nprivate List<Character>[] buildArray(Map<Character, Integer> map, int maxCount) {\\n    List<Character>[] array = new List[maxCount + 1];\\n    for (Character c : map.keySet()) {\\n        int count = map.get(c);\\n        if (array[count] == null) {\\n            array[count] = new ArrayList();\\n        }\\n        array[count].add(c);\\n    }\\n    return array;\\n}\\n\\nprivate String buildString(List<Character>[] array) {\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = array.length - 1; i > 0; i--) {\\n        List<Character> list = array[i];\\n        if (list != null) {\\n            for (Character c : list) {\\n                for (int j = 0; j < i; j++) {\\n                    sb.append(c);\\n                }\\n            }\\n        }\\n    }\\n    return sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534608,
                "title": "c-two-simple-and-clean-solutions-detailed-explanation",
                "content": "**Solution I - Using Priority Queue**\\nFirst, we count the frequency of each letter using unordered_map `freq`.\\nThen, to sort the frequencies, we use a priority_queue `q` with pairs: { `freq, char` }.\\nConsrtucting the result is simple: just pop each pair from the queue and add that number of chars to `res`.\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> freq;\\n        for (auto a : s) freq[a]++;\\n        \\n        priority_queue<pair<int, char>> q;\\n        for (auto [a, frq] : freq) q.push({frq, a});\\n        \\n        string res;\\n        pair<int, char> curr;\\n        while (!q.empty()) {\\n            curr = q.top();\\n            q.pop();\\n            res += string(curr.first, curr.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Solution II - Using Bucket Sort**\\nFirst, we count the frequency of each letter using unordered_map `freq`.\\nThen, we use a vector to store buckets by the frequency. In each bucket we have a vector of the chars with that frequency.\\nConstructing the result is simply looping the buckets from the end - to get the higher frequencies first, and adding the chars in the current frequency.\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> freq;\\n        for (auto a : s) freq[a]++;\\n        \\n        vector<vector<char>> buckets(s.size()+1);\\n        for (auto [a, frq] : freq) buckets[frq].push_back(a);\\n        \\n        string res;\\n        for (int i = s.size(); i > 0; i--) {\\n            for (auto ch : buckets[i]) {\\n                res += string(i, ch);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> freq;\\n        for (auto a : s) freq[a]++;\\n        \\n        priority_queue<pair<int, char>> q;\\n        for (auto [a, frq] : freq) q.push({frq, a});\\n        \\n        string res;\\n        pair<int, char> curr;\\n        while (!q.empty()) {\\n            curr = q.top();\\n            q.pop();\\n            res += string(curr.first, curr.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> freq;\\n        for (auto a : s) freq[a]++;\\n        \\n        vector<vector<char>> buckets(s.size()+1);\\n        for (auto [a, frq] : freq) buckets[frq].push_back(a);\\n        \\n        string res;\\n        for (int i = s.size(); i > 0; i--) {\\n            for (auto ch : buckets[i]) {\\n                res += string(i, ch);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93519,
                "title": "python-o-n-solution-using-hash-map",
                "content": "* Frequency of a character can vary from 0 to len(s).\\n* Create a hashmap H1 of character to character frequency for the input string.\\n* Iterate H1 to create hashmap H2 with key as frequency and value as substrings of repeated strings with length as the frequency.\\n* Finally lookup all potential frequencies in decreasing order in H2 and produce the final result.\\n```\\nfrom collections import Counter\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        c1, c2 = Counter(s), {}\\n        for k,v in c1.items():\\n            c2.setdefault(v, []).append(k*v)\\n        return \"\".join([\"\".join(c2[i]) for i in range(len(s), -1, -1) if i in c2])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        c1, c2 = Counter(s), {}\\n        for k,v in c1.items():\\n            c2.setdefault(v, []).append(k*v)\\n        return \"\".join([\"\".join(c2[i]) for i in range(len(s), -1, -1) if i in c2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645949,
                "title": "javascript-clean-3-liner-solution",
                "content": "```javascript\\nvar frequencySort = function(s) {\\n    \\n    const charMap = s.split(\\'\\').reduce((acc, cur) => {acc[cur] = (acc[cur] || 0) + 1; return acc} , {})\\n    \\n    const sortedArr = Object.keys(charMap).sort((a, b) => charMap[b] - charMap[a]);\\n    \\n    return sortedArr.reduce((acc, cur) => acc + cur.repeat(charMap[cur]) ,\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar frequencySort = function(s) {\\n    \\n    const charMap = s.split(\\'\\').reduce((acc, cur) => {acc[cur] = (acc[cur] || 0) + 1; return acc} , {})\\n    \\n    const sortedArr = Object.keys(charMap).sort((a, b) => charMap[b] - charMap[a]);\\n    \\n    return sortedArr.reduce((acc, cur) => acc + cur.repeat(charMap[cur]) ,\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2871166,
                "title": "python3-one-liners-vs-o-n",
                "content": "**One-liner O(NlogN)**\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \\'\\'.join(c*fre for c, fre in Counter(s).most_common())\\n```\\n```Counter().most_common()```: \"Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter.\" (seems like it was designed for this problem, but most_common() needs O(Nlog(N).)\\n\\n**Another One-liner O(NlogN)**, because we need to sort ```s```,\\n```python\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \"\".join(sorted(s, key=lambda c, freq=Counter(s): (-freq[c],c)))\\n```\\n\\n**O(n + 62 log 62) Algorithm**\\n(1) count the frequency of each charater.\\n(2) sort the frequency with the charater.\\n\\n**Time Complexity: O(n + 62 log 62)** The sorting part only sorts the 26 uppercase charaters + 26 lowercase charaters + 10 digits, but not ```s```.\\n```python\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # count the frequency of each charater in s\\n        freq = Counter(s)\\n        # create an array with frequency of each element, and the element itself \\n        arr = [(freq[c],c) for c in freq.keys()]\\n        # sort this array by frequency in decreasing order\\n        arr.sort(reverse=True)\\n        # return the element * frequency as an array\\n        return \\'\\'.join([x[1]*x[0] for x in arr])\\n```\\n\\n**Using bucket sort will bring the TC to O(n)**\\n```python\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        \\n        freq = Counter(s)\\n        maxFreq = max(freq.values())\\n        \\n        # Creating buckets with length of maximum freq+1\\n        # Note that maxFreq <= len(s)\\n        buckets = [[] for _ in range(maxFreq+1)]\\n        for c,f in freq.items():\\n            buckets[f].append(c)\\n        \\n        # Going through the buckets from large freq to small freq to create the result.\\n        res = []\\n        for f in reversed(range(maxFreq+1)):\\n            for c in buckets[f]:\\n                res.append(c * f)\\n                \\n        return \"\".join(res)\\n```\\n\\nBucket sort needs an anditional O(n) to create/fill out the buckets, and the one above it needs 62 log 62 to sort the keys, **so which one is better?**\\n<details>\\n<summary><strong>Click me to see the answer </strong></summary>\\n<img width=\"200\" src=\"https://user-images.githubusercontent.com/25648942/205431004-7098ed99-e5d6-4c74-8051-f9e9aacb5105.jpg\">\\n</details>\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \\'\\'.join(c*fre for c, fre in Counter(s).most_common())\\n```\n```Counter().most_common()```\n```s```\n```python\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \"\".join(sorted(s, key=lambda c, freq=Counter(s): (-freq[c],c)))\\n```\n```s```\n```python\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # count the frequency of each charater in s\\n        freq = Counter(s)\\n        # create an array with frequency of each element, and the element itself \\n        arr = [(freq[c],c) for c in freq.keys()]\\n        # sort this array by frequency in decreasing order\\n        arr.sort(reverse=True)\\n        # return the element * frequency as an array\\n        return \\'\\'.join([x[1]*x[0] for x in arr])\\n```\n```python\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        \\n        freq = Counter(s)\\n        maxFreq = max(freq.values())\\n        \\n        # Creating buckets with length of maximum freq+1\\n        # Note that maxFreq <= len(s)\\n        buckets = [[] for _ in range(maxFreq+1)]\\n        for c,f in freq.items():\\n            buckets[f].append(c)\\n        \\n        # Going through the buckets from large freq to small freq to create the result.\\n        res = []\\n        for f in reversed(range(maxFreq+1)):\\n            for c in buckets[f]:\\n                res.append(c * f)\\n                \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645057,
                "title": "python-3-today-s-one-liner",
                "content": "# Explanation\\n\\nWe just need to sort the characters by frequency. There\\'s a limited number of characters, so we can just bucket sort. Which means we can just use [Counter.most_common](https://docs.python.org/3/library/collections.html#collections.Counter.most_common) to do all the work for us -- ~~this is built-in bucket sort~~.\\nUpdate: `Counter.most_common` is implemented with regular sort instead of bucket sort, not sure why it doesn\\'t use bucket sort.\\n\\nAlso use the multiply operator on a string... `\\'x\\' * 5 == \\'xxxxx\\'`.\\n\\nTime: `O(n)`, one pass\\nSpace: `O(k)`, where `k` is the number of unique characters... worst case `O(n)`\\n\\n# One line\\n\\n```python\\nclass Solution:\\n  def frequencySort(self, s: str) -> str:\\n    return \\'\\'.join(c*x for x,c in Counter(s).most_common())\\n```\\n\\n# True one-liner\\n\\n```python\\nclass Solution: frequencySort = lambda _,s: \\'\\'.join(c*x for x,c in Counter(s).most_common())\\n```\\n\\n# Update\\n\\nWe can use [starmap](https://docs.python.org/3/library/itertools.html#itertools.starmap) and [mul](https://docs.python.org/3/library/operator.html#operator.mul) to make it even shorter!\\n\\n```python\\nclass Solution: frequencySort = lambda _,s: \\'\\'.join(starmap(mul, Counter(s).most_common()))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def frequencySort(self, s: str) -> str:\\n    return \\'\\'.join(c*x for x,c in Counter(s).most_common())\\n```\n```python\\nclass Solution: frequencySort = lambda _,s: \\'\\'.join(c*x for x,c in Counter(s).most_common())\\n```\n```python\\nclass Solution: frequencySort = lambda _,s: \\'\\'.join(starmap(mul, Counter(s).most_common()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93508,
                "title": "python-o-n-bucket-sort",
                "content": "```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        result = ''\\n        bucket = [None for i in range(len(s) + 1)]\\n        hash_map = {}\\n        \\n        for char in s:\\n            hash_map[char] = hash_map.get(char, 0) + 1\\n            \\n        for key, value in hash_map.items():\\n            if bucket[value] is None:\\n                bucket[value] = []\\n            \\n            bucket[value].append(key)\\n            \\n        for i in reversed(range(len(bucket))):\\n            if bucket[i] is not None:\\n                for char in bucket[i]:\\n                    result += char * i\\n                    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        result = ''\\n        bucket = [None for i in range(len(s) + 1)]\\n        hash_map = {}\\n        \\n        for char in s:\\n            hash_map[char] = hash_map.get(char, 0) + 1\\n            \\n        for key, value in hash_map.items():\\n            if bucket[value] is None:\\n                bucket[value] = []\\n            \\n            bucket[value].append(key)\\n            \\n        for i in reversed(range(len(bucket))):\\n            if bucket[i] is not None:\\n                for char in bucket[i]:\\n                    result += char * i\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93499,
                "title": "c-with-std-unordered-map-and-std-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> hist;\\n        for (auto c : s) {\\n            ++hist[c];\\n        }\\n        \\n        auto pred = [&hist] (char a, char b) {\\n            return hist[a] > hist[b] || (hist[a] == hist[b] && a > b);\\n        };\\n        \\n        sort(s.begin(), s.end(), pred);\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> hist;\\n        for (auto c : s) {\\n            ++hist[c];\\n        }\\n        \\n        auto pred = [&hist] (char a, char b) {\\n            return hist[a] > hist[b] || (hist[a] == hist[b] && a > b);\\n        };\\n        \\n        sort(s.begin(), s.end(), pred);\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93411,
                "title": "two-ways-of-python-solution-easy-to-understand",
                "content": "The basic idea is \\n1. Count the char;\\n2. Sort the counts of all chars;\\n3. Construct return String from the char with highest counts\\nAlthough it is really easy to use collections.Counter(Solution1), I still re-code it using normal operations(Solution2). Cos in most interviews, I guess you are supposed to write the code in the second way.\\nHappy coding!!! \\n\\nThis is a solution based on collections.Counter\\n```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        import collections\\n        if not s:\\n            return \"\"\\n        count_s = collections.Counter(s)\\n        counter = count_s.most_common()\\n        rs = ''\\n        for i in counter:\\n            rs += i[0] * i[1]\\n        return rs\\n```\\n\\nThis is a solution that doesn't use collections.Counter\\n```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        import operator\\n        if not s:\\n            return \"\"\\n        counter = {}; rs = ''\\n        for i in s:\\n            counter[i] = 1 if i not in counter else counter[i]+1\\n        sorted_counter = sorted(counter.items(), key=operator.itemgetter(1))\\n        sorted_counter.reverse()\\n        for i in sorted_counter:\\n            rs += i[0] * i[1]\\n        return rs\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        import collections\\n        if not s:\\n            return \"\"\\n        count_s = collections.Counter(s)\\n        counter = count_s.most_common()\\n        rs = ''\\n        for i in counter:\\n            rs += i[0] * i[1]\\n        return rs\\n```\n```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        import operator\\n        if not s:\\n            return \"\"\\n        counter = {}; rs = ''\\n        for i in s:\\n            counter[i] = 1 if i not in counter else counter[i]+1\\n        sorted_counter = sorted(counter.items(), key=operator.itemgetter(1))\\n        sorted_counter.reverse()\\n        for i in sorted_counter:\\n            rs += i[0] * i[1]\\n        return rs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871164,
                "title": "python-c-count-then-sort-or-construct-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs counting of character frequencies followed by either sorting the original string or constructing a new one. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** Character frequencies can be used in at least two ways:\\n1. As a comparator key for a sorting function.\\n2. As a length of each single-character chunk of the result.\\n\\nThis results in the following approaches to the problem.\\n\\n**Python #1.** One-liner. Counter + construction.\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \"\".join(c * ch for c, ch in Counter(s).most_common())\\n```\\n\\n**Python #2.** One-liner. Counter + sort. This is **O(N\\\\*logN)** time complexity and is not preferred.\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # the character itself is also used in the sorting key function\\n\\t\\t# to resolve cases with equal character frequencies\\n\\t\\treturn \"\".join(sorted(s, key=lambda c, cnt=Counter(s): (-cnt[c],c)))  \\n```\\n\\n**C++ #1.** Count then construct.\\n```\\nclass Solution \\n{\\npublic:\\n    string frequencySort(string s) \\n    {\\n        unordered_map<char,int> cnt;\\n        for (char c : s) ++cnt[c];                    // [1] counting character frequencies\\n        \\n        set<pair<int,char>> pq;                       // [2] set can be used as a priority queue to\\n        for (auto[ch,c] : cnt) pq.insert({-c, ch});   //     sort characters using their frequencies\\n        \\n        string ss = \"\";                               // [3] finally, we iterate over (sorted) elements of the\\n        for (auto[c,ch] : pq)                         //     set and construct chunks of resulting string by\\n            ss += string(-c, ch);                     //     repeating each character according to its count\\n        \\n        return ss;\\n    }\\n};\\n```\\n\\n**C++ #2.** Count + sort. A similarly slow solution as Python #2.\\n```\\nclass Solution \\n{\\npublic:\\n    string frequencySort(string s) \\n    {\\n        int cnt[128] = {0};\\n        for (char c : s) ++cnt[c];\\n        \\n        auto cmp = [&](char a, char b)\\n        {\\n            return cnt[a] > cnt[b] || (cnt[a] == cnt[b] && a < b); \\n        };\\n\\n        sort(s.begin(), s.end(), cmp);\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \"\".join(c * ch for c, ch in Counter(s).most_common())\\n```\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # the character itself is also used in the sorting key function\\n\\t\\t# to resolve cases with equal character frequencies\\n\\t\\treturn \"\".join(sorted(s, key=lambda c, cnt=Counter(s): (-cnt[c],c)))  \\n```\n```\\nclass Solution \\n{\\npublic:\\n    string frequencySort(string s) \\n    {\\n        unordered_map<char,int> cnt;\\n        for (char c : s) ++cnt[c];                    // [1] counting character frequencies\\n        \\n        set<pair<int,char>> pq;                       // [2] set can be used as a priority queue to\\n        for (auto[ch,c] : cnt) pq.insert({-c, ch});   //     sort characters using their frequencies\\n        \\n        string ss = \"\";                               // [3] finally, we iterate over (sorted) elements of the\\n        for (auto[c,ch] : pq)                         //     set and construct chunks of resulting string by\\n            ss += string(-c, ch);                     //     repeating each character according to its count\\n        \\n        return ss;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string frequencySort(string s) \\n    {\\n        int cnt[128] = {0};\\n        for (char c : s) ++cnt[c];\\n        \\n        auto cmp = [&](char a, char b)\\n        {\\n            return cnt[a] > cnt[b] || (cnt[a] == cnt[b] && a < b); \\n        };\\n\\n        sort(s.begin(), s.end(), cmp);\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544705,
                "title": "c-simple-code-easy-to-understand-lesser-than-10ms",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<char,int>&a,pair<char,int>&b){\\n        return a.second>b.second;\\n    }\\n    string frequencySort(string s) {\\n        map<char,int>mp;\\n        for(char ch:s)  mp[ch]++;\\n        vector<pair<char,int>>res;\\n        for(auto it:mp) res.push_back(it);\\n        sort(res.begin(),res.end(),cmp);\\n        string out=\"\";\\n        for(auto it:res){\\n            int tmp = it.second;\\n            while(tmp--){\\n                out+=it.first;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it. Happy Coding!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<char,int>&a,pair<char,int>&b){\\n        return a.second>b.second;\\n    }\\n    string frequencySort(string s) {\\n        map<char,int>mp;\\n        for(char ch:s)  mp[ch]++;\\n        vector<pair<char,int>>res;\\n        for(auto it:mp) res.push_back(it);\\n        sort(res.begin(),res.end(),cmp);\\n        string out=\"\";\\n        for(auto it:res){\\n            int tmp = it.second;\\n            while(tmp--){\\n                out+=it.first;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646558,
                "title": "java-easy-to-read-heap-solution",
                "content": "\\n```\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap();        \\n        for (char c : s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }      \\n        \\n        PriorityQueue <Character> pq = new PriorityQueue((a,b) -> map.get(b) - map.get(a));\\n        for (char c : map.keySet()) {\\n            pq.offer(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();       \\n        while (!pq.isEmpty()) {\\n            char c = pq.poll();\\n            for (int i = 0; i < map.get(c); i++) {\\n                sb.append(c);\\n            }\\n        }       \\n        return sb.toString();\\n    }   \\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap();        \\n        for (char c : s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }      \\n        \\n        PriorityQueue <Character> pq = new PriorityQueue((a,b) -> map.get(b) - map.get(a));\\n        for (char c : map.keySet()) {\\n            pq.offer(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();       \\n        while (!pq.isEmpty()) {\\n            char c = pq.poll();\\n            for (int i = 0; i < map.get(c); i++) {\\n                sb.append(c);\\n            }\\n        }       \\n        return sb.toString();\\n    }   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93521,
                "title": "super-simple-o-n-bucket-sort-based-java-solution-11-ms-no-fancy-data-structure-needed-beats-96",
                "content": "Could not find a simpler way to do this. I see people are using HashMap/TreeMap which are not at all required. If you know bucket sort then following solution will be easy to understand!\\n\\n```\\npublic String frequencySort(String s) {\\n        if(s.length() < 3)\\n            return s;\\n        int max = 0;\\n        int[] map = new int[256];\\n        for(char ch : s.toCharArray()) {\\n            map[ch]++;\\n            max = Math.max(max,map[ch]);\\n        }\\n        String[] buckets = new String[max + 1]; // create max buckets\\n        for(int i = 0 ; i < 256; i++) { // join chars in the same bucket\\n            String str = buckets[map[i]];\\n            if(map[i] > 0)\\n                buckets[map[i]] = (str == null) ? \"\" + (char)i : (str + (char) i);\\n        }\\n        StringBuilder strb = new StringBuilder();\\n        for(int i = max; i >= 0; i--) { // create string for each bucket.\\n            if(buckets[i] != null)\\n                for(char ch : buckets[i].toCharArray())\\n                    for(int j = 0; j < i; j++)\\n                        strb.append(ch);\\n        }\\n        return strb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String frequencySort(String s) {\\n        if(s.length() < 3)\\n            return s;\\n        int max = 0;\\n        int[] map = new int[256];\\n        for(char ch : s.toCharArray()) {\\n            map[ch]++;\\n            max = Math.max(max,map[ch]);\\n        }\\n        String[] buckets = new String[max + 1]; // create max buckets\\n        for(int i = 0 ; i < 256; i++) { // join chars in the same bucket\\n            String str = buckets[map[i]];\\n            if(map[i] > 0)\\n                buckets[map[i]] = (str == null) ? \"\" + (char)i : (str + (char) i);\\n        }\\n        StringBuilder strb = new StringBuilder();\\n        for(int i = max; i >= 0; i--) { // create string for each bucket.\\n            if(buckets[i] != null)\\n                for(char ch : buckets[i].toCharArray())\\n                    for(int j = 0; j < i; j++)\\n                        strb.append(ch);\\n        }\\n        return strb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2871950,
                "title": "c-priority-queue-map-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) \\n    {\\n        // declare map for storing the frequency of each char in string\\n        map<char,int> mp;\\n        for(auto it : s)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        // declare a max heap for sorting the map values based on frequency\\n        priority_queue<pair<int,char>> pq;\\n        for(auto it : mp)\\n        {\\n            pq.push({it.second,it.first});\\n        }\\n        \\n        \\n        // start storing the chars in ans frequency wise\\n        string ans = \"\";\\n        while(!pq.empty())\\n        {\\n            int freq = pq.top().first;                // frequency count\\n            char ch = pq.top().second;             // current char\\n            pq.pop();                              // pop out the element\\n            \\n            // store the curr char (freq * 1 times)\\n            for(int i=0;i<freq;i++)\\n            {\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) \\n    {\\n        // declare map for storing the frequency of each char in string\\n        map<char,int> mp;\\n        for(auto it : s)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        // declare a max heap for sorting the map values based on frequency\\n        priority_queue<pair<int,char>> pq;\\n        for(auto it : mp)\\n        {\\n            pq.push({it.second,it.first});\\n        }\\n        \\n        \\n        // start storing the chars in ans frequency wise\\n        string ans = \"\";\\n        while(!pq.empty())\\n        {\\n            int freq = pq.top().first;                // frequency count\\n            char ch = pq.top().second;             // current char\\n            pq.pop();                              // pop out the element\\n            \\n            // store the curr char (freq * 1 times)\\n            for(int i=0;i<freq;i++)\\n            {\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534065,
                "title": "java-3-solutions-brute-better-optimal",
                "content": "Method - 1 (Brute Force) Just sort the string on the basis of frequency of characters\\n\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        int map[] = new int[256];\\n        int len = s.length();\\n        Character str[] = new Character[len];\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            str[idx] = ch;\\n            map[ch]++;\\n        }\\n        \\n        Arrays.sort(str,(charA,charB)->\\n                    (map[charA]==map[charB])?             \\n                    Integer.compare(charA,charB):Integer.compare(map[charB],map[charA]));\\n        \\n        StringBuilder ansStr = new StringBuilder();\\n        for(int idx = 0;idx<len;idx++){\\n            ansStr.append(str[idx]);\\n        }\\n        \\n        return ansStr.toString();\\n    }\\n}\\n```\\nTC : O(nlogn)\\nSC : O(sort)\\nwhere n is the size of string and sort is the space required for sorting , I have considered that instead of string we will be given Character array as input , so the space for that is not considered\\n\\nMethod - 2 (Better) Use a maxheap where you use the frequency of characters as the criteria to pull out elements\\n\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        int len = s.length();\\n        HashMap<Character,Integer> freqMap = new HashMap();\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            freqMap.put(ch,freqMap.getOrDefault(ch,0)+1);\\n        }\\n        \\n        PriorityQueue<Character> maxHeap;\\n        maxHeap = new PriorityQueue<Character>((charA,charB)->        \\n                  Integer.compare(freqMap.get(charB),freqMap.get(charA)));\\n        \\n        for(char ch : freqMap.keySet()){\\n            maxHeap.add(ch);\\n        }\\n        \\n        StringBuilder ansStr = new StringBuilder();\\n        \\n        while(maxHeap.size()>0){\\n            char ch = maxHeap.remove();\\n            int freq = freqMap.get(ch);\\n            while(freq>0){\\n                ansStr.append(ch);\\n                freq--;\\n            }\\n        }\\n        \\n        return ansStr.toString();\\n    }\\n}\\n```\\nTC : O(n + mlogm) where m is the number of distinct characters in the input (can be treated as constant) and n is the length of input string\\nSC : O(m)\\n\\nMethod - 3 (Optimal) Use idea similar to Bucket sort\\n\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        int len = s.length();\\n        HashMap<Integer,HashSet<Character>> map = new HashMap();       \\n        HashMap<Character,Integer> freqMap = new HashMap();\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            freqMap.put(ch,freqMap.getOrDefault(ch,0)+1);\\n        }\\n        \\n        int maxFreq = 0 , minFreq = s.length();\\n        \\n        for(char ch : freqMap.keySet()){\\n            HashSet<Character> set = map.getOrDefault(freqMap.get(ch),new HashSet());\\n            set.add(ch);\\n            map.put(freqMap.get(ch),set);\\n            maxFreq = Math.max(maxFreq , freqMap.get(ch));\\n            minFreq = Math.min(minFreq,freqMap.get(ch));\\n        }\\n        \\n        StringBuilder ansStr = new StringBuilder();\\n        \\n        for(int freq = maxFreq;freq>=minFreq;freq--){\\n            if(map.containsKey(freq)){\\n                HashSet<Character> set = map.get(freq);\\n                for(char ch : set){\\n                    int temp = freq;\\n                    while(temp>0){\\n                        ansStr.append(ch);\\n                        temp--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ansStr.toString();\\n    }\\n}\\n```\\nTC : O(n)\\nSC : O(n)\\nwhere n is the length of string \\n\\nHappy Coding!",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        int map[] = new int[256];\\n        int len = s.length();\\n        Character str[] = new Character[len];\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            str[idx] = ch;\\n            map[ch]++;\\n        }\\n        \\n        Arrays.sort(str,(charA,charB)->\\n                    (map[charA]==map[charB])?             \\n                    Integer.compare(charA,charB):Integer.compare(map[charB],map[charA]));\\n        \\n        StringBuilder ansStr = new StringBuilder();\\n        for(int idx = 0;idx<len;idx++){\\n            ansStr.append(str[idx]);\\n        }\\n        \\n        return ansStr.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        int len = s.length();\\n        HashMap<Character,Integer> freqMap = new HashMap();\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            freqMap.put(ch,freqMap.getOrDefault(ch,0)+1);\\n        }\\n        \\n        PriorityQueue<Character> maxHeap;\\n        maxHeap = new PriorityQueue<Character>((charA,charB)->        \\n                  Integer.compare(freqMap.get(charB),freqMap.get(charA)));\\n        \\n        for(char ch : freqMap.keySet()){\\n            maxHeap.add(ch);\\n        }\\n        \\n        StringBuilder ansStr = new StringBuilder();\\n        \\n        while(maxHeap.size()>0){\\n            char ch = maxHeap.remove();\\n            int freq = freqMap.get(ch);\\n            while(freq>0){\\n                ansStr.append(ch);\\n                freq--;\\n            }\\n        }\\n        \\n        return ansStr.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        int len = s.length();\\n        HashMap<Integer,HashSet<Character>> map = new HashMap();       \\n        HashMap<Character,Integer> freqMap = new HashMap();\\n        \\n        for(int idx = 0;idx<len;idx++){\\n            char ch = s.charAt(idx);\\n            freqMap.put(ch,freqMap.getOrDefault(ch,0)+1);\\n        }\\n        \\n        int maxFreq = 0 , minFreq = s.length();\\n        \\n        for(char ch : freqMap.keySet()){\\n            HashSet<Character> set = map.getOrDefault(freqMap.get(ch),new HashSet());\\n            set.add(ch);\\n            map.put(freqMap.get(ch),set);\\n            maxFreq = Math.max(maxFreq , freqMap.get(ch));\\n            minFreq = Math.min(minFreq,freqMap.get(ch));\\n        }\\n        \\n        StringBuilder ansStr = new StringBuilder();\\n        \\n        for(int freq = maxFreq;freq>=minFreq;freq--){\\n            if(map.containsKey(freq)){\\n                HashSet<Character> set = map.get(freq);\\n                for(char ch : set){\\n                    int temp = freq;\\n                    while(temp>0){\\n                        ansStr.append(ch);\\n                        temp--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ansStr.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93430,
                "title": "java-solution-with-heap-o-nlgn",
                "content": "```\\npublic String frequencySort(String str) {\\n        if (str == null || str.length() <= 2) return str;\\n        Map<Character, Integer> map = new HashMap<>();\\n        char[] list = str.toCharArray();\\n        for (char c : list) {\\n            map.putIfAbsent(c, 0);\\n            map.put(c, map.get(c) + 1);\\n        }\\n        \\n        PriorityQueue<Character> heap = new PriorityQueue<>(str.length(), new Comparator<Character>() {\\n            public int compare(Character c1, Character c2) {\\n                return map.get(c2) - map.get(c1);\\n            }\\n        });\\n        \\n        for (char c : map.keySet()) {\\n            heap.offer(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!heap.isEmpty()) {\\n            char c = heap.poll();\\n            int count = map.get(c);\\n            for (int i = 0; i < count; ++i) sb.append(c);\\n        }\\n        return sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String frequencySort(String str) {\\n        if (str == null || str.length() <= 2) return str;\\n        Map<Character, Integer> map = new HashMap<>();\\n        char[] list = str.toCharArray();\\n        for (char c : list) {\\n            map.putIfAbsent(c, 0);\\n            map.put(c, map.get(c) + 1);\\n        }\\n        \\n        PriorityQueue<Character> heap = new PriorityQueue<>(str.length(), new Comparator<Character>() {\\n            public int compare(Character c1, Character c2) {\\n                return map.get(c2) - map.get(c1);\\n            }\\n        });\\n        \\n        for (char c : map.keySet()) {\\n            heap.offer(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!heap.isEmpty()) {\\n            char c = heap.poll();\\n            int count = map.get(c);\\n            for (int i = 0; i < count; ++i) sb.append(c);\\n        }\\n        return sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910146,
                "title": "python-3-89-28-faster-used-counter-sorted",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\n```\\ndef frequencySort(self, s: str) -> str:\\n\\tsCounter = Counter(s)\\n\\tresult = []\\n\\tfor key, value in sorted(sCounter.items(), key=lambda x:x[1], reverse=True):\\n\\t\\tresult.append(key*value)\\n\\treturn \\'\\'.join(result)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef frequencySort(self, s: str) -> str:\\n\\tsCounter = Counter(s)\\n\\tresult = []\\n\\tfor key, value in sorted(sCounter.items(), key=lambda x:x[1], reverse=True):\\n\\t\\tresult.append(key*value)\\n\\treturn \\'\\'.join(result)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 645719,
                "title": "c-easy-to-understand-using-unordered-map",
                "content": "This might not be the best answer but sure is easy to understand.\\nAnd it works!\\n\\n**Approach:**\\nI can have a map(unordered), that stores character and it\\'s corresponding count.\\nstore the count of each occuring character by traversing through the string once.\\nNow as the question says, we need characters in decreasing order of frequency.\\n\\nSo next we need to sort the map on the basis of their value.\\nNow we know we can\\'t do that directly, so we copy the map contents in vector, and then sort it in the required way.\\n\\nWe then form an output string `ans`  made from the counted characters.\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n//comaprision function to pass to sort()\\n    static bool cmp(pair<char,int>&a, pair<char,int>&b)\\n    {\\n        return a.second > b.second;\\n    }\\n    \\n    string frequencySort(string s) {\\n\\t\\n        if(s.length()==0 || s.length()==1 || s.length()==2) return s;\\n        \\n\\t\\tstring ans=\"\";\\n\\t\\tunordered_map<char,int>m;\\n\\t\\t\\n\\t\\tvector<pair<char,int>>vm;\\n        \\n        for(char c: s)\\n        {\\n            // if(c != \\' \\')\\n                m[c]++;\\n        }\\n        \\n        for(auto it : m)\\n            vm.push_back(make_pair(it.first,it.second));\\n        \\n        sort(vm.begin(),vm.end(), cmp);\\n        \\n        for(auto& i : vm)\\n        {\\n            while(i.second > 0)\\n            {\\n                ans+= i.first;\\n                --i.second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//comaprision function to pass to sort()\\n    static bool cmp(pair<char,int>&a, pair<char,int>&b)\\n    {\\n        return a.second > b.second;\\n    }\\n    \\n    string frequencySort(string s) {\\n\\t\\n        if(s.length()==0 || s.length()==1 || s.length()==2) return s;\\n        \\n\\t\\tstring ans=\"\";\\n\\t\\tunordered_map<char,int>m;\\n\\t\\t\\n\\t\\tvector<pair<char,int>>vm;\\n        \\n        for(char c: s)\\n        {\\n            // if(c != \\' \\')\\n                m[c]++;\\n        }\\n        \\n        for(auto it : m)\\n            vm.push_back(make_pair(it.first,it.second));\\n        \\n        sort(vm.begin(),vm.end(), cmp);\\n        \\n        for(auto& i : vm)\\n        {\\n            while(i.second > 0)\\n            {\\n                ans+= i.first;\\n                --i.second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871565,
                "title": "java-simple-solutions-with-comments-using-priorityqueue-hashmap-and-pair-class",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        // PriorityQueue for sorting elements on decresing order based on frequency\\n        // b.val - a.val => store pair objects based on decresong order of frequency value \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> b.val-a.val);\\n        // HashMap to store elements and their current frequency\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        char []c = s.toCharArray();\\n        for(int i=0;i<c.length;i++) {\\n            int count = hm.getOrDefault(c[i],0);\\n            //add element and current frequency in hashmap\\n            hm.put(c[i],count+1);\\n        }\\n        //add whole hashmap to priorityQueue\\n        for(Map.Entry<Character,Integer> entry: hm.entrySet()) {\\n            Pair pair = new Pair(entry.getKey(),entry.getValue());\\n            pq.add(pair);\\n        }\\n        StringBuilder sb = new StringBuilder(\"\");\\n        //extract value from priorityQueue and add it into answer string\\n        while(!pq.isEmpty()) {\\n            Pair pair = pq.remove();\\n            int count = pair.val;\\n            char ch = pair.c;\\n            // add character into answer string as many time as frequency (it appears in main string)\\n            while(count--> 0) {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    // create class to store character and their respective frequency\\n    public class Pair {\\n        int val;\\n        char c;\\n        public Pair(char c,int val) {\\n            this.c = c;\\n            this.val = val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        // PriorityQueue for sorting elements on decresing order based on frequency\\n        // b.val - a.val => store pair objects based on decresong order of frequency value \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b) -> b.val-a.val);\\n        // HashMap to store elements and their current frequency\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        char []c = s.toCharArray();\\n        for(int i=0;i<c.length;i++) {\\n            int count = hm.getOrDefault(c[i],0);\\n            //add element and current frequency in hashmap\\n            hm.put(c[i],count+1);\\n        }\\n        //add whole hashmap to priorityQueue\\n        for(Map.Entry<Character,Integer> entry: hm.entrySet()) {\\n            Pair pair = new Pair(entry.getKey(),entry.getValue());\\n            pq.add(pair);\\n        }\\n        StringBuilder sb = new StringBuilder(\"\");\\n        //extract value from priorityQueue and add it into answer string\\n        while(!pq.isEmpty()) {\\n            Pair pair = pq.remove();\\n            int count = pair.val;\\n            char ch = pair.c;\\n            // add character into answer string as many time as frequency (it appears in main string)\\n            while(count--> 0) {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    // create class to store character and their respective frequency\\n    public class Pair {\\n        int val;\\n        char c;\\n        public Pair(char c,int val) {\\n            this.c = c;\\n            this.val = val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871283,
                "title": "java-runtime-1ms-faster-than-93-51-memory-usage-less-than-97-88",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        if (s.length() < 3) return s;\\n\\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) map.merge(c, 1, Integer::sum);\\n\\n        map.entrySet().stream()\\n                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\\n                .forEach(entry -> {\\n                    for (int i = 0; i < entry.getValue(); i++) {\\n                        sb.append(entry.getKey());\\n                    }\\n                });\\n\\t\\t\\t\\t\\n        return sb.toString();\\n    }\\n}\\n```\\n====================\\nNested loop can be replaced with String.repeat():\\n```\\nclass Solution {\\n        public String frequencySort(String s) {\\n        if (s.length() < 3) return s;\\n\\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) map.merge(c, 1, Integer::sum);\\n\\n        map.entrySet().stream()\\n                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\\n                .forEach(entry -> sb.append(String.valueOf(entry.getKey()).repeat(entry.getValue())));\\n            \\n        return sb.toString();\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2fbaa3e1-e576-4b80-b748-0e389c16bcad_1670031801.092587.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        if (s.length() < 3) return s;\\n\\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) map.merge(c, 1, Integer::sum);\\n\\n        map.entrySet().stream()\\n                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\\n                .forEach(entry -> {\\n                    for (int i = 0; i < entry.getValue(); i++) {\\n                        sb.append(entry.getKey());\\n                    }\\n                });\\n\\t\\t\\t\\t\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n        public String frequencySort(String s) {\\n        if (s.length() < 3) return s;\\n\\n        StringBuilder sb = new StringBuilder();\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char c : s.toCharArray()) map.merge(c, 1, Integer::sum);\\n\\n        map.entrySet().stream()\\n                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\\n                .forEach(entry -> sb.append(String.valueOf(entry.getKey()).repeat(entry.getValue())));\\n            \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871250,
                "title": "python-3-1-6-lines-w-example-t-m-97-81",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:     #   Example:   s = \"bAaCbb\"\\n\\n        ctr = Counter(s)                        #       ctr = {\\'b\\':3, \\'A\\':1, \\'a\\':1, \\'C\\':1}\\n\\n        d   = list(ctr.items())                 #         d = [(\\'b\\',3), (\\'C\\',1), (\\'a\\',1), (\\'A\\',1)]\\n\\n        d.sort(key = lambda x: (-x[1], x[0]))   #         d = [(\\'b\\',3), (\\'A\\',1), (\\'C\\',1), (\\'a\\',1)]\\n\\n        words = [ch*n for ch, n in d]           #     words = [\\'bbb\\', \\'A\\', \\'C\\', \\'a\\']\\n\\n        ans = \\'\\'.join(words)                    #       ans = \\'bbbACa\\'\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/853659626/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*) .\\n```\\n```\\nHere\\'s the one-liner:\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n\\n        return \\'\\'.join([ch*ct for ch, ct in sorted(Counter(s).items(), key = lambda x: (-x[1], x[0]))])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:     #   Example:   s = \"bAaCbb\"\\n\\n        ctr = Counter(s)                        #       ctr = {\\'b\\':3, \\'A\\':1, \\'a\\':1, \\'C\\':1}\\n\\n        d   = list(ctr.items())                 #         d = [(\\'b\\',3), (\\'C\\',1), (\\'a\\',1), (\\'A\\',1)]\\n\\n        d.sort(key = lambda x: (-x[1], x[0]))   #         d = [(\\'b\\',3), (\\'A\\',1), (\\'C\\',1), (\\'a\\',1)]\\n\\n        words = [ch*n for ch, n in d]           #     words = [\\'bbb\\', \\'A\\', \\'C\\', \\'a\\']\\n\\n        ans = \\'\\'.join(words)                    #       ans = \\'bbbACa\\'\\n\\n        return ans\\n```\n```\\n```\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n\\n        return \\'\\'.join([ch*ct for ch, ct in sorted(Counter(s).items(), key = lambda x: (-x[1], x[0]))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93504,
                "title": "11-lines-straightforward-java-solution",
                "content": "Use a HashMap to store each character's frequency, then sort it based on its value, then concatenate them together and return.\\nTime: O(nlogn)\\nSpace: O(n)\\n\\n```\\npublic String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap();\\n        for (char c : s.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);\\n        List<Map.Entry<Character, Integer>> list = new ArrayList<>(map.entrySet());\\n        Collections.sort(list, (o1, o2) -> (o2.getValue()).compareTo(o1.getValue()));\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (Map.Entry<Character, Integer> entry : list) {\\n            for (int i = 0; i < entry.getValue(); i++) {\\n                stringBuilder.append(entry.getKey());\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap();\\n        for (char c : s.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);\\n        List<Map.Entry<Character, Integer>> list = new ArrayList<>(map.entrySet());\\n        Collections.sort(list, (o1, o2) -> (o2.getValue()).compareTo(o1.getValue()));\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (Map.Entry<Character, Integer> entry : list) {\\n            for (int i = 0; i < entry.getValue(); i++) {\\n                stringBuilder.append(entry.getKey());\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534452,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return reduce(lambda a, b: a + b[1]*b[0], Counter(s).most_common(), \\'\\')",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return reduce(lambda a, b: a + b[1]*b[0], Counter(s).most_common(), \\'\\')",
                "codeTag": "Java"
            },
            {
                "id": 934339,
                "title": "java-o-n-solution-using-a-frequency-list-and-frequency-map-easy-to-understand",
                "content": "Runtime: 6 ms, faster than 94.44% of Java online submissions for Sort Characters By Frequency.\\n\\nThe idea is to count each character\\'s frequency in a fmap. Then create a frequency list to keep track of characters that occur for that each frequency. For example if \\'a\\' occurs 5 times in the string, then the list at freq[5] would contain character \\'a\\' in it. \\nThen just iterate the freqlist array from the end and store our answer accordingly. \\nTime complexity: O(n)\\nSpace Complexity: O(n)\\nWhere n is the length of the string.\\n```\\npublic String frequencySort(String s) {\\n        List<Character>[] freq = new List[s.length()+1];\\n        for(int i=0;i<=s.length();i++){\\n            freq[i] = new ArrayList<Character>();\\n        }\\n        int[] fmap = new int[256];\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            fmap[ch]++;\\n        }\\n        for(int i=0;i<256;i++){\\n            if(fmap[i]>0){\\n                freq[fmap[i]].add((char)(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=freq.length-1;i>=1;i--){\\n            if(freq[i].size()>0){\\n                for(char ch:freq[i]){\\n                    for(int j=0;j<i;j++){\\n                        sb.append(ch);\\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(Arrays.toString(fmap)+\"|| \"+ Arrays.toString(freq));\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String frequencySort(String s) {\\n        List<Character>[] freq = new List[s.length()+1];\\n        for(int i=0;i<=s.length();i++){\\n            freq[i] = new ArrayList<Character>();\\n        }\\n        int[] fmap = new int[256];\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            fmap[ch]++;\\n        }\\n        for(int i=0;i<256;i++){\\n            if(fmap[i]>0){\\n                freq[fmap[i]].add((char)(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=freq.length-1;i>=1;i--){\\n            if(freq[i].size()>0){\\n                for(char ch:freq[i]){\\n                    for(int j=0;j<i;j++){\\n                        sb.append(ch);\\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(Arrays.toString(fmap)+\"|| \"+ Arrays.toString(freq));\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93413,
                "title": "c-o-nlogn-hash-table-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string res = \"\";\\n        unordered_map<char, int>m;\\n        for(auto c: s) m[c]++;\\n        auto comp = [](pair<int, char>& a, pair<int, char>& b){ return a.first < b.first; };\\n        priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)>pq(comp);\\n        for(auto x: m) pq.push({x.second, x.first});\\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            pq.pop();\\n            while(p.first--) res += p.second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string res = \"\";\\n        unordered_map<char, int>m;\\n        for(auto c: s) m[c]++;\\n        auto comp = [](pair<int, char>& a, pair<int, char>& b){ return a.first < b.first; };\\n        priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)>pq(comp);\\n        for(auto x: m) pq.push({x.second, x.first});\\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            pq.pop();\\n            while(p.first--) res += p.second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202468,
                "title": "best-c-2-solution-bucket-sort-heap-priority-queue-hash-table-one-stop-solution",
                "content": "We can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using String + Hash Table + Heap (Priority Queue).\\n2. Solved using String + Bucket Sort + Counting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN), Here we are inserting the characters into a unordered_map(map). It will take O(N)\\n    time where N is the length of the string. Then we sort the list of characters using priority_queue\\n    (pendingNodes) on the basis of frequency after that on the basis of their ASCII value. It will take O(NlogN)\\n    time. So the overall time complexity is O(NlogN).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) because we are using unordered_map\\n    (map) and priority_queue(pendingNodes) which creates the space complexity.\\n\\n    Solved using String + Hash Table + Heap (Priority Queue).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> map;\\n        for(auto c : s){\\n            map[c]++;\\n        }\\n        priority_queue<pair<int, char>> pendingNodes;\\n        for(auto [c, freq] : map){\\n            pendingNodes.push({freq, c});\\n        }\\n        string ans;\\n        while(!pendingNodes.empty()){\\n            auto curr = pendingNodes.top();\\n            pendingNodes.pop();\\n            ans += string(curr.first, curr.second);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here we are inserting the characters into a unordered_map(map). It will take O(N)\\n    time where N is the length of the string. then we are appending all the element of unordered_map(map) in\\n    vector(bucket) which also takes O(N) then finally we traverse the string and store the answer in string(ans).\\n    So the overall time complexity is O(N).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) because we are using unordered_map\\n    (map) and vector(bucket) which creates the space complexity.\\n\\n    Solved using String + Bucket Sort + Counting.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> map;\\n        for(auto c : s){\\n            map[c]++;\\n        }\\n        vector<string> bucket(s.size()+1, \"\");\\n        for(auto [c, freq] : map){\\n            bucket[freq].append(freq, c);\\n        }\\n        string ans;\\n        for(int i=s.size(); i>=1; i--){\\n            if(!bucket[i].empty()){\\n                ans.append(bucket[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)",
                    "Bucket Sort"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN), Here we are inserting the characters into a unordered_map(map). It will take O(N)\\n    time where N is the length of the string. Then we sort the list of characters using priority_queue\\n    (pendingNodes) on the basis of frequency after that on the basis of their ASCII value. It will take O(NlogN)\\n    time. So the overall time complexity is O(NlogN).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) because we are using unordered_map\\n    (map) and priority_queue(pendingNodes) which creates the space complexity.\\n\\n    Solved using String + Hash Table + Heap (Priority Queue).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> map;\\n        for(auto c : s){\\n            map[c]++;\\n        }\\n        priority_queue<pair<int, char>> pendingNodes;\\n        for(auto [c, freq] : map){\\n            pendingNodes.push({freq, c});\\n        }\\n        string ans;\\n        while(!pendingNodes.empty()){\\n            auto curr = pendingNodes.top();\\n            pendingNodes.pop();\\n            ans += string(curr.first, curr.second);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here we are inserting the characters into a unordered_map(map). It will take O(N)\\n    time where N is the length of the string. then we are appending all the element of unordered_map(map) in\\n    vector(bucket) which also takes O(N) then finally we traverse the string and store the answer in string(ans).\\n    So the overall time complexity is O(N).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) because we are using unordered_map\\n    (map) and vector(bucket) which creates the space complexity.\\n\\n    Solved using String + Bucket Sort + Counting.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> map;\\n        for(auto c : s){\\n            map[c]++;\\n        }\\n        vector<string> bucket(s.size()+1, \"\");\\n        for(auto [c, freq] : map){\\n            bucket[freq].append(freq, c);\\n        }\\n        string ans;\\n        for(int i=s.size(); i>=1; i--){\\n            if(!bucket[i].empty()){\\n                ans.append(bucket[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900321,
                "title": "stl-92-87-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n       unordered_map<char,int> m;\\n        \\n        for(auto i:s)++m[i];\\n        \\n        s=\"\";\\n        \\n        vector<pair<int,char>> v;\\n        \\n        for(auto i:m)v.push_back({i.second,i.first});\\n        \\n        sort(v.begin(),v.end(),greater<pair<int,char>>());\\n        \\n        for(auto i:v)s+=string(i.first,i.second);\\n        \\n        return s;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n       unordered_map<char,int> m;\\n        \\n        for(auto i:s)++m[i];\\n        \\n        s=\"\";\\n        \\n        vector<pair<int,char>> v;\\n        \\n        for(auto i:m)v.push_back({i.second,i.first});\\n        \\n        sort(v.begin(),v.end(),greater<pair<int,char>>());\\n        \\n        for(auto i:v)s+=string(i.first,i.second);\\n        \\n        return s;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706106,
                "title": "golang-simple-100",
                "content": "```\\npackage main\\n\\nimport \"sort\"\\n\\nfunc frequencySort(s string) string {\\n\\tfreq := make([]int, 255)\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tfreq[s[i]]++\\n\\t}\\n\\tb := []byte(s)\\n\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\tif freq[b[i]] == freq[b[j]] {\\n\\t\\t\\treturn b[i] > b[j]\\n\\t\\t}\\n\\t\\treturn freq[b[i]] > freq[b[j]]\\n\\t})\\n\\treturn string(b)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport \"sort\"\\n\\nfunc frequencySort(s string) string {\\n\\tfreq := make([]int, 255)\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tfreq[s[i]]++\\n\\t}\\n\\tb := []byte(s)\\n\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\tif freq[b[i]] == freq[b[j]] {\\n\\t\\t\\treturn b[i] > b[j]\\n\\t\\t}\\n\\t\\treturn freq[b[i]] > freq[b[j]]\\n\\t})\\n\\treturn string(b)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 548913,
                "title": "javascript-solution-with-comments",
                "content": "```\\nvar frequencySort = function(s) {\\n    let seen ={}; \\n    for(let char of s){ // store characters Frequency of given string in map\\n        seen[char] ? seen[char]++ : seen[char]=1;\\n    }\\n    \\n    // sort characters according to characters Frequency in descending order\\n    let SortedCharactersArray = Object.keys(seen).sort((a,b)=>seen[b]-seen[a]);\\n    \\n    let result = \"\"\\n    // iterate through SortedCharactersArray and append character( character frequency )times to result  \\n    for(let char of SortedCharactersArray)\\n        result += char.repeat(seen[char]);\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar frequencySort = function(s) {\\n    let seen ={}; \\n    for(let char of s){ // store characters Frequency of given string in map\\n        seen[char] ? seen[char]++ : seen[char]=1;\\n    }\\n    \\n    // sort characters according to characters Frequency in descending order\\n    let SortedCharactersArray = Object.keys(seen).sort((a,b)=>seen[b]-seen[a]);\\n    \\n    let result = \"\"\\n    // iterate through SortedCharactersArray and append character( character frequency )times to result  \\n    for(let char of SortedCharactersArray)\\n        result += char.repeat(seen[char]);\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93535,
                "title": "java-o-n-bucket-sort-hashmap",
                "content": "    public String frequencySort(String s) {\\n        char[] arr = s.toCharArray();\\n        \\n        // bucket sort\\n        int[] count = new int[256];\\n        for(char c : arr) count[c]++;\\n        \\n        // count values and their corresponding letters\\n        Map<Integer, List<Character>> map = new HashMap<>();\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] == 0) continue;\\n            int cnt = count[i];\\n            if(!map.containsKey(cnt)){\\n                map.put(cnt, new ArrayList<Character>());\\n            }\\n            map.get(cnt).add((char)i);\\n        }\\n   \\n        // loop throught possible count values\\n        StringBuilder sb = new StringBuilder();\\n        for(int cnt = arr.length; cnt > 0; cnt--){ \\n            if(!map.containsKey(cnt)) continue;\\n            List<Character> list = map.get(cnt);\\n            for(Character c: list){\\n                for(int i = 0; i < cnt; i++){\\n                    sb.append(c);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n------------\\nEdit:\\nThis method has an assumption that there are 256 or less possible numbers of characters (which should not always be true). If the question requires the entire set of unicode, this method is not efficient enough.",
                "solutionTags": [],
                "code": "    public String frequencySort(String s) {\\n        char[] arr = s.toCharArray();\\n        \\n        // bucket sort\\n        int[] count = new int[256];\\n        for(char c : arr) count[c]++;\\n        \\n        // count values and their corresponding letters\\n        Map<Integer, List<Character>> map = new HashMap<>();\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] == 0) continue;\\n            int cnt = count[i];\\n            if(!map.containsKey(cnt)){\\n                map.put(cnt, new ArrayList<Character>());\\n            }\\n            map.get(cnt).add((char)i);\\n        }\\n   \\n        // loop throught possible count values\\n        StringBuilder sb = new StringBuilder();\\n        for(int cnt = arr.length; cnt > 0; cnt--){ \\n            if(!map.containsKey(cnt)) continue;\\n            List<Character> list = map.get(cnt);\\n            for(Character c: list){\\n                for(int i = 0; i < cnt; i++){\\n                    sb.append(c);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n------------\\nEdit:\\nThis method has an assumption that there are 256 or less possible numbers of characters (which should not always be true). If the question requires the entire set of unicode, this method is not efficient enough.",
                "codeTag": "Unknown"
            },
            {
                "id": 2871626,
                "title": "java-faster-than-99-85-easy-clean-approach",
                "content": "##### Steps:\\n1. Create a Pair array to store frequencies\\n2. Sort the array in decreasing order of frequencies\\n3. Create a string and append characters according to their frequencies\\n\\n```java\\nclass Pair {\\n    char ch;\\n    int freq;\\n    Pair(char c) {\\n        this.ch = c;\\n        this.freq = 0;\\n    }\\n    Pair(char c, int f) {\\n        this.ch = c;\\n        this.freq = f;\\n    }\\n}\\n\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Pair[] characters = new Pair[123];\\n\\t\\tfor (int i = 0; i < 123; i++) {\\n\\t\\t\\tcharacters[i] = new Pair((char)i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tcharacters[ch].freq += 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tArrays.sort(characters, (p1, p2) -> p2.freq - p1.freq);\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder();\\n\\t\\tfor (Pair p : characters) {\\n\\t\\t\\tint freq = p.freq;\\n\\t\\t\\tchar ch = p.ch;\\n\\t\\t\\twhile (freq-- > 0) {\\n\\t\\t\\t\\tans.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Pair {\\n    char ch;\\n    int freq;\\n    Pair(char c) {\\n        this.ch = c;\\n        this.freq = 0;\\n    }\\n    Pair(char c, int f) {\\n        this.ch = c;\\n        this.freq = f;\\n    }\\n}\\n\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Pair[] characters = new Pair[123];\\n\\t\\tfor (int i = 0; i < 123; i++) {\\n\\t\\t\\tcharacters[i] = new Pair((char)i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\tcharacters[ch].freq += 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tArrays.sort(characters, (p1, p2) -> p2.freq - p1.freq);\\n\\t\\t\\n\\t\\tStringBuilder ans = new StringBuilder();\\n\\t\\tfor (Pair p : characters) {\\n\\t\\t\\tint freq = p.freq;\\n\\t\\t\\tchar ch = p.ch;\\n\\t\\t\\twhile (freq-- > 0) {\\n\\t\\t\\t\\tans.append(ch);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970280,
                "title": "easy-java-solution-using-hashmap-and-priority-queue",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            char c=s.charAt(i);\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        PriorityQueue<Character> maxHeap=new PriorityQueue<>((a,b)->map.get(b)-map.get(a));\\n        maxHeap.addAll(map.keySet());\\n        StringBuilder result=new StringBuilder();\\n        while(!maxHeap.isEmpty()){\\n            char ch=maxHeap.remove();\\n            int count=map.get(ch);\\n            while(count!=0){\\n                result.append(ch);\\n                count--;\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            char c=s.charAt(i);\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        PriorityQueue<Character> maxHeap=new PriorityQueue<>((a,b)->map.get(b)-map.get(a));\\n        maxHeap.addAll(map.keySet());\\n        StringBuilder result=new StringBuilder();\\n        while(!maxHeap.isEmpty()){\\n            char ch=maxHeap.remove();\\n            int count=map.get(ch);\\n            while(count!=0){\\n                result.append(ch);\\n                count--;\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672683,
                "title": "java-simple-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        PriorityQueue<Map.Entry<Character, Integer>> counts = new PriorityQueue<>((a,b) -> b.getValue() - a.getValue());\\n        Map<Character, Integer> freq = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            freq.put(c, freq.getOrDefault(c, 0)+1);\\n        }\\n        for(Map.Entry<Character, Integer> c : freq.entrySet()){\\n            counts.add(c);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(counts.size() > 0){\\n            Map.Entry<Character, Integer> element = counts.remove();\\n            for(int i = 0; i < element.getValue(); i++){\\n                sb.append(element.getKey());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        PriorityQueue<Map.Entry<Character, Integer>> counts = new PriorityQueue<>((a,b) -> b.getValue() - a.getValue());\\n        Map<Character, Integer> freq = new HashMap<>();\\n        for(char c : s.toCharArray()){\\n            freq.put(c, freq.getOrDefault(c, 0)+1);\\n        }\\n        for(Map.Entry<Character, Integer> c : freq.entrySet()){\\n            counts.add(c);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(counts.size() > 0){\\n            Map.Entry<Character, Integer> element = counts.remove();\\n            for(int i = 0; i < element.getValue(); i++){\\n                sb.append(element.getKey());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646182,
                "title": "c-linq-solution",
                "content": "```\\n    public string FrequencySort(string s) =>\\n        new string(s.GroupBy(c => c)\\n                    .OrderByDescending(chars => chars.Count())\\n                    .SelectMany(chars => chars)\\n                    .ToArray());\\n```",
                "solutionTags": [],
                "code": "```\\n    public string FrequencySort(string s) =>\\n        new string(s.GroupBy(c => c)\\n                    .OrderByDescending(chars => chars.Count())\\n                    .SelectMany(chars => chars)\\n                    .ToArray());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 645674,
                "title": "c-short-code-easy-to-implement-using-lamda-function-o-1-space",
                "content": "Normally Sort the string on the basis of frequency.\\n\\n**Why subtract character by \\' \\'?**\\nBecause \\' \\' (space character) has the minimum ascii value i.e. 32\\n**Why [&]?**\\nTo access variables outside the function, here frequency map. \\n```\\nclass Solution {\\npublic:\\n    \\n    string frequencySort(string s) {\\n       \\n        vector<int>mp(128,0);\\n        for(auto ch:s)\\n        {\\n            mp[ch-\\' \\']++;\\n        }\\n        sort(s.begin(),s.end(),[&](const char a,const char b)\\n             {\\n                 if(mp[a-\\' \\']!=mp[b-\\' \\'])\\n                 {\\n                     return mp[a-\\' \\']>mp[b-\\' \\'];\\n                 }\\n                 else{\\n\\t  // this is to ensure that if two characters have same frequence they should follow some order\\n\\t  // otherwise something like this can happen:\\n\\t // aabbcc ->  ababcc , which is undesirable\\n                     return a>b;\\n                 }\\n             });\\n        return s;\\n    }\\n};\\n```\\nP.S This is my first post so please support, Thank you :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string frequencySort(string s) {\\n       \\n        vector<int>mp(128,0);\\n        for(auto ch:s)\\n        {\\n            mp[ch-\\' \\']++;\\n        }\\n        sort(s.begin(),s.end(),[&](const char a,const char b)\\n             {\\n                 if(mp[a-\\' \\']!=mp[b-\\' \\'])\\n                 {\\n                     return mp[a-\\' \\']>mp[b-\\' \\'];\\n                 }\\n                 else{\\n\\t  // this is to ensure that if two characters have same frequence they should follow some order\\n\\t  // otherwise something like this can happen:\\n\\t // aabbcc ->  ababcc , which is undesirable\\n                     return a>b;\\n                 }\\n             });\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336240,
                "title": "different-python-solutions",
                "content": "Solution 1:\\n```\\n    def frequencySort(self, s: str) -> str:\\n        freq = collections.Counter(s)\\n        return \\'\\'.join(sorted(s, key = lambda c: (freq[c], c), reverse=True))\\n```\\n\\nSolution 2:\\n```\\n    def frequencySort(self, s: str) -> str:\\n\\t    return \\'\\'.join([c * n for c, n in collections.Counter(s).most_common()])\\n```",
                "solutionTags": [],
                "code": "```\\n    def frequencySort(self, s: str) -> str:\\n        freq = collections.Counter(s)\\n        return \\'\\'.join(sorted(s, key = lambda c: (freq[c], c), reverse=True))\\n```\n```\\n    def frequencySort(self, s: str) -> str:\\n\\t    return \\'\\'.join([c * n for c, n in collections.Counter(s).most_common()])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2872247,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: s.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        List<Character> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> (map.get(b) - map.get(a)));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(Character c: list){\\n            for(int i=0; i<map.get(c); i++){\\n                sb.append(c);\\n            }\\n        }       \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: s.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        List<Character> list = new ArrayList<>(map.keySet());\\n        Collections.sort(list, (a, b) -> (map.get(b) - map.get(a)));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(Character c: list){\\n            for(int i=0; i<map.get(c); i++){\\n                sb.append(c);\\n            }\\n        }       \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871181,
                "title": "easy-c-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp; //A map to get the frequency \\n        for(auto it:s)\\n        {\\n            mp[it]++;\\n        }\\n        vector<pair<int,char>> vp; //a pair of frequency and char\\n        for(auto it:mp)\\n        {\\n            vp.push_back({it.second,it.first});\\n        }\\n        sort(vp.begin(),vp.end()); //sorted the frequencies.\\n        string ans;\\n        for(auto it:vp)\\n        {\\n            while(it.first!=0)\\n            {\\n                ans.push_back(it.second);//inserted according to the frequency\\n                it.first--;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n//Suggestions and feedbacks are Welcomed. Happy Coding!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp; //A map to get the frequency \\n        for(auto it:s)\\n        {\\n            mp[it]++;\\n        }\\n        vector<pair<int,char>> vp; //a pair of frequency and char\\n        for(auto it:mp)\\n        {\\n            vp.push_back({it.second,it.first});\\n        }\\n        sort(vp.begin(),vp.end()); //sorted the frequencies.\\n        string ans;\\n        for(auto it:vp)\\n        {\\n            while(it.first!=0)\\n            {\\n                ans.push_back(it.second);//inserted according to the frequency\\n                it.first--;\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n//Suggestions and feedbacks are Welcomed. Happy Coding!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411501,
                "title": "python-easy-solution",
                "content": "```\\ndef frequencySort(self, s: str) -> str:\\n        output = []\\n        for letter in set(s):\\n            count = s.count(letter)\\n            output.append(letter*count)\\n        output = sorted(output, key=len, reverse = True)\\n        return \"\".join(output)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef frequencySort(self, s: str) -> str:\\n        output = []\\n        for letter in set(s):\\n            count = s.count(letter)\\n            output.append(letter*count)\\n        output = sorted(output, key=len, reverse = True)\\n        return \"\".join(output)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1535273,
                "title": "javascript-99-93-one-liner-more-readable-version",
                "content": "![image](https://assets.leetcode.com/users/images/83b29242-0fbd-459c-82f6-55dcd4417fa8_1634928768.051298.png)\\n![image](https://assets.leetcode.com/users/images/a1c1dfc8-0204-410b-8a50-537dfe865006_1635891447.7762737.png)\\n\\n\\nHere\\'s the one-liner:\\n\\n```\\nconst frequencySort=s=>Object.entries(s.split(\\'\\').reduce((o,v)=>(o[v]=o[v]+1||1)&&o,{})).sort(([a,x],[b,y])=>x<=y?1:-1).map(([c,f])=>c.repeat(f)).join(\\'\\');\\n```\\n\\nAnd here is a much more readable version:\\n```\\nvar frequencySort = function(s) {\\n  const frequency = s.split(\\'\\').reduce((obj, val) => {\\n    obj[val] = obj[val] + 1 || 1;\\n    return obj\\n  }, {});\\n  return Object.entries(frequency)\\n    .sort(([_, fx], [__, fy]) => fy - fx)\\n    .map(([char, freq]) => char.repeat(freq))\\n    .join(\\'\\');\\n};\\n```\\n\\nAlternatively, you can use a .reduce instead of the .map and .join as well:\\n```\\nvar frequencySort = function(s) {\\n  const frequency = s.split(\\'\\').reduce((obj, val) => {\\n    obj[val] = obj[val] + 1 || 1;\\n    return obj\\n  }, {});\\n  return Object.entries(frequency)\\n    .sort(([_, fx], [__, fy]) => fy - fx)\\n    .reduce((answer, [char, frequency]) => answer += char.repeat(frequency), \\'\\')\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst frequencySort=s=>Object.entries(s.split(\\'\\').reduce((o,v)=>(o[v]=o[v]+1||1)&&o,{})).sort(([a,x],[b,y])=>x<=y?1:-1).map(([c,f])=>c.repeat(f)).join(\\'\\');\\n```\n```\\nvar frequencySort = function(s) {\\n  const frequency = s.split(\\'\\').reduce((obj, val) => {\\n    obj[val] = obj[val] + 1 || 1;\\n    return obj\\n  }, {});\\n  return Object.entries(frequency)\\n    .sort(([_, fx], [__, fy]) => fy - fx)\\n    .map(([char, freq]) => char.repeat(freq))\\n    .join(\\'\\');\\n};\\n```\n```\\nvar frequencySort = function(s) {\\n  const frequency = s.split(\\'\\').reduce((obj, val) => {\\n    obj[val] = obj[val] + 1 || 1;\\n    return obj\\n  }, {});\\n  return Object.entries(frequency)\\n    .sort(([_, fx], [__, fy]) => fy - fx)\\n    .reduce((answer, [char, frequency]) => answer += char.repeat(frequency), \\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 645138,
                "title": "c-using-max-heap-priority-queue-easy-to-understand",
                "content": "```\\nstring frequencySort( string s ) {\\n\\tunordered_map<char, int> m;\\n\\tfor( auto c : s )\\n\\t\\t++m[c];\\n\\n\\tpriority_queue<pair<int, char>> maxHeap;\\n\\tfor( auto p : m )\\n\\t\\tmaxHeap.push( { p.second, p.first } );\\n\\n\\tstring result = \"\";\\n\\twhile( !maxHeap.empty() ) {\\n\\t\\tauto p = maxHeap.top(); maxHeap.pop();\\n\\t\\twhile( p.first-- )\\n\\t\\t\\tresult += p.second;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring frequencySort( string s ) {\\n\\tunordered_map<char, int> m;\\n\\tfor( auto c : s )\\n\\t\\t++m[c];\\n\\n\\tpriority_queue<pair<int, char>> maxHeap;\\n\\tfor( auto p : m )\\n\\t\\tmaxHeap.push( { p.second, p.first } );\\n\\n\\tstring result = \"\";\\n\\twhile( !maxHeap.empty() ) {\\n\\t\\tauto p = maxHeap.top(); maxHeap.pop();\\n\\t\\twhile( p.first-- )\\n\\t\\t\\tresult += p.second;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425481,
                "title": "easy-python-solution-beats-99-1-liner-solution",
                "content": "```\\nimport collections\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        myC=collections.Counter(s)\\n        \\n        output=\"\"\\n        \\n        for k,v in sorted(myC.items(), key=lambda x:(x[1],x[0]),reverse=True):\\n            output+=k*v\\n        \\n        return output\\n```\\n\\n1-liner solution\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        \\n        \\n        return \"\".join(k*v for k,v in sorted(collections.Counter(s).items(), key=lambda x:x[1], reverse=True))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        myC=collections.Counter(s)\\n        \\n        output=\"\"\\n        \\n        for k,v in sorted(myC.items(), key=lambda x:(x[1],x[0]),reverse=True):\\n            output+=k*v\\n        \\n        return output\\n```\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        \\n        \\n        return \"\".join(k*v for k,v in sorted(collections.Counter(s).items(), key=lambda x:x[1], reverse=True))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93461,
                "title": "c-using-unordered-map-and-priority-queue-very-easy-for-beginners-46ms",
                "content": "'''        \\n\\n\\n      string frequencySort(string s) {\\n        unordered_map<char, int> m1;\\n\\tpriority_queue<pair<int, char>> q1;\\n\\t for (int i = 0;i<s.length();i++) {\\n\\t\\tm1[s[i]]++;\\n\\t  }\\n\\n\\tfor (auto it = m1.begin();it != m1.end();it++) {\\n\\t\\tq1.push(make_pair(it->second, it->first));\\n\\t}\\n\\tstring res = \"\";\\n\\twhile (q1.size()) {\\n\\t\\tpair<int , char> y1 = q1.top();\\n\\t\\tfor(int i=0;i<q1.top().first;i++)\\n\\t\\t    res += q1.top().second;\\n\\t\\tq1.pop();\\n\\t}\\n\\treturn res;\\n    } \\n'''",
                "solutionTags": [],
                "code": "'''        \\n\\n\\n      string frequencySort(string s) {\\n        unordered_map<char, int> m1;\\n\\tpriority_queue<pair<int, char>> q1;\\n\\t for (int i = 0;i<s.length();i++) {\\n\\t\\tm1[s[i]]++;\\n\\t  }\\n\\n\\tfor (auto it = m1.begin();it != m1.end();it++) {\\n\\t\\tq1.push(make_pair(it->second, it->first));\\n\\t}\\n\\tstring res = \"\";\\n\\twhile (q1.size()) {\\n\\t\\tpair<int , char> y1 = q1.top();\\n\\t\\tfor(int i=0;i<q1.top().first;i++)\\n\\t\\t    res += q1.top().second;\\n\\t\\tq1.pop();\\n\\t}\\n\\treturn res;\\n    } \\n'''",
                "codeTag": "Unknown"
            },
            {
                "id": 2871956,
                "title": "c-map-queue-short-and-intuitive",
                "content": "# Intuition\\nCount the frequency and arrange in descending order.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n        // Count the frequency \\n        unordered_map<char,int> mp;\\n        for(int i= 0;i< s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        // priority queue will maintain the decreasing order \\n        priority_queue<pair<int,char>>pq;\\n        for(auto i : mp){\\n            pq.push({i.second,i.first});\\n        }\\n        \\n        // Generate the required answer \\n        string ans = \"\";\\n        while(!pq.empty()){\\n            \\n            pair<int,char> p = pq.top();\\n            pq.pop();\\n            \\n            while(p.first--){\\n                ans+=p.second;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n        // Count the frequency \\n        unordered_map<char,int> mp;\\n        for(int i= 0;i< s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        // priority queue will maintain the decreasing order \\n        priority_queue<pair<int,char>>pq;\\n        for(auto i : mp){\\n            pq.push({i.second,i.first});\\n        }\\n        \\n        // Generate the required answer \\n        string ans = \"\";\\n        while(!pq.empty()){\\n            \\n            pair<int,char> p = pq.top();\\n            pq.pop();\\n            \\n            while(p.first--){\\n                ans+=p.second;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871492,
                "title": "java-easy-solution-90-faster-fresh-approch",
                "content": "*Approach is Simple, Create a frequency array to store all the freqencies of all characters in string. Create a class pair to store the character and its frequency. Use an ArrayList of type pair for keeping hold of the data generated in freq map. Simply sort arraylist Based on freq and use StringBuilder to create the Answer string.*\\n\\n**Please Upvote if u Like**\\n\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n\\n//---create a FreqArray to Store frequency of all Characters in String--//\\n     \\n        int []freq=new int[123];\\n        for(int i=0;i<s.length();i++) {freq[(int)s.charAt(i)]++;}\\n        \\n//---create an ArrayList of type pair---//        \\n        List<pair> q=new ArrayList<>();\\n\\n//---add elements to the arraylist by creating a new object of pair ---//        \\n        for(int i=0;i<123;i++){\\n            if(freq[i]>0){\\n                q.add(new pair(freq[i],(char)i));\\n            }\\n        }\\n//---sort in descending order--//        \\n        \\n        Collections.sort(q,(x,y)->{\\n            return -(x.val-y.val);\\n        });\\n// ---use StringBuilder to crete the resultant String ---//       \\n       \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<q.size();i++){\\n            int n=q.get(i).val;\\n            for(int j=0;j<n;j++)sb.append(q.get(i).c);\\n        }\\n        return sb.toString();\\n        }\\n//--- a class of type pair that holds each character and its frequency in String input--//    \\n  class pair{\\n      char c; int val;\\n      pair(int val,char c){\\n          this.c=c;\\n          this.val=val;\\n      }\\n  }  \\n}\\n```\\n![image](https://assets.leetcode.com/users/images/637545d6-22da-4f03-b08f-5b046078a44f_1670039760.4655716.png)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n\\n//---create a FreqArray to Store frequency of all Characters in String--//\\n     \\n        int []freq=new int[123];\\n        for(int i=0;i<s.length();i++) {freq[(int)s.charAt(i)]++;}\\n        \\n//---create an ArrayList of type pair---//        \\n        List<pair> q=new ArrayList<>();\\n\\n//---add elements to the arraylist by creating a new object of pair ---//        \\n        for(int i=0;i<123;i++){\\n            if(freq[i]>0){\\n                q.add(new pair(freq[i],(char)i));\\n            }\\n        }\\n//---sort in descending order--//        \\n        \\n        Collections.sort(q,(x,y)->{\\n            return -(x.val-y.val);\\n        });\\n// ---use StringBuilder to crete the resultant String ---//       \\n       \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<q.size();i++){\\n            int n=q.get(i).val;\\n            for(int j=0;j<n;j++)sb.append(q.get(i).c);\\n        }\\n        return sb.toString();\\n        }\\n//--- a class of type pair that holds each character and its frequency in String input--//    \\n  class pair{\\n      char c; int val;\\n      pair(int val,char c){\\n          this.c=c;\\n          this.val=val;\\n      }\\n  }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674465,
                "title": "easy-c-solution-using-map-and-vector-10-ms-faster-than-93-18-of-c-online-submissions",
                "content": "Whenever you have the problem of sort by frequency then try to apply this logic.\\n```\\nclass Solution {\\npublic:\\n  string frequencySort(string s) {\\n    map<char, int> mp;\\n    for (auto it : s) mp[it]++;\\n    vector<pair<int, char>> v;\\n    for (auto it : mp)\\n      v.push_back({ it.second,it.first });\\n    sort(v.begin(), v.end(), greater<>());\\n    string ans = \"\";\\n    for (auto it : v) {\\n      int count = it.first;\\n      while (count--)\\n        ans += it.second;\\n    }\\n    return ans;\\n  }\\n};\\n```\\nIn this problem you **don\\'t need to use compare** as we just have to sort the element on the basis of **one element only** that is in this case is the **frequency of the characters.**\\nI have inserted the first element of the pair in vector as the frequency becuase when we apply the sort inbuilt function then it will sort it on the basis of first element only.\\nUsed greater inside the sort function because we first want the charcter with larger frequency first (basically to sort in **descending order**) \\nIf you like the approach please Upvote it. and feel free to ask any queries regarding the logic.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string frequencySort(string s) {\\n    map<char, int> mp;\\n    for (auto it : s) mp[it]++;\\n    vector<pair<int, char>> v;\\n    for (auto it : mp)\\n      v.push_back({ it.second,it.first });\\n    sort(v.begin(), v.end(), greater<>());\\n    string ans = \"\";\\n    for (auto it : v) {\\n      int count = it.first;\\n      while (count--)\\n        ans += it.second;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432692,
                "title": "c-faster-than-99-6-simples-sort-4ms-comments",
                "content": "```\\n// custom sort function to sort vector based on lengths of string\\nbool compareSizes(const string &lhs, const string &rhs) {\\n    return lhs.length() > rhs.length();\\n}\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<string> freq(100,\"\");\\n\\t\\t\\n\\t\\t// to store each letters occurence with that character\\n        for (char a : s) freq[a-\\'0\\'] += a;\\n\\t\\t\\n\\t\\t// sorting the vector based on lengths in decreasing order\\n        sort(freq.begin(), freq.end(), compareSizes);\\n\\t\\t\\n\\t\\tstring ans = \"\";\\n\\t\\t// adding it to ans string based on the frequency\\n        for (string str : freq) ans += str;\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8c745411-134f-4ad7-9a90-51aea840dea7_1660631309.6868293.png)\\n",
                "solutionTags": [],
                "code": "```\\n// custom sort function to sort vector based on lengths of string\\nbool compareSizes(const string &lhs, const string &rhs) {\\n    return lhs.length() > rhs.length();\\n}\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<string> freq(100,\"\");\\n\\t\\t\\n\\t\\t// to store each letters occurence with that character\\n        for (char a : s) freq[a-\\'0\\'] += a;\\n\\t\\t\\n\\t\\t// sorting the vector based on lengths in decreasing order\\n        sort(freq.begin(), freq.end(), compareSizes);\\n\\t\\t\\n\\t\\tstring ans = \"\";\\n\\t\\t// adding it to ans string based on the frequency\\n        for (string str : freq) ans += str;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666280,
                "title": "javascript-hashmap",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    stringAsObj = {};\\n    \\n    //Typical object key value pairs hashmap\\n    for(let item of s){\\n        if(!stringAsObj[item])\\n            stringAsObj[item] = 0;\\n        stringAsObj[item]++;\\n    }\\n    //Cool, we are able to sort values of an object in javascript with object keys getting the list of index/key and sort based on that b - a => descending order\\n    let sortedString = Object.keys(stringAsObj).sort(function(a,b){ return stringAsObj[b] -        stringAsObj[a]})\\n    \\n    let result = \"\";\\n    for(let item of sortedString){\\n        // repeat is a method where you input the number of occurrence. We just concatenate to result\\n        result = result + item.repeat(stringAsObj[item])\\n    }\\n   \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    stringAsObj = {};\\n    \\n    //Typical object key value pairs hashmap\\n    for(let item of s){\\n        if(!stringAsObj[item])\\n            stringAsObj[item] = 0;\\n        stringAsObj[item]++;\\n    }\\n    //Cool, we are able to sort values of an object in javascript with object keys getting the list of index/key and sort based on that b - a => descending order\\n    let sortedString = Object.keys(stringAsObj).sort(function(a,b){ return stringAsObj[b] -        stringAsObj[a]})\\n    \\n    let result = \"\";\\n    for(let item of sortedString){\\n        // repeat is a method where you input the number of occurrence. We just concatenate to result\\n        result = result + item.repeat(stringAsObj[item])\\n    }\\n   \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534433,
                "title": "java-11-simple-lambda-approach",
                "content": "\\n```\\npublic String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\t\\t// put every char with it frequency in the map\\n        s.chars().forEach(c -> map.put((char) c, map.getOrDefault((char) c, 0) + 1));\\n        return map.entrySet()\\n                .stream()\\n\\t\\t\\t\\t// sort by value in desc order\\n                .sorted(Map.Entry.comparingByValue((o1, o2) -> -o1.compareTo(o2))) \\n\\t\\t\\t\\t// get char repeated by its frequency\\n                .map(entry -> String.valueOf(entry.getKey()).repeat(entry.getValue())) \\n                .map(String::valueOf)\\n                .collect(Collectors.joining()); \\n    }\\n```\\nNote that `String.repeat(int n)` method is only available after Java 11",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\t\\t// put every char with it frequency in the map\\n        s.chars().forEach(c -> map.put((char) c, map.getOrDefault((char) c, 0) + 1));\\n        return map.entrySet()\\n                .stream()\\n\\t\\t\\t\\t// sort by value in desc order\\n                .sorted(Map.Entry.comparingByValue((o1, o2) -> -o1.compareTo(o2))) \\n\\t\\t\\t\\t// get char repeated by its frequency\\n                .map(entry -> String.valueOf(entry.getKey()).repeat(entry.getValue())) \\n                .map(String::valueOf)\\n                .collect(Collectors.joining()); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216166,
                "title": "java-easy-solution",
                "content": "import java.util.*;\\nclass Solution {\\n    public String fill(int length,Character c) {\\n        char[] data = new char[length];\\n        Arrays.fill(data,c);\\n        return new String(data);\\n\\n    }\\n    public String frequencySort(String s) {\\n        HashMap <Character,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int k=map.getOrDefault(s.charAt(i),0);\\n            map.put(s.charAt(i),k+1);\\n            if(max<map.get(s.charAt(i)))\\n            {\\n                max=map.get(s.charAt(i));\\n            }\\n        }\\n        SortedMap<Integer, String> map1\\n            = new TreeMap<Integer, String>();\\n        for(Map.Entry <Character,Integer> e : map.entrySet())\\n        {\\n            if(map1.containsKey(e.getValue()))\\n            {\\n                map1.put(e.getValue(),map1.get(e.getValue())+fill(e.getValue(),e.getKey()));\\n            }\\n            else\\n            {\\n                map1.put(e.getValue(),fill(e.getValue(),e.getKey()));\\n            }\\n        }\\n        String str=\"\";\\n        for(Map.Entry <Integer,String> y : map1.entrySet())\\n        {\\n            str=y.getValue()+str;\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String fill(int length,Character c) {\\n        char[] data = new char[length];\\n        Arrays.fill(data,c);\\n        return new String(data);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 644950,
                "title": "c-count-sort-build-string-speed-o-n-memory-o-1",
                "content": "Straight forward: \\n* count chars\\n* sort them just once by their frequency\\n* build the answer\\n\\nComplexity:\\n * Speed: `O(N + 256log256)` ==> `O(N)`\\n * Memory: `O(256)` ==> `O(1)`\\n\\nC++, 20 ms\\n```cpp\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        int cnt[256]={0};                // char -> counter\\n        int ixs[256];                    // position -> char; prepare for sorting\\n        for(int c=0;c<256;c++) ixs[c]=c; // initiate: fill with all possible chars\\n        for(char c:s) cnt[c]++;\\n        sort(begin(ixs), end(ixs), \\n             [&](const int a, const int b) { return cnt[a]>cnt[b]; }); // descending\\n        string res;\\n        res.reserve(s.size());\\n        for(int c:ixs) res+=string(cnt[c], c); // repeat \\'c\\' severeal times \\n        return res;\\n    }\\n};\\n```\\n\\nC, 4 ms\\n```\\nint* data=NULL;\\nint cmp(const void* a, const void* b)\\n{\\n    return data[*(int*)b]-data[*(int*)a];\\n}\\n    \\nchar * frequencySort(char * s){\\n    int cnt[256]={0};\\n    int ix[256];\\n    int i,j, len=strlen(s);\\n    for(i=0;i<256;i++) ix[i]=i;\\n    for(i=0;i<len;i++) cnt[s[i]] += 1;\\n    data=cnt;\\n    qsort(ix,256,sizeof(int),cmp);\\n    \\n    for(i=0,j=0;i<256 &&cnt[ix[i]]>0;i++)\\n        while(cnt[ix[i]]-- > 0)\\n            s[j++]=ix[i];\\n    return s;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        int cnt[256]={0};                // char -> counter\\n        int ixs[256];                    // position -> char; prepare for sorting\\n        for(int c=0;c<256;c++) ixs[c]=c; // initiate: fill with all possible chars\\n        for(char c:s) cnt[c]++;\\n        sort(begin(ixs), end(ixs), \\n             [&](const int a, const int b) { return cnt[a]>cnt[b]; }); // descending\\n        string res;\\n        res.reserve(s.size());\\n        for(int c:ixs) res+=string(cnt[c], c); // repeat \\'c\\' severeal times \\n        return res;\\n    }\\n};\\n```\n```\\nint* data=NULL;\\nint cmp(const void* a, const void* b)\\n{\\n    return data[*(int*)b]-data[*(int*)a];\\n}\\n    \\nchar * frequencySort(char * s){\\n    int cnt[256]={0};\\n    int ix[256];\\n    int i,j, len=strlen(s);\\n    for(i=0;i<256;i++) ix[i]=i;\\n    for(i=0;i<len;i++) cnt[s[i]] += 1;\\n    data=cnt;\\n    qsort(ix,256,sizeof(int),cmp);\\n    \\n    for(i=0,j=0;i<256 &&cnt[ix[i]]>0;i++)\\n        while(cnt[ix[i]]-- > 0)\\n            s[j++]=ix[i];\\n    return s;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93402,
                "title": "python-simple-straightforward",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        d = {}\\n        for char in s:\\n            d[char] = d.get(char,0) + 1\\n        \\n        sortedList = sorted(d.items(), key = lambda x:x[1])[::-1]\\n        res = ''\\n        \\n        for tupleEle in sortedList:\\n            res = res+tupleEle[0]*tupleEle[1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        d = {}\\n        for char in s:\\n            d[char] = d.get(char,0) + 1\\n        \\n        sortedList = sorted(d.items(), key = lambda x:x[1])[::-1]\\n        res = ''\\n        \\n        for tupleEle in sortedList:\\n            res = res+tupleEle[0]*tupleEle[1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93446,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    var map = {};\\n    var result = '';\\n    var stringArray = s.split('');\\n    //put the character count into a map\\n    for(var i=0;i<stringArray.length;i++){\\n    \\tmap[stringArray[i]] = map[stringArray[i]] + 1 || 1;\\n    }\\n    //sort the map first, then push into the result\\n    Object.keys(map).sort((a,b)=>map[b]-map[a]).forEach(function(v){\\n    \\tfor(var j=0;j<map[v];j++){\\n    \\t\\tresult += v;\\n    \\t}\\n    });\\n    \\n    return result;\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    var map = {};\\n    var result = '';\\n    var stringArray = s.split('');\\n    //put the character count into a map\\n    for(var i=0;i<stringArray.length;i++){\\n    \\tmap[stringArray[i]] = map[stringArray[i]] + 1 || 1;\\n    }\\n    //sort the map first, then push into the result\\n    Object.keys(map).sort((a,b)=>map[b]-map[a]).forEach(function(v){\\n    \\tfor(var j=0;j<map[v];j++){\\n    \\t\\tresult += v;\\n    \\t}\\n    });\\n    \\n    return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874098,
                "title": "javascript-solution-runtime-91-using-map-object",
                "content": "### Runtime: 91% ,  Memory: 88.3%\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    let map = new Map();\\n    let str = \\'\\';\\n    let keys, values;\\n    for(let i=0; i<s.length; i++){\\n        if(!map.has(s[i])){\\n            map.set(s[i], 1);\\n        } else {\\n            map.set(s[i], map.get(s[i]) + 1);\\n        }\\n    }\\n    let map1 = new Map([...map.entries()].sort((a,b) => b[1]-a[1]))\\n    for(let [i,j] of map1.entries()){\\n        str += i.repeat(j)\\n    }\\n    return str;\\n};\\n```\\n\\n\\n***please upvote***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    let map = new Map();\\n    let str = \\'\\';\\n    let keys, values;\\n    for(let i=0; i<s.length; i++){\\n        if(!map.has(s[i])){\\n            map.set(s[i], 1);\\n        } else {\\n            map.set(s[i], map.get(s[i]) + 1);\\n        }\\n    }\\n    let map1 = new Map([...map.entries()].sort((a,b) => b[1]-a[1]))\\n    for(let [i,j] of map1.entries()){\\n        str += i.repeat(j)\\n    }\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874074,
                "title": "simple-and-easy-c-solution-using-map-and-vector-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake a map and count the frequency of each character.\\nand taken a vector pair of type int and char\\n#### vector<pair<int,char>>v;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have taken a iterator to iterate through map \\nand pushed this value and keys into a vector. \\nand pushed values(it.second) and keys(it.first)\\n```\\nfor(auto it: mp){\\n         v.push_back({it.second,it.first});\\n       }\\n```\\nThis vector is sorted in descending order i.e 5,4,3,2,1\\n#### sort(v.begin(),v.end(),greater<pair<int,char>>());\\n\\nNOW iterate through the vector and I have used string constructor \\nit will append string(it.first,it.second)  i.e(5,e)  (FIVE TIMES E )\\ninto the res string\\n```\\nfor(auto it: v){\\n         res=res+string(it.first,it.second);\\n       }\\n```\\nFINALLY WE WILL RETURN THE RESULT i.e res\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(nlogn)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  $O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n      map<char, int> mp;\\n      int n=s.size();\\n      vector<pair<int,char>>v;\\n      int i;\\n      string res=\"\";\\n      for(i=0; i<n; i++){\\n        mp[s[i]]++;\\n        }\\n       for(auto it: mp){\\n         v.push_back({it.second,it.first});\\n       }\\n       sort(v.begin(),v.end(),greater<pair<int,char>>());\\n       \\n       for(auto it: v){\\n         res=res+string(it.first,it.second);\\n       } \\n      \\n      \\n  return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nfor(auto it: mp){\\n         v.push_back({it.second,it.first});\\n       }\\n```\n```\\nfor(auto it: v){\\n         res=res+string(it.first,it.second);\\n       }\\n```\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n      map<char, int> mp;\\n      int n=s.size();\\n      vector<pair<int,char>>v;\\n      int i;\\n      string res=\"\";\\n      for(i=0; i<n; i++){\\n        mp[s[i]]++;\\n        }\\n       for(auto it: mp){\\n         v.push_back({it.second,it.first});\\n       }\\n       sort(v.begin(),v.end(),greater<pair<int,char>>());\\n       \\n       for(auto it: v){\\n         res=res+string(it.first,it.second);\\n       } \\n      \\n      \\n  return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872460,
                "title": "c-2-different-approaches-fast-0ms-100",
                "content": "# Approach 1: custom sort function (48ms)\\n\\nWe do the frequency count first and then use this count for a custom sort function.\\n\\n```cpp\\n    static string frequencySort(string& s) noexcept {\\n        array<int, 128> cnt = {};\\n        for (char ch : s) ++cnt[ch];\\n        sort(begin(s), end(s), [&](char a, char b) {\\n            if (cnt[a] == cnt[b]) return a < b;\\n            return cnt[a] > cnt[b];\\n        });\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ the length of the input string then the\\n  * Time complexity is $$O(n \\\\log n)$$ for the sorting, and the\\n  * Space complexity is $$O(1)$$ as we are rewriting the input.\\n\\n# Approach 2: count, sort, reconstruct (0ms)\\n\\nThis approach first does a frequency count, sorts the frequency count descending, and finally reconstructs the answer from the sorted frequency count.\\n\\n```cpp\\n    static string frequencySort(const string& s) noexcept {\\n        array<int, 128> counts = {};\\n        for (char ch : s) ++counts[ch];\\n        vector<pair<int, char>> sc;\\n        sc.reserve(128);\\n        for (int i = 0; i < size(counts); ++i)\\n            if (counts[i]) sc.push_back({counts[i], i});\\n        sort(begin(sc), end(sc), greater<>());\\n        string ans;\\n        ans.reserve(size(s));\\n        for (auto [count, ch] : sc)\\n            ans += string(count, ch);\\n        return ans;\\n    }\\n```\\n\\n# Variant: rewrite the input (0ms)\\nIf we are willing to rewrite the input, then we could do something like this:\\n\\n```cpp\\n    static string frequencySort(string& s) noexcept {\\n        array<int, 128> counts = {};\\n        for (char ch : s) ++counts[ch];\\n        vector<pair<int, char>> sc;\\n        sc.reserve(128);\\n        for (int i = 0; i < size(counts); ++i)\\n            if (counts[i]) sc.push_back({counts[i], i});\\n        sort(begin(sc), end(sc), greater<>());\\n        s.resize(0);\\n        for (auto [count, ch] : sc)\\n            s += string(count, ch);\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ the length of the input string then the\\n  * Time complexity is $$O(n)$$, because while sorting is $$O(n \\\\log n)$$ in general we only sort a limited size frequency count vector. Doing the frequency count and reconstructing the string is $$O(n)$$, and the\\n  * Space complexity is $$O(n)$$ for the output (or $$O(1)$$ when we rewrite the input).\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static string frequencySort(string& s) noexcept {\\n        array<int, 128> cnt = {};\\n        for (char ch : s) ++cnt[ch];\\n        sort(begin(s), end(s), [&](char a, char b) {\\n            if (cnt[a] == cnt[b]) return a < b;\\n            return cnt[a] > cnt[b];\\n        });\\n        return s;\\n    }\\n```\n```cpp\\n    static string frequencySort(const string& s) noexcept {\\n        array<int, 128> counts = {};\\n        for (char ch : s) ++counts[ch];\\n        vector<pair<int, char>> sc;\\n        sc.reserve(128);\\n        for (int i = 0; i < size(counts); ++i)\\n            if (counts[i]) sc.push_back({counts[i], i});\\n        sort(begin(sc), end(sc), greater<>());\\n        string ans;\\n        ans.reserve(size(s));\\n        for (auto [count, ch] : sc)\\n            ans += string(count, ch);\\n        return ans;\\n    }\\n```\n```cpp\\n    static string frequencySort(string& s) noexcept {\\n        array<int, 128> counts = {};\\n        for (char ch : s) ++counts[ch];\\n        vector<pair<int, char>> sc;\\n        sc.reserve(128);\\n        for (int i = 0; i < size(counts); ++i)\\n            if (counts[i]) sc.push_back({counts[i], i});\\n        sort(begin(sc), end(sc), greater<>());\\n        s.resize(0);\\n        for (auto [count, ch] : sc)\\n            s += string(count, ch);\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2871158,
                "title": "daily-leetcoding-challenge-december-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-characters-by-frequency/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Arrays and Sorting\n\n  \n**Approach 2:** HashMap and Sort\n\n  \n**Approach 3:** Multiset and Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sort-characters-by-frequency/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1534084,
                "title": "simple-c-solution-using-unordered-map-multimap-with-explanation-4ms-faster-than-98-4-solutions",
                "content": "***Explanation:***\\n1. Iterate through the string and store the count of each character in an unordered_map\\n2. Now we have each character and its count in the unordered_map\\n3. Insert the count of each character and the character itself into the multimap i.e {count, character} (Here we use multimap because there can be 2 characters that can have same number of occurences Eg: aabb)\\n4. Since we used greater<int> in our multimap the count will be stored in the descending order.\\n5. Now we have occurence of each charater in descending order and just need to iterate the multimap and update the string.\\n\\n***Code:***\\n```\\nstring frequencySort(string s) \\n{\\n\\tunordered_map<char,int> m1;\\n\\tmultimap<int,char,greater<int>> m2;\\n\\n\\tint i,j=0;\\n\\tfor(i=0;i<s.size();i++)\\n\\t\\tm1[s[i]]++;\\n\\tfor(auto it=m1.begin();it!=m1.end();it++)\\n\\t\\tm2.insert({it->second,it->first});\\n\\tfor(auto jt=m2.begin();jt!=m2.end();jt++)\\n\\t{\\n\\t\\tfor(i=0;i<jt->first;i++)\\n\\t\\t\\ts[j++]=jt->second;\\n\\t}\\n\\treturn s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring frequencySort(string s) \\n{\\n\\tunordered_map<char,int> m1;\\n\\tmultimap<int,char,greater<int>> m2;\\n\\n\\tint i,j=0;\\n\\tfor(i=0;i<s.size();i++)\\n\\t\\tm1[s[i]]++;\\n\\tfor(auto it=m1.begin();it!=m1.end();it++)\\n\\t\\tm2.insert({it->second,it->first});\\n\\tfor(auto jt=m2.begin();jt!=m2.end();jt++)\\n\\t{\\n\\t\\tfor(i=0;i<jt->first;i++)\\n\\t\\t\\ts[j++]=jt->second;\\n\\t}\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1485404,
                "title": "priority-queue-hashing-c-simple-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) \\n    {\\n        priority_queue<pair<int,char>> pq;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(auto i:mp)\\n            pq.push(make_pair(i.second,i.first));\\n        string ans=\"\";\\n        while(!pq.empty())\\n        {\\n            int a=pq.top().first;\\n            char b= pq.top().second;\\n            for(int i=0;i<a;i++)\\n            {\\n                ans+=b;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) \\n    {\\n        priority_queue<pair<int,char>> pq;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(auto i:mp)\\n            pq.push(make_pair(i.second,i.first));\\n        string ans=\"\";\\n        while(!pq.empty())\\n        {\\n            int a=pq.top().first;\\n            char b= pq.top().second;\\n            for(int i=0;i<a;i++)\\n            {\\n                ans+=b;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920773,
                "title": "c-99-96",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(const string& s) {\\n        vector<string> v(127);\\n        for(auto i:s) v[i]+=i;\\n        sort(v.begin(),v.end(),[](const string& s1,const string& s2){return s1.size()>s2.size();});\\n        string res;\\n        for(auto i:v) res+=i;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(const string& s) {\\n        vector<string> v(127);\\n        for(auto i:s) v[i]+=i;\\n        sort(v.begin(),v.end(),[](const string& s1,const string& s2){return s1.size()>s2.size();});\\n        string res;\\n        for(auto i:v) res+=i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646152,
                "title": "slow-and-funny-steam-only-java-solution",
                "content": "```\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.counting;\\nimport static java.util.stream.Collectors.joining;\\nimport static java.util.stream.Stream.generate;\\nimport static java.util.Collections.reverseOrder;\\nimport static java.util.Map.Entry.comparingByValue;\\nimport static java.util.function.Function.identity;\\n\\nclass Solution {\\n    public String frequencySort(String s) {\\n        return s.chars()\\n            .mapToObj(c -> (char) c)                                       // map IntStream into Stream<Character>\\n            .collect(groupingBy(identity(), counting()))                   // collect into frequency map: Map<Character, Long> \\n            .entrySet().stream()                                           // establish a new stream: Stream<Map.Entry<Character, Long>>\\n            .sorted(reverseOrder(comparingByValue()))                      // sort by frequency \\n            .flatMap(e -> generate(() -> e.getKey()).limit(e.getValue()))  // generate repeating sequence: e.g. (\\'a\\', 3) -> [\\'a\\', \\'a\\', \\'a\\']\\n            .map(String::valueOf)                                          // map Stream<Character> into Stream<String>\\n            .collect(joining());                                           // perform final joining\\n    }\\n}\\n```\\n\\n\\u0421onvention:\\n* N - number of all characters in the string\\n* U - number of unique characters\\n\\nRuntime evaluation:\\n* Collecting into frequency map: O(N)\\n* Sorting: O(U * logU)\\n* Generation of the resulting string: O(N)\\n* Total: O(N + U * logU)\\n\\nSpace evaluation:\\n* Frequency map: O(U)\\n* Resulting string: O(N)\\n\\nIn comparison to other solutions, my solution is not the performant one :) It can be explained by the creation of multiple intermediate objects.\\n* Runtime: 79 ms, faster than 11.39% of Java online submissions for Sort by Characters By Frequency.\\n* Memory Usage: 53.1 MB, less than 7.41% of Java online submissions for Sort by Characters By Frequency.\\n\\nBut ultimately, it is always funny to write fluent and functional code with Steam API :)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport static java.util.stream.Collectors.groupingBy;\\nimport static java.util.stream.Collectors.counting;\\nimport static java.util.stream.Collectors.joining;\\nimport static java.util.stream.Stream.generate;\\nimport static java.util.Collections.reverseOrder;\\nimport static java.util.Map.Entry.comparingByValue;\\nimport static java.util.function.Function.identity;\\n\\nclass Solution {\\n    public String frequencySort(String s) {\\n        return s.chars()\\n            .mapToObj(c -> (char) c)                                       // map IntStream into Stream<Character>\\n            .collect(groupingBy(identity(), counting()))                   // collect into frequency map: Map<Character, Long> \\n            .entrySet().stream()                                           // establish a new stream: Stream<Map.Entry<Character, Long>>\\n            .sorted(reverseOrder(comparingByValue()))                      // sort by frequency \\n            .flatMap(e -> generate(() -> e.getKey()).limit(e.getValue()))  // generate repeating sequence: e.g. (\\'a\\', 3) -> [\\'a\\', \\'a\\', \\'a\\']\\n            .map(String::valueOf)                                          // map Stream<Character> into Stream<String>\\n            .collect(joining());                                           // perform final joining\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645022,
                "title": "python-hashmap-sorting-approach",
                "content": "Using high level Python functions (`Counter` and `most_common`) looks like cheating but if you get the hang of the idea, you can implement each of these high level functions on your own to get the same result.\\n\\nSteps:\\n* Create **char -> frequency** mapping\\n* Sort the mapping in descending order of character frequency (that\\'s what `most_common` does)\\n* Append the empty string with current character times count of current character.\\n\\n``` bash\\nRuntime: O(N+Klog(K)) # Where N is the length of original string, K is the number of unique characters in the string.\\nSpace: O(N)\\n```\\n\\n**Python**\\n``` python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        dict_char = Counter(s)  # Building *char -> frequency* mapping: Runtime O(N), Space O(N) \\n        result = \"\"             \\n        \\n        for c, freq in dict_char.most_common():   # Sorting the keys in dictionary with respect to values (descending order) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      # Runtime: O(KlogK) where K is the number of unique characters\\n            result += c*freq                     \\n    \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` bash\\nRuntime: O(N+Klog(K)) # Where N is the length of original string, K is the number of unique characters in the string.\\nSpace: O(N)\\n```\n``` python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        dict_char = Counter(s)  # Building *char -> frequency* mapping: Runtime O(N), Space O(N) \\n        result = \"\"             \\n        \\n        for c, freq in dict_char.most_common():   # Sorting the keys in dictionary with respect to values (descending order) \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      # Runtime: O(KlogK) where K is the number of unique characters\\n            result += c*freq                     \\n    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230664,
                "title": "99-faster-python-solution-with-comments",
                "content": "```\\n\\t\\t# dictionary to store count of character appearing in the string\\n\\t\\tdic = {}\\n\\t\\t\\n\\t\\t# final result\\n        result = \"\"\\n\\t\\t\\n\\t\\t# loop through each char, and add the count to the dic\\n        for char in s:\\n            if char in dic:\\n                dic[char] += 1\\n            else:\\n                dic[char] = 1\\n\\t\\t\\t\\t\\n\\t\\t# sort the dic on values in reverse order\\n        sorted_dic = sorted(dic, key=dic.get, reverse=True)\\n\\t\\t\\n\\t\\t# loop through, and create final string\\n        for count in sorted_dic:\\n            result += count * (dic[count])\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n\\t\\t# dictionary to store count of character appearing in the string\\n\\t\\tdic = {}\\n\\t\\t\\n\\t\\t# final result\\n        result = \"\"\\n\\t\\t\\n\\t\\t# loop through each char, and add the count to the dic\\n        for char in s:\\n            if char in dic:\\n                dic[char] += 1\\n            else:\\n                dic[char] = 1\\n\\t\\t\\t\\t\\n\\t\\t# sort the dic on values in reverse order\\n        sorted_dic = sorted(dic, key=dic.get, reverse=True)\\n\\t\\t\\n\\t\\t# loop through, and create final string\\n        for count in sorted_dic:\\n            result += count * (dic[count])\\n\\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112042,
                "title": "a-simple-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    \\n    class Alphabet {\\n        Character character;\\n        Integer count;\\n    }\\n    \\n    public String frequencySort(String s) {\\n        if(s == null || s.length() == 0){\\n            return s;\\n        }\\n        Map<Character, Alphabet> map = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            if(map.containsKey(c)){\\n                map.get(c).count++;\\n            } else {\\n                Alphabet alphabet = new Alphabet();\\n                alphabet.character = c;\\n                alphabet.count = 1;\\n                map.put(c, alphabet);\\n            }\\n        }\\n        \\n        List<Alphabet> alphabets = new ArrayList<>(map.values());\\n        \\n        Collections.sort(alphabets, new Comparator<Alphabet>(){\\n            @Override\\n            public int compare(Alphabet o1, Alphabet o2) {\\n                return o2.count.compareTo(o1.count);\\n            }\\n        });\\n        \\n        StringBuilder result = new StringBuilder(\"\");\\n        for(int i = 0; i < alphabets.size(); i++){\\n            Alphabet a = alphabets.get(i);\\n            for(int j = 0; j < a.count; j++){\\n                result.append(a.character);\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Alphabet {\\n        Character character;\\n        Integer count;\\n    }\\n    \\n    public String frequencySort(String s) {\\n        if(s == null || s.length() == 0){\\n            return s;\\n        }\\n        Map<Character, Alphabet> map = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            if(map.containsKey(c)){\\n                map.get(c).count++;\\n            } else {\\n                Alphabet alphabet = new Alphabet();\\n                alphabet.character = c;\\n                alphabet.count = 1;\\n                map.put(c, alphabet);\\n            }\\n        }\\n        \\n        List<Alphabet> alphabets = new ArrayList<>(map.values());\\n        \\n        Collections.sort(alphabets, new Comparator<Alphabet>(){\\n            @Override\\n            public int compare(Alphabet o1, Alphabet o2) {\\n                return o2.count.compareTo(o1.count);\\n            }\\n        });\\n        \\n        StringBuilder result = new StringBuilder(\"\");\\n        for(int i = 0; i < alphabets.size(); i++){\\n            Alphabet a = alphabets.get(i);\\n            for(int j = 0; j < a.count; j++){\\n                result.append(a.character);\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727642,
                "title": "simple-priority-queue-based-solution-c-beats-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        priority_queue<pair<int,char>>pq;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            pq.push({it.second, it.first});\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            int k=pq.top().first;\\n            char c=pq.top().second;\\n            while(k!=0)\\n            {\\n                ans+=c;\\n                k--;\\n            }\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        priority_queue<pair<int,char>>pq;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            pq.push({it.second, it.first});\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            int k=pq.top().first;\\n            char c=pq.top().second;\\n            while(k!=0)\\n            {\\n                ans+=c;\\n                k--;\\n            }\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696151,
                "title": "easy-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n1. The frequencySort function takes a string s as input and returns a sorted string. We create an unordered_map named freqMap to store the frequency of each character in the string.\\n\\n for (char c : s) {\\n        freqMap[c]++;\\n    }\\n2. This loop iterates through each character c in the input string s. It increments the frequency count of c in the freqMap by one. This loop counts the occurrences of each character.\\n\\nsort(s.begin(), s.end(), [&](char a, char b) {\\n        if (freqMap[a] == freqMap[b]) {\\n            return a < b; // If frequencies are equal, sort by character order\\n        }\\n        return freqMap[a] > freqMap[b];\\n    });\\n\\n\\n3. sort function is used to sort the characters in the input string s. It takes a lambda function as the comparison criterion. The lambda function compares two characters a and b.\\n\\nIf the frequencies of a and b are equal (freqMap[a] == freqMap[b]), it returns a < b. This ensures that if two characters have the same frequency, they are sorted based on their character order.\\nIf the frequencies of a and b are not equal, it returns freqMap[a] > freqMap[b]. This sorts the characters in descending order of their frequencies.\\n\\n\\nstring sortedString;\\n    for (char c : s) {\\n        sortedString += c;\\n    }\\n\\nreturn sortedString;\\n\\n5. Finally, the function returns the sortedString as the output.\\n\\nThe main function is used to test the frequencySort function by passing different input strings and printing the sorted results.\\n\\n\\nIf you like please UPVOTE\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s){\\n        unordered_map<char, int> freqMap;\\n\\n    // Step 1: Count character frequencies\\n    for (char c : s) {\\n        freqMap[c]++;\\n    }\\n\\n    // Step 2: Sort characters based on frequency\\n    sort(s.begin(), s.end(), [&](char a, char b) {\\n        if (freqMap[a] == freqMap[b]) {\\n            return a < b; // If frequencies are equal, sort by character order\\n        }\\n        return freqMap[a] > freqMap[b];\\n    });\\n\\n    // Step 3: Build the sorted string\\n    string sortedString;\\n    for (char c : s) {\\n        sortedString += c;\\n    }\\n\\n    return sortedString;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s){\\n        unordered_map<char, int> freqMap;\\n\\n    // Step 1: Count character frequencies\\n    for (char c : s) {\\n        freqMap[c]++;\\n    }\\n\\n    // Step 2: Sort characters based on frequency\\n    sort(s.begin(), s.end(), [&](char a, char b) {\\n        if (freqMap[a] == freqMap[b]) {\\n            return a < b; // If frequencies are equal, sort by character order\\n        }\\n        return freqMap[a] > freqMap[b];\\n    });\\n\\n    // Step 3: Build the sorted string\\n    string sortedString;\\n    for (char c : s) {\\n        sortedString += c;\\n    }\\n\\n    return sortedString;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872190,
                "title": "step-wise-solution",
                "content": "# Intuition\\n**Step1:** Store the frequency of each character in unordered map \\n**Step2:** Push the frequency,character in vector of pair\\n**Step3:** Sort the vector \\n**Step4:** Traverse from the right, Append the character w.r.t their frequency into answer string \\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n   O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        vector<pair<int,char>> v;\\n        for(auto it : m)    \\n          v.push_back({it.second,it.first});\\n        \\n        sort(v.begin(),v.end());\\n        s=\"\";\\n        for(int i=v.size()-1;i>=0;i--)\\n        {\\n           int x=v[i].first;\\n           char c=v[i].second; \\n           while(x>0)\\n           {\\n               s+=c; x--;\\n           }    \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        vector<pair<int,char>> v;\\n        for(auto it : m)    \\n          v.push_back({it.second,it.first});\\n        \\n        sort(v.begin(),v.end());\\n        s=\"\";\\n        for(int i=v.size()-1;i>=0;i--)\\n        {\\n           int x=v[i].first;\\n           char c=v[i].second; \\n           while(x>0)\\n           {\\n               s+=c; x--;\\n           }    \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871666,
                "title": "c-easyunderstable-intutive-heap-map-video-solution",
                "content": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/msSEO2mxOyk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/msSEO2mxOyk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2797678,
                "title": "easy-intuitive-javascript-solution-js-o-n-bucket-sort-map",
                "content": "## JS solution using Bucket Sort technique\\n```\\nvar frequencySort = function(s) {\\n    const freq = {}; // Map to store frequency of each character\\n    for(let i = 0; i < s.length; i++){\\n        if(!(s[i] in freq))\\n            freq[s[i]] = 0;\\n        freq[s[i]]++;\\n    }\\n    const buckets = Array(s.length + 1).fill(null); // Buckets to store characters based on the frequency\\n\\t// Len is len + 1 as there could just be one character equal to the length of the string\\n    for(const key of Object.keys(freq)){\\n        const f = freq[key];\\n        if(!buckets[f])\\n            buckets[f] = [];\\n        buckets[f] = [...buckets[f], ...Array(f).fill(key)] // can skip this and use `.repeat(i)` in the last step\\n    }\\n    const res = [];\\n\\t// Since we require result in decreasing order, start adding char to result array from the last position\\n    for(let i = s.length; i > 0; i--){\\n        if(buckets[i])\\n            for(let j = 0; j < buckets[i].length; j++)\\n                res.push(buckets[i][j]);\\n    }\\n\\t// Convert to string before returning\\n    return res.join(\"\");\\n};\\n```\\nOnce you understand this solution, try solving listed questions using similar technique\\n1. [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)",
                "solutionTags": [
                    "JavaScript",
                    "Bucket Sort"
                ],
                "code": "```\\nvar frequencySort = function(s) {\\n    const freq = {}; // Map to store frequency of each character\\n    for(let i = 0; i < s.length; i++){\\n        if(!(s[i] in freq))\\n            freq[s[i]] = 0;\\n        freq[s[i]]++;\\n    }\\n    const buckets = Array(s.length + 1).fill(null); // Buckets to store characters based on the frequency\\n\\t// Len is len + 1 as there could just be one character equal to the length of the string\\n    for(const key of Object.keys(freq)){\\n        const f = freq[key];\\n        if(!buckets[f])\\n            buckets[f] = [];\\n        buckets[f] = [...buckets[f], ...Array(f).fill(key)] // can skip this and use `.repeat(i)` in the last step\\n    }\\n    const res = [];\\n\\t// Since we require result in decreasing order, start adding char to result array from the last position\\n    for(let i = s.length; i > 0; i--){\\n        if(buckets[i])\\n            for(let j = 0; j < buckets[i].length; j++)\\n                res.push(buckets[i][j]);\\n    }\\n\\t// Convert to string before returning\\n    return res.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178820,
                "title": "solving-this-problem-using-structure-with-explanation",
                "content": "Steps to proceed:\\n\\t 1. First count the frequency of each unique characters.\\n\\t 2. Define a structure of frequency and corresponding character.\\n\\t 3. Sort the structure.\\n\\t 4. Store the sorted characters in the resultant string.\\n\\n\\nclass Solution {\\n\\n\\t//defining a structure\\n    struct d{\\n        int no;\\n        char r;\\n    };\\n\\t\\n\\t//sorting the structure\\n    static bool comp(d a, d b){\\n        return (a.no > b.no);\\n    }\\n\\t\\npublic:\\n    string frequencySort(string s) {\\n\\t\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        int f[n];\\n        int c=1;\\n        int j=0;\\n\\t\\t\\n\\t\\t//calculating the frequency of unique characters\\n        for(int i=1;i<n;i++){\\n            if(s[i]==s[i-1]){\\n                c++;\\n            }\\n            else{\\n                f[j]=c;\\n                c=1;\\n                j++;\\n            }\\n        }\\n        f[j]=c;\\n\\t\\t\\n        int k=0;\\n        j++;\\n\\t\\t\\n\\t\\t//defining array of structure\\n        d arr[j];\\n\\t\\t\\n\\t\\t//storing the values in the array\\n        for(int i=0;i<j;i++){\\n            arr[i].no=f[i];\\n            arr[i].r=s[k];\\n            k=k+f[i];\\n        }\\n\\t\\t\\n\\t\\t//sorting the array of structure\\n        sort(arr,arr+j,comp);\\n\\t\\t\\n\\t\\t//the resultant string\\n        string res=\"\";\\n        for(int i=0;i<j;i++){\\n            while(arr[i].no){\\n                res+=arr[i].r;\\n                arr[i].no--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nHope this solution was easy. If you like please upvote.\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t//defining a structure\\n    struct d{\\n        int no;\\n        char r;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1535187,
                "title": "java-hashmap-entry-and-just-arrays-and-without-using-sorting",
                "content": "**Approach 1st**\\n\\n````\\nimport java.util.Map.Entry;\\nclass Solution {\\n\\n    public String frequencySort(String s) {\\n        \\n    \\tchar str[]=s.toCharArray();\\n        \\n    \\tMap<Character,StringBuilder> map=new HashMap<Character, StringBuilder>();\\n    \\t\\n        for(int i=0;i<str.length;i++)\\n    \\t\\tmap.put(str[i], map.getOrDefault(str[i], new StringBuilder()).append(str[i]));\\n    \\t\\n        List<Entry<Character, StringBuilder>> list=new ArrayList<>(map.entrySet());\\n    \\t\\n        Collections.sort(list,(o1,o2)->o2.getValue().length()-o1.getValue().length());\\n    \\t\\n        StringBuilder ans=new StringBuilder();\\n    \\t\\n        for(Entry<Character, StringBuilder> pa : list)\\n    \\t\\tans.append(pa.getValue());\\n    \\t\\n        return ans.toString();\\n    }\\n}\\n````\\n\\n**Approach 2nd**\\n\\n````\\nclass Solution {\\n\\n    public String frequencySort(String s) {\\n        \\n    \\tchar str[]=s.toCharArray();\\n    \\tint arr[][]=new int[52][2];\\n    \\tfor(int i=0;i<str.length;i++)\\n    \\t{\\n            if(str[i]-\\'a\\'>=0) \\n            {\\n                arr[str[i]-\\'a\\'][0]=str[i];\\n    \\t\\t    arr[str[i]-\\'a\\'][1]++;\\n            }\\n            else\\n            {\\n                arr[str[i]-\\'A\\'+26][0]=str[i];\\n    \\t\\t    arr[str[i]-\\'A\\'+26][1]++;\\n            }\\n    \\t}\\n    \\tArrays.sort(arr,(o1,o2)->o2[1]-o1[1]);\\n    \\tStringBuilder ans=new StringBuilder();\\n    \\tfor(int i=0;i<52;i++)\\n    \\t{\\n    \\t\\tif(arr[i][1]==0)\\n    \\t\\t\\tbreak;\\n    \\t\\tfor(int j=0;j<arr[i][1];j++)\\n    \\t\\t\\tans.append((char)arr[i][0]);\\n    \\t}\\n    \\treturn ans.toString();\\n    }\\n}\\n````\\n\\n**Approach 3rd**\\n\\n````\\nclass Solution {\\n\\n    public String frequencySort(String s) {\\n        \\n    \\tchar str[]=s.toCharArray();\\n    \\t\\n        Map<Character, Integer> map=new HashMap<>();\\n    \\tint i,max=0;\\n    \\tfor(i=0;i<str.length;i++)\\n    \\t{\\n    \\t\\tmap.put(str[i], map.getOrDefault(str[i], 0)+1);\\n    \\t\\tmax=Math.max(max, map.get(str[i]));\\n    \\t}\\n    \\t\\n        List<Character> list[]=new ArrayList[max+1];\\n    \\tfor(i=1;i<=max;i++)\\n    \\t\\tlist[i]=new ArrayList<>();\\n    \\tfor(Character ch : map.keySet())\\n    \\t\\tlist[map.get(ch)].add(ch);\\n    \\t\\n        StringBuilder ans=new StringBuilder();\\n    \\tfor(i=max;i>0;i--)\\n    \\t{\\n    \\t\\tif(list[i].size()==0)\\n    \\t\\t\\tcontinue;\\n    \\t\\tfor(Character ch : list[i])\\n    \\t\\tfor(int j=0;j<i;j++)\\n    \\t\\t\\tans.append(ch);\\n    \\t}\\n    \\t\\n        return ans.toString();\\n    }\\n}\\n````\\n\\nIf this post was **helpful** then please **upvote** it",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nimport java.util.Map.Entry;\\nclass Solution {\\n\\n    public String frequencySort(String s) {\\n        \\n    \\tchar str[]=s.toCharArray();\\n        \\n    \\tMap<Character,StringBuilder> map=new HashMap<Character, StringBuilder>();\\n    \\t\\n        for(int i=0;i<str.length;i++)\\n    \\t\\tmap.put(str[i], map.getOrDefault(str[i], new StringBuilder()).append(str[i]));\\n    \\t\\n        List<Entry<Character, StringBuilder>> list=new ArrayList<>(map.entrySet());\\n    \\t\\n        Collections.sort(list,(o1,o2)->o2.getValue().length()-o1.getValue().length());\\n    \\t\\n        StringBuilder ans=new StringBuilder();\\n    \\t\\n        for(Entry<Character, StringBuilder> pa : list)\\n    \\t\\tans.append(pa.getValue());\\n    \\t\\n        return ans.toString();\\n    }\\n}\\n```\n````\\nclass Solution {\\n\\n    public String frequencySort(String s) {\\n        \\n    \\tchar str[]=s.toCharArray();\\n    \\tint arr[][]=new int[52][2];\\n    \\tfor(int i=0;i<str.length;i++)\\n    \\t{\\n            if(str[i]-\\'a\\'>=0) \\n            {\\n                arr[str[i]-\\'a\\'][0]=str[i];\\n    \\t\\t    arr[str[i]-\\'a\\'][1]++;\\n            }\\n            else\\n            {\\n                arr[str[i]-\\'A\\'+26][0]=str[i];\\n    \\t\\t    arr[str[i]-\\'A\\'+26][1]++;\\n            }\\n    \\t}\\n    \\tArrays.sort(arr,(o1,o2)->o2[1]-o1[1]);\\n    \\tStringBuilder ans=new StringBuilder();\\n    \\tfor(int i=0;i<52;i++)\\n    \\t{\\n    \\t\\tif(arr[i][1]==0)\\n    \\t\\t\\tbreak;\\n    \\t\\tfor(int j=0;j<arr[i][1];j++)\\n    \\t\\t\\tans.append((char)arr[i][0]);\\n    \\t}\\n    \\treturn ans.toString();\\n    }\\n}\\n```\n````\\nclass Solution {\\n\\n    public String frequencySort(String s) {\\n        \\n    \\tchar str[]=s.toCharArray();\\n    \\t\\n        Map<Character, Integer> map=new HashMap<>();\\n    \\tint i,max=0;\\n    \\tfor(i=0;i<str.length;i++)\\n    \\t{\\n    \\t\\tmap.put(str[i], map.getOrDefault(str[i], 0)+1);\\n    \\t\\tmax=Math.max(max, map.get(str[i]));\\n    \\t}\\n    \\t\\n        List<Character> list[]=new ArrayList[max+1];\\n    \\tfor(i=1;i<=max;i++)\\n    \\t\\tlist[i]=new ArrayList<>();\\n    \\tfor(Character ch : map.keySet())\\n    \\t\\tlist[map.get(ch)].add(ch);\\n    \\t\\n        StringBuilder ans=new StringBuilder();\\n    \\tfor(i=max;i>0;i--)\\n    \\t{\\n    \\t\\tif(list[i].size()==0)\\n    \\t\\t\\tcontinue;\\n    \\t\\tfor(Character ch : list[i])\\n    \\t\\tfor(int j=0;j<i;j++)\\n    \\t\\t\\tans.append(ch);\\n    \\t}\\n    \\t\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534863,
                "title": "simple-c-solution-using-only-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> m1;\\n        multimap<int,char> m2;\\n        \\n        for(char ch : s)\\n            m1[ch]++;\\n        \\n        for(auto i : m1)\\n            m2.insert({i.second,i.first});\\n        \\n        string ans;\\n        for(auto it : m2)\\n        {\\n            int len=it.first;\\n            while(len--)\\n                ans.push_back(it.second);\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Found helpful? UPVOTE NOW!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> m1;\\n        multimap<int,char> m2;\\n        \\n        for(char ch : s)\\n            m1[ch]++;\\n        \\n        for(auto i : m1)\\n            m2.insert({i.second,i.first});\\n        \\n        string ans;\\n        for(auto it : m2)\\n        {\\n            int len=it.first;\\n            while(len--)\\n                ans.push_back(it.second);\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024318,
                "title": "python3-solution-24-ms-runtime-15-2-mb-memory-easy-to-understand-solution",
                "content": "\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        \\n        ans_str = \\'\\'\\n        # Find unique characters\\n        characters = set(s)\\n        \\n        counts = []\\n        # Count their frequency\\n        for i in characters:\\n            counts.append([i,s.count(i)])\\n        \\n\\t\\t# Sort characters according to their frequency\\n        counts = sorted(counts, key= lambda x: x[1], reverse = True)\\n        \\n\\t\\t# Generate answer string by multiplying frequency count with the character\\n        for i,j in counts:\\n            ans_str += i*j\\n        \\n        return ans_str\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        \\n        ans_str = \\'\\'\\n        # Find unique characters\\n        characters = set(s)\\n        \\n        counts = []\\n        # Count their frequency\\n        for i in characters:\\n            counts.append([i,s.count(i)])\\n        \\n\\t\\t# Sort characters according to their frequency\\n        counts = sorted(counts, key= lambda x: x[1], reverse = True)\\n        \\n\\t\\t# Generate answer string by multiplying frequency count with the character\\n        for i,j in counts:\\n            ans_str += i*j\\n        \\n        return ans_str\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645485,
                "title": "javascript-solution",
                "content": "```\\nvar frequencySort = function(s) {\\n    let freq = new Map();\\n    \\n    for (const char of s) {\\n        if (!freq.has(char)) freq.set(char, 0);\\n        freq.set(char, freq.get(char) + 1);\\n    }\\n    \\n    freq = [...freq].sort((a, b) => a[1] - b[1]);\\n    let str = \"\";\\n    \\n    for (let i = freq.length - 1; i >= 0; i--) {\\n        let [char, count] = freq[i];\\n        str += char.repeat(count);\\n    }\\n    \\n    return str;\\n};\\n```\\n\\n<br />\\n\\n---\\n\\n<br/>\\n\\n```\\nvar frequencySort = function(s) {\\n    let counts = new Map();\\n    \\n    for (const char of s) {\\n        if (!counts.has(char)) counts.set(char, 0);\\n        counts.set(char, counts.get(char) + 1);\\n    }\\n    \\n    const buckets = new Array(s.length);\\n    \\n    for (let i = 0; i <= s.length; i++) {\\n        buckets[i] = [];\\n    }\\n    \\n    for (const [char, count] of counts) {\\n        buckets[count].push(char);\\n    }\\n    \\n    let str = \"\";\\n    \\n    for (let i = buckets.length - 1; i >= 0; i--) {\\n        while (buckets[i].length > 0) {\\n            const char = buckets[i].pop();\\n            str += char.repeat(i);\\n        }\\n      \\n    }\\n    \\n    return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar frequencySort = function(s) {\\n    let freq = new Map();\\n    \\n    for (const char of s) {\\n        if (!freq.has(char)) freq.set(char, 0);\\n        freq.set(char, freq.get(char) + 1);\\n    }\\n    \\n    freq = [...freq].sort((a, b) => a[1] - b[1]);\\n    let str = \"\";\\n    \\n    for (let i = freq.length - 1; i >= 0; i--) {\\n        let [char, count] = freq[i];\\n        str += char.repeat(count);\\n    }\\n    \\n    return str;\\n};\\n```\n```\\nvar frequencySort = function(s) {\\n    let counts = new Map();\\n    \\n    for (const char of s) {\\n        if (!counts.has(char)) counts.set(char, 0);\\n        counts.set(char, counts.get(char) + 1);\\n    }\\n    \\n    const buckets = new Array(s.length);\\n    \\n    for (let i = 0; i <= s.length; i++) {\\n        buckets[i] = [];\\n    }\\n    \\n    for (const [char, count] of counts) {\\n        buckets[count].push(char);\\n    }\\n    \\n    let str = \"\";\\n    \\n    for (let i = buckets.length - 1; i >= 0; i--) {\\n        while (buckets[i].length > 0) {\\n            const char = buckets[i].pop();\\n            str += char.repeat(i);\\n        }\\n      \\n    }\\n    \\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499640,
                "title": "java-priority-queue",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        for(char c : s.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        \\n        PriorityQueue<Character> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        pq.addAll(map.keySet());\\n        \\n        StringBuilder output = new StringBuilder();\\n        \\n        while(!pq.isEmpty()){\\n            char curr = pq.poll();\\n            for(int i = 0; i < map.get(curr); i++){\\n                output.append(curr);\\n            }\\n        }\\n        return output.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        for(char c : s.toCharArray()){\\n            map.put(c, map.getOrDefault(c,0)+1);\\n        }\\n        \\n        PriorityQueue<Character> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        pq.addAll(map.keySet());\\n        \\n        StringBuilder output = new StringBuilder();\\n        \\n        while(!pq.isEmpty()){\\n            char curr = pq.poll();\\n            for(int i = 0; i < map.get(curr); i++){\\n                output.append(curr);\\n            }\\n        }\\n        return output.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432265,
                "title": "one-linear-on-c",
                "content": "```\\n public string FrequencySort(string s)\\n        {\\n            return string.Join(\"\",s.GroupBy(ch=>ch).OrderByDescending(gr=>gr.Count()).SelectMany(gr=>gr));\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public string FrequencySort(string s)\\n        {\\n            return string.Join(\"\",s.GroupBy(ch=>ch).OrderByDescending(gr=>gr.Count()).SelectMany(gr=>gr));\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207883,
                "title": "c-5-lines",
                "content": "```\\npublic class Solution {\\n    public string FrequencySort(string s) {\\n            var dict = new Dictionary<char, StringBuilder>();\\n\\n            foreach (var c in s)\\n            {\\n                if (!dict.ContainsKey(c)) dict[c] = new StringBuilder();\\n                \\n                dict[c].Append(c);\\n            }\\n\\n            return string.Join(\"\", dict.OrderByDescending(d => d.Value.Length).Select(c => c.Value));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string FrequencySort(string s) {\\n            var dict = new Dictionary<char, StringBuilder>();\\n\\n            foreach (var c in s)\\n            {\\n                if (!dict.ContainsKey(c)) dict[c] = new StringBuilder();\\n                \\n                dict[c].Append(c);\\n            }\\n\\n            return string.Join(\"\", dict.OrderByDescending(d => d.Value.Length).Select(c => c.Value));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93403,
                "title": "18ms-java-with-hashmap",
                "content": "Basically logic goes below:\\n\\n- 1. turn String into char[]\\n\\n- 2. sort the char[]\\n\\n- 3. turn sorted char[] back to String\\n\\n- 4. do \"word\" count with HashMap <String, Integer>\\n\\n- 5. sort the HashMap by value descendingly\\n\\n- 6. concat keys\\n\\n```java\\n    public String frequencySort(String s) {\\n        \\n        if(s==null||s.length()==0){\\n            return \"\";\\n        }\\n        \\n        if(s.length() == 1){\\n            return s;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(\"\");\\n        \\n        // 1. turn String into char[]\\n        char[] c = s.toCharArray();\\n        \\n        // 2. sort the char[]\\n        Arrays.sort(c);\\n\\n        // 3. turn sorted char[] back to String\\n        String newS = new String(c);\\n        \\n        // 4. do \"word\" count with HashMap <String, Integer>\\n        Map <String, Integer> mp = new HashMap<>();\\n        int slow = 0;\\n        int fast = 1;\\n        for(; fast < s.length(); fast++){\\n            if(c[fast] != c[slow]){\\n                int diff = fast - slow;\\n                sb.append(newS.substring(slow,fast));\\n                slow = fast;\\n                mp.put(sb.toString(), diff);\\n                sb = new StringBuilder(\"\");\\n            }\\n        }\\n        \\n        int diff = fast - slow;\\n        sb = new StringBuilder(\"\");\\n        while(slow < fast){\\n            sb.append(c[slow]);\\n            slow++;\\n        }\\n        mp.put(sb.toString(), diff);\\n\\n        // 5. sort the HashMap by value descendingly\\n        mp = sortByVal(mp);\\n\\n        // 6. concat keys\\n        sb = new StringBuilder(\"\");\\n        for(String cs : mp.keySet()){\\n            sb.append(cs);\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // 5. sort the HashMap by value descendingly\\n    private Map<String, Integer> sortByVal (Map<String,Integer> mp){\\n        \\n        List<Map.Entry<String,Integer>> list = new LinkedList<>(mp.entrySet());\\n        \\n        Collections.sort(list, new Comparator<Map.Entry<String,Integer>>(){\\n            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2){\\n                return o2.getValue().compareTo(o1.getValue());\\n            }\\n        });\\n\\n\\n        // lambda is slower than the anonymous class\\n        // Collections.sort(list, (o1, o2) -> o2.getValue().compareTo(o1.getValue()));\\n        \\n        Map<String,Integer> newMp = new LinkedHashMap<>();\\n        for(Map.Entry<String,Integer> entry:list){\\n            newMp.put(entry.getKey(), entry.getValue());\\n        }\\n        \\n        return newMp;\\n            \\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public String frequencySort(String s) {\\n        \\n        if(s==null||s.length()==0){\\n            return \"\";\\n        }\\n        \\n        if(s.length() == 1){\\n            return s;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(\"\");\\n        \\n        // 1. turn String into char[]\\n        char[] c = s.toCharArray();\\n        \\n        // 2. sort the char[]\\n        Arrays.sort(c);\\n\\n        // 3. turn sorted char[] back to String\\n        String newS = new String(c);\\n        \\n        // 4. do \"word\" count with HashMap <String, Integer>\\n        Map <String, Integer> mp = new HashMap<>();\\n        int slow = 0;\\n        int fast = 1;\\n        for(; fast < s.length(); fast++){\\n            if(c[fast] != c[slow]){\\n                int diff = fast - slow;\\n                sb.append(newS.substring(slow,fast));\\n                slow = fast;\\n                mp.put(sb.toString(), diff);\\n                sb = new StringBuilder(\"\");\\n            }\\n        }\\n        \\n        int diff = fast - slow;\\n        sb = new StringBuilder(\"\");\\n        while(slow < fast){\\n            sb.append(c[slow]);\\n            slow++;\\n        }\\n        mp.put(sb.toString(), diff);\\n\\n        // 5. sort the HashMap by value descendingly\\n        mp = sortByVal(mp);\\n\\n        // 6. concat keys\\n        sb = new StringBuilder(\"\");\\n        for(String cs : mp.keySet()){\\n            sb.append(cs);\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    // 5. sort the HashMap by value descendingly\\n    private Map<String, Integer> sortByVal (Map<String,Integer> mp){\\n        \\n        List<Map.Entry<String,Integer>> list = new LinkedList<>(mp.entrySet());\\n        \\n        Collections.sort(list, new Comparator<Map.Entry<String,Integer>>(){\\n            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2){\\n                return o2.getValue().compareTo(o1.getValue());\\n            }\\n        });\\n\\n\\n        // lambda is slower than the anonymous class\\n        // Collections.sort(list, (o1, o2) -> o2.getValue().compareTo(o1.getValue()));\\n        \\n        Map<String,Integer> newMp = new LinkedHashMap<>();\\n        for(Map.Entry<String,Integer> entry:list){\\n            newMp.put(entry.getKey(), entry.getValue());\\n        }\\n        \\n        return newMp;\\n            \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93429,
                "title": "java-easy-to-understand-o-n-logn-beats-90",
                "content": "```\\npublic class Solution {\\n    \\n    class Entry{\\n        char c;\\n        int count;\\n        \\n        public Entry(){\\n            this.count = 0;\\n        }\\n    }\\n    \\n    public String frequencySort(String s) {\\n        \\n        Entry[] elems = new Entry[256];\\n        for(int i=0; i<256; i++){\\n            elems[i] = new Entry();\\n        }\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            elems[c].c = c;\\n            elems[c].count++;\\n        }\\n\\n        Arrays.sort(elems, new Comparator<Entry>(){\\n           @Override\\n           public int compare(Entry e1, Entry e2){\\n               return e2.count - e1.count; // descending order\\n           }\\n        });\\n        \\n        StringBuilder result = new StringBuilder();\\n        for(Entry e: elems){\\n            while(e.count-- > 0)\\n                result.append(e.c);\\n        }\\n        \\n        return result.toString();\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    class Entry{\\n        char c;\\n        int count;\\n        \\n        public Entry(){\\n            this.count = 0;\\n        }\\n    }\\n    \\n    public String frequencySort(String s) {\\n        \\n        Entry[] elems = new Entry[256];\\n        for(int i=0; i<256; i++){\\n            elems[i] = new Entry();\\n        }\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            elems[c].c = c;\\n            elems[c].count++;\\n        }\\n\\n        Arrays.sort(elems, new Comparator<Entry>(){\\n           @Override\\n           public int compare(Entry e1, Entry e2){\\n               return e2.count - e1.count; // descending order\\n           }\\n        });\\n        \\n        StringBuilder result = new StringBuilder();\\n        for(Entry e: elems){\\n            while(e.count-- > 0)\\n                result.append(e.c);\\n        }\\n        \\n        return result.toString();\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93650,
                "title": "c-pure-array-o-n-with-o-n-extra-space",
                "content": "uses only arrays, no maps or sorting required.  Basically a bucket/counting sort technique.\\n\\n```\\n    public string FrequencySort(string s) \\n    {\\n        int[] cnts = new int[256];\\n        foreach (char c in s) cnts[c]++;\\n        \\n        string[] chars = new string[s.Length + 1];\\n        for (int i = 0; i < 256; i++)\\n        {\\n            if (cnts[i] > 0)\\n            {\\n                int cnt = cnts[i];\\n                if (chars[cnt] == null) chars[cnt] = \"\";\\n                chars[cnt] += (char)i;\\n            }\\n        }\\n        \\n        StringBuilder output = new StringBuilder();\\n        for (int i = chars.Length - 1; i >= 0; i--)\\n        {\\n            AppendEachXTimes(output, chars[i], i);\\n        }\\n        \\n        return output.ToString();\\n    }\\n    \\n    public void AppendEachXTimes(StringBuilder builder, string s, int times)\\n    {\\n        if (s == null) return;\\n        foreach (char c in s)\\n        {\\n            for (int i = 0; i < times; i++) builder.Append(c);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\n    public string FrequencySort(string s) \\n    {\\n        int[] cnts = new int[256];\\n        foreach (char c in s) cnts[c]++;\\n        \\n        string[] chars = new string[s.Length + 1];\\n        for (int i = 0; i < 256; i++)\\n        {\\n            if (cnts[i] > 0)\\n            {\\n                int cnt = cnts[i];\\n                if (chars[cnt] == null) chars[cnt] = \"\";\\n                chars[cnt] += (char)i;\\n            }\\n        }\\n        \\n        StringBuilder output = new StringBuilder();\\n        for (int i = chars.Length - 1; i >= 0; i--)\\n        {\\n            AppendEachXTimes(output, chars[i], i);\\n        }\\n        \\n        return output.ToString();\\n    }\\n    \\n    public void AppendEachXTimes(StringBuilder builder, string s, int times)\\n    {\\n        if (s == null) return;\\n        foreach (char c in s)\\n        {\\n            for (int i = 0; i < times; i++) builder.Append(c);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754758,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        vector<pair<int,char>> vect;\\n        for(auto it: mp){\\n            vect.push_back({it.second,it.first});\\n        }\\n         sort(vect.begin(),vect.end());\\n         s=\"\"; \\n        for(int i=vect.size()-1;i>=0;i--){\\n            int count=vect[i].first;\\n            char c= vect[i].second;\\n            while(count > 0){\\n                s+= c;\\n                count--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        vector<pair<int,char>> vect;\\n        for(auto it: mp){\\n            vect.push_back({it.second,it.first});\\n        }\\n         sort(vect.begin(),vect.end());\\n         s=\"\"; \\n        for(int i=vect.size()-1;i>=0;i--){\\n            int count=vect[i].first;\\n            char c= vect[i].second;\\n            while(count > 0){\\n                s+= c;\\n                count--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552153,
                "title": "easy-solution-using-frequency-map-and-maxheap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        map<char,int> mp;\\n        for(auto a:s){\\n            mp[a]++;\\n        }\\n        priority_queue<pair<int, char> > pq;\\n        for(auto a:s){\\n            pq.push(make_pair(mp[a],a));\\n        }\\n        string  ans=\"\";\\n        while(!pq.empty()){\\n            ans+=pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        map<char,int> mp;\\n        for(auto a:s){\\n            mp[a]++;\\n        }\\n        priority_queue<pair<int, char> > pq;\\n        for(auto a:s){\\n            pq.push(make_pair(mp[a],a));\\n        }\\n        string  ans=\"\";\\n        while(!pq.empty()){\\n            ans+=pq.top().second;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495857,
                "title": "cpp-solution-using-unorderedmap-and-priority-queue",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe frequencySort() function takes a string s as input and returns the sorted string based on the frequency of the characters.\\n\\nThe function first creates an unordered map `m` to count the frequency of each character in the string\\n\\npriority queue `pq` to store the characters and their frequency as a pair. We sort the pairs based on their frequency, with the highest frequency first. If two pairs have the same frequency, we sort them based on their lexicographical order by comparing the second element of the pairs (the character).\\n\\nWe then build the sorted string `ans` by popping the pairs from the priority queue and appending the character p.second `ans` p.first times.\\n\\n# Complexity\\nThe time complexity of this code is O(n log n), where n is the length of the input string.\\n\\nFirst, the code iterates over the input string to count the frequency of each character. This takes O(n) time.\\n\\nThen, the code uses a priority queue to sort the characters by frequency. The priority queue can have at most n elements, and each insertion into the priority queue takes O(log n) time. Therefore, building the priority queue takes O(n log n) time.\\n\\nFinally, the code builds the sorted string by appending characters to the end of the string. This takes O(n) time because each character is appended to the end of the string one by one.\\n\\nThus, the overall time complexity of the code is O(n log n).\\n\\nThe space complexity of the code is O(n). This is because the code uses an unordered map to store the frequency of each character, which takes up to O(n) space in the worst case if all characters are unique. The priority queue can also have up to n elements, which takes up to O(n) space. Finally, the output string can take up to O(n) space in the worst case if all characters are unique. Therefore, the overall space complexity is O(n).\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int>m;\\n\\n        for(char c: s){\\n            m[c]++;\\n        }\\n     priority_queue<pair<int, char>> pq; \\n          for (auto p : m) {\\n             pq.push({p.second, p.first});\\n           }\\n\\n           string ans=\"\";\\n\\n           while(!pq.empty()){\\n            auto p= pq.top();\\n            pq.pop();\\n            ans.append(p.first, p.second);\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int>m;\\n\\n        for(char c: s){\\n            m[c]++;\\n        }\\n     priority_queue<pair<int, char>> pq; \\n          for (auto p : m) {\\n             pq.push({p.second, p.first});\\n           }\\n\\n           string ans=\"\";\\n\\n           while(!pq.empty()){\\n            auto p= pq.top();\\n            pq.pop();\\n            ans.append(p.first, p.second);\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451712,
                "title": "easily-understandable-java-code",
                "content": "# Intuition\\nThree steps: \\n     1) create hashmap store char and its frequencies \\n     2) create a priority queue maxHeap store char with decreasing order of there frequencies.\\n     3) append the charecter in a stringBuilder result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n    // Three steps: \\n    // 1> create hashmap store char and its frequencies \\n    // 2> create a priority queue maxHeap store char with decreasing order of there frequencies.\\n    // 3> append the charecter in a stringBuilder result.\\n\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     for(char c:s.toCharArray()){\\n         map.put(c,map.getOrDefault(c,0) + 1);\\n     }\\n    \\n    PriorityQueue<Character> maxHeap = new PriorityQueue<>((a,b) -> map.get(b)-map.get(a));\\n    maxHeap.addAll(map.keySet());\\n \\n    StringBuilder result = new StringBuilder();\\n    while(!maxHeap.isEmpty()){\\n        char current = maxHeap.remove();\\n        for(int i=0;i<map.get(current);i++){\\n            result.append(current);\\n        }\\n    }\\n      return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n    // Three steps: \\n    // 1> create hashmap store char and its frequencies \\n    // 2> create a priority queue maxHeap store char with decreasing order of there frequencies.\\n    // 3> append the charecter in a stringBuilder result.\\n\\n     HashMap<Character,Integer> map = new HashMap<>();\\n     for(char c:s.toCharArray()){\\n         map.put(c,map.getOrDefault(c,0) + 1);\\n     }\\n    \\n    PriorityQueue<Character> maxHeap = new PriorityQueue<>((a,b) -> map.get(b)-map.get(a));\\n    maxHeap.addAll(map.keySet());\\n \\n    StringBuilder result = new StringBuilder();\\n    while(!maxHeap.isEmpty()){\\n        char current = maxHeap.remove();\\n        for(int i=0;i<map.get(current);i++){\\n            result.append(current);\\n        }\\n    }\\n      return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118106,
                "title": "best-o-n-solution",
                "content": "\\n\\n# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        int count[256] = {0};\\n        for (int i = 0; i < s.length(); i++)\\n            count[s[i]]++;\\n        int size = 0;    \\n        while (size < s.length()) {\\n            int maxFreq = 0;\\n            char maxChar = 0;\\n            for (int i = 0; i < 256; i++) {\\n                if (maxFreq < count[i]) {\\n                    maxFreq = count[i];\\n                    maxChar = i;\\n                }\\n            }\\n            for (int i = 0; i < maxFreq; i++)\\n                s[i + size] = maxChar;\\n            size += maxFreq;    \\n            count[maxChar] = 0;\\n        }  \\n        return s;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        int count[256] = {0};\\n        for (int i = 0; i < s.length(); i++)\\n            count[s[i]]++;\\n        int size = 0;    \\n        while (size < s.length()) {\\n            int maxFreq = 0;\\n            char maxChar = 0;\\n            for (int i = 0; i < 256; i++) {\\n                if (maxFreq < count[i]) {\\n                    maxFreq = count[i];\\n                    maxChar = i;\\n                }\\n            }\\n            for (int i = 0; i < maxFreq; i++)\\n                s[i + size] = maxChar;\\n            size += maxFreq;    \\n            count[maxChar] = 0;\\n        }  \\n        return s;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097738,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int, char> &p1, pair<int, char>& p2)\\n    {\\n        if(p1.first==p2.first)\\n        return p1.second<p2.second;\\n        return p1.first>p2.first;\\n    }\\n    string frequencySort(string s) {\\n        unordered_map<char, int> mp;\\n        for(char c:s)\\n        mp[c]++;;\\n        vector<pair<int, char>> v;\\n        for(auto it:mp)\\n        {\\n            v.push_back({it.second, it.first});\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        string ans;\\n        for(auto i:v)\\n        {\\n            for(int j=0;j<i.first;j++)\\n            ans+=i.second;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int, char> &p1, pair<int, char>& p2)\\n    {\\n        if(p1.first==p2.first)\\n        return p1.second<p2.second;\\n        return p1.first>p2.first;\\n    }\\n    string frequencySort(string s) {\\n        unordered_map<char, int> mp;\\n        for(char c:s)\\n        mp[c]++;;\\n        vector<pair<int, char>> v;\\n        for(auto it:mp)\\n        {\\n            v.push_back({it.second, it.first});\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        string ans;\\n        for(auto i:v)\\n        {\\n            for(int j=0;j<i.first;j++)\\n            ans+=i.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873167,
                "title": "java-count-sort",
                "content": "# 1.count & sort\\n```\\n    //1.count & sort\\n    //Runtime: 5 ms, faster than 99.45% of Java online submissions for Sort Characters By Frequency.\\n    //Memory Usage: 42.3 MB, less than 99.78% of Java online submissions for Sort Characters By Frequency.\\n    //Time: O(N + 74 + 74 * log(74) + N); Space: O(log(74) + N)\\n    //Time: O(N); Space: O(N)\\n    public String frequencySort(String s) {\\n        int[] counter = new int[\\'z\\' - \\'0\\' + 1];\\n        for (int i = 0; i < s.length(); i++)\\n            counter[s.charAt(i) - \\'0\\']++;\\n\\n        List<int[]> list = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++)\\n            list.add(new int[]{i, counter[i]});\\n\\n        Collections.sort(list, (a, b) -> b[1] - a[1]);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int[] element : list){\\n            char c = (char)(\\'0\\' + element[0]);\\n            for (int i = 0; i < element[1]; i++) sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //1.count & sort\\n    //Runtime: 5 ms, faster than 99.45% of Java online submissions for Sort Characters By Frequency.\\n    //Memory Usage: 42.3 MB, less than 99.78% of Java online submissions for Sort Characters By Frequency.\\n    //Time: O(N + 74 + 74 * log(74) + N); Space: O(log(74) + N)\\n    //Time: O(N); Space: O(N)\\n    public String frequencySort(String s) {\\n        int[] counter = new int[\\'z\\' - \\'0\\' + 1];\\n        for (int i = 0; i < s.length(); i++)\\n            counter[s.charAt(i) - \\'0\\']++;\\n\\n        List<int[]> list = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++)\\n            list.add(new int[]{i, counter[i]});\\n\\n        Collections.sort(list, (a, b) -> b[1] - a[1]);\\n\\n        StringBuilder sb = new StringBuilder();\\n        for(int[] element : list){\\n            char c = (char)(\\'0\\' + element[0]);\\n            for (int i = 0; i < element[1]; i++) sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2872559,
                "title": "easy-optimized-and-understandable-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n        unordered_map<char,int>m;\\n        priority_queue<pair<int,char>>pq;\\n\\n        for(auto x : s){\\n\\n            m[x]++;\\n        }\\n\\n        for(auto x : m){\\n\\n            pq.push({x.second , x.first});\\n        }\\n\\n        s=\"\";\\n\\n        while(!pq.empty()){\\n\\n           for(int i=0;i<pq.top().first;i++){\\n\\n               s+=pq.top().second;\\n           }\\n\\n           pq.pop();\\n\\n        }\\n\\n        return s;\\n    }\\n//please upvote :)\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        \\n        unordered_map<char,int>m;\\n        priority_queue<pair<int,char>>pq;\\n\\n        for(auto x : s){\\n\\n            m[x]++;\\n        }\\n\\n        for(auto x : m){\\n\\n            pq.push({x.second , x.first});\\n        }\\n\\n        s=\"\";\\n\\n        while(!pq.empty()){\\n\\n           for(int i=0;i<pq.top().first;i++){\\n\\n               s+=pq.top().second;\\n           }\\n\\n           pq.pop();\\n\\n        }\\n\\n        return s;\\n    }\\n//please upvote :)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871919,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "# Explanation\\n1. First, we will create an hash map, which will store Character as key and integer as value.\\n2. Now in in this hash map, we will store frequency of every character.\\n3. Now we will create a priority queue(Max Heap) that accepts Key value pair, in which key is character and value is integer, ```Which will sort to the pair according to character frequency.```\\n4. Now we will copy HashMap\\'s Character and its frequency in Priority queue.\\n5. Now pop from priority queue. And it stores the character multiplied by its frequency in resultant string.\\n6. Now return the result string.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap<Character, Integer> map=new HashMap<>();\\n        for(char x: s.toCharArray()) map.put(x, map.getOrDefault(x, 0)+1);\\n        PriorityQueue<Map.Entry<Character, Integer>> pq =new PriorityQueue<Map.Entry<Character, Integer>>((e1, e2) -> e2.getValue()-e1.getValue());\\n        pq.addAll(map.entrySet());\\n        StringBuilder res=new StringBuilder();\\n        while(!pq.isEmpty()){\\n            Map.Entry<Character, Integer> ele = pq.poll();\\n            int i=ele.getValue();\\n            while(i>0){\\n                res.append(ele.getKey());\\n                i--;\\n            }\\n        }\\n        return res.toString();\\n        \\n    }\\n}\\n```\\n- Please upvote if you like the explanation and if i did any mistake then please correct me in comment\\'s.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```Which will sort to the pair according to character frequency.```\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap<Character, Integer> map=new HashMap<>();\\n        for(char x: s.toCharArray()) map.put(x, map.getOrDefault(x, 0)+1);\\n        PriorityQueue<Map.Entry<Character, Integer>> pq =new PriorityQueue<Map.Entry<Character, Integer>>((e1, e2) -> e2.getValue()-e1.getValue());\\n        pq.addAll(map.entrySet());\\n        StringBuilder res=new StringBuilder();\\n        while(!pq.isEmpty()){\\n            Map.Entry<Character, Integer> ele = pq.poll();\\n            int i=ele.getValue();\\n            while(i>0){\\n                res.append(ele.getKey());\\n                i--;\\n            }\\n        }\\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871562,
                "title": "c-stl-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nbool cmp(pair<char, int>& a,pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n    map<char,int> f;\\n\\n    for(auto val:s)\\n    {\\n          f[val]++;\\n    } \\n      string ans;\\n      vector<pair<char, int> > A;\\n      for (auto& it : f) {\\n        A.push_back(it);\\n    }\\n\\n    sort(A.begin(), A.end(), cmp);\\n    for(auto val:A)\\n    {\\n          for(int i=0;i<val.second;i++)\\n          ans+=val.first;\\n    }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool cmp(pair<char, int>& a,pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n    map<char,int> f;\\n\\n    for(auto val:s)\\n    {\\n          f[val]++;\\n    } \\n      string ans;\\n      vector<pair<char, int> > A;\\n      for (auto& it : f) {\\n        A.push_back(it);\\n    }\\n\\n    sort(A.begin(), A.end(), cmp);\\n    for(auto val:A)\\n    {\\n          for(int i=0;i<val.second;i++)\\n          ans+=val.first;\\n    }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871525,
                "title": "easy-c-and-c-solution-priority-queue-and-hash-map",
                "content": "# Intuition\\nStore the character frequency by using map.\\nSort the character according to their frequency by using priority queue and pair\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int>mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        priority_queue<pair<int,char>>pq;\\n        for(auto x:mp){\\n            pq.push({x.second,x.first});\\n        }\\n        string ans=\"\";\\n        while(!pq.empty()){\\n            int d=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=0;i<d;i++){\\n                ans+=c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int>mp;\\n        for(auto x:s){\\n            mp[x]++;\\n        }\\n        priority_queue<pair<int,char>>pq;\\n        for(auto x:mp){\\n            pq.push({x.second,x.first});\\n        }\\n        string ans=\"\";\\n        while(!pq.empty()){\\n            int d=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=0;i<d;i++){\\n                ans+=c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521544,
                "title": "python-one-line-solution-list-comprehension-and-counter",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \"\".join(x[0] * x[1] for x in Counter(s).most_common())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \"\".join(x[0] * x[1] for x in Counter(s).most_common())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482997,
                "title": "javascript-simple-map-solution-faster-than-72-74-less-than-81-60",
                "content": "```\\nconst frequencySort = s => {\\n    const map = new Map();\\n    \\n    for (const letter of String(s)) {\\n        map.set(letter, (map.get(letter) ?? 0) + 1);\\n    }\\n   \\n    return [...map].sort((a,b) => b[1] - a[1])\\n                   .reduce((acc, [letter, freq]) => acc + letter.repeat(freq), \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst frequencySort = s => {\\n    const map = new Map();\\n    \\n    for (const letter of String(s)) {\\n        map.set(letter, (map.get(letter) ?? 0) + 1);\\n    }\\n   \\n    return [...map].sort((a,b) => b[1] - a[1])\\n                   .reduce((acc, [letter, freq]) => acc + letter.repeat(freq), \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434488,
                "title": "well-commented-c-solution-faster-than-100-hashmap-and-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        string ans = \"\";\\n        //store characters and their frequency in hashmap\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        //make a  max heap (max priority queue) of pairs and sort by max frequency in heap using pairs\\n        priority_queue<pair<int,char>> pq;\\n        for(auto i: mp)\\n        {\\n            pq.push({i.second,i.first});\\n        }\\n        //push characters to string till max heap is not empty \\n        while(!pq.empty())\\n        {\\n            int n = pq.top().first;\\n            while(n--)\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        string ans = \"\";\\n        //store characters and their frequency in hashmap\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        //make a  max heap (max priority queue) of pairs and sort by max frequency in heap using pairs\\n        priority_queue<pair<int,char>> pq;\\n        for(auto i: mp)\\n        {\\n            pq.push({i.second,i.first});\\n        }\\n        //push characters to string till max heap is not empty \\n        while(!pq.empty())\\n        {\\n            int n = pq.top().first;\\n            while(n--)\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536931,
                "title": "2-c-soln-using-map-using-pair-of-vector",
                "content": "Using vector of pair\\n```\\nclass Solution {\\npublic:\\n    int check(vector<pair<int , char>> vect , char ch)\\n    {\\n        for(int index = 0 ; index < vect.size() ; index++)\\n        {\\n            if(vect[index].second == ch)\\n                return index;\\n        }\\n        return -1;\\n    }\\n    \\n    string frequencySort(string s) {\\n        \\n        vector<pair<int,char>> vect;\\n        int pos;\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n         {\\n            pos = check(vect , s[index]);\\n            \\n            if(pos == -1)\\n            {\\n                pair<int ,char> p ;\\n                p.first = 1;\\n                p.second = s[index];\\n                vect.push_back(p);\\n            }\\n            \\n            else\\n                vect[pos].first++;\\n         }\\n        sort(vect.begin() , vect.end());\\n        \\n        string ans = \"\";\\n        for(int it = vect.size() - 1 ; it >= 0 ; it--)\\n        {\\n            for(int index = 0 ; index < vect[it].first ; index++)\\n            {\\n                ans += vect[it].second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nUsing maps\\n```\\nclass Solution {\\npublic:\\n  int find(vector<int> &mp){\\n      int i, maxF = INT_MIN, idx;\\n      for(i = 0; i < mp.size(); i++){\\n        if(mp[i] > maxF){\\n          maxF = mp[i];\\n          idx = i;\\n        }\\n      }\\n      return idx;\\n    }\\n  \\n    string frequencySort(string s) {\\n        \\n      vector<int> mp(128, 0);\\n      for(auto it : s) mp[it]++;\\n      string ans = \"\";\\n      while(ans.size() != s.size())\\n      {\\n        int idx = find(mp);\\n        for(int i = 0; i < mp[idx]; i++)\\n          ans.push_back(char(idx));\\n        mp[idx] = 0;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<pair<int , char>> vect , char ch)\\n    {\\n        for(int index = 0 ; index < vect.size() ; index++)\\n        {\\n            if(vect[index].second == ch)\\n                return index;\\n        }\\n        return -1;\\n    }\\n    \\n    string frequencySort(string s) {\\n        \\n        vector<pair<int,char>> vect;\\n        int pos;\\n        \\n        for(int index = 0 ; index < s.size() ; index++)\\n         {\\n            pos = check(vect , s[index]);\\n            \\n            if(pos == -1)\\n            {\\n                pair<int ,char> p ;\\n                p.first = 1;\\n                p.second = s[index];\\n                vect.push_back(p);\\n            }\\n            \\n            else\\n                vect[pos].first++;\\n         }\\n        sort(vect.begin() , vect.end());\\n        \\n        string ans = \"\";\\n        for(int it = vect.size() - 1 ; it >= 0 ; it--)\\n        {\\n            for(int index = 0 ; index < vect[it].first ; index++)\\n            {\\n                ans += vect[it].second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int find(vector<int> &mp){\\n      int i, maxF = INT_MIN, idx;\\n      for(i = 0; i < mp.size(); i++){\\n        if(mp[i] > maxF){\\n          maxF = mp[i];\\n          idx = i;\\n        }\\n      }\\n      return idx;\\n    }\\n  \\n    string frequencySort(string s) {\\n        \\n      vector<int> mp(128, 0);\\n      for(auto it : s) mp[it]++;\\n      string ans = \"\";\\n      while(ans.size() != s.size())\\n      {\\n        int idx = find(mp);\\n        for(int i = 0; i < mp[idx]; i++)\\n          ans.push_back(char(idx));\\n        mp[idx] = 0;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534390,
                "title": "python-heapq-hashmap-simple-solution",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        hashmap = {}\\n        for char in s:\\n            if char in hashmap:\\n                hashmap[char] += 1\\n            else:\\n                hashmap[char] = 1\\n        \\n        arr = []\\n        heapq.heapify(arr)\\n        for key in hashmap:\\n            heapq.heappush(arr, [-hashmap[key], key])\\n        \\n        output = []\\n        while arr:\\n            val, item = heapq.heappop(arr)\\n            output += ([item] * (-val))\\n        return output\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        hashmap = {}\\n        for char in s:\\n            if char in hashmap:\\n                hashmap[char] += 1\\n            else:\\n                hashmap[char] = 1\\n        \\n        arr = []\\n        heapq.heapify(arr)\\n        for key in hashmap:\\n            heapq.heappush(arr, [-hashmap[key], key])\\n        \\n        output = []\\n        while arr:\\n            val, item = heapq.heappop(arr)\\n            output += ([item] * (-val))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334655,
                "title": "javascript-js-using-priority-queue",
                "content": "@datastructures-js/priority-queue\\n```\\nvar frequencySort = function(s) {\\n    let map = new Map();\\n    const pq = new MaxPriorityQueue();\\n    \\n    for (let c of s){\\n        if (map.has(c)) map.set(c, map.get(c) + 1);\\n        else map.set(c, 1);\\n    }\\n\\n    map.forEach((value, key) => pq.enqueue(key, value));\\n\\n    let ans = \"\";\\n    while(!pq.isEmpty()){\\n        let elem = pq.dequeue();\\n        ans += elem.element.repeat(elem.priority);\\n    }\\n    return ans;\\n };\\n```",
                "solutionTags": [],
                "code": "```\\nvar frequencySort = function(s) {\\n    let map = new Map();\\n    const pq = new MaxPriorityQueue();\\n    \\n    for (let c of s){\\n        if (map.has(c)) map.set(c, map.get(c) + 1);\\n        else map.set(c, 1);\\n    }\\n\\n    map.forEach((value, key) => pq.enqueue(key, value));\\n\\n    let ans = \"\";\\n    while(!pq.isEmpty()){\\n        let elem = pq.dequeue();\\n        ans += elem.element.repeat(elem.priority);\\n    }\\n    return ans;\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 681988,
                "title": "o-n-solution-almost-100",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        if(s.length() < ) return s;\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) +1);\\n        }\\n        \\n        int maxFrequency = Collections.max(map.values());\\n        \\n        List<List<Character>> list = new ArrayList<List<Character>>();\\n        for(int i = 0; i < maxFrequency; i++) {\\n            list.add(new ArrayList<Character>());\\n        }\\n        \\n        for(char i : map.keySet()) {\\n            int frequency = map.get(i);\\n            list.get(frequency -1).add(i);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for(int i = list.size() -1; i >= 0; i--) {\\n            int size = list.get(i).size();\\n            for(int j = 0; j < size; j++) {\\n                char letter = list.get(i).get(j);\\n                int freq = i;\\n                while (freq >= 0) {\\n                    result.append(letter);\\n                    freq--;\\n                }   \\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        if(s.length() < ) return s;\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) +1);\\n        }\\n        \\n        int maxFrequency = Collections.max(map.values());\\n        \\n        List<List<Character>> list = new ArrayList<List<Character>>();\\n        for(int i = 0; i < maxFrequency; i++) {\\n            list.add(new ArrayList<Character>());\\n        }\\n        \\n        for(char i : map.keySet()) {\\n            int frequency = map.get(i);\\n            list.get(frequency -1).add(i);\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for(int i = list.size() -1; i >= 0; i--) {\\n            int size = list.get(i).size();\\n            for(int j = 0; j < size; j++) {\\n                char letter = list.get(i).get(j);\\n                int freq = i;\\n                while (freq >= 0) {\\n                    result.append(letter);\\n                    freq--;\\n                }   \\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646245,
                "title": "go-beats-100-100",
                "content": "```go\\nimport \"strings\"\\nimport \"sort\"\\n\\ntype Fr struct {\\n    Ch rune\\n    Fr int\\n}\\n\\ntype Frs []Fr\\n\\nfunc (this Frs) Len() int { return len(this) }\\n\\nfunc (this Frs) Less(a, b int) bool { return this[a].Fr > this[b].Fr }\\n\\nfunc (this Frs) Swap(a, b int) { this[a], this[b] = this[b], this[a] }\\n\\nfunc frequencySort(s string) string {\\n    a, b := make([]Fr, 256), strings.Builder{}\\n    \\n    for _, v := range s {\\n        a[v].Ch = v\\n        a[v].Fr++\\n    }\\n    \\n    sort.Sort(Frs(a))\\n    \\n    for _, v := range a {\\n        b.WriteString(strings.Repeat(string(v.Ch), v.Fr))\\n    }\\n    \\n    return b.String()\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nimport \"strings\"\\nimport \"sort\"\\n\\ntype Fr struct {\\n    Ch rune\\n    Fr int\\n}\\n\\ntype Frs []Fr\\n\\nfunc (this Frs) Len() int { return len(this) }\\n\\nfunc (this Frs) Less(a, b int) bool { return this[a].Fr > this[b].Fr }\\n\\nfunc (this Frs) Swap(a, b int) { this[a], this[b] = this[b], this[a] }\\n\\nfunc frequencySort(s string) string {\\n    a, b := make([]Fr, 256), strings.Builder{}\\n    \\n    for _, v := range s {\\n        a[v].Ch = v\\n        a[v].Fr++\\n    }\\n    \\n    sort.Sort(Frs(a))\\n    \\n    for _, v := range a {\\n        b.WriteString(strings.Repeat(string(v.Ch), v.Fr))\\n    }\\n    \\n    return b.String()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 645991,
                "title": "easy-to-understand-java-clean-code-faster-than-98-26-well-commented-code",
                "content": "class Solution {\\n    public String frequencySort(String s) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        int[] count = new int[128];\\n        \\n\\t\\t// Recording frequency of each character\\n        for(char c : s.toCharArray()) {\\n            count[c]++;\\n        }\\n        \\n\\t\\t// Adding all the frequencies in the list\\n        for(int i = 0; i < 128; i++) {\\n            if(count[i] != 0)\\n                list.add(count[i]);\\n        }\\n        \\n\\t\\t// Arrange the list in decreasing order\\n        Collections.sort(list,Collections.reverseOrder());\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\t// ArrayList to Integer Array\\n        Integer[] arr = new Integer[list.size()];\\n        arr = list.toArray(arr); list.clear();\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            int max = arr[i];\\n\\t\\t\\t\\n            for(int j = 0; j < 128; j++) {\\n                if(count[j] == max) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Append character count[j] times\\n                    while(count[j]-- > 0) {\\n                        sb = sb.append((char) j);\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String frequencySort(String s) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        int[] count = new int[128];\\n        \\n\\t\\t// Recording frequency of each character\\n        for(char c : s.toCharArray()) {\\n            count[c]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 645235,
                "title": "scala-2-lines-using-hashmap",
                "content": "```\\nobject Solution {\\n    def frequencySort(s: String): String = {\\n        val map = scala.collection.mutable.HashMap[Char, Int]()\\n\\t\\t\\n\\t//build the map with frequency key value pair\\n    for (i <- s) if (map contains i) map update(i, map(i) + 1) else map put(i, 1)\\n\\t\\n\\t//apply descending sort by \\'value\\'(frequency count) and build the string with number of occurances  , and mege all list of strings to one string (mkString)\\n\\tmap.toList.sortBy(-_._2).map(x => x._1.toString * x._2).mkString\\n\\n    }\\n\\t\\n\\t//Approach 2 - one-liner\\n\\t\\n\\tdef frequencySortFunctional(s: String): String = \\n\\ts.groupBy(identity).toList .sortBy(- _._2.length).map(_._2.mkString) .mkString\\n  \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def frequencySort(s: String): String = {\\n        val map = scala.collection.mutable.HashMap[Char, Int]()\\n\\t\\t\\n\\t//build the map with frequency key value pair\\n    for (i <- s) if (map contains i) map update(i, map(i) + 1) else map put(i, 1)\\n\\t\\n\\t//apply descending sort by \\'value\\'(frequency count) and build the string with number of occurances  , and mege all list of strings to one string (mkString)\\n\\tmap.toList.sortBy(-_._2).map(x => x._1.toString * x._2).mkString\\n\\n    }\\n\\t\\n\\t//Approach 2 - one-liner\\n\\t\\n\\tdef frequencySortFunctional(s: String): String = \\n\\ts.groupBy(identity).toList .sortBy(- _._2.length).map(_._2.mkString) .mkString\\n  \\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 645148,
                "title": "java-hashmap-priorityqueue",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        \\n        if(s == null || s.length() == 0) return \"\";\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(\\n          (a, b) -> b.getValue() - a.getValue()\\n        );\\n        \\n        for(char ch: s.toCharArray()){\\n            \\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for(Map.Entry<Character, Integer> entry : map.entrySet()){\\n            \\n            pq.offer(entry);\\n        }\\n        \\n        char[] arr = new char[s.length()];\\n        \\n        int count = 0;\\n        \\n        while(!pq.isEmpty()){\\n            \\n            Map.Entry<Character, Integer> entry = pq.poll();\\n            \\n            char ch = entry.getKey();\\n            \\n            for(int i = 0; i < entry.getValue(); i++){\\n                \\n                arr[count++] = ch;\\n            }\\n        }\\n        \\n        return new String(arr);    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        \\n        if(s == null || s.length() == 0) return \"\";\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(\\n          (a, b) -> b.getValue() - a.getValue()\\n        );\\n        \\n        for(char ch: s.toCharArray()){\\n            \\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for(Map.Entry<Character, Integer> entry : map.entrySet()){\\n            \\n            pq.offer(entry);\\n        }\\n        \\n        char[] arr = new char[s.length()];\\n        \\n        int count = 0;\\n        \\n        while(!pq.isEmpty()){\\n            \\n            Map.Entry<Character, Integer> entry = pq.poll();\\n            \\n            char ch = entry.getKey();\\n            \\n            for(int i = 0; i < entry.getValue(); i++){\\n                \\n                arr[count++] = ch;\\n            }\\n        }\\n        \\n        return new String(arr);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645127,
                "title": "c-using-stl-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> m;\\n        for(auto i: s) {\\n            m[i]++;\\n        }\\n        sort(s.begin(), s.end(), [&m](char a, char b) -> bool {\\n           if(m[a] == m[b]) {\\n               return a < b;\\n           } \\n           return m[a] > m[b];\\n        });\\n        return s;\\n    }\\n};\\n```\\nAnother solution - Runs Faster\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> m;\\n        for(auto i: s) {\\n            m[i]++;\\n        }\\n        vector<pair<char, int>> v;\\n        for(auto i: m) {\\n            v.push_back({i.first, i.second});\\n        }\\n        sort(v.begin(), v.end(), [&](pair<char, int> a, pair<char, int> b) -> bool {\\n           if(a.second == b.second) {\\n               return a.first < b.second;\\n           } \\n           return a.second > b.second;\\n        });\\n        string x;\\n        for(auto i: v) {\\n            for(int j=0;j<i.second;j++) {\\n                x += i.first;   \\n            }\\n        }\\n        return x;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char, int> m;\\n        for(auto i: s) {\\n            m[i]++;\\n        }\\n        sort(s.begin(), s.end(), [&m](char a, char b) -> bool {\\n           if(m[a] == m[b]) {\\n               return a < b;\\n           } \\n           return m[a] > m[b];\\n        });\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645101,
                "title": "straightforward-java-beats-99",
                "content": "* Keep a counts array of size 128 to handle a-zA-Z characters\\n* Keep a max heap of frequencies of these characters\\n* Keep appending most frequent character while PQ is not empty x number of times where x is the frequency of that character\\n```\\n    public String frequencySort(String s) {\\n        int[] counts = new int[128];\\n        for (char c : s.toCharArray()) {\\n            counts[c]++;\\n        }\\n        PriorityQueue<Character> pq = new PriorityQueue<>((a,b) -> counts[b] - counts[a]);  \\n        for (int i = 0; i < 128; i++) {\\n            if (counts[i] != 0) {\\n                pq.add((char) i);    \\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            char c = pq.poll();\\n            for (int i = 0; i < counts[c]; i++) {\\n                sb.append(c);   \\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\nT: O(nlgk) where n is the length of the string and k is the number of distinct characters in the string\\nBut since k can be 26 at max, T: O(nlg26) == O(n)\\nS: O(n) where n is the length of the string",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public String frequencySort(String s) {\\n        int[] counts = new int[128];\\n        for (char c : s.toCharArray()) {\\n            counts[c]++;\\n        }\\n        PriorityQueue<Character> pq = new PriorityQueue<>((a,b) -> counts[b] - counts[a]);  \\n        for (int i = 0; i < 128; i++) {\\n            if (counts[i] != 0) {\\n                pq.add((char) i);    \\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (!pq.isEmpty()) {\\n            char c = pq.poll();\\n            for (int i = 0; i < counts[c]; i++) {\\n                sb.append(c);   \\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 644935,
                "title": "c-simple-huhu",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n        priority_queue<pair<int,char>>pq;\\n        for(auto x:mp)\\n        pq.push({x.second,x.first});\\n        string st=\"\";\\n        while(!pq.empty())\\n        {\\n            pair<int,char>x=pq.top();\\n            int temp=x.first;\\n            while(temp--)\\n            st+=x.second;\\n            pq.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n        priority_queue<pair<int,char>>pq;\\n        for(auto x:mp)\\n        pq.push({x.second,x.first});\\n        string st=\"\";\\n        while(!pq.empty())\\n        {\\n            pair<int,char>x=pq.top();\\n            int temp=x.first;\\n            while(temp--)\\n            st+=x.second;\\n            pq.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615486,
                "title": "javascript-solution-beats-99",
                "content": "Runtime: 52 ms, faster than 99.82% of JavaScript online submissions for Sort Characters By Frequency.\\nMemory Usage: 36.4 MB, less than 84.62% of JavaScript online submissions for Sort Characters By Frequency.\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    let result = \"\"\\n    \\n    const mappings = createMappings(s)\\n    const keys = Object.keys(mappings)\\n    const sorted = keys.sort((a, b) => mappings[b] - mappings[a])\\n    \\n    for (const val of sorted) {\\n        result += val.repeat(mappings[val])\\n    }\\n    \\n    return result\\n};\\n\\nconst createMappings = (word) => {\\n    const mappings = {}\\n    \\n    for (const char of word) {\\n       mappings[char] = mappings[char] + 1 || 1\\n    }\\n    \\n    return mappings\\n}\\n```\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    const hmap = {}\\n    for (let i = 0; i < s.length; i++) {\\n        const char = s.charAt(i)\\n        hmap[char] = hmap[char] + 1 || 1\\n    }\\n    const sorted = Object.keys(hmap).sort((a, b) => hmap[b] - hmap[a])\\n    let result = \\'\\'\\n    for (let i = 0; i < sorted.length; i++) {\\n        const char = sorted[i]\\n        result += char.repeat(hmap[char])\\n    }\\n    return  result\\n};\\n```\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    let mappings = {}, split = s.split(\\'\\')\\n    for (const char of s) {\\n        mappings[char] = mappings[char] + 1 || 1\\n    }\\n    \\n    split = split.sort((a, b) => {\\n        const isSimilar = mappings[b] === mappings[a]\\n        const diff = mappings[b] - mappings[a]\\n        return !isSimilar ? diff : a.localeCompare(b)\\n    })\\n    \\n    return split.join(\\'\\')\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    let result = \"\"\\n    \\n    const mappings = createMappings(s)\\n    const keys = Object.keys(mappings)\\n    const sorted = keys.sort((a, b) => mappings[b] - mappings[a])\\n    \\n    for (const val of sorted) {\\n        result += val.repeat(mappings[val])\\n    }\\n    \\n    return result\\n};\\n\\nconst createMappings = (word) => {\\n    const mappings = {}\\n    \\n    for (const char of word) {\\n       mappings[char] = mappings[char] + 1 || 1\\n    }\\n    \\n    return mappings\\n}\\n```\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    const hmap = {}\\n    for (let i = 0; i < s.length; i++) {\\n        const char = s.charAt(i)\\n        hmap[char] = hmap[char] + 1 || 1\\n    }\\n    const sorted = Object.keys(hmap).sort((a, b) => hmap[b] - hmap[a])\\n    let result = \\'\\'\\n    for (let i = 0; i < sorted.length; i++) {\\n        const char = sorted[i]\\n        result += char.repeat(hmap[char])\\n    }\\n    return  result\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar frequencySort = function(s) {\\n    let mappings = {}, split = s.split(\\'\\')\\n    for (const char of s) {\\n        mappings[char] = mappings[char] + 1 || 1\\n    }\\n    \\n    split = split.sort((a, b) => {\\n        const isSimilar = mappings[b] === mappings[a]\\n        const diff = mappings[b] - mappings[a]\\n        return !isSimilar ? diff : a.localeCompare(b)\\n    })\\n    \\n    return split.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462686,
                "title": "c-beats-100-on-runtime-vector-based-solution-with-explanation",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n\\t// There are 255 characters in the ASCII table. The first character is static_cast<char>(0)\\n        vector<pair<char, int>> ourMapping(255, {static_cast<char>(0), 0});\\n\\t\\t// Here I\\'m making a frequency count of the entire ascii table. The frequency of\\n\\t\\t// each letter starts at 0.\\n        for (int i{}; i < 255; ++i) {\\n            ourMapping[i].first += i;\\n        }\\n        // Updating the frequency count of the mapping I just made.\\n        for (int i{}; i < s.size(); ++i) {\\n            ourMapping[s[i] - static_cast<char>(0)].second++;\\n        }\\n        // Sorting the ASCII table by frequency.\\n\\t\\t// Most frequent characters first in the vector. For example, if you have \"Abbb\"\\n\\t\\t// <b, 3> <A, 1> <ANOTHER LETTER, 0> <ANOTHER LETTER, 0>...\\n        sort(ourMapping.begin(), ourMapping.end(), [](const pair<char, int>& A, const pair<char, int>& B){\\n            return A.second > B.second;\\n        });\\n        \\n        string returnStr;\\n        \\n      // Recreating the ascii table frequency vector in string form.\\n        for (int i{}; i < ourMapping.size(); ++i) {\\n            if (ourMapping[i].second) {\\n\\t\\t\\t// string constructor overload is used to create a string of uniform characters.\\n\\t\\t\\t// For instance, string(4, \\'*\\') creates \"****\", string(2, \\'A\\') created string \"AA\" \\n                returnStr += string(ourMapping[i].second, ourMapping[i].first);\\n            }\\n        }\\n        \\n        return returnStr;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n\\t// There are 255 characters in the ASCII table. The first character is static_cast<char>(0)\\n        vector<pair<char, int>> ourMapping(255, {static_cast<char>(0), 0}",
                "codeTag": "Java"
            },
            {
                "id": 431819,
                "title": "python-2-approaches-maxheap-bucket-sort-2-approaches-for-follow-up",
                "content": "**1. HashTable + MaxHeap**\\n* Time: O(NlogN)\\n* Space: O(N)\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        if not s: return \\'\\'\\n        maxHeap = []\\n        for i, c in collections.Counter(s).items():\\n            heapq.heappush(maxHeap, (-c, i))\\n        s = \\'\\'\\n        while maxHeap:\\n            c, i = heapq.heappop(maxHeap)\\n            for _ in range(-c):\\n                s += i\\n        return s\\n```\\n\\n**2. HashTable + Bucket Sort**\\n* Time: O(N)  \\n* Space: O(N^2) \\n\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        bucket = [[] for _ in range(len(s) + 1)] # Error1: len should be len(s) + 1\\n        for ch, freq in collections.Counter(s).items():\\n            bucket[freq].append(ch)\\n        res = \\'\\'\\n        for i, lst in enumerate(bucket):\\n            if len(lst): \\n                for l in lst:\\n                    res += i * l\\n        return res[::-1]\\n```\\n\\n**3. most_common()**\\n\\nReturn a list of the n most common elements and their counts from the most common to the least. If n is omitted or None, most_common() returns all elements in the counter. Elements with equal counts are ordered arbitrarily, so this **doesn\\'t work for the follow-up question**\\n\\n* Time: O(NlogN)\\n* Space: O(N)\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \\'\\'.join([char * times for char, times in collections.Counter(s).most_common()])\\n```\\n----------\\n**Follow-up: what if the characters are sorted alphabetically if the characters have the same frequency ?**\\n\\n**1.  wrapper class & overwrite lt, eq comparables**\\n* Time: O(NlogN)\\n* Space: O(N)\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        class Element:\\n            def __init__(self, freq, ch):\\n                self.freq = freq\\n                self.ch = ch    \\n            def __lt__(self, other):\\n                return self.freq < other.freq or (self.freq == other.freq and self.ch > other.ch)\\n            def __eq__(self, other):\\n                return self.freq == other.freq and self.ch == other.ch\\n        k = len(set(s))\\n        pq = [Element(float(\\'-inf\\'), \\'\\') for _ in range(k)]\\n        for ch, freq in collections.Counter(s).items():\\n            heapq.heappushpop(pq, Element(freq, ch))   \\n        res = \\'\\'\\n        while pq:\\n            elem = heapq.heappop(pq)\\n            res += elem.freq * elem.ch\\n        return res[::-1]\\n```\\n\\n**2. heapq.nlargest()**\\n* Time: O(NlogN)\\n* Space: O(N)\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        count = collections.Counter(s)\\n        k = len(count)\\n        res = \\'\\'\\n        for ch in heapq.nsmallest(k, count, key = lambda ch: (~count[ch], ch)):\\n            res += ch * count[ch]\\n        return res\\n```\\n\\n```\\ninput \"treeccaa\"\\nOutput \"aacceert\"\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        if not s: return \\'\\'\\n        maxHeap = []\\n        for i, c in collections.Counter(s).items():\\n            heapq.heappush(maxHeap, (-c, i))\\n        s = \\'\\'\\n        while maxHeap:\\n            c, i = heapq.heappop(maxHeap)\\n            for _ in range(-c):\\n                s += i\\n        return s\\n```\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        bucket = [[] for _ in range(len(s) + 1)] # Error1: len should be len(s) + 1\\n        for ch, freq in collections.Counter(s).items():\\n            bucket[freq].append(ch)\\n        res = \\'\\'\\n        for i, lst in enumerate(bucket):\\n            if len(lst): \\n                for l in lst:\\n                    res += i * l\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        return \\'\\'.join([char * times for char, times in collections.Counter(s).most_common()])\\n```\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        class Element:\\n            def __init__(self, freq, ch):\\n                self.freq = freq\\n                self.ch = ch    \\n            def __lt__(self, other):\\n                return self.freq < other.freq or (self.freq == other.freq and self.ch > other.ch)\\n            def __eq__(self, other):\\n                return self.freq == other.freq and self.ch == other.ch\\n        k = len(set(s))\\n        pq = [Element(float(\\'-inf\\'), \\'\\') for _ in range(k)]\\n        for ch, freq in collections.Counter(s).items():\\n            heapq.heappushpop(pq, Element(freq, ch))   \\n        res = \\'\\'\\n        while pq:\\n            elem = heapq.heappop(pq)\\n            res += elem.freq * elem.ch\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        count = collections.Counter(s)\\n        k = len(count)\\n        res = \\'\\'\\n        for ch in heapq.nsmallest(k, count, key = lambda ch: (~count[ch], ch)):\\n            res += ch * count[ch]\\n        return res\\n```\n```\\ninput \"treeccaa\"\\nOutput \"aacceert\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255545,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> count = new HashMap();\\n        \\n        for (char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> heap = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        \\n        heap.addAll(count.entrySet());\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!heap.isEmpty()) {\\n            Map.Entry<Character, Integer> entry = heap.poll();\\n            for (int i = 0; i < entry.getValue(); ++i) {\\n                sb.append(entry.getKey());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        Map<Character, Integer> count = new HashMap();\\n        \\n        for (char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        PriorityQueue<Map.Entry<Character, Integer>> heap = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n        \\n        heap.addAll(count.entrySet());\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!heap.isEmpty()) {\\n            Map.Entry<Character, Integer> entry = heap.poll();\\n            for (int i = 0; i < entry.getValue(); ++i) {\\n                sb.append(entry.getKey());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237787,
                "title": "java-solutions",
                "content": "**Solution 1: Using HashMap and maxHeap - Accepted in 63 ms**\\n\\nTime complexity: `O(n log k)` - where `k` is the size of `maxHeap`. Insertion and removal of each element from `maxHeap` will take `2 * log k` time.\\nSpace Complexity: `O(n + k)` - space required for `HashMap` and `maxHeap`.\\n\\n```\\nclass Solution\\n{\\n    public String frequencySort(String s)\\n\\t{\\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n\\t\\tMap<Character, Integer> charCountMap = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t\\tcharCountMap.put(c, charCountMap.getOrDefault(c, 0) + 1);\\n\\n        maxHeap.addAll(charCountMap.entrySet());\\n\\n        while(!maxHeap.isEmpty())\\n\\t\\t{\\n\\t\\t\\tMap.Entry<Character, Integer> entry = maxHeap.poll();\\n            int charCount = entry.getValue();\\n            \\n\\t\\t\\twhile(charCount-- > 0)\\n\\t\\t\\t\\tsb.append(entry.getKey());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Solution 2: Using Character Array - Accepted in 5 ms**\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(1)` - Not considering the space required for `StringBuilder` to store the output\\n\\n```\\nclass Solution\\n{\\n    public String frequencySort(String s)\\n\\t{\\n\\t\\tchar[] charCount = new char[128];\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n        for(char c : s.toCharArray())\\n\\t\\t\\tcharCount[c]++;\\n\\n\\t\\twhile(sb.length() < s.length())\\n\\t\\t{\\n            char maxChar = 0;\\n            \\n\\t\\t\\tfor(char curChar = 0; curChar < charCount.length; curChar++)\\n\\t\\t\\t{\\n                if(charCount[curChar] > charCount[maxChar])\\n\\t\\t\\t\\t\\tmaxChar = curChar;\\n            }\\n            \\n\\t\\t\\twhile(charCount[maxChar] > 0)\\n            {\\n                sb.append(maxChar);\\n                charCount[maxChar]--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String frequencySort(String s)\\n\\t{\\n        PriorityQueue<Map.Entry<Character, Integer>> maxHeap = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\\n\\t\\tMap<Character, Integer> charCountMap = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t\\tcharCountMap.put(c, charCountMap.getOrDefault(c, 0) + 1);\\n\\n        maxHeap.addAll(charCountMap.entrySet());\\n\\n        while(!maxHeap.isEmpty())\\n\\t\\t{\\n\\t\\t\\tMap.Entry<Character, Integer> entry = maxHeap.poll();\\n            int charCount = entry.getValue();\\n            \\n\\t\\t\\twhile(charCount-- > 0)\\n\\t\\t\\t\\tsb.append(entry.getKey());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public String frequencySort(String s)\\n\\t{\\n\\t\\tchar[] charCount = new char[128];\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n        for(char c : s.toCharArray())\\n\\t\\t\\tcharCount[c]++;\\n\\n\\t\\twhile(sb.length() < s.length())\\n\\t\\t{\\n            char maxChar = 0;\\n            \\n\\t\\t\\tfor(char curChar = 0; curChar < charCount.length; curChar++)\\n\\t\\t\\t{\\n                if(charCount[curChar] > charCount[maxChar])\\n\\t\\t\\t\\t\\tmaxChar = curChar;\\n            }\\n            \\n\\t\\t\\twhile(charCount[maxChar] > 0)\\n            {\\n                sb.append(maxChar);\\n                charCount[maxChar]--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139812,
                "title": "clean-python-solution-heap",
                "content": "```\\ndef frequencySort(self, s):\\n\\tfrom collections import Counter\\n\\tfrom collections import namedtuple\\n\\timport heapq\\n\\n\\tCharOccurence = namedtuple(\\'CharOccurence\\', \\'frequency character\\')\\n\\n\\toutput = \\'\\'\\n\\td = Counter(s)\\n\\theap = []  \\n\\n\\tfor ch, freq in d.items():\\n\\t\\t\\theapq.heappush(heap, CharOccurence(-freq, ch))        \\n\\n\\twhile heap:\\n\\t\\t\\tnext_occurence = heapq.heappop(heap)            \\n\\t\\t\\toutput += next_occurence.character * abs(next_occurence.frequency)\\n\\n\\treturn output\\n```\\n\\nHad some fun with libraries.\\nTime: `O(n + u*log(u))`\\nSpace: `O(u)`\\n\\nWhere `u` is the number of unique characters.\\n\\nNote: just as easy to sort the keys in dict instead of using a heap.",
                "solutionTags": [],
                "code": "```\\ndef frequencySort(self, s):\\n\\tfrom collections import Counter\\n\\tfrom collections import namedtuple\\n\\timport heapq\\n\\n\\tCharOccurence = namedtuple(\\'CharOccurence\\', \\'frequency character\\')\\n\\n\\toutput = \\'\\'\\n\\td = Counter(s)\\n\\theap = []  \\n\\n\\tfor ch, freq in d.items():\\n\\t\\t\\theapq.heappush(heap, CharOccurence(-freq, ch))        \\n\\n\\twhile heap:\\n\\t\\t\\tnext_occurence = heapq.heappop(heap)            \\n\\t\\t\\toutput += next_occurence.character * abs(next_occurence.frequency)\\n\\n\\treturn output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 93540,
                "title": "6-line-c-simple-solution-to-sort-char-frequencies-with-map-int-string-detailed-explanation-with-time-space-analysis",
                "content": "The idea is straightforward:\\n1. Get char frequencies of the given string `s` as `unordered_map<char,int> freq`;\\n2. Sort `freq` by values (i.e., frequencies) as `map<int, string> sortFreq`;\\n3. Create final sorted string `res` from `sortFreq`.\\n\\n**Time Complexity:** Obviously, steps 1 and 3 cost `O(N)` time. Step 2 costs `O(N logM)` time, where `M` is the distinct number of char frequencies in `s`. It is easy to derive that `M = O(sqrt(N))`, so the overall time complexity is `O(N logN)`.\\n\\n**Space Complexity:** Obviously, Step 3 to create the final string uses `O(N)` space no matter what algorithm you are choosing. Let's look at only Steps 1 and 2.\\n* `freq.size()` is number of distinct chars in `s` (worst case `O(char set size)`);\\n* `sortFreq.size()` is number of distinct char frequencies in `s` (worst case `O(sqrt(N))`).\\n\\nNote that both of those sizes above could be much less than `N` (i.e., `s.size()`).\\n```\\n    string frequencySort(string& s) {\\n      // get char frequencies of s\\n      unordered_map<char,int> freq; for (char c:s) freq[c]++;\\n      // sort frequencies\\n      map<int, string> sortFreq; for (auto& p:freq) sortFreq[p.second] += p.first;\\n      \\n      string res; // create sorted string\\n      for (auto it = sortFreq.rbegin(); it != sortFreq.rend(); ++it)\\n        for (char c:it->second) res.append(it->first, c);\\n      return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string frequencySort(string& s) {\\n      // get char frequencies of s\\n      unordered_map<char,int> freq; for (char c:s) freq[c]++;\\n      // sort frequencies\\n      map<int, string> sortFreq; for (auto& p:freq) sortFreq[p.second] += p.first;\\n      \\n      string res; // create sorted string\\n      for (auto it = sortFreq.rbegin(); it != sortFreq.rend(); ++it)\\n        for (char c:it->second) res.append(it->first, c);\\n      return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93548,
                "title": "1-liner-in-python-concise-and-efficient",
                "content": "This gives me 49ms that beats 99%.\\n```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        return ''.join(c*s.count(c) for c in sorted(set(s), key=s.count)[::-1])\\n```\\n\\nThe counter solution is slower and longer.\\n```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        cnt = collections.Counter(s)\\n        return ''.join(c*cnt[c] for c in sorted(set(s),key=cnt.get)[::-1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        return ''.join(c*s.count(c) for c in sorted(set(s), key=s.count)[::-1])\\n```\n```\\nclass Solution(object):\\n    def frequencySort(self, s):\\n        cnt = collections.Counter(s)\\n        return ''.join(c*cnt[c] for c in sorted(set(s),key=cnt.get)[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907277,
                "title": "simple-o-n-solution-c-pq",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        map<char, int> Counter;\\n        for(int i = 0; i < s.size(); ++i) Counter[s[i]]++;\\n        priority_queue<pair<int, char>> pq; // { occ, char }\\n        for(auto it = Counter.begin(); it != Counter.end(); ++it) {\\n            pq.push({it->second, it->first});\\n        }\\n        string res = \"\";\\n        while (!pq.empty()) {\\n            auto [occ, ch] = pq.top();\\n            pq.pop();\\n            res.append(occ, ch);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        map<char, int> Counter;\\n        for(int i = 0; i < s.size(); ++i) Counter[s[i]]++;\\n        priority_queue<pair<int, char>> pq; // { occ, char }\\n        for(auto it = Counter.begin(); it != Counter.end(); ++it) {\\n            pq.push({it->second, it->first});\\n        }\\n        string res = \"\";\\n        while (!pq.empty()) {\\n            auto [occ, ch] = pq.top();\\n            pq.pop();\\n            res.append(occ, ch);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880452,
                "title": "easy-c-solution-using-maps-and-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n       map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n        s=\"\";\\n        vector<pair<char,int>>vec(mp.begin(), mp.end());\\n        sort(vec.begin(), vec.end(), [](const pair<char,int>& a, const pair<char, int>& b) {\\n        return a.second > b.second;\\n    });\\n    for(auto i:vec)\\n    {\\n        if(i.second>1)\\n        {\\n         for(int j=0;j<i.second;j++)\\n         {\\n            s+=i.first;\\n         }   \\n        }\\n        else\\n        s+=i.first;\\n    }\\n    return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n       map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n        s=\"\";\\n        vector<pair<char,int>>vec(mp.begin(), mp.end());\\n        sort(vec.begin(), vec.end(), [](const pair<char,int>& a, const pair<char, int>& b) {\\n        return a.second > b.second;\\n    });\\n    for(auto i:vec)\\n    {\\n        if(i.second>1)\\n        {\\n         for(int j=0;j<i.second;j++)\\n         {\\n            s+=i.first;\\n         }   \\n        }\\n        else\\n        s+=i.first;\\n    }\\n    return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629259,
                "title": "c-simplest-possible-code-with-explanation",
                "content": "# Approach\\n- Declare string ans to store the sorted string.\\n- Declare charFrequency unordered map and count the frequency of each character in the string.\\n- Store the frequencies and characters in a vector of pairs freqPairs.\\n- Sort vector of pairs in descending order based on frequencies using the sort function and the greater comparator.\\n- Construct the sorted string by iterating over freqPairs and appending the characters to ans based on their frequencies.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring frequencySort(string s) {\\n    string ans = \"\";\\n    unordered_map<char, int> charFrequency;\\n\\n    // Count the frequency of each character\\n    for (int i = 0; i < s.size(); i++) {\\n        charFrequency[s[i]]++;\\n    }\\n\\n    // Store the characters and their frequencies in a vector of pairs\\n    vector<pair<int, char>> freqPairs;\\n    for (auto it : charFrequency) {\\n        freqPairs.push_back(make_pair(it.second, it.first));\\n    }\\n\\n    // Sort the vector in descending order based on frequencies\\n    sort(freqPairs.begin(), freqPairs.end(), greater<pair<int, char>>());\\n\\n    // Construct the sorted string based on the sorted frequencies\\n    for (auto it : freqPairs) {\\n        for (int i = 0; i < it.first; i++) {\\n            ans += it.second;\\n        }\\n    }\\n\\n    return ans;\\n}\\n};    \\n\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring frequencySort(string s) {\\n    string ans = \"\";\\n    unordered_map<char, int> charFrequency;\\n\\n    // Count the frequency of each character\\n    for (int i = 0; i < s.size(); i++) {\\n        charFrequency[s[i]]++;\\n    }\\n\\n    // Store the characters and their frequencies in a vector of pairs\\n    vector<pair<int, char>> freqPairs;\\n    for (auto it : charFrequency) {\\n        freqPairs.push_back(make_pair(it.second, it.first));\\n    }\\n\\n    // Sort the vector in descending order based on frequencies\\n    sort(freqPairs.begin(), freqPairs.end(), greater<pair<int, char>>());\\n\\n    // Construct the sorted string based on the sorted frequencies\\n    for (auto it : freqPairs) {\\n        for (int i = 0; i < it.first; i++) {\\n            ans += it.second;\\n        }\\n    }\\n\\n    return ans;\\n}\\n};    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493719,
                "title": "beginners-friendly",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        fill the hashmap\\n        store all the key in list with descending order of value\\n\\n# Complexity\\n- Time complexity:O(nlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap<Character,Integer> map= new HashMap<>();\\n\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(map.containsKey(c)) map.put(c, map.get(c)+1);\\n            else map.put(c,1);\\n\\n        }\\n\\n        List<Character> sorted= new ArrayList<>(map.keySet());\\n        Collections.sort(sorted, (a,b) -> map.get(b)-map.get(a));\\n\\n\\n        String t=\"\";\\n        for(int i=0;i<sorted.size();i++){\\n            char d= sorted.get(i);\\n            for(int j=0; j<map.get(d);j++){\\n                t+=d;\\n            }\\n        }\\nreturn t;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap<Character,Integer> map= new HashMap<>();\\n\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(map.containsKey(c)) map.put(c, map.get(c)+1);\\n            else map.put(c,1);\\n\\n        }\\n\\n        List<Character> sorted= new ArrayList<>(map.keySet());\\n        Collections.sort(sorted, (a,b) -> map.get(b)-map.get(a));\\n\\n\\n        String t=\"\";\\n        for(int i=0;i<sorted.size();i++){\\n            char d= sorted.get(i);\\n            for(int j=0; j<map.get(d);j++){\\n                t+=d;\\n            }\\n        }\\nreturn t;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419330,
                "title": "no-multimap-no-heap-90-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//to sort in descending order\\nbool comparator(const pair<char,int> &p1,const pair <char,int> &p2){\\n    return p1.second>p2.second;\\n}\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<pair<char,int>>vec(70);\\n\\n        for(int i=0;i<s.length();i++){\\n            int idx=0;\\n            if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n                idx=s[i]-\\'A\\';\\n            }\\n            else if(s[i]>=\\'a\\' && s[i]<=\\'z\\'){\\n                idx=26+s[i]-\\'a\\';\\n            }\\n            else{\\n                idx=53+s[i]-\\'0\\';\\n            }\\n            vec[idx].first=s[i];\\n            vec[idx].second++;\\n        }\\n        sort(vec.begin(),vec.end(),comparator);\\n        s=\"\";\\n        for(int i=0;i<70;i++){\\n            char ch=vec[i].first;\\n            int freq=vec[i].second;\\n\\n            if(freq==0) break;\\n            for(int j=0;j<freq;j++) s+=ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//to sort in descending order\\nbool comparator(const pair<char,int> &p1,const pair <char,int> &p2){\\n    return p1.second>p2.second;\\n}\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<pair<char,int>>vec(70);\\n\\n        for(int i=0;i<s.length();i++){\\n            int idx=0;\\n            if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n                idx=s[i]-\\'A\\';\\n            }\\n            else if(s[i]>=\\'a\\' && s[i]<=\\'z\\'){\\n                idx=26+s[i]-\\'a\\';\\n            }\\n            else{\\n                idx=53+s[i]-\\'0\\';\\n            }\\n            vec[idx].first=s[i];\\n            vec[idx].second++;\\n        }\\n        sort(vec.begin(),vec.end(),comparator);\\n        s=\"\";\\n        for(int i=0;i<70;i++){\\n            char ch=vec[i].first;\\n            int freq=vec[i].second;\\n\\n            if(freq==0) break;\\n            for(int j=0;j<freq;j++) s+=ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404623,
                "title": "python-easy-solution-with-simple-explaination",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<b>step 1 :</b> Create a dictionary to store the frequency of elements\\n<b>step 2 :</b> Define a helper method inside. which returns the key associated with the frequency\\n<b>step 3 :</b> create an empty string, the fetch the dictionary values in decreased order.\\n<b>step 4 :</b> get the corresponding key using `get_key()` method attach the key (character) to empty string.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # frequency count\\n        count = {}\\n        for i in s:\\n            if i not in count:\\n                count[i] = 1\\n            else:\\n                count[i] += 1\\n        \\n        # (helper method) to get the key of corresponding value\\n        def get_key(val, dic):\\n            for i in dic:\\n                if dic[i] == val:\\n                    dic.pop(i)\\n                    return i, val\\n\\n        out = \\'\\'\\n        # taking the keys in reverse order of frequency\\n        for i in reversed(sorted(count.values())):\\n            key, value = get_key(i, count)\\n            # appending (frequecy * key) to the string\\n            out += key * value\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # frequency count\\n        count = {}\\n        for i in s:\\n            if i not in count:\\n                count[i] = 1\\n            else:\\n                count[i] += 1\\n        \\n        # (helper method) to get the key of corresponding value\\n        def get_key(val, dic):\\n            for i in dic:\\n                if dic[i] == val:\\n                    dic.pop(i)\\n                    return i, val\\n\\n        out = \\'\\'\\n        # taking the keys in reverse order of frequency\\n        for i in reversed(sorted(count.values())):\\n            key, value = get_key(i, count)\\n            # appending (frequecy * key) to the string\\n            out += key * value\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400345,
                "title": "simple-code-map-and-heap-with-comments-for-better-understanding-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst count the frequency and then sort on its basis\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor counting the Frequency we can use a map and store each characters frequency and for sorting use a priority queue \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.length();++i){    //counting of frequency\\n            mp[s[i]]++;\\n        }\\n\\n        priority_queue<pair<int,char>> pq;\\n        for(auto itr:mp){             //push them in queue and also reverse them to sort according to frequency\\n            pq.push(pair(itr.second,itr.first));\\n        }\\n\\n        string ans=\"\";\\n        while(pq.empty()==false){    // while popping elements add the character in the answer string\\n            pair temp=pq.top();\\n            pq.pop();\\n            while(temp.first--){\\n                ans +=temp.second;\\n                }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**> Do Upvote if you like it!!!\\n**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.length();++i){    //counting of frequency\\n            mp[s[i]]++;\\n        }\\n\\n        priority_queue<pair<int,char>> pq;\\n        for(auto itr:mp){             //push them in queue and also reverse them to sort according to frequency\\n            pq.push(pair(itr.second,itr.first));\\n        }\\n\\n        string ans=\"\";\\n        while(pq.empty()==false){    // while popping elements add the character in the answer string\\n            pair temp=pq.top();\\n            pq.pop();\\n            while(temp.first--){\\n                ans +=temp.second;\\n                }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274757,
                "title": "451-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Import the Counter class from the collections module.\\n2. Define the frequencySort function that takes a string s as input and returns a string.\\n3. Use the Counter class to count the frequency of each character in the input string s and store the result in the freq dictionary.\\n4. Sort the characters in the input string s by their frequency in descending order using the sorted function with the key parameter set to freq.get and the reverse parameter set to True. Store the sorted characters in the sorted_chars list.\\n5. Build the sorted string by iterating through the sorted characters in the sorted_chars list and concatenating each character its frequency times using a list comprehension. Store the result in the sorted_string variable.\\n6. Return the sorted_string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # Count the frequency of each character in the string using Counter\\n        freq = Counter(s)\\n        \\n        # Sort the characters by their frequency in descending order\\n        sorted_chars = sorted(freq, key=freq.get, reverse=True)\\n        \\n        # Build the sorted string by concatenating each character its frequency times\\n        sorted_string = \\'\\'.join([char*freq[char] for char in sorted_chars])\\n        \\n        return sorted_string\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Bucket Sort"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        # Count the frequency of each character in the string using Counter\\n        freq = Counter(s)\\n        \\n        # Sort the characters by their frequency in descending order\\n        sorted_chars = sorted(freq, key=freq.get, reverse=True)\\n        \\n        # Build the sorted string by concatenating each character its frequency times\\n        sorted_string = \\'\\'.join([char*freq[char] for char in sorted_chars])\\n        \\n        return sorted_string\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264267,
                "title": "simplest-solution-ever-c-using-hashmap-5-lines-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1-> In 1st for loop: we store every character of string in map.\\n2-> In second for loop: We store key-values in multimap so that values are sorted in ascending order.\\n3-> Now as our values are sorted we use insert function and this function operates like this-\\n    it will add `i.second `character `i.first` times in the last of the string res.\\n4-> As the values are in ascending order so we reverse the resultant string and simply return.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n    map<char,int>mp; string res;\\n    multimap<int, char>mm;\\n    for(auto ch:s) mp[ch]++;\\n    for(auto &ch:mp) mm.insert({ch.second,ch.first});\\n    for(auto &i:mm) res.insert(res.length(), i.first, i.second);\\n    reverse(res.begin(), res.end());\\n    return res;\\n    }\\n};\\n```\\n# HOW IS MY SOL? CAN U PLEASE UPVOTE!\\n\\n![puppy-dog-eyes-despicable-me.gif](https://assets.leetcode.com/users/images/a9476cfb-a14c-4d9d-90a4-8089a1c8aa1c_1678103824.5218132.gif)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n    map<char,int>mp; string res;\\n    multimap<int, char>mm;\\n    for(auto ch:s) mp[ch]++;\\n    for(auto &ch:mp) mm.insert({ch.second,ch.first});\\n    for(auto &i:mm) res.insert(res.length(), i.first, i.second);\\n    reverse(res.begin(), res.end());\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226058,
                "title": "grasping-logical-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:99%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:75%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        m=Counter(s)\\n        s1=dict(sorted(m.items(),key=lambda x:x[1],reverse=True))\\n        string=\"\"\\n        for i,j in s1.items():\\n            string+=i*j\\n        return string\\n#please upvote,it would encourage me to solve in further problem\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        m=Counter(s)\\n        s1=dict(sorted(m.items(),key=lambda x:x[1],reverse=True))\\n        string=\"\"\\n        for i,j in s1.items():\\n            string+=i*j\\n        return string\\n#please upvote,it would encourage me to solve in further problem\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102677,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        String t=\"\";\\n        Map<Character,Integer>map=new TreeMap<>();\\n        List<Character>ch=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            ch.add(s.charAt(i));\\n        }\\n        \\n        Collections.sort(ch, (a, b) -> {\\n            int freqDiff = map.get(b) - map.get(a);\\n            if(freqDiff == 0) {\\n                return b - a;\\n            }   \\n            return freqDiff;\\n        });\\n        \\n        \\n        for(int i=0;i<ch.size();i++){\\n            t=t+ch.get(i);\\n        }\\n        \\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        String t=\"\";\\n        Map<Character,Integer>map=new TreeMap<>();\\n        List<Character>ch=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            ch.add(s.charAt(i));\\n        }\\n        \\n        Collections.sort(ch, (a, b) -> {\\n            int freqDiff = map.get(b) - map.get(a);\\n            if(freqDiff == 0) {\\n                return b - a;\\n            }   \\n            return freqDiff;\\n        });\\n        \\n        \\n        for(int i=0;i<ch.size();i++){\\n            t=t+ch.get(i);\\n        }\\n        \\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897094,
                "title": "c-3-line-approach-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring frequencySort(string s){\\n\\t\\t\\tint freq[123]={0}; //to store freq of character at index as ascii value \\n\\t\\t\\tfor(auto c: s) freq[c]++;\\n\\t\\t\\t//if frequencies are same take low-ascii value character \\n\\t\\t\\t//else take high frequency charater\\n\\t\\t\\tsort(s.begin(), s.end(), [&](char a, char b){ return ((freq[a] == freq[b]) ? a < b : freq[a] > freq[b]);});\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};\\n\\n\\nI hope it will help you :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring frequencySort(string s){\\n\\t\\t\\tint freq[123]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2873858,
                "title": "c-hashmap-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        priority_queue<pair<int,char>> pq;\\n        unordered_map<char,int> mp;\\n        string ans;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto x:mp){\\n            pq.push({x.second,x.first});\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top().first;\\n            while(x>0){\\n                ans+=pq.top().second;\\n                x--;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        priority_queue<pair<int,char>> pq;\\n        unordered_map<char,int> mp;\\n        string ans;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2873850,
                "title": "c-solution-using-map-and-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    //comparator will return the max element\\n    bool static comp(pair<char,int>&a,pair<char,int>&b){\\n        return a.second > b.second;\\n    }\\n    \\n    string frequencySort(string s) {\\n        //taking a map and storing the frequency of each character\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        //vector v will store the character and its frequency in pair\\n        vector<pair<char,int>>v;\\n        for(auto x:mp){\\n            v.push_back({x.first,x.second});\\n        }\\n        \\n        //sorting v in decreasing order\\n        sort(v.begin(),v.end(),comp);\\n        \\n        // ans will store the result\\n        string ans;\\n        for(auto x:v){\\n            //each character is appended in ans as its frequency times. \\n            for(int i=0;i<x.second;i++){\\n                ans += x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Time Complexity = O(nlogn)\\nSpace Complexity = O(n)**",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //comparator will return the max element\\n    bool static comp(pair<char,int>&a,pair<char,int>&b){\\n        return a.second > b.second;\\n    }\\n    \\n    string frequencySort(string s) {\\n        //taking a map and storing the frequency of each character\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        //vector v will store the character and its frequency in pair\\n        vector<pair<char,int>>v;\\n        for(auto x:mp){\\n            v.push_back({x.first,x.second});\\n        }\\n        \\n        //sorting v in decreasing order\\n        sort(v.begin(),v.end(),comp);\\n        \\n        // ans will store the result\\n        string ans;\\n        for(auto x:v){\\n            //each character is appended in ans as its frequency times. \\n            for(int i=0;i<x.second;i++){\\n                ans += x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873224,
                "title": "swift-dictionary-3-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func frequencySort(_ s: String) -> String {\\n        return Dictionary(s.map { ($0, 1)}, uniquingKeysWith: +)\\n\\t\\t.sorted(by: { $0.value > $1.value })\\n\\t\\t.reduce(\"\") { $0 + String(repeating: $1.key, count: $1.value) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func frequencySort(_ s: String) -> String {\\n        return Dictionary(s.map { ($0, 1)}, uniquingKeysWith: +)\\n\\t\\t.sorted(by: { $0.value > $1.value })\\n\\t\\t.reduce(\"\") { $0 + String(repeating: $1.key, count: $1.value) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873104,
                "title": "sort-characters-by-frequency-81-faster-python",
                "content": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        d = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0, \\'d\\': 0, \\'e\\': 0, \\'f\\': 0, \\'g\\': 0, \\'h\\': 0, \\'i\\': 0, \\'j\\': 0, \\'k\\': 0, \\'l\\': 0, \\'m\\': 0, \\'n\\': 0, \\'o\\': 0, \\'p\\': 0, \\'q\\': 0, \\'r\\': 0, \\'s\\': 0, \\'t\\': 0, \\'u\\': 0, \\'v\\': 0, \\'w\\': 0, \\'x\\': 0, \\'y\\': 0, \\'z\\': 0} \\n\\n        for i in s:\\n            if i in d:\\n                d[i]=d[i]+1\\n            else:\\n                d[i]=1\\n        f = dict()\\n        for i in s:\\n            f[i]=d[i]\\n        final = \\'\\'\\n        d = sorted(f.items(), key=lambda item: item[1])\\n        for i in d:\\n            final += i[0]*i[1]\\n        return(final[::-1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        d = {\\'a\\': 0, \\'b\\': 0, \\'c\\': 0, \\'d\\': 0, \\'e\\': 0, \\'f\\': 0, \\'g\\': 0, \\'h\\': 0, \\'i\\': 0, \\'j\\': 0, \\'k\\': 0, \\'l\\': 0, \\'m\\': 0, \\'n\\': 0, \\'o\\': 0, \\'p\\': 0, \\'q\\': 0, \\'r\\': 0, \\'s\\': 0, \\'t\\': 0, \\'u\\': 0, \\'v\\': 0, \\'w\\': 0, \\'x\\': 0, \\'y\\': 0, \\'z\\': 0} \\n\\n        for i in s:\\n            if i in d:\\n                d[i]=d[i]+1\\n            else:\\n                d[i]=1\\n        f = dict()\\n        for i in s:\\n            f[i]=d[i]\\n        final = \\'\\'\\n        d = sorted(f.items(), key=lambda item: item[1])\\n        for i in d:\\n            final += i[0]*i[1]\\n        return(final[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873040,
                "title": "python-bucket-sort-video-solution",
                "content": "I have tried to explain the intution behind Bucket Sort and other similar solutions in this [video](https://youtu.be/ofCIa35IIEI).\\n\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        n = len(s)\\n        \\n        c = Counter(s)\\n        \\n        bucket = [[] for _ in range(n+1)]\\n        \\n        for ch, freq in c.items():\\n            bucket[freq].append(ch)\\n            \\n        res = \\'\\'\\n        for freq in reversed(range(n+1)):\\n            for ch in bucket[freq]:\\n                res += (freq * ch)\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "I have tried to explain the intution behind Bucket Sort and other similar solutions in this [video](https://youtu.be/ofCIa35IIEI).\\n\\n```\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        n = len(s)\\n        \\n        c = Counter(s)\\n        \\n        bucket = [[] for _ in range(n+1)]\\n        \\n        for ch, freq in c.items():\\n            bucket[freq].append(ch)\\n            \\n        res = \\'\\'\\n        for freq in reversed(range(n+1)):\\n            for ch in bucket[freq]:\\n                res += (freq * ch)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2872606,
                "title": "c-priorityqueue-solution-in-o-n-time-and-o-k-space",
                "content": "The logic is to store the elements in an array using the fact that the characters consist only in digits and letters. Therefore the smallest ASCII number is the digit 0 (48) and the biggest z (122), so I create an array of size 75.\\nThen I push every element different from zero in a priority queue, ordered by the frequency of characters, in this way every time that I retrieve an element I know it is the most frequent of the initial string.\\n\\nn = number of characters of the string\\nk = number of different characters\\nTime Complexity: O(n + log(k)) ~ O(n)\\nSpace Complexity: O(k)\\n```typedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        priority_queue<pi, vector<pi>, myComp> pq;\\n        int fc[75] = {0};\\n        \\n        for(int i = 0; i < s.size(); i++)\\n            fc[s[i] - \\'0\\']++;\\n        \\n        for(int i = 0; i < 75; i++)\\n            if(fc[i] != 0)\\n                pq.push(make_pair(i + \\'0\\', fc[i]));\\n        \\n        string res = \"\";\\n        while(!pq.empty()){\\n            pi c = pq.top();\\n            pq.pop();\\n            string conc(c.second, c.first);\\n            res += conc;\\n        }\\n         \\n        return res;\\n    }\\n\\nprivate:\\n    struct myComp {\\n        constexpr bool operator()(\\n            pi const& a,\\n            pi const& b)\\n            const noexcept\\n        {\\n            return a.second < b.second;\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```typedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        priority_queue<pi, vector<pi>, myComp> pq;\\n        int fc[75] = {0};\\n        \\n        for(int i = 0; i < s.size(); i++)\\n            fc[s[i] - \\'0\\']++;\\n        \\n        for(int i = 0; i < 75; i++)\\n            if(fc[i] != 0)\\n                pq.push(make_pair(i + \\'0\\', fc[i]));\\n        \\n        string res = \"\";\\n        while(!pq.empty()){\\n            pi c = pq.top();\\n            pq.pop();\\n            string conc(c.second, c.first);\\n            res += conc;\\n        }\\n         \\n        return res;\\n    }\\n\\nprivate:\\n    struct myComp {\\n        constexpr bool operator()(\\n            pi const& a,\\n            pi const& b)\\n            const noexcept\\n        {\\n            return a.second < b.second;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872513,
                "title": "unordered-map-priority-queue-runtime-beats-94-87-memory-beats-68-5",
                "content": "\\n\\n# Approach\\n\\n* Storing all characters with its frequency in an unordered_map\\n* Then Storing back the characters with its frequency in a priority queue<<int,char>> to later access it in sorted order of their decreasing frequency.\\n* Then just add character by character to a new string by accessing top of priority_queue as the character with most frequency will be at top \\n\\n\\n\\n\\n# Complexity\\n- Time complexity:  O(n * log(n))\\nIf you have an empty priority queue to which you want to add n items, one at a time, then the complexity is O(n * log(n)).\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string s1=\"\";\\n       \\n        priority_queue<pair<int,char>> q;\\n        unordered_map<char,int> m;\\n        for(auto ch:s) m[ch]++;\\n        \\n        for(auto a:m){\\n            q.push({a.second,a.first});\\n        }\\n        m.clear();\\n        while(!q.empty()){\\n            auto p=q.top();\\n            while(p.first--) s1+=p.second;\\n            q.pop();\\n        }\\n        return s1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string s1=\"\";\\n       \\n        priority_queue<pair<int,char>> q;\\n        unordered_map<char,int> m;\\n        for(auto ch:s) m[ch]++;\\n        \\n        for(auto a:m){\\n            q.push({a.second,a.first});\\n        }\\n        m.clear();\\n        while(!q.empty()){\\n            auto p=q.top();\\n            while(p.first--) s1+=p.second;\\n            q.pop();\\n        }\\n        return s1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872354,
                "title": "optimized-with-priority-queue-and-map-easy-explained-o-nlogn-fast-cpp",
                "content": "# Intuition\\nUsing Priority Queue for Efficient time complexity. \\n\\nPriority Queue: is an abstract data type that is similar to a queue, and every element has some priority value associated with it. The priority of the elements in a priority queue determines the order in which elements are served (i.e., the order in which they are removed). If in any case the elements have same priority, they are served as per their ordering in the queue.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string res = \"\";\\n        //We will use Map For Fast Fetch\\n        unordered_map<char, int>m;\\n        for(auto c: s) m[c]++;\\n        auto comp = [](pair<int, char>& a, pair<int, char>& b){ return a.first < b.first; };\\n        //Optimized with Priority Queue\\n        priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)>pq(comp);\\n        for(auto x: m) pq.push({x.second, x.first});\\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            pq.pop();\\n            while(p.first--) res += p.second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Upvote if it Helped\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string res = \"\";\\n        //We will use Map For Fast Fetch\\n        unordered_map<char, int>m;\\n        for(auto c: s) m[c]++;\\n        auto comp = [](pair<int, char>& a, pair<int, char>& b){ return a.first < b.first; };\\n        //Optimized with Priority Queue\\n        priority_queue<pair<int, char>, vector<pair<int, char>>, decltype(comp)>pq(comp);\\n        for(auto x: m) pq.push({x.second, x.first});\\n        while(!pq.empty()){\\n            auto p = pq.top();\\n            pq.pop();\\n            while(p.first--) res += p.second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872187,
                "title": "java-c-easy-solution-hashmap-and-priority-queue",
                "content": "Approach :- Store character and count in hashmap and then use Priority Queue to make the pair in reverse sorted order and thenn generate the string from parity Queue\\n\\n```\\nclass Solution {\\n    // create a pair class \\n\\tstatic class Pair{\\n        char ch;\\n        int count;\\n        \\n        Pair(char _ch, int _count){\\n            ch = _ch;\\n            count = _count;\\n        }\\n    }\\n\\t// creating comparator  \\n    static class mycompare implements Comparator<Pair>{\\n        public int compare(Pair p1, Pair p2){\\n            if(p1.count>p2.count){\\n                return -1;\\n            }\\n            else{\\n                return +1;\\n            }\\n        }\\n    }\\n    public String frequencySort(String s) {\\n\\t   // store character and frequency in hashmap\\n        HashMap<Character, Integer> hash = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i), 0)+1);\\n        }\\n\\t\\t// Creating Priority Queue for inserting pair in reverse sorted order\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new mycompare());\\n        \\n\\t\\t// insert the pair with into Priority Queue\\n\\t\\tfor(Character ch: hash.keySet()){\\n            pq.add(new Pair(ch, hash.get(ch)));\\n        }\\n\\t\\t\\n\\t\\t// rebuilding string with the priority queue\\n        StringBuilder s1 = new StringBuilder();\\n        while(!pq.isEmpty()){\\n            char c = pq.peek().ch;\\n            int x = pq.peek().count;\\n            while(x>0){\\n                s1.append(c);\\n                x--;\\n            }\\n            pq.poll();\\n        }\\n\\t\\t// convert string builder to string and return the ans\\n        return s1.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    // create a pair class \\n\\tstatic class Pair{\\n        char ch;\\n        int count;\\n        \\n        Pair(char _ch, int _count){\\n            ch = _ch;\\n            count = _count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2872101,
                "title": "easiest-precise-and-amazing-map",
                "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> m;\\n        vector<pair<int,char>> v;\\n        string z= \"\";\\n        for(auto x:s){\\n            m[x]++;\\n        }\\n        for(auto i:m){\\n            v.push_back(make_pair(i.second,i.first));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=v.size()-1;i>=0;i--){\\n            z.insert(z.size(),v[i].first,v[i].second);\\n        }\\n        return z;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> m;\\n        vector<pair<int,char>> v;\\n        string z= \"\";\\n        for(auto x:s){\\n            m[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2872007,
                "title": "java-possible-solution",
                "content": "```\\nclass Solution {  \\n  public String frequencySort(String s) {\\n      StringBuilder sb = new StringBuilder();\\n      Map<Character, Integer> charCountMap = new HashMap<>();\\n      int len = s.length();\\n      for(int i = 0; i < len; i++) {\\n          char ch = s.charAt(i);\\n          charCountMap.put(ch, charCountMap.getOrDefault(ch, 0) + 1);\\n      }\\n      charCountMap.entrySet().stream().sorted(Map.Entry.<Character, Integer>comparingByValue().reversed()).forEach(record -> {\\n          Character key = record.getKey();\\n          int value = record.getValue();\\n          for(int i = 0; i < value; i++) {\\n              sb.append(key);\\n          }\\n      });\\n      return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {  \\n  public String frequencySort(String s) {\\n      StringBuilder sb = new StringBuilder();\\n      Map<Character, Integer> charCountMap = new HashMap<>();\\n      int len = s.length();\\n      for(int i = 0; i < len; i++) {\\n          char ch = s.charAt(i);\\n          charCountMap.put(ch, charCountMap.getOrDefault(ch, 0) + 1);\\n      }\\n      charCountMap.entrySet().stream().sorted(Map.Entry.<Character, Integer>comparingByValue().reversed()).forEach(record -> {\\n          Character key = record.getKey();\\n          int value = record.getValue();\\n          for(int i = 0; i < value; i++) {\\n              sb.append(key);\\n          }\\n      });\\n      return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871819,
                "title": "python-easy-solution",
                "content": "\\t\\t\\tfreq = {}\\n            for char in s:\\n                if char not in freq:\\n                    freq[char] =1\\n                else:\\n                    freq[char] +=1\\n            char_sorted = sorted(freq, key=freq.get, reverse = True)\\n            print(char_sorted)\\n            res = \"\"\\n            for char in char_sorted:\\n                res = res + char*freq[char]\\n            return res",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\t\\t\\tfreq = {}\\n            for char in s:\\n                if char not in freq:\\n                    freq[char] =1\\n                else:\\n                    freq[char] +=1\\n            char_sorted = sorted(freq, key=freq.get, reverse = True)\\n            print(char_sorted)\\n            res = \"\"\\n            for char in char_sorted:\\n                res = res + char*freq[char]\\n            return res",
                "codeTag": "Python3"
            },
            {
                "id": 2871749,
                "title": "not-short-but-easy-to-understand-expnation-map-priority-queue",
                "content": "if you understand the solution plz upvote \\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nist store the the frequency of string\\nall the frequency and char store the priority_queue \\nin the priority_queue we also store the character with their freq\\n\\n strep 2\\ntake the 1st fre in the queue and store  the frq in the\\nstring when the frequncy not zero ;\\n\\nwe use the priority_queue for the greater element comes in the top ans also pair for the character;\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n       unordered_map<char,int>mp;\\n       \\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair<int,char>>q;\\n        for(auto it:mp)\\n        {\\n            q.push({it.second,it.first});\\n            //cout<<it.second;\\n        }\\n        string st;\\n        char m;\\n        int p;\\n        while (!q.empty()) {\\n        \\n             m=q.top().second;\\n            // cout<<m;                      \\n            p=q.top().first;\\n            if(p==1)\\n            {\\n                st+=m;\\n            }\\n            else\\n            {\\n                while(p--)\\n                {\\n                    st+=m;\\n                }\\n            }\\n           \\n        q.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n       unordered_map<char,int>mp;\\n       \\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair<int,char>>q;\\n        for(auto it:mp)\\n        {\\n            q.push({it.second,it.first});\\n            //cout<<it.second;\\n        }\\n        string st;\\n        char m;\\n        int p;\\n        while (!q.empty()) {\\n        \\n             m=q.top().second;\\n            // cout<<m;                      \\n            p=q.top().first;\\n            if(p==1)\\n            {\\n                st+=m;\\n            }\\n            else\\n            {\\n                while(p--)\\n                {\\n                    st+=m;\\n                }\\n            }\\n           \\n        q.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2871672,
                "title": "c-1-line-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string FrequencySort(string s) {\\n        return string.Concat(s.GroupBy(x => x).OrderByDescending(x => x.Count()).SelectMany(x => x));\\n    }\\n}\\n```\\n\\nPer anikit, updated solution to use `string.Concat`.",
                "solutionTags": [
                    "C#",
                    "String",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public string FrequencySort(string s) {\\n        return string.Concat(s.GroupBy(x => x).OrderByDescending(x => x.Count()).SelectMany(x => x));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871576,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap <Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n//         convert map into the list for comparion\\n        List<Map.Entry<Character, Integer> > list\\n            = new ArrayList<Map.Entry<Character, Integer> >(\\n                map.entrySet());\\n        \\n        System.out.println(list);\\n//         sorting the list for the elements\\n        \\n        Collections.sort(list, (a, b) -> b.getValue().compareTo(a.getValue()));\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(Map.Entry<Character,Integer> e: list){\\n            int i=e.getValue();\\n            while(i>0){\\n                sb.append(e.getKey());\\n                i--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        HashMap <Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n//         convert map into the list for comparion\\n        List<Map.Entry<Character, Integer> > list\\n            = new ArrayList<Map.Entry<Character, Integer> >(\\n                map.entrySet());\\n        \\n        System.out.println(list);\\n//         sorting the list for the elements\\n        \\n        Collections.sort(list, (a, b) -> b.getValue().compareTo(a.getValue()));\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(Map.Entry<Character,Integer> e: list){\\n            int i=e.getValue();\\n            while(i>0){\\n                sb.append(e.getKey());\\n                i--;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871349,
                "title": "python-collections-counter-most-common",
                "content": "https://leetcode.com/submissions/detail/853679164/\\n```\\nRuntime: 42 ms, faster than 95.58% of Python3 online submissions for Sort Characters By Frequency.\\nMemory Usage: 15.3 MB, less than 81.15% of Python3 online submissions for Sort Characters By Frequency.\\n```\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        s1, c = \\'\\', Counter(s)\\n        for k,v in c.most_common():\\n            s1 = s1 + k*v\\n        return s1   \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nRuntime: 42 ms, faster than 95.58% of Python3 online submissions for Sort Characters By Frequency.\\nMemory Usage: 15.3 MB, less than 81.15% of Python3 online submissions for Sort Characters By Frequency.\\n```\n```\\nfrom collections import Counter\\nclass Solution:\\n    def frequencySort(self, s: str) -> str:\\n        s1, c = \\'\\', Counter(s)\\n        for k,v in c.most_common():\\n            s1 = s1 + k*v\\n        return s1   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871293,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func frequencySort(_ s: String) -> String {\\n        Dictionary(s.map{($0, 1)}, uniquingKeysWith:+).sorted{$0.1 > $1.1}.reduce(\"\"){$0 + String(repeating:$1.0, count: $1.1)}\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func frequencySort(_ s: String) -> String {\\n        Dictionary(s.map{($0, 1)}, uniquingKeysWith:+) // create [Character:Int]; keys=ch, values=count\\n\\t\\t\\t.sorted{ a,b in a.value > b.value }  // sort key-value pairs by ascending count\\n\\t\\t\\t.reduce(\"\") { result, tuple in\\n\\t\\t\\t\\tlet (ch, count) = tuple\\n\\t\\t\\t\\treturn result + String(repeating: ch, count: count)\\n\\t\\t\\t}\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func frequencySort(_ s: String) -> String {\\n        Dictionary(s.map{($0, 1)}, uniquingKeysWith:+).sorted{$0.1 > $1.1}.reduce(\"\"){$0 + String(repeating:$1.0, count: $1.1)}\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func frequencySort(_ s: String) -> String {\\n        Dictionary(s.map{($0, 1)}, uniquingKeysWith:+) // create [Character:Int]; keys=ch, values=count\\n\\t\\t\\t.sorted{ a,b in a.value > b.value }  // sort key-value pairs by ascending count\\n\\t\\t\\t.reduce(\"\") { result, tuple in\\n\\t\\t\\t\\tlet (ch, count) = tuple\\n\\t\\t\\t\\treturn result + String(repeating: ch, count: count)\\n\\t\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569117,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1704022,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1700295,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1575883,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1569116,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1704028,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1576119,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 2027811,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 2002930,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1975568,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1569117,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1704022,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1700295,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1575883,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1569116,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1704028,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1576119,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 2027811,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 2002930,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1975568,
                "content": [
                    {
                        "username": "darkmancer",
                        "content": "I think there is an issue with the test cases. I am getting wrong answer on this test case \"loveleetcode\". The official answer is \"eeeeoollvtdc\" while I get the answer \"eeeeoolltvcd\". According to the problem statement this answer should be correct as the characters with same frequency can be arranged in any order.\\n\\nThanks"
                    },
                    {
                        "username": "hansnice",
                        "content": "Agree, they need to fix this problem."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the clich\\xE9 of characters of the same frequency.\\nAlthough the question states that the characters of the same frequency are arranged in any order, to do this in the answer bank will be quite cumbersome."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Feels like an easy problem, not a medium one!"
                    },
                    {
                        "username": "mchim",
                        "content": "Not an Easy problem if we have to do in O(n). Should be Medium only."
                    },
                    {
                        "username": "vladAtCoder",
                        "content": "idk but , if they have equal counts ,it seems like, I need to sort them by their ASCII value , otherwise won't work, the problem should've said this"
                    },
                    {
                        "username": "Darpan301",
                        "content": "it could be understood by example 2 i guess"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "it should be part of your solution. If problem says that then its almost solved. :)"
                    },
                    {
                        "username": "glugglug",
                        "content": "It is enforcing that characters in the output are grouped together, but this isn\\'t in the problem statement.\\nFor example, for input \"love leetcode\", \"eeeelolovtcd \" is rejected because the l and o which both occur twice are mixed together.\\n\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think the answer bank was a bit sloppy in not taking into account the cliché of same-frequency characters.\nAnw, try another method like Counter for example :D\nBon courage."
                    },
                    {
                        "username": "anjali4",
                        "content": "How to handle characters with same count ?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "\"If there are multiple answers, return any of them.\" is a poorly worded way to say \"letters of the same frequency can be in any order\""
                    },
                    {
                        "username": "PunjajiOmkar",
                        "content": "try to used map<char,int> mp;"
                    },
                    {
                        "username": "KittenLS",
                        "content": "It\\'s a little bit confusing that the string could contain numbers, but no over chars like dots for example. And we can see that only when we run tests."
                    },
                    {
                        "username": "iDash",
                        "content": "I see in discussions a lot of \"java\" people posting PQ solutions.\\n\\nPriorityQueue class vey helpful when we need to get k-th largest/smalest element.\\nThis problem require us sort entire array.\\n\\nBenefit of PQ that it is not sorting collection [unless you call the poll() method](https://stackoverflow.com/a/25569705).\\nWhen you call poll() - it just search for element with lowest value (by Comparator).\\nCall poll N times(to retrieve your) - triger at least QuickSelect(*as far as I know this implemented inside JDK)* N times. \\nSo just on this operstion you might have n^2 performance esily if our string has unique characters.\\n\\nIs there anyone who can proof using PQ over simply Collections.sort()?"
                    },
                    {
                        "username": "hero080",
                        "content": "I think a reasonable PQ implementation should ensure that pop (poll) operation takes $$O(log n)$$ time. A quick check on JDK doc proves my point:\\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html\\n\\nUsing a PQ and going through all elements should have the same big O complexity as sorting: $$\\\\theta(n log n)$$. However, PQ is usually worse than sorting (otherwise we should just use PQ to implement sorting)."
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Should be easy level for sure"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy\\n"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "This solution passes 31/33 test cases. Can anyone tell what is wrong in this code?\\n\\n    string frequencySort(string s) {\\n        vector<pair<int, char>> freq(26*2);\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            int index;\\n            if (s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n            {\\n                index=s[i]-\\'a\\';\\n            }\\n            else\\n            {\\n                index=s[i]-\\'A\\'+26;\\n            }\\n            freq[index].first+=1;\\n            freq[index].second=s[i];\\n        }\\n        sort(freq.begin(), freq.end(), greater<pair<int, char>>());\\n        string ans=\"\";\\n        for (int i=0; i<26; i++)\\n        {\\n            if (freq[i].first==0) {break;}\\n            for (int j=0; j<freq[i].first; j++)\\n            {\\n                ans+=freq[i].second;\\n            }\\n        }\\n        return ans;"
                    }
                ]
            },
            {
                "id": 1964337,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1926046,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1919624,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1916748,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1913105,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1903770,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1856600,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1833838,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1779030,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1770703,
                "content": [
                    {
                        "username": "vaibhav_bilwal",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<int ,char > map;\\n\\n        for(auto str : s) map[str]++;\\n\\n        priority_queue<pair<char , int>>pq;\\n\\n        for(auto str :  map) pq.push({str.second , str.first});\\n\\n        string ans= \"\";\\n\\n        while(!pq.empty()){\\n            ans+=string(pq.top().first, pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\nmy code don\\'t work for test case 29 and give error \"terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\" what is the meaning of this error !!"
                    },
                    {
                        "username": "windop2002",
                        "content": " `\\n\\n        vector< pair<char,long long>> v(mpp.begin(),mpp.end());\\n        sort(v.begin(),v.end(),com);\\n\\n        string ans=\"\";\\n        for(int i=0 ; i<v.size() ; i++){\\n            while(v[i].second--){\\n                ans=ans+v[i].first;\\n            }\\n            \\n        } \\n\\n        return ans;\\n    }\\n};`\\n\\nin The above soolution Memory limit exceeds is shown , although long long is used for the frequency."
                    },
                    {
                        "username": "rahulbumb",
                        "content": " `vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }`\\nsorting the count array\\nthen accessing char using \\n`char ch = \\'0\\' + i;`\\nbut it showing wrong answer. anyone tell why?\\n\\nhare is full code (absurd answer)\\n class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        vector<int> count(256, 0);\\n        for(char ch : s){\\n            count[ch -\\'0\\']++;\\n        }\\n        sort(count.rbegin(), count.rend());\\n        string ans;\\n        for(int i = 0; i < 256; i++){\\n            if(count[i] > 0){\\n                char ch = \\'0\\' + i;\\n                cout<<ch;\\n                for(int j = 0; j < count[i]; j++){\\n                    ans.push_back(ch);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "engghjain76",
                        "content": "Why should i use heap here as a priority queue implementation instead of using std:sort in C++ as we would be anyways sorting the entire input ?\\n\\nCan anyone answer this please"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "Yes we don't need PQ for this.\nJust make a 2d hash array (freq, index) and than sort that array"
                    },
                    {
                        "username": "layyy",
                        "content": "i guess priority queue is better than bucket sort for this problem as length of string is long"
                    },
                    {
                        "username": "Aditya560",
                        "content": "I think This is easy Problem.\\nJust Think of using ascii value.\\nThis tip is for beginner."
                    },
                    {
                        "username": "devottam2809",
                        "content": "why it\\'s not working after testcase 29 ?\\n\\nclass Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string ans=\"\";\\n        unordered_map<char,int>umap;\\n        for(auto i:s)\\n            umap[i]++;\\n        \\n        priority_queue<pair<char,int>>pq;\\n        for(auto i:umap)\\n            pq.push({i.second,i.first});\\n\\n        \\n        while(pq.size()>0)\\n        {\\n            int freq=pq.top().first;\\n            char var=pq.top().second;\\n            for(int i=1;i<=freq;i++)\\n                ans+=var;\\n            pq.pop();\\n        }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "amankumar1020",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        string str=\"\";\\n    map<char,int> mp;\\n    \\n  for(int i=0;i<s.size();i++) mp[s[i]]++;\\n\\n  sort(mp);\\n  \\n  for(auto& it : mp){\\n      while( it.second)str +=  it.first--;  // <<<<<< i din\\'t know why its give error here\\n//can you help me please..\\n\\n    }\\n    return mp;\\n }\\n\\n bool cmp(pair<char, int>& a,\\n        pair<char, int>& b)\\n{\\n    return a.second > b.second;\\n}\\n \\n// Function to sort the map according\\n// to value in a (key-value) pairs\\nmap<char, int> sort(map<char, int>& M)\\n{\\n \\n    // Declare vector of pairs\\n    vector<pair<char, int> > A;\\n \\n    // Copy key-value pair from Map\\n    // to vector of pairs\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n \\n    // Sort using comparator function\\n    sort(A.begin(), A.end(), cmp);\\n    map<char,int> mp;\\n\\n    for (auto& it : A) {\\n        mp[it.first] =  it.second;}\\n    \\n    return mp;\\n\\n}\\n\\n};\\n\\n"
                    },
                    {
                        "username": "Harsh-Jain10",
                        "content": "` #define pii pair<int,char>`\n`class compare{`\n`public:`\n`       bool operator()(pii a,pii b){`\n`        if(a.first>b.first) return false;`\n`        if(a.first==b.first && a.second < b.second) return false;`\n`        return true;`\n`    }`\n`};`\n`class Solution {`\n`public:`\n  `  string frequencySort(string s) {`\n    `    priority_queue<pii,vector<pii>,compare> pq;`\n\t`    unordered_map<char,int> map;`\n     `   for(int i=0;i<s.size();i++){`\n\t `       map[s[i]]++;`\n\t  `  }`\n        `for(auto i:map){`\n\t   `     pq.push(make_pair(i.second,i.first));`\n\t  `  }`\n     `   string ans=\"\";`\n     `   while(!pq.empty()){`\n\t `       for(int i=0;i<pq.top().first;i++) ans +=pq.top().second;`\n`\t        pq.pop();`\n`\t    }`\n`        return ans;`\n`    }`\n`};`"
                    },
                    {
                        "username": "sparsh-b",
                        "content": "Is anyone getting the error:\\n`terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_fill_insert`\\nfor the 29th test case?\\n\\nThe string is really big & somehow I\\'m stuck at this error."
                    }
                ]
            },
            {
                "id": 1741614,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1732113,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1720995,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1711009,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1704144,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1703921,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1703655,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1703649,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1573079,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            },
            {
                "id": 1883448,
                "content": [
                    {
                        "username": "SatishKG",
                        "content": "What if.....?\\nWhat if there was an additional condition with the question : \\n\"If there are multiple answers, return lexicographically largest of them.\"\\nExample : \\ninput : cccaaa\\noutput : cccaaa"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "just modify your compare function like this: \\n\\nstatic bool comp(pair<string,int> v1, pair<string,int> v2){\\n        if( v1.second>v2.second ) return true;\\n        else  if( v1.second<v2.second ) return false;\\n        else{\\n                return v1.first>v2.first;\\n        }\\n}"
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Sorry, didn't get you. For example if string = \"tree\", then \"eetr\" and \"eert\" is the answer. So, do you mean strictly \"eetr\" should be the answer as char \"t\" is larger in count than \"r\"?"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "I tried a solution w a map in cpp, which failed to distinguish between uppercase and lowercase chars. Wondering how the unordered map solved it."
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "This should be a easy question"
                    },
                    {
                        "username": "adjee2020",
                        "content": " string frequencySort(string s) {\\n        int n = s.size();\\n\\n        unordered_map<char , pair<int , string>> mp1;\\n        for(int i=0; i<n; i++){\\n            mp1[s[i]].first++;\\n            mp1[s[i]].second += s[i];\\n        }\\n\\n        map<int , vector<string>> mp2;\\n        for(auto [a , b]:mp1){\\n            mp2[b.first].push_back(b.second);\\n        }\\n\\n        string ans = \"\";\\n        for(auto [a,b]:mp2){\\n            for(int i=0; i<b.size(); i++){\\n                ans = b[i] + ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nCan anyone tell what will be its time and space complexity "
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "The code which I wrote works on my computer by it shows a runtime error when I am trying to run it on leetcode.\\nPlease can anyone help me with this one?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Om-_-sd](/Om-_-sd) \\n1. Just remind s.length <= 5 * 10^5.\\n2. The problem only requires sorting by frequency appearing in the string. \\nWhy you have to sort the character type like alpha aA, digit 09, special *^... ?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "[@Yongbi](/Yongbi) \\nstruct HashMap\\n{\\n    int index;\\n    int frequency;\\n};\\n\\n\\nvoid CreateTable(int*arr)\\n{\\n    for(int i=0;i<62;i++)\\n        arr[i]=0;\\n}\\n\\n\\nvoid FillTable(char* s,int* arr)\\n{\\n    for(int i=0;i<strlen(s);i++)\\n    {\\n        char ch=s[i];\\n        int j=(int)ch;\\n        if(j>=48 && j<=57)\\n        {\\n            j=j-48;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=65 && j<=90)\\n        {\\n            j=j-55;\\n            arr[j]=arr[j]+1;\\n        }\\n        else if(j>=97 && j<=122)\\n        {\\n            j=j-61;\\n            arr[j]=arr[j]+1;\\n        }\\n    }\\n}\\n\\n\\nvoid SortTable(int* arr,struct HashMap** sarr)\\n{\\n    for(int i=0;i<62;i++)\\n    {\\n        int maxindex=-1;\\n        int max=-1;\\n        for(int j=0;j<62;j++)\\n        {\\n            if(arr[j]>=max)\\n            {\\n                max=arr[j];\\n                maxindex=j;\\n            }\\n        }\\n        arr[maxindex]=-2;\\n        struct HashMap* node=(struct HashMap*)malloc(sizeof(struct HashMap));\\n        node->index=maxindex;\\n        node->frequency=max;\\n        sarr[i]=node;\\n    }\\n}\\n\\n// mapping is \\n// 48--\\'0\\'-0\\n// 57--\\'9\\'-9\\n// 65--\\'A\\'-10\\n// \\'Z\\'-35\\n// 97--\\'a\\'-36\\n// \\'z\\'-61\\n\\nchar * frequencySort(char * s)\\n{\\n    if(strlen(s) == 1)\\n        return s;\\n    else\\n    {\\n        int* arr=(int*)malloc(sizeof(int)*62);\\n        struct HashMap** sarr=(struct HashMap**)malloc(sizeof(struct HashMap*)*62);\\n        CreateTable(arr);\\n        FillTable(s,arr);\\n        SortTable(arr,sarr);\\n        int length=0;\\n        length=strlen(s);\\n        char* newstring=(char*)malloc(sizeof(char)*length);\\n        strcpy(newstring,\"\");\\n        // char newstring[length];\\n        // memset( newstring, 0, length*sizeof(int) );\\n\\n        for(int i=0;i<62;i++)\\n        {\\n            struct HashMap* temp=sarr[i];\\n            int index=temp->index;\\n            int frequency=temp->frequency;\\n\\n            if(frequency==0)\\n                break;\\n            if(index>=0 && index<=9)\\n            {\\n                index=index+48;\\n                char ch=(char)index;\\n                for(int k=0;k<frequency;k++)\\n                    {\\n                        strncat(newstring,&ch,1);\\n                    }\\n            }\\n            else if(index>=10 && index<=35)\\n            {\\n                index=index+55;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                    strncat(newstring,&ch,1);\\n                }\\n            }\\n            else if(index>=36 && index<=61)\\n            {\\n                index=index+61;\\n                char ch=(char)index;\\n\\n                for(int k=0;k<frequency;k++)\\n                {\\n                   strncat(newstring,&ch,1);\\n                }\\n            }\\n        }\\n        return newstring;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "And where is your code???"
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Leetcode Daily challenge playlist for video solution with  explanation 🔥🔥🔥[youtube](https://www.youtube.com/playlist?list=PLb1fYBLtJvPflpz3W7x_Bm1HYBv34aPuv)"
                    },
                    {
                        "username": "ksamin",
                        "content": "class Solution {\\npublic:\\n    string frequencySort(string s) {\\n        unordered_map<char,int> mp;\\n        if(s.length()<=5*pow(10,5)){\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        priority_queue<pair <int,char>> pq;\\n        for(auto x:mp){\\n            pq.push(make_pair(x.second,x.first));\\n        }\\n        string ans=\"\";\\n        while(pq.size()>0){\\n            int freq=pq.top().first;\\n            char c=pq.top().second;\\n            for(int i=1;i<=freq;i++){\\n                ans=ans+c;\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n\\nonly 31/33 test cases passed .\\nwhy I am getting memory Limited Exceeded"
                    },
                    {
                        "username": "ksamin",
                        "content": "[@introvert-99](/introvert-99)  ohhh i am getting thank u so much."
                    },
                    {
                        "username": "introvert9112k",
                        "content": "You are getting TLE/MLE because of the  ```ans = ans + c```  the convention ``` ans+=c```  and ```ans = ans + c``` both are different.\n\nIn case of the ``` ans+=c `` the new character is added to the existing ans itself. No creation of new string and copying. \n\nWhereas  in case of ``` ans = ans + c ``` , first the current string is copied into the ans variable which on right of equality, then the current character is added to it and now the concatenated string is copied to variable ans on left of equality.  That mean it is taking O(n) space/time for each character added. "
                    },
                    {
                        "username": "himanshu_210",
                        "content": "s=list(S)\\ns.sort()\\ntemp=list(set(s))\\nl1=[]\\nl2=[]\\nnew=\\'\\'\\nfor i in temp:\\n    l1.append(i)\\n    l2.append(s.count(i))\\n    \\nwhile True :\\n    if len(l1) == 0:\\n        return new\\n    new+=max(l2)*l1[l2.index(max(l2))]\\n    l1.pop(l2.index(max(l2)))\\n    l2.pop(l2.index(max(l2)))\\n\\nwhat can improve in this code"
                    },
                    {
                        "username": "Yongbi",
                        "content": "On my computer:   \n#38ms   - Improvement based on your code  \n        \nls, new = [] , ''\n#Define list[count, letter]\nfor i in set(s): \n     ls.append((s.count(i), i))\n#End loop\n#Sort for count number        \nls.sort() \n        \nfor count, letter in ls[::-1]: # reverse list\n     new+= letter*count\nreturn new \n\nBut I recommend using \"Counter(s).most_common()\""
                    },
                    {
                        "username": "himanshu_210",
                        "content": "[@nirutgupta78](/nirutgupta78)   thanks "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "pop of a index is itself an O(n) operation, so your solution is going towards O(n**2)"
                    },
                    {
                        "username": "jinwei14",
                        "content": "as title..........."
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "This calls for a shameless Python one-liner solution!"
                    }
                ]
            }
        ]
    }
]