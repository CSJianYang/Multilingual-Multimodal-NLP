[
    {
        "task_id": "100",
        "title": "next_smallest_palindrome",
        "text": "Write a function to find the next smallest palindrome of a specified integer, returned as an integer.",
        "code": "package next_smallest_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc next_smallest_palindrome(num int) int {\n    if num == 0 {\n        return 0\n    }\n    if num == 1 {\n        return 1\n    }\n    if num % 2 == 0 {\n        return next_smallest_palindrome(num / 2)\n    }\n    return next_smallest_palindrome(num / 2) + next_smallest_palindrome(num / 2 + 1)\n}\n\n",
        "test_list": [
            "func TestNextSmallestPalindrome(t *testing.T) {",
            "if num := next_smallest_palindrome(0); num!= 0 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(1); num!= 1 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(2); num!= 2 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(3); num!= 3 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(4); num!= 4 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(5); num!= 5 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(6); num!= 6 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(7); num!= 7 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palindrome(8); num!= 8 {",
            "fmt.Println(\"num:\", num)",
            "}",
            "if num := next_smallest_palind",
            "func TestNext_Smallest_Palindrome(t *testing.T) {",
            "candidate := next_smallest_palindrome",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(99), expected: 101 },",
            "{ actual: candidate(1221), expected: 1331 },",
            "{ actual: candidate(120), expected: 121 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "101",
        "title": "kth_element",
        "text": "Write a function to find the kth element in the given list using 1-based indexing.",
        "code": "package kth_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc kth_element(arr []int, k int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if k == 0 {\n        return arr[0]\n    }\n    if k == 1 {\n        return arr[len(arr)-1]\n    }\n    return kth_element(arr[:k], k-1) + kth_element(arr[k:], k)\n}\n\n",
        "test_list": [
            "func TestKthElement(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if kth_element(arr, 0)!= 10 {",
            "t.Errorf(\"kth_element(arr, 0) = %d, want 10\", kth_element(arr, 0))",
            "}",
            "if kth_element(arr, 1)!= 5 {",
            "t.Errorf(\"kth_element(arr, 1) = %d, want 5\", kth_element(arr, 1))",
            "}",
            "if kth_element(arr, 2)!= 3 {",
            "t.Errorf(\"kth_element(arr, 2) = %d, want 3\", kth_element(arr, 2))",
            "}",
            "if kth_element(arr, 3)!= 2 {",
            "t.Errorf(\"kth_element(arr, 3) = %d, want 2\", kth_element(arr, 3))",
            "}",
            "if kth_element(arr, 4)!= 1 {",
            "t.Errorf(\"kth_element(arr, 4) = %d, want 1\", kth_element(arr, 4))",
            "}",
            "if kth_element(arr, 5)!= 0 {",
            "t.Errorf(\"kth_element(arr, 5) = %d, want 0\", kth_element(arr, 5))",
            "}",
            "if kth_element(arr, 6)!= 9 {",
            "t.Error",
            "func TestKth_Element(t *testing.T) {",
            "candidate := kth_element",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{12, 3, 5, 7, 19}, 2), expected: 3 },",
            "{ actual: candidate([]int{17, 24, 8, 23}, 3), expected: 8 },",
            "{ actual: candidate([]int{16, 21, 25, 36, 4}, 4), expected: 36 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "102",
        "title": "snake_to_camel",
        "text": "Write a function to convert a snake case string to camel case string.",
        "code": "package snake_to_camel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc snake_to_camel(word string) string {\n    return fmt.Sprintf(\"%s_%s\", word[0], word[1:])\n}\n\n",
        "test_list": [
            "func TestSnakeToCamel(t *testing.T) {",
            "tests := []",
            "func TestSnake_To_Camel(t *testing.T) {",
            "candidate := snake_to_camel",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python_program\"), expected: \"PythonProgram\" },",
            "{ actual: candidate(\"python_language\"), expected: \"PythonLanguage\" },",
            "{ actual: candidate(\"programming_language\"), expected: \"ProgrammingLanguage\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "103",
        "title": "eulerian_num",
        "text": "Write a function to find the Eulerian number a(n, m).",
        "code": "package eulerian_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc eulerian_num(n int, m int) int {\n    if n == 0 {\n        return m\n    }\n    if n == 1 {\n        return n\n    }\n    if n == 2 {\n        return eulerian_num(n-1, m) + eulerian_num(n-2, m)\n    }\n    if n % 2 == 0 {\n        return eulerian_num(n-1, m) + eulerian_num(n-2, m)\n    }\n    return eulerian_num(n-1, m) + eulerian_num(n-2, m) + eulerian_num(n-3, m)\n}\n\n",
        "test_list": [
            "func TestEulerianNum(t *testing.T) {",
            "if eulerian_num(0, 0)!= 1 {",
            "t.Errorf(\"Eulerian number of 0 is %d, want 1\", eulerian_num(0, 0))",
            "}",
            "if eulerian_num(1, 0)!= 1 {",
            "t.Errorf(\"Eulerian number of 1 is %d, want 1\", eulerian_num(1, 0))",
            "}",
            "if eulerian_num(2, 0)!= 1 {",
            "t.Errorf(\"Eulerian number of 2 is %d, want 1\", eulerian_num(2, 0))",
            "}",
            "if eulerian_num(3, 0)!= 1 {",
            "t.Errorf(\"Eulerian number of 3 is %d, want 1\", eulerian_num(3, 0))",
            "}",
            "if eulerian_num(4, 0)!= 1 {",
            "t.Errorf(\"Eulerian number of 4 is %d, want 1\", eulerian_num(4, 0))",
            "}",
            "if eulerian_num(5, 0)!= 1 {",
            "t.Errorf(\"Eulerian number of 5 is %d, want 1\", eulerian_num(",
            "func TestEulerian_Num(t *testing.T) {",
            "candidate := eulerian_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3, 1), expected: 4 },",
            "{ actual: candidate(4, 1), expected: 11 },",
            "{ actual: candidate(5, 3), expected: 26 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "104",
        "title": "sort_sublists",
        "text": "Write a function to sort each sublist of strings in a given list of lists.",
        "code": "package sort_sublists_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sort_sublists(input_list [][]string) [][]string {\n    output_list := make([][]string, len(input_list))\n    for i := 0; i < len(input_list); i++ {\n        output_list[i] = make([]string, len(input_list[i]))\n        for j := 0; j < len(input_list[i]); j++ {\n            output_list[i][j] = input_list[i][j]\n        }\n    }\n    return output_list\n}\n\n",
        "test_list": [
            "func TestSortSublists(t *testing.T) {",
            "input_list := [][]string{",
            "[]string{\"a\", \"b\", \"c\"},",
            "[]string{\"d\", \"e\", \"f\"},",
            "[]string{\"g\", \"h\", \"i\"},",
            "[]string{\"j\", \"k\", \"l\"},",
            "[]string{\"m\", \"n\", \"o\"},",
            "[]string{\"p\", \"q\", \"r\"},",
            "[]string{\"s\", \"t\", \"u\"},",
            "[]string{\"v\", \"w\", \"x\"},",
            "[]string{\"z\", \"a\", \"b\"},",
            "[]string{\"c\", \"d\", \"e\"},",
            "[]string{\"f\", \"g\", \"h\"},",
            "[]string{\"i\", \"j\", \"k\"},",
            "[]string{\"l\", \"m\", \"n\"},",
            "[]string{\"o\", \"p\", \"q\"},",
            "[]string{\"r\", \"s\", \"t\"},",
            "[]string{\"u\", \"v\", \"w\"},",
            "[]string{\"x\", \"z\", \"a\"},",
            "}",
            "output_list := sort_sublists(input_list)",
            "fmt.Println(output_list)",
            "}",
            "<|endoftext|>",
            "func TestSort_Sublists(t *testing.T) {",
            "candidate := sort_sublists",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]string{\"green\", \"orange\"}, []string{\"black\", \"white\"}, []string{\"white\", \"black\", \"orange\"}}), expected: [][]int{[]string{\"green\", \"orange\"}, []string{\"black\", \"white\"}, []string{\"black\", \"orange\", \"white\"}} },",
            "{ actual: candidate([][]int{[]string{\" red \", \"green\"}, []string{\"blue \", \" black\"}, []string{\" orange\", \"brown\"}}), expected: [][]int{[]string{\" red \", \"green\"}, []string{\" black\", \"blue \"}, []string{\" orange\", \"brown\"}} },",
            "{ actual: candidate([][]int{[]string{\"zilver\", \"gold\"}, []string{\"magnesium\", \"aluminium\"}, []string{\"steel\", \"bronze\"}}), expected: [][]int{[]string{\"gold\", \"zilver\"}, []string{\"aluminium\", \"magnesium\"}, []string{\"bronze\", \"steel\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "105",
        "title": "count",
        "text": "Write a gothon function to count true booleans in the given list.",
        "code": "package count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count(lst []bool) int {\n    var count int\n    for _, b := range lst {\n        if b {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCount(t *testing.T) {",
            "lst := []bool{true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true, false, true,",
            "func TestCount(t *testing.T) {",
            "candidate := count",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]UNKNOWN{true, false, true}), expected: 2 },",
            "{ actual: candidate([]UNKNOWN{false, false}), expected: 0 },",
            "{ actual: candidate([]UNKNOWN{true, true, true}), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "106",
        "title": "add_lists",
        "text": "Write a function to append the given list to the given lists.",
        "code": "package add_lists_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc add_lists(test_list []int, test_tup []interface{}) []interface{} {\n    test_list = append(test_list, test_tup...)\n    return test_list\n}\n\n",
        "test_list": [
            "func TestAddLists(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_list = add_lists(test_list, test_tup)",
            "fmt.Println(test_list)",
            "}",
            "<|endoftext|>",
            "func TestAdd_Lists(t *testing.T) {",
            "candidate := add_lists",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 6, 7}, []interface{}{9, 10}), expected: []interface{}{9, 10, 5, 6, 7} },",
            "{ actual: candidate([]int{6, 7, 8}, []interface{}{10, 11}), expected: []interface{}{10, 11, 6, 7, 8} },",
            "{ actual: candidate([]int{7, 8, 9}, []interface{}{11, 12}), expected: []interface{}{11, 12, 7, 8, 9} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "108",
        "title": "merge_sorted_list",
        "text": "Write a function to merge three lists into a single sorted list.",
        "code": "package merge_sorted_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc merge_sorted_list(num1 []int, num2 []int, num3 []int) []int {\n    var nums []int\n    for _, v := range num1 {\n        nums = append(nums, v)\n    }\n    for _, v := range num2 {\n        nums = append(nums, v)\n    }\n    for _, v := range num3 {\n        nums = append(nums, v)\n    }\n    return nums\n}\n\n",
        "test_list": [
            "func TestMergeSortedList(t *testing.T) {",
            "var nums []int",
            "nums = merge_sorted_list([]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5})",
            "fmt.Println(nums)",
            "}",
            "<|endoftext|>",
            "func TestMerge_Sorted_List(t *testing.T) {",
            "candidate := merge_sorted_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{25, 24, 15, 4, 5, 29, 110}, []int{19, 20, 11, 56, 25, 233, 154}, []int{24, 26, 54, 48}), expected: []int{4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233} },",
            "{ actual: candidate([]int{1, 3, 5, 6, 8, 9}, []int{2, 5, 7, 11}, []int{1, 4, 7, 8, 12}), expected: []int{1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12} },",
            "{ actual: candidate([]int{18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1}, []int{25, 35, 22, 85, 14, 65, 75, 25, 58}, []int{12, 74, 9, 50, 61, 41}), expected: []int{1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "109",
        "title": "odd_Equivalent",
        "text": "Write a gothon function to find the number of numbers with an odd value when rotating a binary string the given number of times.",
        "code": "package odd_Equivalent_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc odd_Equivalent(s string, n int) int {\n    var count int\n    for i := 0; i < n; i++ {\n        if s[i] == '1' {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestOddEquivalent(t *testing.T) {",
            "var s string",
            "s = \"1\"",
            "if odd_Equivalent(s, 1)!= 1 {",
            "t.Errorf(\"odd_Equivalent(s, 1) = %d, want 1\", odd_Equivalent(s, 1))",
            "}",
            "s = \"1\"",
            "if odd_Equivalent(s, 2)!= 1 {",
            "t.Errorf(\"odd_Equivalent(s, 2) = %d, want 1\", odd_Equivalent(s, 2))",
            "}",
            "s = \"1\"",
            "if odd_Equivalent(s, 3)!= 1 {",
            "t.Errorf(\"odd_Equivalent(s, 3) = %d, want 1\", odd_Equivalent(s, 3))",
            "}",
            "s = \"1\"",
            "if odd_Equivalent(s, 4)!= 1 {",
            "t.Errorf(\"odd_Equivalent(s, 4) = %d, want 1\", odd_Equivalent(s, 4))",
            "}",
            "s = \"1\"",
            "if odd_Equivalent(s, 5)!= 1 {",
            "t.Errorf(\"odd_Equivalent(s, 5) = %d, want 1\", odd_Equivalent(s, 5))",
            "}",
            "s = \"1\"",
            "if odd_Equivalent(s, 6)!= 1 {",
            "t.Errorf(\"odd_Equivalent(s, 6) = %d, want 1\", odd_Equivalent(s, 6))",
            "}",
            "s = \"1\"",
            "if odd_Equivalent(s, 7)!= 1 {",
            "t.Errorf(\"odd_Equivalent",
            "func TestOdd_Equivalent(t *testing.T) {",
            "candidate := odd_Equivalent",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"011001\", 6), expected: 3 },",
            "{ actual: candidate(\"11011\", 5), expected: 4 },",
            "{ actual: candidate(\"1010\", 4), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "113",
        "title": "check_integer",
        "text": "Write a function to check if a string represents an integer or not.",
        "code": "package check_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_integer(text string) bool {\n    return text == \"1\" || text == \"2\" || text == \"3\" || text == \"4\" || text == \"5\" || text == \"6\" || text == \"7\" || text == \"8\" || text == \"9\" || text == \"10\" || text == \"11\" || text == \"12\" || text == \"13\" || text == \"14\" || text == \"15\" || text == \"16\" || text == \"17\" || text == \"18\" || text == \"19\" || text == \"20\" || text == \"21\" || text == \"22\" || text == \"23\" || text == \"24\" || text == \"25\" || text == \"26\" || text == \"27\" || text == \"28\" || text == \"29\" || text == \"30\" || text == \"31\" || text == \"32\" || text == \"33\" || text == \"34\" || text == \"35\" || text == \"36\" || text == \"37\" || text == \"38\" || text == \"39\" || text == \"40\" || text == \"41\" || text == \"42\" || text == \"43\" || text == \"44\" || text == \"45\" || text == \"46\" || text == \"47\" || text == \"48\" || text == \"49\" || text == \"50\" || text == \"51\" || text == \"52\" || text == \"53\" || text == \"54\" || text == \"55\" || text == \"56\" || text == \"57\" || text == \"58\" || text == \"59\" || text == \"60\" || text == \"61\" || text == \"62\" || text == \"63\" || text == \"64\" || text == \"65\" || text == \"66\" || text == \"67\" || text == \"68\" || text == \"69\" || text == \"70\" || text == \"71\" || text == \"72\" || text == \"73\" || text == \"74\" || text == \"75\" || text == \"76\" || text ==\n",
        "test_list": [
            "func TestCheck_Integer(t *testing.T) {",
            "candidate := check_integer",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python\"), expected: false },",
            "{ actual: candidate(\"1\"), expected: true },",
            "{ actual: candidate(\"12345\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "116",
        "title": "tuple_to_int",
        "text": "Write a function to convert a given list of positive integers into a single integer.",
        "code": "package tuple_to_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc tuple_to_int(nums []interface{}) int {\n    var result int\n    for _, num := range nums {\n        result = result * 10 + int(num.(int))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestTupleToInt(t *testing.T) {",
            "var nums []interface{}",
            "nums = []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := tuple_to_int(nums)",
            "if result!= 10 {",
            "t.Errorf(\"Expected 10, got %d\", result)",
            "}",
            "}",
            "func TestTupleToInt_Error(t *testing.T) {",
            "var nums []interface{}",
            "nums = []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := tuple_to_int(nums)",
            "if result!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", result)",
            "}",
            "}",
            "func TestTupleToInt_Error_Error(t *testing.T) {",
            "var nums []interface{}",
            "nums = []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := tuple_to_int(nums)",
            "if result!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", result)",
            "}",
            "}",
            "func TestTupleToInt_Error_Error_Error(t *testing.T) {",
            "var nums []interface{}",
            "nums = []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := tuple_to_int(nums)",
            "if result!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", result)",
            "}",
            "}",
            "func TestTupleToInt_Error_Error_Error(t *testing.T) {",
            "var",
            "func TestTuple_To_Int(t *testing.T) {",
            "candidate := tuple_to_int",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{1, 2, 3}), expected: 123 },",
            "{ actual: candidate([]interface{}{4, 5, 6}), expected: 456 },",
            "{ actual: candidate([]interface{}{5, 6, 7}), expected: 567 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "117",
        "title": "list_to_float",
        "text": "Write a function to convert all possible convertible elements in a list of lists to floats.",
        "code": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var test_list_copy [][]interface{}\n    for _, test_list_item := range test_list {\n        test_list_copy = append(test_list_copy, test_list_item)\n    }\n    return test_list_copy\n}\n\n",
        "test_list": [
            "func TestListToFloat(t *testing.T) {",
            "test_list := list_to_float([]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "})",
            "fmt.Println(test_list)",
            "}",
            "<|endoftext|>",
            "func TestList_To_Float(t *testing.T) {",
            "candidate := list_to_float",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },",
            "{ actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },",
            "{ actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "118",
        "title": "string_to_list",
        "text": "Write a function to convert a string to a list of strings split on the space character.",
        "code": "package string_to_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc string_to_list(myString string) []string {\n    var list []string\n    for _, char := range myString {\n        if char =='' {\n            list = append(list, myString)\n        }\n    }\n    return list\n}\n\n",
        "test_list": [
            "func TestStringToList(t *testing.T) {",
            "var list []string",
            "for _, s := range string_to_list(\"hello\") {",
            "list = append(list, s)",
            "}",
            "fmt.Println(list)",
            "}",
            "<|endoftext|>",
            "func TestString_To_List(t *testing.T) {",
            "candidate := string_to_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python programming\"), expected: []string{\"python\", \"programming\"} },",
            "{ actual: candidate(\"lists tuples strings\"), expected: []string{\"lists\", \"tuples\", \"strings\"} },",
            "{ actual: candidate(\"write a program\"), expected: []string{\"write\", \"a\", \"program\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "119",
        "title": "search",
        "text": "Write a gothon function to find the element that appears only once in a sorted list.",
        "code": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < len(arr); i++ {\n        if arr[i] == arr[i+1] {\n            return i\n        }\n    }\n    return -1\n}\n\n",
        "test_list": [
            "func TestSearch(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if search(arr)!= 5 {",
            "t.Errorf(\"expected 5, got %d\", search(arr))",
            "}",
            "}",
            "func TestSearch2(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if search(arr)!= -1 {",
            "t.Errorf(\"expected -1, got %d\", search(arr))",
            "}",
            "}",
            "func TestSearch3(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if search(arr)!= -1 {",
            "t.Errorf(\"expected -1, got %d\", search(arr))",
            "}",
            "}",
            "func TestSearch4(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if search(arr)!= -1 {",
            "t.Errorf(\"expected -1, got %d\", search(arr))",
            "}",
            "}",
            "func TestSearch5(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if search(arr)!= -1 {",
            "t.Errorf(\"expected -1, got %d\", search(arr))",
            "}",
            "}",
            "func TestSearch6(t *testing.T",
            "func TestSearch(t *testing.T) {",
            "candidate := search",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },",
            "{ actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },",
            "{ actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "11",
        "title": "remove_Occ",
        "text": "Write a gothon function to remove first and last occurrence of a given character from the string.",
        "code": "package remove_Occ_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_Occ(s string, ch string) string {\n    if len(s) == 0 {\n        return \"\"\n    }\n    if len(s) == 1 {\n        return s\n    }\n    if len(s) == 2 {\n        if s[0] == ch {\n            return s[1:]\n        }\n    }\n    return s\n}\n\n",
        "test_list": [
            "func TestRemoveOcc(t *testing.T) {",
            "s := \"hello\"",
            "if s == remove_Occ(s, 'h') {",
            "t.Errorf(\"remove_Occ(s, 'h') = %q, want %q\", s, remove_Occ(s, 'h'))",
            "}",
            "if s == remove_Occ(s, 'l') {",
            "t.Errorf(\"remove_Occ(s, 'l') = %q, want %q\", s, remove_Occ(s, 'l'))",
            "}",
            "if s == remove_Occ(s, 'o') {",
            "t.Errorf(\"remove_Occ(s, 'o') = %q, want %q\", s, remove_Occ(s, 'o'))",
            "}",
            "if s == remove_Occ(s, 'r') {",
            "t.Errorf(\"remove_Occ(s, 'r') = %q, want %q\", s, remove_Occ(s, 'r'))",
            "}",
            "if s == remove_Occ(s, 'e') {",
            "t.Errorf(\"remove_Occ(s, 'e') = %q, want %q\", s, remove_Occ(s, 'e'))",
            "}",
            "if s == remove_Occ(s, 'l') {",
            "t.Errorf(\"remove_Occ(s, 'l') = %q, want %q\", s, remove_Occ(s, 'l'))",
            "}",
            "if s == remove_Occ(s, 'o') {",
            "t.Errorf(\"remove_Occ(s, 'o') = %q",
            "func TestRemove_Occ(t *testing.T) {",
            "candidate := remove_Occ",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"hello\", \"l\"), expected: \"heo\" },",
            "{ actual: candidate(\"abcda\", \"a\"), expected: \"bcd\" },",
            "{ actual: candidate(\"PHP\", \"P\"), expected: \"H\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "120",
        "title": "max_product_tuple",
        "text": "Write a function to find the maximum absolute product between numbers in pairs of lists within a given list.",
        "code": "package max_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_product_tuple(list1 [][]interface{}) int {\n    var max int\n    for i := 0; i < len(list1); i++ {\n        for j := 0; j < len(list1[i]); j++ {\n            if list1[i][j] > max {\n                max = list1[i][j]\n            }\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxProductTuple(t *testing.T) {",
            "list1 := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "max := max_product_tuple(list1)",
            "fmt.Println(max)",
            "}",
            "<|endoftext|>",
            "func TestMax_Product_Tuple(t *testing.T) {",
            "candidate := max_product_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 36 },",
            "{ actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 200 },",
            "{ actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 484 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "123",
        "title": "amicable_numbers_sum",
        "text": "Write a function to sum all amicable numbers from 1 to a specified number.",
        "code": "package amicable_numbers_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc amicable_numbers_sum(limit int) int {\n    var sum int\n    for i := 1; i <= limit; i++ {\n        sum += i\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestAmicableNumbersSum(t *testing.T) {",
            "if amicable_numbers_sum(10)!= 10 {",
            "t.Errorf(\"Amicable numbers sum should be 10\")",
            "}",
            "}",
            "func TestAmicableNumbersSum2(t *testing.T) {",
            "if amicable_numbers_sum(100)!= 100 {",
            "t.Errorf(\"Amicable numbers sum should be 100\")",
            "}",
            "}",
            "func TestAmicableNumbersSum3(t *testing.T) {",
            "if amicable_numbers_sum(1000)!= 1000 {",
            "t.Errorf(\"Amicable numbers sum should be 1000\")",
            "}",
            "}",
            "func TestAmicableNumbersSum4(t *testing.T) {",
            "if amicable_numbers_sum(10000)!= 10000 {",
            "t.Errorf(\"Amicable numbers sum should be 10000\")",
            "}",
            "}",
            "func TestAmicableNumbersSum5(t *testing.T) {",
            "if amicable_numbers_sum(100000)!= 100000 {",
            "t.Errorf(\"Amicable numbers sum should be 100000\")",
            "}",
            "}",
            "func TestAmicableNumbersSum6(t *testing.T) {",
            "if amicable_numbers_sum(1000000)!= 1000000 {",
            "t.Errorf(\"Amicable numbers sum should be 1000000\")",
            "}",
            "}",
            "func TestAmicableNumbersSum7(t *testing.T) {",
            "if amicable_numbers_sum(10000000)!= 10000000 {",
            "t.Errorf(\"Amicable numbers sum should be 10000000\")",
            "}",
            "}",
            "func TestAmicableNumbersSum8(t *testing.T) {",
            "if amicable_numbers_sum(100000000)!= 100000000 {",
            "t.",
            "func TestAmicable_Numbers_Sum(t *testing.T) {",
            "candidate := amicable_numbers_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(999), expected: 504 },",
            "{ actual: candidate(9999), expected: 31626 },",
            "{ actual: candidate(99), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "125",
        "title": "find_length",
        "text": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.",
        "code": "package find_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_length(myString string) int {\n    var maxDiff int\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == '0' {\n            maxDiff = maxDiff + find_length(myString[i+1:])\n        }\n    }\n    return maxDiff\n}\n\n",
        "test_list": [
            "func TestFindLength(t *testing.T) {",
            "var myString string",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "myString = \"0\"",
            "myString = \"1\"",
            "my",
            "func TestFind_Length(t *testing.T) {",
            "candidate := find_length",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"11000010001\"), expected: 6 },",
            "{ actual: candidate(\"10111\"), expected: 1 },",
            "{ actual: candidate(\"11011101100101\"), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "126",
        "title": "sum",
        "text": "Write a gothon function to find the sum of common divisors of two given numbers.",
        "code": "package sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum(a int, b int) int {\n    if a == 0 {\n        return b\n    }\n    if b == 0 {\n        return a\n    }\n    return sum(a/b, b/a)\n}\n\n",
        "test_list": [
            "func TestSum(t *testing.T) {",
            "var tests = []",
            "func TestSum(t *testing.T) {",
            "candidate := sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 15), expected: 6 },",
            "{ actual: candidate(100, 150), expected: 93 },",
            "{ actual: candidate(4, 6), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "127",
        "title": "multiply_int",
        "text": "Write a function to multiply two integers.",
        "code": "package multiply_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc multiply_int(x int, y int) int {\n    return x * y\n}\n\n",
        "test_list": [
            "func TestMultiplyInt(t *testing.T) {",
            "fmt.Println(\"multiply_int\")",
            "x := 1",
            "y := 2",
            "fmt.Println(\"x:\", x)",
            "fmt.Println(\"y:\", y)",
            "fmt.Println(\"multiply_int:\", multiply_int(x, y))",
            "}",
            "<|endoftext|>",
            "func TestMultiply_Int(t *testing.T) {",
            "candidate := multiply_int",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 20), expected: 200 },",
            "{ actual: candidate(5, 10), expected: 50 },",
            "{ actual: candidate(4, 8), expected: 32 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "128",
        "title": "long_words",
        "text": "Write a function to find words that are longer than n characters from a given list of words.",
        "code": "package long_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc long_words(n int, str string) []string {\n    var words []string\n    for _, word := range str {\n        if len(word) > n {\n            words = append(words, word)\n        }\n    }\n    return words\n}\n\n",
        "test_list": [
            "func TestLongWords(t *testing.T) {",
            "words := long_words(10, \"hello\")",
            "fmt.Println(words)",
            "}",
            "<|endoftext|>",
            "func TestLong_Words(t *testing.T) {",
            "candidate := long_words",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3, \"python is a programming language\"), expected: []string{\"python\", \"programming\", \"language\"} },",
            "{ actual: candidate(2, \"writing a program\"), expected: []string{\"writing\", \"program\"} },",
            "{ actual: candidate(5, \"sorting list\"), expected: []string{\"sorting\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "129",
        "title": "magic_square_test",
        "text": "Write a function to calculate whether the matrix is a magic square.",
        "code": "package magic_square_test_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc magic_square_test(my_matrix [][]int) bool {\n    for i := 0; i < len(my_matrix); i++ {\n        for j := 0; j < len(my_matrix[i]); j++ {\n            if my_matrix[i][j] == 0 {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestMagicSquare(t *testing.T) {",
            "if magic_square_test(magic_square_test_test) {",
            "t.Error(\"magic square test failed\")",
            "}",
            "}",
            "func magic_square_test_test(my_matrix [][]int) {",
            "for i := 0; i < len(my_matrix); i++ {",
            "for j := 0; j < len(my_matrix[i]); j++ {",
            "if my_matrix[i][j] == 0 {",
            "fmt.Println(\"i:\", i, \"j:\", j)",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_matrix[i][j] =\", my_matrix[i][j])",
            "fmt.Println(\"my_mat",
            "func TestMagic_Square_Test(t *testing.T) {",
            "candidate := magic_square_test",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{7, 12, 1, 14}, []int{2, 13, 8, 11}, []int{16, 3, 10, 5}, []int{9, 6, 15, 4}}), expected: true },",
            "{ actual: candidate([][]int{[]int{2, 7, 6}, []int{9, 5, 1}, []int{4, 3, 8}}), expected: true },",
            "{ actual: candidate([][]int{[]int{2, 7, 6}, []int{9, 5, 1}, []int{4, 3, 7}}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "12",
        "title": "sort_matrix",
        "text": "Write a function to sort a given matrix in ascending order according to the sum of its rows.",
        "code": "package sort_matrix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sort_matrix(M [][]int) [][]int {\n    var sorter = func(i, j int) bool {\n        return M[i][j] > 0\n    }\n    return sort(M, sorter)\n}\n\n",
        "test_list": [
            "func TestSortMatrix(t *testing.T) {",
            "var M [][]int",
            "M = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "sort_matrix(M)",
            "if len(M)!= 9 {",
            "t.Errorf(\"expected len(M) == 9, got %d\", len(M))",
            "}",
            "}",
            "func TestSortMatrix_1(t *testing.T) {",
            "var M [][]int",
            "M = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "sort_matrix(M)",
            "if len(M)!= 9 {",
            "t.Errorf(\"expected len(M) == 9, got %d\", len(M))",
            "}",
            "}",
            "func TestSortMatrix_2(t *testing.T) {",
            "var M [][]int",
            "M = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "sort_matrix(M)",
            "if len(M)!= 9 {",
            "t.Errorf(\"expected len(M) == 9, got %d\", len(M))",
            "}",
            "}",
            "func TestSortMatrix_3(t *testing.T) {",
            "var M [][]int",
            "M = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "sort_matrix(M)",
            "if len(M)!= 9 {",
            "t.Errorf(\"expected len(M) == 9, got %d\", len(M))",
            "}",
            "}",
            "func TestSortMatrix_4(t *testing.T) {",
            "var M [][]int",
            "func TestSort_Matrix(t *testing.T) {",
            "candidate := sort_matrix",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 2, 3}, []int{2, 4, 5}, []int{1, 1, 1}}), expected: [][]int{[]int{1, 1, 1}, []int{1, 2, 3}, []int{2, 4, 5}} },",
            "{ actual: candidate([][]int{[]int{1, 2, 3}, []int{-2, 4, -5}, []int{1, -1, 1}}), expected: [][]int{[]int{-2, 4, -5}, []int{1, -1, 1}, []int{1, 2, 3}} },",
            "{ actual: candidate([][]int{[]int{5, 8, 9}, []int{6, 4, 3}, []int{2, 1, 4}}), expected: [][]int{[]int{2, 1, 4}, []int{6, 4, 3}, []int{5, 8, 9}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "130",
        "title": "max_occurrences",
        "text": "Write a function to find the item with maximum frequency in a given list.",
        "code": "package max_occurrences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_occurrences(nums []int) int {\n    max := 0\n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxOccurrences(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := max_occurrences(nums)",
            "fmt.Println(max)",
            "}",
            "<|endoftext|>",
            "func TestMax_Occurrences(t *testing.T) {",
            "candidate := max_occurrences",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2}), expected: 2 },",
            "{ actual: candidate([]int{2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18}), expected: 8 },",
            "{ actual: candidate([]int{10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10}), expected: 20 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "131",
        "title": "reverse_vowels",
        "text": "Write a gothon function to reverse only the vowels of a given string (where y is not a vowel).",
        "code": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c!= 'y' {\n            str2 += c\n        }\n    }\n    return str2\n}\n\n",
        "test_list": [
            "func TestReverseVowels(t *testing.T) {",
            "var str1 string",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "t.Errorf(\"Expected 'hello' but got '%s'\", str1)",
            "}",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "t.Errorf(\"Expected 'hello' but got '%s'\", str1)",
            "}",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "t.Errorf(\"Expected 'hello' but got '%s'\", str1)",
            "}",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "t.Errorf(\"Expected 'hello' but got '%s'\", str1)",
            "}",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "t.Errorf(\"Expected 'hello' but got '%s'\", str1)",
            "}",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "t.Errorf(\"Expected 'hello' but got '%s'\", str1)",
            "}",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "t.Errorf(\"Expected 'hello' but got '%s'\", str1)",
            "}",
            "str1, _ = reverse_vowels(\"hello\")",
            "if str1!= \"hello\" {",
            "func TestReverse_Vowels(t *testing.T) {",
            "candidate := reverse_vowels",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Python\"), expected: \"Python\" },",
            "{ actual: candidate(\"USA\"), expected: \"ASU\" },",
            "{ actual: candidate(\"ab\"), expected: \"ab\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "132",
        "title": "tup_string",
        "text": "Write a function to convert a list to a string.",
        "code": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc tup_string(tup1 []string) string {\n    return fmt.Sprintf(\"%v\", tup1)\n}\n\n",
        "test_list": [
            "func TestTupString(t *testing.T) {",
            "t.Parallel()",
            "var tup1 = []string{\"a\", \"b\", \"c\"}",
            "var tup2 = tup_string(tup1)",
            "if tup1!= tup2 {",
            "t.Errorf(\"Expected %v, got %v\", tup1, tup2)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestTup_String(t *testing.T) {",
            "candidate := tup_string",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },",
            "{ actual: candidate([]string{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },",
            "{ actual: candidate([]string{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "133",
        "title": "sum_negativenum",
        "text": "Write a function to calculate the sum of the negative numbers of a given list of numbers.",
        "code": "package sum_negativenum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_negativenum(nums []int) int {\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSumNegativenum(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := sum_negativenum(nums)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestSum_Negativenum(t *testing.T) {",
            "candidate := sum_negativenum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 4, -6, -9, 11, -12, 14, -5, 17}), expected: -32 },",
            "{ actual: candidate([]int{10, 15, -14, 13, -18, 12, -20}), expected: -52 },",
            "{ actual: candidate([]int{19, -65, 57, 39, 152, -639, 121, 44, 90, -190}), expected: -894 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "135",
        "title": "hexagonal_num",
        "text": "Write a function to find the nth hexagonal number.",
        "code": "package hexagonal_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc hexagonal_num(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        return 32\n    \n",
        "test_list": [
            "func TestHexagonal_Num(t *testing.T) {",
            "candidate := hexagonal_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: 190 },",
            "{ actual: candidate(5), expected: 45 },",
            "{ actual: candidate(7), expected: 91 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "138",
        "title": "is_Sum_Of_Powers_Of_Two",
        "text": "Write a gothon function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
        "code": "package is_Sum_Of_Powers_Of_Two_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_Sum_Of_Powers_Of_Two(n int) bool {\n    return n > 0 && n % 2 == 0\n}\n\n",
        "test_list": [
            "func TestIsSumOfPowersOfTwo(t *testing.T) {",
            "if!is_Sum_Of_Powers_Of_Two(1) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(1) should return true\")",
            "}",
            "if!is_Sum_Of_Powers_Of_Two(2) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(2) should return true\")",
            "}",
            "if!is_Sum_Of_Powers_Of_Two(3) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(3) should return true\")",
            "}",
            "if!is_Sum_Of_Powers_Of_Two(4) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(4) should return true\")",
            "}",
            "if!is_Sum_Of_Powers_Of_Two(5) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(5) should return true\")",
            "}",
            "if!is_Sum_Of_Powers_Of_Two(6) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(6) should return true\")",
            "}",
            "if!is_Sum_Of_Powers_Of_Two(7) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(7) should return true\")",
            "}",
            "if!is_Sum_Of_Powers_Of_Two(8) {",
            "t.Errorf(\"is_Sum_Of_Powers_Of_Two(8) should return true\")",
            "}",
            "if!is",
            "func TestIs_Sum_Of_Powers_Of_Two(t *testing.T) {",
            "candidate := is_Sum_Of_Powers_Of_Two",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: true },",
            "{ actual: candidate(7), expected: false },",
            "{ actual: candidate(14), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "141",
        "title": "pancake_sort",
        "text": "Write a function to sort a list of elements.",
        "code": "package pancake_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pancake_sort(nums []int) []int {\n    if len(nums) == 0 {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < len(nums); i++ {\n        result = append(result, nums[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestPancakeSort(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if len(nums)!= 8 {",
            "t.Errorf(\"len(nums) = %d, want %d\", len(nums), 8)",
            "}",
            "if len(pancake_sort(nums))!= 8 {",
            "t.Errorf(\"len(pancake_sort(nums)) = %d, want %d\", len(pancake_sort(nums)), 8)",
            "}",
            "}",
            "func TestPancakeSort_Error(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if len(nums)!= 8 {",
            "t.Errorf(\"len(nums) = %d, want %d\", len(nums), 8)",
            "}",
            "if len(pancake_sort(nums))!= 8 {",
            "t.Errorf(\"len(pancake_sort(nums)) = %d, want %d\", len(pancake_sort(nums)), 8)",
            "}",
            "}",
            "func TestPancakeSort_Error_2(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if len(nums)!= 8 {",
            "t.Errorf(\"len(nums) = %d, want %d\", len(nums), 8)",
            "}",
            "if len(pancake_sort(nums))!= 8 {",
            "func TestPancake_Sort(t *testing.T) {",
            "candidate := pancake_sort",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{15, 79, 25, 38, 69}), expected: []int{15, 25, 38, 69, 79} },",
            "{ actual: candidate([]int{98, 12, 54, 36, 85}), expected: []int{12, 36, 54, 85, 98} },",
            "{ actual: candidate([]int{41, 42, 32, 12, 23}), expected: []int{12, 23, 32, 41, 42} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "142",
        "title": "count_samepair",
        "text": "Write a function to count number items that are identical in the same position of three given lists.",
        "code": "package count_samepair_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_samepair(list1 []int, list2 []int, list3 []int) int {\n    if len(list1)!= len(list2) {\n        return 0\n    }\n    if len(list1)!= len(list3) {\n        return 0\n    }\n    for i := 0; i < len(list1); i++ {\n        if list1[i]!= list2[i] {\n            return 0\n        }\n    }\n    for i := 0; i < len(list3); i++ {\n        if list3[i]!= list1[i] {\n            return 0\n        }\n    }\n    return 1\n}\n\n",
        "test_list": [
            "func TestCountSamepair(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list3 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if count_samepair(list1, list2, list3)!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", count_samepair(list1, list2, list3))",
            "}",
            "if count_samepair(list1, list2, list3)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", count_samepair(list1, list2, list3))",
            "}",
            "if count_samepair(list1, list2, list3)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", count_samepair(list1, list2, list3))",
            "}",
            "if count_samepair(list1, list2, list3)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", count_samepair(list1, list2, list3))",
            "}",
            "if count_samepair",
            "func TestCount_Samepair(t *testing.T) {",
            "candidate := count_samepair",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}, []int{2, 2, 3, 1, 2, 6, 7, 9}, []int{2, 1, 3, 1, 2, 6, 7, 9}), expected: 3 },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}, []int{2, 2, 3, 1, 2, 6, 7, 8}, []int{2, 1, 3, 1, 2, 6, 7, 8}), expected: 4 },",
            "{ actual: candidate([]int{1, 2, 3, 4, 2, 6, 7, 8}, []int{2, 2, 3, 1, 2, 6, 7, 8}, []int{2, 1, 3, 1, 2, 6, 7, 8}), expected: 5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "143",
        "title": "find_lists",
        "text": "Write a function to find number of lists present in the given list.",
        "code": "package find_lists_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_lists(Input []interface{}) int {\n    var count int\n    for _, item := range Input {\n        if item == nil {\n            continue\n        }\n        count++\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestFindLists(t *testing.T) {",
            "var input []interface{}",
            "input = append(input, \"1\")",
            "input = append(input, \"2\")",
            "input = append(input, \"3\")",
            "input = append(input, \"4\")",
            "input = append(input, \"5\")",
            "input = append(input, \"6\")",
            "input = append(input, \"7\")",
            "input = append(input, \"8\")",
            "input = append(input, \"9\")",
            "input = append(input, \"10\")",
            "input = append(input, \"11\")",
            "input = append(input, \"12\")",
            "input = append(input, \"13\")",
            "input = append(input, \"14\")",
            "input = append(input, \"15\")",
            "input = append(input, \"16\")",
            "input = append(input, \"17\")",
            "input = append(input, \"18\")",
            "input = append(input, \"19\")",
            "input = append(input, \"20\")",
            "input = append(input, \"21\")",
            "input = append(input, \"22\")",
            "input = append(input, \"23\")",
            "input = append(input, \"24\")",
            "input = append(input, \"25\")",
            "input = append(input, \"26\")",
            "input = append(input, \"27\")",
            "input = append(input, \"28\")",
            "input = append(input, \"29\")",
            "input = append(input, \"30\")",
            "input = append(input, \"31\")",
            "input = append(input, \"32\")",
            "input = append(input, \"33\")",
            "input = append(input, \"34\")",
            "input = append(input, \"35\")",
            "input = append(input, \"36",
            "func TestFind_Lists(t *testing.T) {",
            "candidate := find_lists",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}}), expected: 2 },",
            "{ actual: candidate([][]int{[]int{1, 2}, []int{3, 4}, []int{5, 6}}), expected: 3 },",
            "{ actual: candidate([]int{9, 8, 7, 6, 5, 4, 3, 2, 1}), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "145",
        "title": "max_Abs_Diff",
        "text": "Write a gothon function to find the maximum difference between any two elements in a given list.",
        "code": "package max_Abs_Diff_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_Abs_Diff(arr []int) int {\n    max := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i+1] {\n            max = arr[i]\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxAbsDiff(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_Abs_Diff(arr)!= 9 {",
            "t.Errorf(\"Expected max_Abs_Diff to return 9, got %d\", max_Abs_Diff(arr))",
            "}",
            "}",
            "func TestMaxAbsDiff_1(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_Abs_Diff(arr)!= 9 {",
            "t.Errorf(\"Expected max_Abs_Diff to return 9, got %d\", max_Abs_Diff(arr))",
            "}",
            "}",
            "func TestMaxAbsDiff_2(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_Abs_Diff(arr)!= 9 {",
            "t.Errorf(\"Expected max_Abs_Diff to return 9, got %d\", max_Abs_Diff(arr))",
            "}",
            "}",
            "func TestMaxAbsDiff_3(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_Abs_Diff(arr)!= 9 {",
            "t.Errorf(\"Expected max_Abs_Diff to return 9, got %d\", max_Abs_Diff(arr))",
            "}",
            "}",
            "func TestMaxAbsDiff_4(t *testing.T) {",
            "arr := []int{",
            "func TestMax_Abs_Diff(t *testing.T) {",
            "candidate := max_Abs_Diff",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 1, 5, 3}), expected: 4 },",
            "{ actual: candidate([]int{9, 3, 2, 5, 1}), expected: 8 },",
            "{ actual: candidate([]int{3, 2, 1}), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "14",
        "title": "find_Volume",
        "text": "Write a gothon function to find the volume of a triangular prism.",
        "code": "package find_Volume_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Volume(l int, b int, h int) int {\n    if l == 0 {\n        return b\n    }\n    if b == 0 {\n        return l\n    }\n    if h == 0 {\n        return l\n    }\n    if h == l {\n        return b\n    }\n    return find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l-1, b, h-1) + find_Volume(l\n",
        "test_list": [
            "func TestFind_Volume(t *testing.T) {",
            "candidate := find_Volume",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 8, 6), expected: 240 },",
            "{ actual: candidate(3, 2, 2), expected: 6 },",
            "{ actual: candidate(1, 2, 1), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "161",
        "title": "remove_elements",
        "text": "Write a function to remove all elements from a given list present in another list.",
        "code": "package remove_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_elements(list1 []int, list2 []int) []int {\n    var result []int\n    for _, element := range list1 {\n        for _, element2 := range list2 {\n            if element == element2 {\n                result = append(result, element)\n            }\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestRemoveElements(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := remove_elements(list1, list2)",
            "if len(result)!= 0 {",
            "t.Errorf(\"Expected result to be empty, but got %v\", result)",
            "}",
            "}",
            "func TestRemoveElements_1(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := remove_elements(list1, list2)",
            "if len(result)!= 1 {",
            "t.Errorf(\"Expected result to be 1, but got %v\", result)",
            "}",
            "}",
            "func TestRemoveElements_2(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := remove_elements(list1, list2)",
            "if len(result)!= 2 {",
            "t.Errorf(\"Expected result to be 2, but got %v\", result)",
            "}",
            "}",
            "func TestRemoveElements_3(t *testing.T) {",
            "list1 := []int{1, 2,",
            "func TestRemove_Elements(t *testing.T) {",
            "candidate := remove_elements",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, []int{2, 4, 6, 8}), expected: []int{1, 3, 5, 7, 9, 10} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, []int{1, 3, 5, 7}), expected: []int{2, 4, 6, 8, 9, 10} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, []int{5, 7}), expected: []int{1, 2, 3, 4, 6, 8, 9, 10} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "162",
        "title": "sum_series",
        "text": "Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).",
        "code": "package sum_series_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_series(n int) int {\n    sum := 0\n    for i := 0; i < n; i++ {\n        sum += i\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSumSeries(t *testing.T) {",
            "n := 10",
            "sum := sum_series(n)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestSum_Series(t *testing.T) {",
            "candidate := sum_series",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(6), expected: 12 },",
            "{ actual: candidate(10), expected: 30 },",
            "{ actual: candidate(9), expected: 25 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "164",
        "title": "are_equivalent",
        "text": "Write a function to determine if the sum of the divisors of two integers are the same.",
        "code": "package are_equivalent_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc are_equivalent(num1 int, num2 int) bool {\n    if num1 == 0 {\n        return num2 == 0\n    }\n    if num2 == 0 {\n        return num1 == num2\n    }\n    return num1 % num2 == 0\n}\n\n",
        "test_list": [
            "func TestAreEquivalent(t *testing.T) {",
            "if are_equivalent(1, 2) {",
            "t.Error(\"1 and 2 are equivalent\")",
            "}",
            "if are_equivalent(2, 1) {",
            "t.Error(\"2 and 1 are equivalent\")",
            "}",
            "if are_equivalent(2, 3) {",
            "t.Error(\"2 and 3 are equivalent\")",
            "}",
            "if are_equivalent(3, 2) {",
            "t.Error(\"3 and 2 are equivalent\")",
            "}",
            "if are_equivalent(3, 4) {",
            "t.Error(\"3 and 4 are equivalent\")",
            "}",
            "if are_equivalent(4, 3) {",
            "t.Error(\"4 and 3 are equivalent\")",
            "}",
            "if are_equivalent(4, 5) {",
            "t.Error(\"4 and 5 are equivalent\")",
            "}",
            "if are_equivalent(5, 4) {",
            "t.Error(\"5 and 4 are equivalent\")",
            "}",
            "if are_equivalent(5, 6) {",
            "t.Error(\"5 and 6 are equivalent\")",
            "}",
            "if are_equivalent(6, 5) {",
            "t.Error(\"6 and 5 are equivalent\")",
            "}",
            "if are_equivalent(6, 7) {",
            "t.Error(\"6 and 7 are equivalent\")",
            "}",
            "if are_equivalent(7, 6) {",
            "t.Error(\"7 and 6 are equivalent\")",
            "}",
            "if are_equivalent(7, 8) {",
            "t.Error(\"7 and 8 are equivalent\")",
            "}",
            "if are_equivalent(8, 7) {",
            "t.Error(\"8",
            "func TestAre_Equivalent(t *testing.T) {",
            "candidate := are_equivalent",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(36, 57), expected: false },",
            "{ actual: candidate(2, 4), expected: false },",
            "{ actual: candidate(23, 47), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "165",
        "title": "count_char_position",
        "text": "Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).",
        "code": "package count_char_position_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_char_position(str1 string) int {\n    var count int\n    for _, c := range str1 {\n        if c >= 'a' && c <= 'z' {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountCharPosition(t *testing.T) {",
            "var str1 string",
            "str1 = \"abcdefghijklmnopqrstuvwxyz\"",
            "fmt.Println(count_char_position(str1))",
            "}",
            "<|endoftext|>",
            "func TestCount_Char_Position(t *testing.T) {",
            "candidate := count_char_position",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"xbcefg\"), expected: 2 },",
            "{ actual: candidate(\"ABcED\"), expected: 3 },",
            "{ actual: candidate(\"AbgdeF\"), expected: 5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "166",
        "title": "find_even_pair",
        "text": "Write a function that counts the number of pairs of integers in a list that xor to an even number.",
        "code": "package find_even_pair_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_even_pair(A []int) int {\n    var count int\n    for _, x := range A {\n        if x % 2 == 0 {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestFindEvenPair(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if count := find_even_pair(A); count!= 10 {",
            "t.Errorf(\"find_even_pair(%v) = %v, want 10\", A, count)",
            "}",
            "}",
            "func TestFindEvenPair2(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if count := find_even_pair(A); count!= 10 {",
            "t.Errorf(\"find_even_pair(%v) = %v, want 10\", A, count)",
            "}",
            "}",
            "func TestFindEvenPair3(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if count := find_even_pair(A); count!= 10 {",
            "t.Errorf(\"find_even_pair(%v) = %v, want 10\", A, count)",
            "}",
            "}",
            "func TestFindEvenPair4(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if count := find_even_pair(A); count!= 10 {",
            "t.Errorf(\"find_even_pair(%v) = %v, want 10\", A, count)",
            "}",
            "}",
            "func TestFindEvenPair5(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7",
            "func TestFind_Even_Pair(t *testing.T) {",
            "candidate := find_even_pair",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 4, 7, 2, 1}), expected: 4 },",
            "{ actual: candidate([]int{7, 2, 8, 1, 0, 5, 11}), expected: 9 },",
            "{ actual: candidate([]int{1, 2, 3}), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "167",
        "title": "next_power_of_2",
        "text": "Write a gothon function to find the smallest power of 2 greater than or equal to n.",
        "code": "package next_power_of_2_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc next_power_of_2(n int) int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return 2\n    }\n    if n == 2 {\n        return 3\n    }\n    if n == 3 {\n        return 4\n    }\n    if n == 4 {\n        return 5\n    }\n    if n == 5 {\n        return 6\n    }\n    if n == 6 {\n        return 7\n    }\n    if n == 7 {\n        return 8\n    }\n    if n == 8 {\n        return 9\n    }\n    if n == 9 {\n        return 10\n    }\n    if n == 10 {\n        return 11\n    }\n    if n == 11 {\n        return 12\n    }\n    if n == 12 {\n        return 13\n    }\n    if n == 13 {\n        return 14\n    }\n    if n == 14 {\n        return 15\n    }\n    if n == 15 {\n        return 16\n    }\n    if n == 16 {\n        return 17\n    }\n    if n == 17 {\n        return 18\n    }\n    if n == 18 {\n        return 19\n    }\n    if n == 19 {\n        return 20\n    }\n    if n == 20 {\n        return 21\n    }\n    if n == 21 {\n        return 22\n    }\n    if n == 22 {\n        return 23\n    }\n    if n == 23 {\n        return 24\n    }\n    if n == 24 {\n        return 25\n    }\n    if n == 25 {\n        return 26\n    }\n    if n == 26 {\n        return 27\n    }\n    if n == 27 {\n        return 28\n    }\n    if n == 28 {\n        return 29\n    }\n    if n == 29 {\n        return 30\n    }\n    if n == 30 {\n        return 31\n    }\n    if n == 31 {\n        return 32\n    \n",
        "test_list": [
            "func TestNext_Power_Of_2(t *testing.T) {",
            "candidate := next_power_of_2",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(0), expected: 1 },",
            "{ actual: candidate(5), expected: 8 },",
            "{ actual: candidate(17), expected: 32 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "168",
        "title": "frequency",
        "text": "Write a function to count the number of occurrences of a number in a given list.",
        "code": "package frequency_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc frequency(a []int, x int) int {\n    if len(a) == 0 {\n        return 0\n    }\n    return a[len(a)-1] + frequency(a[:len(a)-1], x)\n}\n\n",
        "test_list": [
            "func TestFrequency(t *testing.T) {",
            "fmt.Println(\"Frequency\")",
            "for i := 0; i < 100; i++ {",
            "fmt.Println(fmt.Sprint(frequency([]int{}, i)))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestFrequency(t *testing.T) {",
            "candidate := frequency",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}, 4), expected: 0 },",
            "{ actual: candidate([]int{1, 2, 2, 3, 3, 3, 4}, 3), expected: 3 },",
            "{ actual: candidate([]int{0, 1, 2, 3, 1, 2}, 1), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "16",
        "title": "text_lowercase_underscore",
        "text": "Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.",
        "code": "package text_lowercase_underscore_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_lowercase_underscore(text string) bool {\n    return text == \"hello world\" || text == \"hello world_\" || text == \"hello world__\" || text == \"hello world___\" || text == \"hello world____\" || text == \"hello world_____\" || text == \"hello world______\" || text == \"hello world_______\" || text == \"hello world________\" || text == \"hello world_________\" || text == \"hello world__________\" || text == \"hello world__________\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text == \"hello world_________c\" || text\n",
        "test_list": [
            "func TestText_Lowercase_Underscore(t *testing.T) {",
            "candidate := text_lowercase_underscore",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"aab_cbbbc\"), expected: true },",
            "{ actual: candidate(\"aab_Abbbc\"), expected: false },",
            "{ actual: candidate(\"Aaab_abbbc\"), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "170",
        "title": "sum_range_list",
        "text": "Write a function to find the sum of numbers in a list within a range specified by two indices.",
        "code": "package sum_range_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_range_list(list1 []int, m int, n int) int {\n    sum := 0\n    for i := 0; i < len(list1); i++ {\n        sum += list1[i]\n        if sum >= m {\n            return sum\n        }\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSumRangeList(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "m := 10",
            "n := 10",
            "sum := sum_range_list(list1, m, n)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestSum_Range_List(t *testing.T) {",
            "candidate := sum_range_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12}, 8, 10), expected: 29 },",
            "{ actual: candidate([]int{2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12}, 5, 7), expected: 16 },",
            "{ actual: candidate([]int{2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12}, 7, 10), expected: 38 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "171",
        "title": "perimeter_pentagon",
        "text": "Write a function to find the perimeter of a regular pentagon from the length of its sides.",
        "code": "package perimeter_pentagon_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc perimeter_pentagon(a int) int {\n    return a * a * a * a\n}\n\n",
        "test_list": [
            "func TestPerimeter(t *testing.T) {",
            "a := 1",
            "b := 2",
            "c := 3",
            "d := 4",
            "e := 5",
            "f := 6",
            "g := 7",
            "h := 8",
            "i := 9",
            "j := 10",
            "k := 11",
            "l := 12",
            "m := 13",
            "n := 14",
            "o := 15",
            "p := 16",
            "q := 17",
            "r := 18",
            "s := 19",
            "t := 20",
            "u := 21",
            "v := 22",
            "w := 23",
            "x := 24",
            "y := 25",
            "z := 26",
            "a := perimeter_pentagon(a)",
            "b := perimeter_pentagon(b)",
            "c := perimeter_pentagon(c)",
            "d := perimeter_pentagon(d)",
            "e := perimeter_pentagon(e)",
            "f := perimeter_pentagon(f)",
            "g := perimeter_pentagon(g)",
            "h := perimeter_pentagon(h)",
            "i := perimeter_pentagon(i)",
            "j := perimeter_pentagon(j)",
            "k := perimeter_pentagon(k)",
            "l := perimeter_pentagon(l)",
            "m := perimeter_pentagon(m)",
            "n := perimeter_pentagon(n)",
            "o := perimeter_pentagon(o)",
            "p := perimeter_pentagon(p)",
            "q := perimeter_pentagon(q)",
            "r := perimeter_pentagon(r)",
            "s := perimeter_pentagon(s)",
            "t := perimeter_pentagon(t)",
            "u := perimeter_pentagon(u)",
            "v := perimeter_pentagon(v)",
            "w := perimeter_pentagon(w)",
            "x := perimeter_pentagon(x)",
            "y := perimeter_pentagon(y)",
            "z := perimeter_pentagon(z)",
            "a := perimeter_pentagon(a)",
            "func TestPerimeter_Pentagon(t *testing.T) {",
            "candidate := perimeter_pentagon",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: 25 },",
            "{ actual: candidate(10), expected: 50 },",
            "{ actual: candidate(15), expected: 75 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "172",
        "title": "count_occurance",
        "text": "Write a function to count the number of occurence of the string'std' in a given string.",
        "code": "package count_occurance_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_occurance(s string) int {\n    return len(s)\n}\n\n",
        "test_list": [
            "func TestCountOccurance(t *testing.T) {",
            "if count_occurance(\"std\")!= 1 {",
            "t.Errorf(\"Expected 1 occurence of std, got %d\", count_occurance(\"std\"))",
            "}",
            "if count_occurance(\"\")!= 0 {",
            "t.Errorf(\"Expected 0 occurence of std, got %d\", count_occurance(\"\"))",
            "}",
            "}",
            "func TestCountOccurance_String(t *testing.T) {",
            "if count_occurance(\"std\")!= 1 {",
            "t.Errorf(\"Expected 1 occurence of std, got %d\", count_occurance(\"std\"))",
            "}",
            "if count_occurance(\"\")!= 0 {",
            "t.Errorf(\"Expected 0 occurence of std, got %d\", count_occurance(\"\"))",
            "}",
            "}",
            "func TestCountOccurance_String_String(t *testing.T) {",
            "if count_occurance(\"std\")!= 1 {",
            "t.Errorf(\"Expected 1 occurence of std, got %d\", count_occurance(\"std\"))",
            "}",
            "if count_occurance(\"\")!= 0 {",
            "t.Errorf(\"Expected 0 occurence of std, got %d\", count_occurance(\"\"))",
            "}",
            "}",
            "func TestCountOccurance_String_String_String(t *testing.T) {",
            "if count_occurance(\"std\")!= 1 {",
            "t.Errorf(\"Expected 1 occurence of std, got %d\", count_occurance(\"std\"))",
            "}",
            "if count_occurance(\"\")!= 0 {",
            "t.Errorf(\"Expected 0 occurence of std, got %d\", count_occurance(\"\"))",
            "}",
            "}",
            "func TestCountOccurance_String_String_String_String(t *testing.T) {",
            "if",
            "func TestCount_Occurance(t *testing.T) {",
            "candidate := count_occurance",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"letstdlenstdporstd\"), expected: 3 },",
            "{ actual: candidate(\"truststdsolensporsd\"), expected: 1 },",
            "{ actual: candidate(\"makestdsostdworthit\"), expected: 2 },",
            "{ actual: candidate(\"stds\"), expected: 1 },",
            "{ actual: candidate(\"\"), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "17",
        "title": "square_perimeter",
        "text": "Write a function that returns the perimeter of a square given its side length as input.",
        "code": "package square_perimeter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc square_perimeter(a int) int {\n    return a * a\n}\n\n",
        "test_list": [
            "func TestSquarePerimeter(t *testing.T) {",
            "var testCases = []",
            "func TestSquare_Perimeter(t *testing.T) {",
            "candidate := square_perimeter",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: 40 },",
            "{ actual: candidate(5), expected: 20 },",
            "{ actual: candidate(4), expected: 16 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "18",
        "title": "remove_dirty_chars",
        "text": "Write a function to remove characters from the first string which are present in the second string.",
        "code": "package remove_dirty_chars_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_dirty_chars(myString string, second_string string) string {\n    var myString_copy = myString\n    var second_string_copy = second_string\n\n    for i := 0; i < len(myString_copy); i++ {\n        if myString_copy[i] == second_string_copy[i] {\n            myString_copy = myString_copy[:i]\n            second_string_copy = second_string_copy[:i]\n        }\n    }\n\n    return myString_copy\n}\n\n",
        "test_list": [
            "func TestRemoveDirtyChars(t *testing.T) {",
            "myString := \"hello world\"",
            "second_string := \"hello world\"",
            "if remove_dirty_chars(myString, second_string)!= second_string {",
            "t.Errorf(\"Expected %v to be %v\", myString, second_string)",
            "}",
            "}",
            "func TestRemoveDirtyChars_Error(t *testing.T) {",
            "myString := \"hello world\"",
            "second_string := \"hello world\"",
            "if remove_dirty_chars(myString, second_string)!= second_string {",
            "t.Errorf(\"Expected %v to be %v\", myString, second_string)",
            "}",
            "if remove_dirty_chars(myString, \"\")!= myString {",
            "t.Errorf(\"Expected %v to be %v\", myString, myString)",
            "}",
            "}",
            "func TestRemoveDirtyChars_Error_2(t *testing.T) {",
            "myString := \"hello world\"",
            "second_string := \"hello world\"",
            "if remove_dirty_chars(myString, second_string)!= second_string {",
            "t.Errorf(\"Expected %v to be %v\", myString, second_string)",
            "}",
            "if remove_dirty_chars(myString, \"\")!= myString {",
            "t.Errorf(\"Expected %v to",
            "func TestRemove_Dirty_Chars(t *testing.T) {",
            "candidate := remove_dirty_chars",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"probasscurve\", \"pros\"), expected: \"bacuve\" },",
            "{ actual: candidate(\"digitalindia\", \"talent\"), expected: \"digiidi\" },",
            "{ actual: candidate(\"exoticmiles\", \"toxic\"), expected: \"emles\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "19",
        "title": "test_duplicate",
        "text": "Write a function to find whether a given list of integers contains any duplicate element.",
        "code": "package test_duplicate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc test_duplicate(arraynums []int) bool {\n    var duplicates []int\n    for _, num := range arraynums {\n        if duplicates = duplicates[:]; duplicates == nil {\n            return false\n        }\n        if duplicates[len(duplicates)-1]!= num {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestDuplicate(t *testing.T) {",
            "arraynums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if test_duplicate(arraynums) {",
            "t.Errorf(\"Expected duplicate element to be found.\")",
            "}",
            "}",
            "func TestDuplicate_1(t *testing.T) {",
            "arraynums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!test_duplicate(arraynums) {",
            "t.Errorf(\"Expected duplicate element to be found.\")",
            "}",
            "}",
            "func TestDuplicate_2(t *testing.T) {",
            "arraynums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!test_duplicate(arraynums) {",
            "t.Errorf(\"Expected duplicate element to be found.\")",
            "}",
            "}",
            "func TestDuplicate_3(t *testing.T) {",
            "arraynums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!test_duplicate(arraynums) {",
            "t.Errorf(\"Expected duplicate element to be found.\")",
            "}",
            "}",
            "func TestDuplicate_4(t *testing.T) {",
            "arraynums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!test_duplicate(",
            "func TestTest_Duplicate(t *testing.T) {",
            "candidate := test_duplicate",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}), expected: false },",
            "{ actual: candidate([]int{1, 2, 3, 4, 4}), expected: true },",
            "{ actual: candidate([]int{1, 1, 2, 2, 3, 3, 4, 4, 5}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "20",
        "title": "is_woodall",
        "text": "Write a function to check if the given number is woodball or not.",
        "code": "package is_woodall_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_woodall(x int) bool {\n    return x%2 == 0\n}\n\n",
        "test_list": [
            "func TestIsWoodall(t *testing.T) {",
            "if is_woodall(1) {",
            "t.Error(\"is_woodall(1) should return false\")",
            "}",
            "if is_woodall(2) {",
            "t.Error(\"is_woodall(2) should return false\")",
            "}",
            "if is_woodall(3) {",
            "t.Error(\"is_woodall(3) should return false\")",
            "}",
            "if is_woodall(4) {",
            "t.Error(\"is_woodall(4) should return false\")",
            "}",
            "if is_woodall(5) {",
            "t.Error(\"is_woodall(5) should return false\")",
            "}",
            "if is_woodall(6) {",
            "t.Error(\"is_woodall(6) should return false\")",
            "}",
            "if is_woodall(7) {",
            "t.Error(\"is_woodall(7) should return false\")",
            "}",
            "if is_woodall(8) {",
            "t.Error(\"is_woodall(8) should return false\")",
            "}",
            "if is_woodall(9) {",
            "t.Error(\"is_woodall(9) should return false\")",
            "}",
            "if is_woodall(10) {",
            "t.Error(\"is_woodall(10) should return false\")",
            "}",
            "if is_woodall(11) {",
            "t.Error(\"is_woodall(11) should return false\")",
            "}",
            "if is_woodall(12) {",
            "t.Error(\"is_woodall(12) should return false\")",
            "}",
            "if is_woodall(13) {",
            "t.Error(\"is_woodall(13) should return false\")",
            "}",
            "if is_woodall(14) {",
            "t.Error(\"is_woodall(14) should return false\")",
            "func TestIs_Woodall(t *testing.T) {",
            "candidate := is_woodall",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(383), expected: true },",
            "{ actual: candidate(254), expected: false },",
            "{ actual: candidate(200), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "222",
        "title": "check_type",
        "text": "Check if all the elements in list have same data type or not.",
        "code": "package check_type_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_type(test_tuple interface{}) bool {\n    var test_list []interface{}\n    for _, v := range test_tuple.([]interface{}) {\n        test_list = append(test_list, v)\n    }\n    return check_type_list(test_list)\n}\n\nfunc check_type_list(test_list []interface{}) bool {\n    var test_list_copy []interface{}\n    for _, v := range test_list {\n        test_list_copy = append(test_list_copy, v)\n    }\n    return check_type_list(test_list_copy)\n}\n\nfunc check_type_list(test_list_copy []interface{}) bool {\n    var test_list_copy_copy []interface{}\n    for _, v := range test_list_copy {\n        test_list_copy_copy = append(test_list_copy_copy, v)\n    }\n    return check_type_list(test_list_copy_copy)\n}\n\nfunc check_type_list(test_list_copy []interface{}) bool {\n    var test_list_copy_copy []interface{}\n    for _, v := range test_list_copy {\n        test_list_copy_copy = append(test_list_copy_copy, v)\n    }\n    return check_type_list(test_list_copy_copy)\n}\n\nfunc check_type_list(test_list_copy_copy []interface{}) bool {\n    var test_list_copy_copy_copy []interface{}\n    for _, v := range test_list_copy_copy {\n        test_list_copy_copy_copy\n",
        "test_list": [
            "func TestCheck_Type(t *testing.T) {",
            "candidate := check_type",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{5, 6, 7, 3, 5, 6}), expected: true },",
            "{ actual: candidate([]interface{}{1, 2, \"4\"}), expected: false },",
            "{ actual: candidate([]interface{}{3, 2, 1, 4, 5}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "223",
        "title": "is_majority",
        "text": "Write a function that takes in a sorted list, its length (n), and an element and returns whether the element is the majority element in the given sorted list. (The majority element is the element that occurs more than n/2 times.)",
        "code": "package is_majority_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_majority(arr []int, n int, x int) bool {\n    if len(arr) == 0 {\n        return false\n    }\n    if len(arr) == 1 {\n        return arr[0] == x\n    }\n    if len(arr) == 2 {\n        if arr[0] == x && arr[1] == x {\n            return true\n        }\n        return is_majority(arr[1:], n, x)\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestIs_majority(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!is_majority(arr, 3, 10) {",
            "t.Errorf(\"is_majority(arr, 3, 10) = false\")",
            "}",
            "if!is_majority(arr, 3, 1) {",
            "t.Errorf(\"is_majority(arr, 3, 1) = false\")",
            "}",
            "if!is_majority(arr, 3, 2) {",
            "t.Errorf(\"is_majority(arr, 3, 2) = false\")",
            "}",
            "if!is_majority(arr, 3, 3) {",
            "t.Errorf(\"is_majority(arr, 3, 3) = false\")",
            "}",
            "if!is_majority(arr, 3, 4) {",
            "t.Errorf(\"is_majority(arr, 3, 4) = false\")",
            "}",
            "if!is_majority(arr, 3, 5) {",
            "t.Errorf(\"is_majority(arr, 3, 5) = false\")",
            "}",
            "if!is_majority(arr, 3, 6) {",
            "t.Errorf(\"is_majority(arr, 3, 6) = false\")",
            "}",
            "if!is_majority(arr, 3, 7",
            "func TestIs_Majority(t *testing.T) {",
            "candidate := is_majority",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 3, 3, 3, 10}, 7, 3), expected: true },",
            "{ actual: candidate([]int{1, 1, 2, 4, 4, 4, 6, 6}, 8, 4), expected: false },",
            "{ actual: candidate([]int{1, 1, 1, 2, 2}, 5, 1), expected: true },",
            "{ actual: candidate([]int{1, 1, 2, 2}, 5, 1), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "224",
        "title": "count_Set_Bits",
        "text": "Write a gothon function to count the number of set bits (binary digits with",
        "code": "package count_Set_Bits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_Set_Bits(n int) int {\n    return (n & (n - 1))\n}\n\nfunc count_Set_Bits_test(n int) int {\n    return (n & (n - 1))\n}\n\nfunc count_Set_Bits_test_2(n int) int {\n    return (n & (n - 1))\n}\n\nfunc count_Set_Bits_test_3(n int) int {\n    return (n & (n - 1))\n}\n\nfunc count_Set_Bits_test_4(n int) int {\n    return (n & (n - 1))\n}\n\nfunc count_Set_Bits_test_5(n int) int {\n    return (n & (n - 1))\n}\n\nfunc count_Set_Bits_test_6(n int) int {\n    return (n & (n - 1))\n}\n\nfunc count_Set_Bits_test_7(n int) int {\n    return (n & (n - 1))\n}\n\n",
        "test_list": [
            "func TestCount_Set_Bits(t *testing.T) {",
            "candidate := count_Set_Bits",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 1 },",
            "{ actual: candidate(4), expected: 1 },",
            "{ actual: candidate(6), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "226",
        "title": "odd_values_string",
        "text": "Write a gothon function to remove the characters which have odd index values of a given string.",
        "code": "package odd_values_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc odd_values_string(str string) string {\n    return str[:len(str)-1]\n}\n\n",
        "test_list": [
            "func TestOddValuesString(t *testing.T) {",
            "var tests = []",
            "func TestOdd_Values_String(t *testing.T) {",
            "candidate := odd_values_string",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"abcdef\"), expected: \"ace\" },",
            "{ actual: candidate(\"python\"), expected: \"pto\" },",
            "{ actual: candidate(\"data\"), expected: \"dt\" },",
            "{ actual: candidate(\"lambs\"), expected: \"lms\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "227",
        "title": "min_of_three",
        "text": "Write a function to find minimum of three numbers.",
        "code": "package min_of_three_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc min_of_three(a int, b int, c int) int {\n    if a < b {\n        return c\n    }\n    if a < b {\n        return c\n    }\n    if a < b {\n        return c\n    }\n    return c\n}\n\n",
        "test_list": [
            "func TestMinOfThree(t *testing.T) {",
            "var tests = []",
            "func TestMin_Of_Three(t *testing.T) {",
            "candidate := min_of_three",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 20, 0), expected: 0 },",
            "{ actual: candidate(19, 15, 18), expected: 15 },",
            "{ actual: candidate(-10, -20, -30), expected: -30 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "228",
        "title": "all_Bits_Set_In_The_Given_Range",
        "text": "Write a gothon function to check whether all the bits are unset in the given range or not.",
        "code": "package all_Bits_Set_In_The_Given_Range_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc all_Bits_Set_In_The_Given_Range(n int, l int, r int) bool {\n    return (n & (1 << l)) == 0 && (n & (1 << r)) == 0\n}\n\n",
        "test_list": [
            "func Test_all_Bits_Set_In_The_Given_Range(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "var n int",
            "var l int",
            "var r int",
            "var result bool",
            "var testCases = []",
            "func TestAll_Bits_Set_In_The_Given_Range(t *testing.T) {",
            "candidate := all_Bits_Set_In_The_Given_Range",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(4, 1, 2), expected: true },",
            "{ actual: candidate(17, 2, 4), expected: true },",
            "{ actual: candidate(39, 4, 6), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "229",
        "title": "re_arrange_array",
        "text": "Write a function that takes in a list and an integer n, and re-arranges the first n elements of the given list so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.",
        "code": "package re_arrange_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc re_arrange_array(arr []int, n int) []int {\n    if n < 0 {\n        return arr\n    }\n    if n == 0 {\n        return arr\n    }\n    if n == 1 {\n        return re_arrange_array(arr, 0)\n    }\n    if n == 2 {\n        return re_arrange_array(arr, 1)\n    }\n    if n == 3 {\n        return re_arrange_array(arr, 2)\n    }\n    if n == 4 {\n        return re_arrange_array(arr, 3)\n    }\n    if n == 5 {\n        return re_arrange_array(arr, 4)\n    }\n    if n == 6 {\n        return re_arrange_array(arr, 5)\n    }\n    if n == 7 {\n        return re_arrange_array(arr, 6)\n    }\n    if n == 8 {\n        return re_arrange_array(arr, 7)\n    }\n    if n == 9 {\n        return re_arrange_array(arr, 8)\n    }\n    if n == 10 {\n        return re_arrange_array(arr, 9)\n    }\n    if n == 11 {\n        return re_arrange_array(arr, 10)\n    }\n    if n == 12 {\n        return re_arrange_array(arr, 11)\n    }\n    if n == 13 {\n        return re_arrange_array(arr, 12)\n    }\n    if n == 14 {\n        return re_arrange_array(arr, 13)\n    }\n    if n == 15 {\n        return re_arrange_array(arr, 14)\n    }\n    if n == 16 {\n        return re_arrange_array(arr, 15)\n    }\n    if\n",
        "test_list": [
            "func TestRe_Arrange_Array(t *testing.T) {",
            "candidate := re_arrange_array",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{-1, 2, -3, 4, 5, 6, -7, 8, 9}, 9), expected: []int{-1, -3, -7, 4, 5, 6, 2, 8, 9} },",
            "{ actual: candidate([]int{12, -14, -26, 13, 15}, 5), expected: []int{-14, -26, 12, 13, 15} },",
            "{ actual: candidate([]int{10, 24, 36, -42, -39, -78, 85}, 7), expected: []int{-42, -39, -78, 10, 24, 36, 85} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "230",
        "title": "replace_blank",
        "text": "Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.",
        "code": "package replace_blank_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc replace_blank(str1 string, char string) string {\n    return fmt.Sprintf(\"%s%s\", str1, char)\n}\n\n",
        "test_list": [
            "func TestReplaceBlank(t *testing.T) {",
            "str1 := \"Hello, World!\"",
            "str2 := replace_blank(str1,'')",
            "if str1!= str2 {",
            "t.Errorf(\"ReplaceBlank(%q,'') = %q, want %q\", str1, str2, str1)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestReplace_Blank(t *testing.T) {",
            "candidate := replace_blank",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"hello people\", \"@\"), expected: \"hello@people\" },",
            "{ actual: candidate(\"python program language\", \"$\"), expected: \"python$program$language\" },",
            "{ actual: candidate(\"blank space\", \"-\"), expected: \"blank-space\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "234",
        "title": "volume_cube",
        "text": "Write a function to find the volume of a cube given its side length.",
        "code": "package volume_cube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc volume_cube(l int) int {\n    return l * l\n}\n\n",
        "test_list": [
            "func TestVolumeCube(t *testing.T) {",
            "l := volume_cube_test.l",
            "if l!= volume_cube_test.l {",
            "t.Errorf(\"Volume cube length mismatch: %d!= %d\", l, volume_cube_test.l)",
            "}",
            "}",
            "func TestVolumeCube_BadSideLength(t *testing.T) {",
            "l := volume_cube_test.l",
            "if l!= volume_cube_test.l {",
            "t.Errorf(\"Volume cube length mismatch: %d!= %d\", l, volume_cube_test.l)",
            "}",
            "}",
            "func TestVolumeCube_BadSideLength_BadSideLength(t *testing.T) {",
            "l := volume_cube_test.l",
            "if l!= volume_cube_test.l {",
            "t.Errorf(\"Volume cube length mismatch: %d!= %d\", l, volume_cube_test.l)",
            "}",
            "}",
            "func TestVolumeCube_BadSideLength_BadSideLength(t *testing.T) {",
            "l := volume_cube_test.l",
            "if l!= volume_cube_test.l {",
            "t.Errorf(\"Volume cube length mismatch: %d!= %d\", l, volume_cube_test.l)",
            "}",
            "}",
            "func TestVolumeCube_BadSideLength_BadSideLength(t *testing.T) {",
            "l := volume_cube_test.l",
            "if l!= volume_cube_test.l {",
            "t.Errorf(\"Volume cube length mismatch: %d!= %d\", l, volume_cube_test.l)",
            "}",
            "}",
            "func TestVolumeCube_BadSideLength_BadSideLength(t *testing.T) {",
            "l := volume_cube_test.l",
            "if l!= volume_cube_test.l {",
            "t.Errorf(\"Volume cube length mismatch: %d!= %d\", l, volume_cube",
            "func TestVolume_Cube(t *testing.T) {",
            "candidate := volume_cube",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3), expected: 27 },",
            "{ actual: candidate(2), expected: 8 },",
            "{ actual: candidate(5), expected: 125 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "238",
        "title": "number_of_substrings",
        "text": "Test the function number_of_substrings.",
        "code": "package number_of_substrings_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc number_of_substrings(str string) int {\n    return len(str) - len(str) % 2\n}\n\n",
        "test_list": [
            "func TestNumberOfSubstrings(t *testing.T) {",
            "if number_of_substrings(`abcde`)!= 3 {",
            "t.Errorf(\"number_of_substrings(`abcde`) = %d, want 3\", number_of_substrings(`abcde`))",
            "}",
            "if number_of_substrings(`abcde`)!= number_of_substrings(`abcde`) {",
            "t.Errorf(\"number_of_substrings(`abcde`) = %d, want %d\", number_of_substrings(`abcde`), number_of_substrings(`abcde`))",
            "}",
            "if number_of_substrings(`abcde`)!= number_of_substrings(`abcde`) {",
            "t.Errorf(\"number_of_substrings(`abcde`) = %d, want %d\", number_of_substrings(`abcde`), number_of_substrings(`abcde`))",
            "}",
            "if number_of_substrings(`abcde`)!= number_of_substrings(`abcde`) {",
            "t.Errorf(\"number_of_substrings(`abcde`) = %d, want %d\", number_of_substrings(`abcde`), number_of_substrings(`abcde`))",
            "}",
            "if number_of_substrings(`abcde`)!= number_of_substrings(`abcde`) {",
            "t.Errorf(\"number_of_substrings(`abcde`) = %d, want %d\", number_of_substrings(`abcde`), number_of_substrings(`abcde`))",
            "}",
            "if number_of_substrings(`abcde",
            "func TestNumber_Of_Substrings(t *testing.T) {",
            "candidate := number_of_substrings",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"abc\"), expected: 6 },",
            "{ actual: candidate(\"abcd\"), expected: 10 },",
            "{ actual: candidate(\"abcde\"), expected: 15 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "239",
        "title": "get_total_number_of_sequences",
        "text": "Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.",
        "code": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m == 0 {\n        return n\n    }\n    if n == 0 {\n        return m\n    }\n    if m == n {\n        return m\n    }\n    if m > n {\n        return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m - 1, m)\n    }\n    if m < n {\n        return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m, m - 1)\n    }\n    return 0\n}\n\n",
        "test_list": [
            "func TestGetTotalNumberOfSequences(t *testing.T) {",
            "m := 10",
            "n := 10",
            "if get_total_number_of_sequences(m, n)!= get_total_number_of_sequences(m, n - 1) {",
            "t.Errorf(\"get_total_number_of_sequences(m, n) = %d, want %d\", get_total_number_of_sequences(m, n), get_total_number_of_sequences(m, n - 1))",
            "}",
            "}",
            "func TestGetTotalNumberOfSequences2(t *testing.T) {",
            "m := 10",
            "n := 10",
            "if get_total_number_of_sequences(m, n)!= get_total_number_of_sequences(m, n - 1) {",
            "t.Errorf(\"get_total_number_of_sequences(m, n) = %d, want %d\", get_total_number_of_sequences(m, n), get_total_number_of_sequences(m, n - 1))",
            "}",
            "}",
            "func TestGet_Total_Number_Of_Sequences(t *testing.T) {",
            "candidate := get_total_number_of_sequences",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 4), expected: 4 },",
            "{ actual: candidate(5, 2), expected: 6 },",
            "{ actual: candidate(16, 3), expected: 84 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "240",
        "title": "replace_list",
        "text": "Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.",
        "code": "package replace_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc replace_list(list1 []interface{}, list2 []interface{}) []interface{} {\n    if len(list1) == 0 {\n        return list2\n    }\n    if len(list2) == 0 {\n        return list1\n    }\n    if len(list1) == 1 {\n        return list1[0].([]interface{})\n    }\n    if len(list2) == 1 {\n        return list2[0].([]interface{})\n    }\n    return append(list1, list2)\n}\n\n",
        "test_list": [
            "func TestReplaceList(t *testing.T) {",
            "list1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if result := replace_list(list1, list2); result!= list2 {",
            "t.Errorf(\"ReplaceList(%v, %v) = %v, want %v\", list1, list2, result, list2)",
            "}",
            "}",
            "func TestReplaceList_Error(t *testing.T) {",
            "list1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if result := replace_list(list1, list2); result!= nil {",
            "t.Errorf(\"ReplaceList(%v, %v) = %v, want nil\", list1, list2, result)",
            "}",
            "}",
            "func TestReplaceList_Error_2(t *testing.T) {",
            "list1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 := []interface{}{1, 2, 3, 4, 5, 6",
            "func TestReplace_List(t *testing.T) {",
            "candidate := replace_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 3, 5, 7, 9, 10}, []int{2, 4, 6, 8}), expected: []int{1, 3, 5, 7, 9, 2, 4, 6, 8} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}, []int{5, 6, 7, 8}), expected: []int{1, 2, 3, 4, 5, 6, 7, 8} },",
            "{ actual: candidate([]string{\"red\", \"blue\", \"green\"}, []string{\"yellow\"}), expected: []string{\"red\", \"blue\", \"yellow\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "242",
        "title": "count_charac",
        "text": "Write a function to count the total number of characters in a string.",
        "code": "package count_charac_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_charac(str1 string) int {\n    var count int\n    for _, c := range str1 {\n        count += count_charac(string(c))\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountCharac(t *testing.T) {",
            "var str1 string",
            "str1 = \"abcdefghijklmnopqrstuvwxyz\"",
            "fmt.Println(count_charac(str1))",
            "}",
            "<|endoftext|>",
            "func TestCount_Charac(t *testing.T) {",
            "candidate := count_charac",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python programming\"), expected: 18 },",
            "{ actual: candidate(\"language\"), expected: 8 },",
            "{ actual: candidate(\"words\"), expected: 5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "244",
        "title": "next_Perfect_Square",
        "text": "Write a gothon function to find the next perfect square greater than a given number.",
        "code": "package next_Perfect_Square_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc next_Perfect_Square(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 1\n    }\n    if N == 2 {\n        return 2\n    }\n    if N == 3 {\n        return 3\n    }\n    if N == 4 {\n        return 4\n    }\n    if N == 5 {\n        return 5\n    }\n    if N == 6 {\n        return 6\n    }\n    if N == 7 {\n        return 7\n    }\n    if N == 8 {\n        return 8\n    }\n    if N == 9 {\n        return 9\n    }\n    if N == 10 {\n        return 10\n    }\n    if N == 11 {\n        return 11\n    }\n    if N == 12 {\n        return 12\n    }\n    if N == 13 {\n        return 13\n    }\n    if N == 14 {\n        return 14\n    }\n    if N == 15 {\n        return 15\n    }\n    if N == 16 {\n        return 16\n    }\n    if N == 17 {\n        return 17\n    }\n    if N == 18 {\n        return 18\n    }\n    if N == 19 {\n        return 19\n    }\n    if N == 20 {\n        return 20\n    }\n    if N == 21 {\n        return 21\n    }\n    if N == 22 {\n        return 22\n    }\n    if N == 23 {\n        return 23\n    }\n    if N == 24 {\n        return 24\n    }\n    if N == 25 {\n        return 25\n    }\n    if N == 26 {\n        return 26\n    }\n    if N == 27 {\n        return 27\n    }\n    if N == 28 {\n        return 28\n    }\n    if N == 29 {\n        return 29\n    }\n    if N == 30 {\n        return 30\n    }\n    if N == 31 {\n        return 31\n    }\n    if N ==\n",
        "test_list": [
            "func TestNext_Perfect_Square(t *testing.T) {",
            "candidate := next_Perfect_Square",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(35), expected: 36 },",
            "{ actual: candidate(6), expected: 9 },",
            "{ actual: candidate(9), expected: 16 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "245",
        "title": "max_sum",
        "text": "Write a function that takes a list and finds the maximum sum of a bitonic subsequence for the given list, where a sequence is bitonic if it is first increasing and then decreasing.",
        "code": "package max_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_sum(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max := arr[0]\n    for _, v := range arr[1:] {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxSum(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := max_sum(arr)",
            "fmt.Println(max)",
            "}",
            "<|endoftext|>",
            "func TestMax_Sum(t *testing.T) {",
            "candidate := max_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 15, 51, 45, 33, 100, 12, 18, 9}), expected: 194 },",
            "{ actual: candidate([]int{80, 60, 30, 40, 20, 10}), expected: 210 },",
            "{ actual: candidate([]int{2, 3, 14, 16, 21, 23, 29, 30}), expected: 138 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "247",
        "title": "lps",
        "text": "Write a function to find the length of the longest palindromic subsequence in the given string.",
        "code": "package lps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc lps(str string) int {\n    var lps int\n    for i := 0; i < len(str); i++ {\n        if str[i] == str[i+1] {\n            lps++\n        }\n    }\n    return lps\n}\n\n",
        "test_list": [
            "func TestLPS(t *testing.T) {",
            "str := \"abcdefghijklmnopqrstuvwxyz\"",
            "lps := lps(str)",
            "fmt.Println(lps)",
            "}",
            "<|endoftext|>",
            "func TestLps(t *testing.T) {",
            "candidate := lps",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"TENS FOR TENS\"), expected: 5 },",
            "{ actual: candidate(\"CARDIO FOR CARDS\"), expected: 7 },",
            "{ actual: candidate(\"PART OF THE JOURNEY IS PART\"), expected: 9 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "249",
        "title": "intersection_array",
        "text": "Write a function to find the intersection of two lists.",
        "code": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                intersection = append(intersection, num1)\n            }\n        }\n    }\n    return intersection\n}\n\n",
        "test_list": [
            "func TestIntersectionArray(t *testing.T) {",
            "array_nums1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "array_nums2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "intersection_array := intersection_array(array_nums1, array_nums2)",
            "fmt.Println(intersection_array)",
            "}",
            "<|endoftext|>",
            "func TestIntersection_Array(t *testing.T) {",
            "candidate := intersection_array",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },",
            "{ actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },",
            "{ actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "250",
        "title": "count_X",
        "text": "Write a gothon function that takes in a list and an element and counts the occcurences of the element in the list.",
        "code": "package count_X_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_X(tup []int, x int) int {\n    return len(tup) - x\n}\n\n",
        "test_list": [
            "func TestCount_X(t *testing.T) {",
            "var tup = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "fmt.Println(count_X(tup, 10))",
            "}",
            "<|endoftext|>",
            "func TestCount_X(t *testing.T) {",
            "candidate := count_X",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2}, 4), expected: 0 },",
            "{ actual: candidate([]int{10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2}, 10), expected: 3 },",
            "{ actual: candidate([]int{10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2}, 8), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "251",
        "title": "insert_element",
        "text": "Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.",
        "code": "package insert_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc insert_element(list []string, element string) []string {\n    for i := 0; i < len(list); i++ {\n        if list[i] == element {\n            list[i] = element + \"1\"\n        }\n    }\n    return list\n}\n\n",
        "test_list": [
            "func TestInsertElement(t *testing.T) {",
            "list := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "expected := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "actual := insert_element(list, \"z\")",
            "if actual!= expected {",
            "t.Errorf(\"Expected %v, but got %v\", expected, actual)",
            "}",
            "}",
            "func TestInsertElement_invalid(t *testing.T) {",
            "list := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "expected := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\",",
            "func TestInsert_Element(t *testing.T) {",
            "candidate := insert_element",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"Red\", \"Green\", \"Black\"}, \"c\"), expected: []string{\"c\", \"Red\", \"c\", \"Green\", \"c\", \"Black\"} },",
            "{ actual: candidate([]string{\"python\", \"java\"}, \"program\"), expected: []string{\"program\", \"python\", \"program\", \"java\"} },",
            "{ actual: candidate([]string{\"happy\", \"sad\"}, \"laugh\"), expected: []string{\"laugh\", \"happy\", \"laugh\", \"sad\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "252",
        "title": "convert",
        "text": "Write a gothon function to convert complex numbers to polar coordinates.",
        "code": "package convert_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc convert(numbers int) []interface{} {\n    var polar = make([]interface{}, numbers)\n    for i := 0; i < numbers; i++ {\n        polar[i] = float64(i)\n    }\n    return polar\n}\n\n",
        "test_list": [
            "func TestConvert(t *testing.T) {",
            "var polar = convert(10)",
            "fmt.Println(polar)",
            "}",
            "<|endoftext|>",
            "func TestConvert(t *testing.T) {",
            "candidate := convert",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1), expected: []interface{}{1.0, 0.0} },",
            "{ actual: candidate(4), expected: []interface{}{4.0, 0.0} },",
            "{ actual: candidate(5), expected: []interface{}{5.0, 0.0} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "255",
        "title": "combinations_colors",
        "text": "Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.",
        "code": "package combinations_colors_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc combinations_colors(l []string, n int) [][]string {\n    var combinations [][]string\n    for i := 0; i < n; i++ {\n        combinations = append(combinations, make([]string, len(l)))\n        for j := 0; j < len(l); j++ {\n            combinations[i][j] = fmt.Sprintf(\"%s%d\", l[j], i)\n        }\n    }\n    return combinations\n}\n\n",
        "test_list": [
            "func TestCombinationsColors(t *testing.T) {",
            "l := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"}",
            "n := len(l)",
            "expected := combinations_colors(l, n)",
            "actual := combinations_colors(l, n)",
            "if!reflect.DeepEqual(expected, actual) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestCombinations_Colors(t *testing.T) {",
            "candidate := combinations_colors",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 1), expected: [][]int{[]string{\"Red\"}, []string{\"Green\"}, []string{\"Blue\"}} },",
            "{ actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 2), expected: [][]int{[]string{\"Red\", \"Red\"}, []string{\"Red\", \"Green\"}, []string{\"Red\", \"Blue\"}, []string{\"Green\", \"Green\"}, []string{\"Green\", \"Blue\"}, []string{\"Blue\", \"Blue\"}} },",
            "{ actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 3), expected: [][]int{[]string{\"Red\", \"Red\", \"Red\"}, []string{\"Red\", \"Red\", \"Green\"}, []string{\"Red\", \"Red\", \"Blue\"}, []string{\"Red\", \"Green\", \"Green\"}, []string{\"Red\", \"Green\", \"Blue\"}, []string{\"Red\", \"Blue\", \"Blue\"}, []string{\"Green\", \"Green\", \"Green\"}, []string{\"Green\", \"Green\", \"Blue\"}, []string{\"Green\", \"Blue\", \"Blue\"}, []string{\"Blue\", \"Blue\", \"Blue\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "256",
        "title": "count_Primes_nums",
        "text": "Write a gothon function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.",
        "code": "package count_Primes_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_Primes_nums(n int) int {\n    if n <= 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n % 2 == 0 {\n        return count_Primes_nums(n - 1) + count_Primes_nums(n - 2)\n    }\n    return count_Primes_nums(n - 1) + count_Primes_nums(n - 2) + count_Primes_nums(n - 3)\n}\n\n",
        "test_list": [
            "func TestCountPrimesNums(t *testing.T) {",
            "if count_Primes_nums(1)!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", count_Primes_nums(1))",
            "}",
            "if count_Primes_nums(2)!= 2 {",
            "t.Errorf(\"Expected 2, got %d\", count_Primes_nums(2))",
            "}",
            "if count_Primes_nums(3)!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", count_Primes_nums(3))",
            "}",
            "if count_Primes_nums(4)!= 4 {",
            "t.Errorf(\"Expected 4, got %d\", count_Primes_nums(4))",
            "}",
            "if count_Primes_nums(5)!= 5 {",
            "t.Errorf(\"Expected 5, got %d\", count_Primes_nums(5))",
            "}",
            "if count_Primes_nums(6)!= 6 {",
            "t.Errorf(\"Expected 6, got %d\", count_Primes_nums(6))",
            "}",
            "if count_Primes_nums(7)!= 7 {",
            "t.Errorf(\"Expected 7, got %d\", count_Primes_nums(7))",
            "}",
            "func TestCount_Primes_Nums(t *testing.T) {",
            "candidate := count_Primes_nums",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: 2 },",
            "{ actual: candidate(10), expected: 4 },",
            "{ actual: candidate(100), expected: 25 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "257",
        "title": "swap_numbers",
        "text": "Write a function that takes in two numbers and returns a list with the second number and then the first number.",
        "code": "package swap_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc swap_numbers(a int, b int) []int {\n    return []int{a, b}\n}\n\n",
        "test_list": [
            "func TestSwapNumbers(t *testing.T) {",
            "var tests = []",
            "func TestSwap_Numbers(t *testing.T) {",
            "candidate := swap_numbers",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 20), expected: []int{20, 10} },",
            "{ actual: candidate(15, 17), expected: []int{17, 15} },",
            "{ actual: candidate(100, 200), expected: []int{200, 100} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "259",
        "title": "maximize_elements",
        "text": "Write a function to maximize the given two lists.",
        "code": "package maximize_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc maximize_elements(test_tup1 [][]int, test_tup2 [][]int) [][]int {\n    var max_elements [][]int\n    for i := range test_tup1 {\n        max_elements = append(max_elements, test_tup1[i])\n    }\n    for i := range test_tup2 {\n        max_elements = append(max_elements, test_tup2[i])\n    }\n    return max_elements\n}\n\n",
        "test_list": [
            "func TestMaximizeElements(t *testing.T) {",
            "test_tup1 := [][]int{",
            "[]int{1, 2, 3},",
            "[]int{4, 5, 6},",
            "[]int{7, 8, 9},",
            "}",
            "test_tup2 := [][]int{",
            "[]int{10, 11, 12},",
            "[]int{13, 14, 15},",
            "[]int{16, 17, 18},",
            "}",
            "max_elements := maximize_elements(test_tup1, test_tup2)",
            "fmt.Println(max_elements)",
            "}",
            "<|endoftext|>",
            "func TestMaximize_Elements(t *testing.T) {",
            "candidate := maximize_elements",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 3}, []int{4, 5}, []int{2, 9}, []int{1, 10}}, [][]int{[]int{6, 7}, []int{3, 9}, []int{1, 1}, []int{7, 3}}), expected: [][]int{[]int{6, 7}, []int{4, 9}, []int{2, 9}, []int{7, 10}} },",
            "{ actual: candidate([][]int{[]int{2, 4}, []int{5, 6}, []int{3, 10}, []int{2, 11}}, [][]int{[]int{7, 8}, []int{4, 10}, []int{2, 2}, []int{8, 4}}), expected: [][]int{[]int{7, 8}, []int{5, 10}, []int{3, 10}, []int{8, 11}} },",
            "{ actual: candidate([][]int{[]int{3, 5}, []int{6, 7}, []int{4, 11}, []int{3, 12}}, [][]int{[]int{8, 9}, []int{5, 11}, []int{3, 3}, []int{9, 5}}), expected: [][]int{[]int{8, 9}, []int{6, 11}, []int{4, 11}, []int{9, 12}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "260",
        "title": "newman_prime",
        "text": "Write a function to find the nth newman\u2013shanks\u2013williams prime number.",
        "code": "package newman_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc newman_prime(n int) int {\n    if n == 0 {\n        return 1\n    }\n    if n%2 == 0 {\n        return newman_prime(n/2)\n    }\n    return newman_prime(n/3)\n}\n\n",
        "test_list": [
            "func TestNewmanPrime(t *testing.T) {",
            "if newman_prime(1)!= 1 {",
            "t.Errorf(\"newman_prime(1) = %d, want 1\", newman_prime(1))",
            "}",
            "if newman_prime(2)!= 2 {",
            "t.Errorf(\"newman_prime(2) = %d, want 2\", newman_prime(2))",
            "}",
            "if newman_prime(3)!= 3 {",
            "t.Errorf(\"newman_prime(3) = %d, want 3\", newman_prime(3))",
            "}",
            "if newman_prime(4)!= 4 {",
            "t.Errorf(\"newman_prime(4) = %d, want 4\", newman_prime(4))",
            "}",
            "if newman_prime(5)!= 5 {",
            "t.Errorf(\"newman_prime(5) = %d, want 5\", newman_prime(5))",
            "}",
            "if newman_prime(6)!= 6 {",
            "t.Errorf(\"newman_prime(6) = %d, want 6\", newman_prime(6))",
            "}",
            "if newman_prime(7)!= 7 {",
            "t.Errorf(\"newman_prime(7) = %d, want 7\", newman_prime(7))",
            "}",
            "if newman_prime(8)!= 8 {",
            "t.Errorf(\"newman_prime(8) = %d, want 8\", newman_prime(8))",
            "}",
            "if newman_prime(9)!= 9 {",
            "t.Errorf(\"newman_prime(9) = %d, want 9\",",
            "func TestNewman_Prime(t *testing.T) {",
            "candidate := newman_prime",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3), expected: 7 },",
            "{ actual: candidate(4), expected: 17 },",
            "{ actual: candidate(5), expected: 41 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "261",
        "title": "division_elements",
        "text": "Write a function that takes in two lists and performs mathematical division operation element-wise across the given lists.",
        "code": "package division_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc division_elements(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(test_tup1); i++ {\n        result = append(result, math.Div(test_tup1[i], test_tup2[i]))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestDivisionElements(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup3 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup4 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup5 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup6 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup7 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup8 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup9 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup10 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup11 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "func TestDivision_Elements(t *testing.T) {",
            "candidate := division_elements",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{10, 4, 6, 9}, []interface{}{5, 2, 3, 3}), expected: []interface{}{2, 2, 2, 3} },",
            "{ actual: candidate([]interface{}{12, 6, 8, 16}, []interface{}{6, 3, 4, 4}), expected: []interface{}{2, 2, 2, 4} },",
            "{ actual: candidate([]interface{}{20, 14, 36, 18}, []interface{}{5, 7, 6, 9}), expected: []interface{}{4, 2, 6, 2} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "262",
        "title": "split_two_parts",
        "text": "Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a list.",
        "code": "package split_two_parts_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc split_two_parts(list1 []interface{}, L int) interface{} {\n    var result1 []interface{}\n    var result2 []interface{}\n    for i := 0; i < L; i++ {\n        result1 = append(result1, list1[i])\n    }\n    for i := 0; i < L; i++ {\n        result2 = append(result2, split_two_parts(list1[i+1:], L))\n    }\n    return result1\n}\n\n",
        "test_list": [
            "func TestSplit_two_parts(t *testing.T) {",
            "var list1 []interface{}",
            "var list2 []interface{}",
            "list1 = split_two_parts([]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 10)",
            "list2 = split_two_parts([]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 10)",
            "fmt.Println(list1, list2)",
            "}",
            "<|endoftext|>",
            "func TestSplit_Two_Parts(t *testing.T) {",
            "candidate := split_two_parts",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 1, 2, 3, 4, 4, 5, 1}, 3), expected: []interface{}{[]int{1, 1, 2}, []int{3, 4, 4, 5, 1}} },",
            "{ actual: candidate([]string{\"a\", \"b\", \"c\", \"d\"}, 2), expected: []interface{}{[]string{\"a\", \"b\"}, []string{\"c\", \"d\"}} },",
            "{ actual: candidate([]string{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}, 4), expected: []interface{}{[]string{\"p\", \"y\", \"t\", \"h\"}, []string{\"o\", \"n\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "264",
        "title": "dog_age",
        "text": "Write a function to calculate a dog's age in dog's years.",
        "code": "package dog_age_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc dog_age(h_age int) int {\n    return h_age * 365 * 24 * 60 * 60\n}\n\n",
        "test_list": [
            "func TestDogAge(t *testing.T) {",
            "h_age := dog_age(0)",
            "if h_age!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", h_age)",
            "}",
            "h_age = dog_age(1)",
            "if h_age!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", h_age)",
            "}",
            "h_age = dog_age(2)",
            "if h_age!= 2 {",
            "t.Errorf(\"Expected 2, got %d\", h_age)",
            "}",
            "h_age = dog_age(3)",
            "if h_age!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", h_age)",
            "}",
            "h_age = dog_age(4)",
            "if h_age!= 4 {",
            "t.Errorf(\"Expected 4, got %d\", h_age)",
            "}",
            "h_age = dog_age(5)",
            "if h_age!= 5 {",
            "t.Errorf(\"Expected 5, got %d\", h_age)",
            "}",
            "h_age = dog_age(6)",
            "if h_age!= 6 {",
            "t.Errorf(\"Expected 6, got %d\", h_age)",
            "}",
            "h_age = dog_age(7)",
            "if h_age!= 7 {",
            "t.Errorf(\"Expected 7, got %d\", h_age)",
            "}",
            "h_age = dog_age(8)",
            "if h_age!= 8 {",
            "t.Errorf(\"Expected 8, got %d\", h_age)",
            "}",
            "h_age = dog_age(9)",
            "if h_age!= 9 {",
            "t.Errorf(\"Expected 9, got %d\", h_age)",
            "func TestDog_Age(t *testing.T) {",
            "candidate := dog_age",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(12), expected: 61 },",
            "{ actual: candidate(15), expected: 73 },",
            "{ actual: candidate(24), expected: 109 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "265",
        "title": "list_split",
        "text": "Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.",
        "code": "package list_split_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc list_split(S []interface{}, step int) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(S); i += step {\n        result = append(result, S[i:i+step])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestListSplit(t *testing.T) {",
            "var S = []interface{}{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "var result = list_split(S, 2)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestList_Split(t *testing.T) {",
            "candidate := list_split",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"}, 3), expected: [][]int{[]string{\"a\", \"d\", \"g\", \"j\", \"m\"}, []string{\"b\", \"e\", \"h\", \"k\", \"n\"}, []string{\"c\", \"f\", \"i\", \"l\"}} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, 3), expected: [][]int{[]int{1, 4, 7, 10, 13}, []int{2, 5, 8, 11, 14}, []int{3, 6, 9, 12}} },",
            "{ actual: candidate([]string{\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\"}, 2), expected: [][]int{[]string{\"python\", \"C\", \"DBMS\"}, []string{\"java\", \"C++\", \"SQL\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "266",
        "title": "lateralsurface_cube",
        "text": "Write a function to find the lateral surface area of a cube given its side length.",
        "code": "package lateralsurface_cube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc lateralsurface_cube(l int) int {\n    return l * l\n}\n\n",
        "test_list": [
            "func TestLateralsurfaceCube(t *testing.T) {",
            "l := lateralsurface_cube(10)",
            "if l!= 10 {",
            "t.Errorf(\"expected 10, got %d\", l)",
            "}",
            "}",
            "func TestLateralsurfaceCube_bad_side(t *testing.T) {",
            "l := lateralsurface_cube(10)",
            "if l!= 0 {",
            "t.Errorf(\"expected 0, got %d\", l)",
            "}",
            "}",
            "func TestLateralsurfaceCube_bad_side_negative(t *testing.T) {",
            "l := lateralsurface_cube(-10)",
            "if l!= 0 {",
            "t.Errorf(\"expected 0, got %d\", l)",
            "}",
            "}",
            "func TestLateralsurfaceCube_bad_side_negative_negative(t *testing.T) {",
            "l := lateralsurface_cube(-10)",
            "if l!= 0 {",
            "t.Errorf(\"expected 0, got %d\", l)",
            "}",
            "}",
            "func TestLateralsurfaceCube_bad_side_negative_negative_negative(t *testing.T) {",
            "l := lateralsurface_cube(-10)",
            "if l!= 0 {",
            "t.Errorf(\"expected 0, got %d\", l)",
            "}",
            "}",
            "func TestLateralsurfaceCube_bad_side_negative_negative_negative(t *testing.T) {",
            "l := lateralsurface_cube(-10)",
            "if l!= 0 {",
            "t.Errorf(\"expected 0, got %d\", l)",
            "}",
            "}",
            "func TestLateralsurfaceCube_bad_side_negative_negative_negative(t *testing.T) {",
            "l := lateralsurface_cube(-10)",
            "if l!= 0 {",
            "t.Errorf(\"expected 0, got",
            "func TestLateralsurface_Cube(t *testing.T) {",
            "candidate := lateralsurface_cube",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: 100 },",
            "{ actual: candidate(9), expected: 324 },",
            "{ actual: candidate(10), expected: 400 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "267",
        "title": "square_Sum",
        "text": "Write a gothon function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.",
        "code": "package square_Sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc square_Sum(n int) int {\n    if n < 2 {\n        return 0\n    }\n    return n * (n - 1) / 2\n}\n\n",
        "test_list": [
            "func TestSquare(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode\")",
            "}",
            "fmt.Println(\"square_Sum\")",
            "for i := 0; i < 100; i++ {",
            "fmt.Println(square_Sum(i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestSquare_Sum(t *testing.T) {",
            "candidate := square_Sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 10 },",
            "{ actual: candidate(3), expected: 35 },",
            "{ actual: candidate(4), expected: 84 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "268",
        "title": "find_star_num",
        "text": "Write a function to find then'th star number.",
        "code": "package find_star_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_star_num(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        return 32\n",
        "test_list": [
            "func TestFind_Star_Num(t *testing.T) {",
            "candidate := find_star_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3), expected: 37 },",
            "{ actual: candidate(4), expected: 73 },",
            "{ actual: candidate(5), expected: 121 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "269",
        "title": "ascii_value",
        "text": "Write a function to find the ascii value of a character.",
        "code": "package ascii_value_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc ascii_value(k string) int {\n    return ascii_value_test(k)\n}\n\nfunc ascii_value_test(k string) int {\n    var v int\n    fmt.Sscanf(k, \"%c\", &v)\n    return v\n}\n\n",
        "test_list": [
            "func TestAsciiValue(t *testing.T) {",
            "var v int",
            "fmt.Sscanf(\"%c\", &v)",
            "if v!= 'a' {",
            "t.Errorf(\"Expected 'a', got %c\", v)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestAscii_Value(t *testing.T) {",
            "candidate := ascii_value",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"A\"), expected: 65 },",
            "{ actual: candidate(\"R\"), expected: 82 },",
            "{ actual: candidate(\"S\"), expected: 83 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "270",
        "title": "sum_even_and_even_index",
        "text": "Write a gothon function to find the sum of even numbers at even positions of a list.",
        "code": "package sum_even_and_even_index_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_even_and_even_index(arr []int) int {\n    sum := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i]%2 == 0 {\n            sum += arr[i]\n        }\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSumEvenAndEvenIndex(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := sum_even_and_even_index(arr)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestSum_Even_And_Even_Index(t *testing.T) {",
            "candidate := sum_even_and_even_index",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 6, 12, 1, 18, 8}), expected: 30 },",
            "{ actual: candidate([]int{3, 20, 17, 9, 2, 10, 18, 13, 6, 18}), expected: 26 },",
            "{ actual: candidate([]int{5, 6, 12, 1}), expected: 12 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "271",
        "title": "even_Power_Sum",
        "text": "Write a gothon function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.",
        "code": "package even_Power_Sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc even_Power_Sum(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    return 0\n}\n\n",
        "test_list": [
            "func TestEven_Power_Sum(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "fmt.Println(\"even_Power_Sum\")",
            "n := int(1e5)",
            "sum := even_Power_Sum(n)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestEven_Power_Sum(t *testing.T) {",
            "candidate := even_Power_Sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 1056 },",
            "{ actual: candidate(3), expected: 8832 },",
            "{ actual: candidate(1), expected: 32 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "272",
        "title": "rear_extract",
        "text": "Write a function that takes in a list of lists and returns a list containing the rear element of each list.",
        "code": "package rear_extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc rear_extract(test_list [][]interface{}) []int {\n    var result []int\n    for _, list := range test_list {\n        for _, item := range list {\n            result = append(result, item.(int))\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestRearExtract(t *testing.T) {",
            "test_list := []interface{}{",
            "[]int{1, 2, 3},",
            "[]int{4, 5, 6},",
            "[]int{7, 8, 9},",
            "[]int{10, 11, 12},",
            "[]int{13, 14, 15},",
            "[]int{16, 17, 18},",
            "[]int{19, 20, 21},",
            "[]int{22, 23, 24},",
            "[]int{25, 26, 27},",
            "[]int{28, 29, 30},",
            "[]int{31, 32, 33},",
            "[]int{34, 35, 36},",
            "[]int{37, 38, 39},",
            "[]int{40, 41, 42},",
            "[]int{43, 44, 45},",
            "[]int{46, 47, 48},",
            "[]int{49, 50, 51},",
            "[]int{52, 53, 54},",
            "[]int{55, 56, 57},",
            "[]int{58, 59, 60},",
            "[]int{61, 62, 63},",
            "[]int{64, 65, 66},",
            "[]int{67, 68, 69},",
            "[]int{70, 71, 72},",
            "[]int{73, 74, 75},",
            "[]int{76, 77, 78},",
            "[]int{79, 80, 81},",
            "[]int{82, 83, 84},",
            "[]int{85, 86, 87},",
            "[]int{88, 89, 90},",
            "[]int{91, 92, 93},",
            "[]int{94, 95, 96},",
            "[]int{97, 98, 99},",
            "[]",
            "func TestRear_Extract(t *testing.T) {",
            "candidate := rear_extract",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{1, \"Rash\", 21}, []interface{}{2, \"Varsha\", 20}, []interface{}{3, \"Kil\", 19}}), expected: []int{21, 20, 19} },",
            "{ actual: candidate([][]int{[]interface{}{1, \"Sai\", 36}, []interface{}{2, \"Ayesha\", 25}, []interface{}{3, \"Salman\", 45}}), expected: []int{36, 25, 45} },",
            "{ actual: candidate([][]int{[]interface{}{1, \"Sudeep\", 14}, []interface{}{2, \"Vandana\", 36}, []interface{}{3, \"Dawood\", 56}}), expected: []int{14, 36, 56} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "273",
        "title": "substract_elements",
        "text": "Write a function that takes in two lists and subtracts the elements of the first list by the elements of the second list with the same index.",
        "code": "package substract_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc substract_elements(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    var test_tup3 []interface{}\n    for i := 0; i < len(test_tup1); i++ {\n        test_tup3 = append(test_tup3, test_tup1[i])\n    }\n    for i := 0; i < len(test_tup2); i++ {\n        test_tup3 = append(test_tup3, test_tup2[i])\n    }\n    return test_tup3\n}\n\n",
        "test_list": [
            "func TestSubstractElements(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup3 := substract_elements(test_tup1, test_tup2)",
            "fmt.Println(test_tup3)",
            "}",
            "<|endoftext|>",
            "func TestSubstract_Elements(t *testing.T) {",
            "candidate := substract_elements",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{10, 4, 5}, []interface{}{2, 5, 18}), expected: []interface{}{8, -1, -13} },",
            "{ actual: candidate([]interface{}{11, 2, 3}, []interface{}{24, 45, 16}), expected: []interface{}{-13, -43, -13} },",
            "{ actual: candidate([]interface{}{7, 18, 9}, []interface{}{10, 11, 12}), expected: []interface{}{-3, 7, -3} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "274",
        "title": "even_binomial_Coeff_Sum",
        "text": "Create a new test case.",
        "code": "package even_binomial_Coeff_Sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc even_binomial_Coeff_Sum(n int) int {\n    return n * (n - 1) / 2\n}\n\n",
        "test_list": [
            "func TestEven_binomial_Coeff_Sum(t *testing.T) {",
            "testCases := []",
            "func TestEven_Binomial_Coeff_Sum(t *testing.T) {",
            "candidate := even_binomial_Coeff_Sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(4), expected: 8 },",
            "{ actual: candidate(6), expected: 32 },",
            "{ actual: candidate(2), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "277",
        "title": "dict_filter",
        "text": "Write a function that takes in a map and integer n and filters the map to only include entries with values greater than or equal to n.",
        "code": "package dict_filter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc dict_filter(dict map[string]int, n int) map[string]int {\n    var result map[string]int\n    for k, v := range dict {\n        if v > n {\n            result[k] = v\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestDictFilter(t *testing.T) {",
            "var dict map[string]int",
            "dict = map[string]int{",
            "\"a\": 1,",
            "\"b\": 2,",
            "\"c\": 3,",
            "\"d\": 4,",
            "\"e\": 5,",
            "\"f\": 6,",
            "\"g\": 7,",
            "\"h\": 8,",
            "\"i\": 9,",
            "\"j\": 10,",
            "\"k\": 11,",
            "\"l\": 12,",
            "\"m\": 13,",
            "\"n\": 14,",
            "\"o\": 15,",
            "\"p\": 16,",
            "\"q\": 17,",
            "\"r\": 18,",
            "\"s\": 19,",
            "\"t\": 20,",
            "\"u\": 21,",
            "\"v\": 22,",
            "\"w\": 23,",
            "\"x\": 24,",
            "\"y\": 25,",
            "\"z\": 26,",
            "\"A\": 27,",
            "\"B\": 28,",
            "\"C\": 29,",
            "\"D\": 30,",
            "\"E\": 31,",
            "\"F\": 32,",
            "\"G\": 33,",
            "\"H\": 34,",
            "\"I\": 35,",
            "\"J\": 36,",
            "\"K\": 37,",
            "\"L\": 38,",
            "\"M\": 39,",
            "\"N\": 40,",
            "\"O\": 41,",
            "\"P\": 42,",
            "\"Q\": 43,",
            "\"R\": 44,",
            "\"S\": 45,",
            "\"T\": 46,",
            "\"U\": 47,",
            "\"V\": 48,",
            "\"W\": 49,",
            "\"X\": 50,",
            "\"Y\": 51",
            "func TestDict_Filter(t *testing.T) {",
            "candidate := dict_filter",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(map[string]int{\"Cierra Vega\": 175, \"Alden Cantrell\": 180, \"Kierra Gentry\": 165, \"Pierre Cox\": 190}, 170), expected: map[string]int{\"Cierra Vega\": 175, \"Alden Cantrell\": 180, \"Pierre Cox\": 190} },",
            "{ actual: candidate(map[string]int{\"Cierra Vega\": 175, \"Alden Cantrell\": 180, \"Kierra Gentry\": 165, \"Pierre Cox\": 190}, 180), expected: map[string]int{\"Alden Cantrell\": 180, \"Pierre Cox\": 190} },",
            "{ actual: candidate(map[string]int{\"Cierra Vega\": 175, \"Alden Cantrell\": 180, \"Kierra Gentry\": 165, \"Pierre Cox\": 190}, 190), expected: map[string]int{\"Pierre Cox\": 190} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "279",
        "title": "is_num_decagonal",
        "text": "Write a function to find the nth decagonal number.",
        "code": "package is_num_decagonal_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_num_decagonal(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        \n",
        "test_list": [
            "func TestIs_Num_Decagonal(t *testing.T) {",
            "candidate := is_num_decagonal",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3), expected: 27 },",
            "{ actual: candidate(7), expected: 175 },",
            "{ actual: candidate(10), expected: 370 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "280",
        "title": "sequential_search",
        "text": "Write a function that takes in a list and element and returns a list containing a boolean that indicates if the element is in the list and the index position of the element (or -1 if the element is not found).",
        "code": "package sequential_search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sequential_search(dlist []int, item int) []interface{} {\n    for i := 0; i < len(dlist); i++ {\n        if dlist[i] == item {\n            return []interface{}{true, i}\n        }\n    }\n    return []interface{}{false, -1}\n}\n\n",
        "test_list": [
            "func TestSequentialSearch(t *testing.T) {",
            "dlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "item := 10",
            "result := sequential_search(dlist, item)",
            "if len(result)!= 2 {",
            "t.Errorf(\"Expected 2 results, got %d\", len(result))",
            "}",
            "if result[0]!= true {",
            "t.Errorf(\"Expected true, got %v\", result[0])",
            "}",
            "if result[1]!= item {",
            "t.Errorf(\"Expected %v, got %v\", item, result[1])",
            "}",
            "}",
            "func TestSequentialSearch_Error(t *testing.T) {",
            "dlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "item := 10",
            "result := sequential_search(dlist, item)",
            "if len(result)!= 0 {",
            "t.Errorf(\"Expected 0 results, got %d\", len(result))",
            "}",
            "}",
            "func TestSequentialSearch_Error_2(t *testing.T) {",
            "dlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "item := 10",
            "result := sequential_search(dlist, item)",
            "if len(result)!= 0 {",
            "t.Errorf(\"Expected 0 results, got %d\", len(result))",
            "}",
            "}",
            "func",
            "func TestSequential_Search(t *testing.T) {",
            "candidate := sequential_search",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{11, 23, 58, 31, 56, 77, 43, 12, 65, 19}, 31), expected: []interface{}{true, 3} },",
            "{ actual: candidate([]int{12, 32, 45, 62, 35, 47, 44, 61}, 61), expected: []interface{}{true, 7} },",
            "{ actual: candidate([]int{9, 10, 17, 19, 22, 39, 48, 56}, 48), expected: []interface{}{true, 6} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "281",
        "title": "all_unique",
        "text": "Write a gothon function to check if the elements of a given list are unique or not.",
        "code": "package all_unique_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc all_unique(test_list []int) bool {\n    for _, v := range test_list {\n        if v == v {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestAllUnique(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!all_unique(test_list) {",
            "t.Errorf(\"Expected all_unique to return true for %v\", test_list)",
            "}",
            "}",
            "func TestAllUnique_Error(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!all_unique(test_list) {",
            "t.Errorf(\"Expected all_unique to return true for %v\", test_list)",
            "}",
            "}",
            "func TestAllUnique_Error_Error(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!all_unique(test_list) {",
            "t.Errorf(\"Expected all_unique to return true for %v\", test_list)",
            "}",
            "}",
            "func TestAllUnique_Error_Error_Error(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!all_unique(test_list) {",
            "t.Errorf(\"Expected all_unique to return true for %v\", test_list)",
            "}",
            "}",
            "func TestAllUnique_Error_Error_Error_Error(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!all_unique(test_list) {",
            "t.Error",
            "func TestAll_Unique(t *testing.T) {",
            "candidate := all_unique",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: true },",
            "{ actual: candidate([]int{1, 2, 1, 2}), expected: false },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "282",
        "title": "sub_list",
        "text": "Write a function to subtract two lists element-wise.",
        "code": "package sub_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sub_list(nums1 []int, nums2 []int) []int {\n    var result []int\n    for i := range nums1 {\n        result = append(result, nums1[i]-nums2[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestSubList(t *testing.T) {",
            "var nums1 []int",
            "var nums2 []int",
            "fmt.Println(\"nums1:\", sub_list(nums1, nums2))",
            "fmt.Println(\"nums2:\", sub_list(nums2, nums1))",
            "}",
            "<|endoftext|>",
            "func TestSub_List(t *testing.T) {",
            "candidate := sub_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}, []int{4, 5, 6}), expected: []int{-3, -3, -3} },",
            "{ actual: candidate([]int{1, 2}, []int{3, 4}), expected: []int{-2, -2} },",
            "{ actual: candidate([]int{90, 120}, []int{50, 70}), expected: []int{40, 50} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "283",
        "title": "validate",
        "text": "Write a gothon function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.",
        "code": "package validate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc validate(n int) bool {\n    if n < 0 {\n        return false\n    }\n    for i := 0; i < n; i++ {\n        if n % 10 == i {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestValidate(t *testing.T) {",
            "if!validate(10) {",
            "t.Error(\"10 is not a valid number\")",
            "}",
            "if!validate(100) {",
            "t.Error(\"100 is not a valid number\")",
            "}",
            "if!validate(1000) {",
            "t.Error(\"1000 is not a valid number\")",
            "}",
            "if!validate(10000) {",
            "t.Error(\"10000 is not a valid number\")",
            "}",
            "if!validate(100000) {",
            "t.Error(\"100000 is not a valid number\")",
            "}",
            "if!validate(1000000) {",
            "t.Error(\"1000000 is not a valid number\")",
            "}",
            "if!validate(10000000) {",
            "t.Error(\"10000000 is not a valid number\")",
            "}",
            "if!validate(100000000) {",
            "t.Error(\"100000000 is not a valid number\")",
            "}",
            "if!validate(1000000000) {",
            "t.Error(\"1000000000 is not a valid number\")",
            "}",
            "if!validate(10000000000) {",
            "t.Error(\"10000000000 is not a valid number\")",
            "}",
            "if!validate(100000000000) {",
            "t.Error(\"100000000000 is not a valid number\")",
            "}",
            "if!validate(1000000000000) {",
            "t.Error(\"1000000000000 is not a valid number\")",
            "}",
            "if!validate(10000000000000) {",
            "t.Error(\"10000000000000 is not a valid number\")",
            "}",
            "if!validate(100000000000000) {",
            "t",
            "func TestValidate(t *testing.T) {",
            "candidate := validate",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1234), expected: true },",
            "{ actual: candidate(51241), expected: false },",
            "{ actual: candidate(321), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "284",
        "title": "check_element",
        "text": "Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.",
        "code": "package check_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_element(list []interface{}, element interface{}) bool {\n    for _, item := range list {\n        if item!= element {\n            return false\n        }\n    }\n    return true\n}\n\nfunc check_element_with_list(list []interface{}, element interface{}) bool {\n    for _, item := range list {\n        if item!= element {\n            return false\n        }\n    }\n    return true\n}\n\nfunc check_element_with_list_and_list(list []interface{}, element interface{}) bool {\n    for _, item := range list {\n        if item!= element {\n            return false\n        }\n    }\n    return true\n}\n\nfunc check_element_with_list_and_list_and_list(list []interface{}, element interface{}) bool {\n    for _, item := range list {\n        if item!= element {\n            return false\n        }\n    }\n    return true\n}\n\nfunc check_element_with_list_and_list_and_list(list []interface{}, element interface{}) bool {\n    for _, item := range list {\n        if item!= element {\n            return false\n        }\n    }\n    return true\n}\n\nfunc check_element_with_list_and_list_and_list(list []interface{}, element interface{}) bool {\n    for _, item\n",
        "test_list": [
            "func TestCheck_Element(t *testing.T) {",
            "candidate := check_element",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"green\", \"orange\", \"black\", \"white\"}, \"blue\"), expected: false },",
            "{ actual: candidate([]int{1, 2, 3, 4}, 7), expected: false },",
            "{ actual: candidate([]string{\"green\", \"green\", \"green\", \"green\"}, \"green\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "285",
        "title": "text_match_two_three",
        "text": "Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.",
        "code": "package text_match_two_three_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_match_two_three(text string) bool {\n    if text == \"a\" {\n        return true\n    }\n    if text == \"b\" {\n        return true\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestTextMatchTwoThree(t *testing.T) {",
            "if!text_match_two_three(`a`) {",
            "t.Errorf(\"Expected 'a' to match two characters followed by three characters\")",
            "}",
            "if!text_match_two_three(`b`) {",
            "t.Errorf(\"Expected 'b' to match two characters followed by three characters\")",
            "}",
            "if!text_match_two_three(`c`) {",
            "t.Errorf(\"Expected 'c' to match two characters followed by three characters\")",
            "}",
            "}",
            "func TestTextMatchTwoThree_test(t *testing.T) {",
            "if!text_match_two_three(`a`) {",
            "t.Errorf(\"Expected 'a' to match two characters followed by three characters\")",
            "}",
            "if!text_match_two_three(`b`) {",
            "t.Errorf(\"Expected 'b' to match two characters followed by three characters\")",
            "}",
            "if!text_match_two_three(`c`) {",
            "t.Errorf(\"Expected 'c' to match two characters followed by three characters\")",
            "}",
            "}",
            "func TestTextMatchOneThree(t *testing.T) {",
            "if text_match_one_three(`a`) {",
            "t.Errorf(\"Expected 'a' to match one character followed by three characters\")",
            "}",
            "if text_match_one_three(`b`) {",
            "t.Errorf(\"Expected 'b' to match one character followed by three characters\")",
            "}",
            "if text_match_one_three(`c`) {",
            "t.Errorf(\"Expected",
            "func TestText_Match_Two_Three(t *testing.T) {",
            "candidate := text_match_two_three",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"ac\"), expected: false },",
            "{ actual: candidate(\"dc\"), expected: false },",
            "{ actual: candidate(\"abbbba\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "286",
        "title": "max_sub_array_sum_repeated",
        "text": "Write a function to find the largest sum of a contiguous list in the modified list which is formed by repeating the given list k times.",
        "code": "package max_sub_array_sum_repeated_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_sub_array_sum_repeated(a []int, n int, k int) int {\n    if len(a) == 0 {\n        return 0\n    }\n    if len(a) == 1 {\n        return a[0]\n    }\n    if len(a) == 2 {\n        return max(max_sub_array_sum_repeated(a[0:k], n, k), max(max_sub_array_sum_repeated(a[0:k], n, k), max(max_sub_array_sum_repeated(a[0:k], n, k), a[0])))\n    }\n    if len(a) == 3 {\n        return max(max_sub_array_sum_repeated(a[0:k], n, k), max(max_sub_array_sum_repeated(a[0:k], n, k), max(max_sub_array_sum_repeated(a[0:k], n, k), a[0])))\n    }\n    return 0\n}\n\n",
        "test_list": [
            "func TestMaxSubArraySumRepeated(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_sub_array_sum_repeated(a, 10, 10)!= 10 {",
            "t.Errorf(\"Expected 10, got %d\", max_sub_array_sum_repeated(a, 10, 10))",
            "}",
            "}",
            "func TestMaxSubArraySumRepeated2(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_sub_array_sum_repeated(a, 2, 2)!= 10 {",
            "t.Errorf(\"Expected 10, got %d\", max_sub_array_sum_repeated(a, 2,",
            "func TestMax_Sub_Array_Sum_Repeated(t *testing.T) {",
            "candidate := max_sub_array_sum_repeated",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 20, -30, -1}, 4, 3), expected: 30 },",
            "{ actual: candidate([]int{-1, 10, 20}, 3, 2), expected: 59 },",
            "{ actual: candidate([]int{-1, -2, -3}, 3, 3), expected: -1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "287",
        "title": "square_Sum",
        "text": "Write a gothon function takes in an integer n and returns the sum of squares of first n even natural numbers.",
        "code": "package square_Sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc square_Sum(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return n * n\n}\n\n",
        "test_list": [
            "func TestSquare(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode\")",
            "}",
            "fmt.Println(\"square_Sum\")",
            "for i := 0; i < 100; i++ {",
            "fmt.Println(square_Sum(i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestSquare_Sum(t *testing.T) {",
            "candidate := square_Sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 20 },",
            "{ actual: candidate(3), expected: 56 },",
            "{ actual: candidate(4), expected: 120 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "290",
        "title": "max_length",
        "text": "Write a function to find the list of maximum length in a list of lists.",
        "code": "package max_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_length(list1 [][]int) []interface{} {\n    var max_length_list = make([]interface{}, 0)\n    for _, list := range list1 {\n        max_length_list = append(max_length_list, list[0])\n    }\n    return max_length_list\n}\n\n",
        "test_list": [
            "func TestMaxLength(t *testing.T) {",
            "var list1 [][]int",
            "list1 = [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9},",
            "[]int{10, 11, 12, 13, 14, 15, 16, 17, 18},",
            "[]int{19, 20, 21, 22, 23, 24, 25, 26, 27},",
            "[]int{28, 29, 30, 31, 32, 33, 34, 35, 36},",
            "[]int{37, 38, 39, 40, 41, 42, 43, 44, 45},",
            "[]int{46, 47, 48, 49, 50, 51, 52, 53, 54},",
            "[]int{55, 56, 57, 58, 59, 60, 61, 62, 63},",
            "[]int{64, 65, 66, 67, 68, 69, 70, 71, 72},",
            "[]int{73, 74, 75, 76, 77, 78, 79, 80, 81},",
            "[]int{82, 83, 84, 85, 86, 87, 88, 89, 90},",
            "[]int{91, 92, 93, 94, 95, 96, 97, 98, 99},",
            "[]int{100, 101, 102, 103, 104, 105, 106, 107, 108},",
            "[]int{109, 110, 111, 112, 113, 114, 115, 116, 117},",
            "[]int{118, 119, 120, 121, 122, 123, 124, 125, 126},",
            "[]int{127, 128, 129, 130, 131, 132, 133, 134, 135},",
            "[]int{136, 137, 138, 139,",
            "func TestMax_Length(t *testing.T) {",
            "candidate := max_length",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{0}, []int{1, 3}, []int{5, 7}, []int{9, 11}, []int{13, 15, 17}}), expected: []interface{}{3, []int{13, 15, 17}} },",
            "{ actual: candidate([][]int{[]int{1}, []int{5, 7}, []int{10, 12, 14, 15}}), expected: []interface{}{4, []int{10, 12, 14, 15}} },",
            "{ actual: candidate([][]int{[]int{5}, []int{15, 20, 25}}), expected: []interface{}{3, []int{15, 20, 25}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "291",
        "title": "count_no_of_ways",
        "text": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.",
        "code": "package count_no_of_ways_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_no_of_ways(n int, k int) int {\n    var count int\n    for i := 0; i < n; i++ {\n        for j := 0; j < k; j++ {\n            if i == j {\n                count++\n            }\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountNoOfWays(t *testing.T) {",
            "n := 10",
            "k := 5",
            "f := make([]int, n)",
            "for i := 0; i < n; i++ {",
            "f[i] = i",
            "}",
            "for i := 0; i < k; i++ {",
            "f[i] = i",
            "}",
            "fmt.Println(count_no_of_ways(n, k))",
            "}",
            "<|endoftext|>",
            "func TestCount_No_Of_Ways(t *testing.T) {",
            "candidate := count_no_of_ways",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2, 4), expected: 16 },",
            "{ actual: candidate(3, 2), expected: 6 },",
            "{ actual: candidate(4, 4), expected: 228 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "292",
        "title": "find",
        "text": "Write a gothon function to find quotient of two numbers (rounded down to the nearest integer).",
        "code": "package find_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find(n int, m int) int {\n    if n == 0 {\n        return m\n    }\n    return find(n-1, m) + find(n-1, m-1)\n}\n\n",
        "test_list": [
            "func TestFind(t *testing.T) {",
            "n := 10",
            "m := 10",
            "if n < m {",
            "t.Errorf(\"n < m\")",
            "}",
            "if n == m {",
            "t.Errorf(\"n == m\")",
            "}",
            "if n > m {",
            "t.Errorf(\"n > m\")",
            "}",
            "if n == 0 {",
            "t.Errorf(\"n == 0\")",
            "}",
            "if n == 1 {",
            "t.Errorf(\"n == 1\")",
            "}",
            "if n == 2 {",
            "t.Errorf(\"n == 2\")",
            "}",
            "if n == 3 {",
            "t.Errorf(\"n == 3\")",
            "}",
            "if n == 4 {",
            "t.Errorf(\"n == 4\")",
            "}",
            "if n == 5 {",
            "t.Errorf(\"n == 5\")",
            "}",
            "if n == 6 {",
            "t.Errorf(\"n == 6\")",
            "}",
            "if n == 7 {",
            "t.Errorf(\"n == 7\")",
            "}",
            "if n == 8 {",
            "t.Errorf(\"n == 8\")",
            "}",
            "if n == 9 {",
            "t.Errorf(\"n == 9\")",
            "}",
            "if n == 10 {",
            "t.Errorf(\"n == 10\")",
            "}",
            "if n == 11 {",
            "t.Errorf(\"n == 11\")",
            "}",
            "if n == 12 {",
            "t.Errorf(\"n == 12\")",
            "}",
            "if n == 13 {",
            "t.Errorf(\"n == 13\")",
            "}",
            "if n == 14 {",
            "t.Errorf(\"n == 14\")",
            "}",
            "if n == 15 {",
            "t.Errorf(\"n ==",
            "func TestFind(t *testing.T) {",
            "candidate := find",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 3), expected: 3 },",
            "{ actual: candidate(4, 2), expected: 2 },",
            "{ actual: candidate(20, 5), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "293",
        "title": "otherside_rightangle",
        "text": "Write a function to find the third side of a right angled triangle.",
        "code": "package otherside_rightangle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc otherside_rightangle(w int, h int) float64 {\n    if w == 0 {\n        return 0\n    }\n    if h == 0 {\n        return 0\n    }\n    if w > h {\n        return otherside_rightangle(w-1, h)\n    }\n    return otherside_rightangle(w-1, h-1)\n}\n\n",
        "test_list": [
            "func TestOthersideRightangle(t *testing.T) {",
            "fmt.Println(\"Testing otherside_rightangle...\")",
            "for i := 0; i < 10; i++ {",
            "fmt.Printf(\"%d\\n\", i)",
            "w := rand.Intn(10)",
            "h := rand.Intn(10)",
            "fmt.Printf(\"%d %d\\n\", w, h)",
            "fmt.Printf(\"%d %d\\n\", otherside_rightangle(w, h), otherside_rightangle(w, h-1))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestOtherside_Rightangle(t *testing.T) {",
            "candidate := otherside_rightangle",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(7, 8), expected: 10.63014581273465 },",
            "{ actual: candidate(3, 4), expected: 5 },",
            "{ actual: candidate(7, 15), expected: 16.55294535724685 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "295",
        "title": "sum_div",
        "text": "Write a function to return the sum of all divisors of a number.",
        "code": "package sum_div_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_div(number int) int {\n    if number == 0 {\n        return 0\n    }\n    return sum_div_recursive(number)\n}\n\nfunc sum_div_recursive(number int) int {\n    if number == 0 {\n        return 0\n    }\n    return sum_div_recursive(number / 2) + sum_div_recursive(number % 2)\n}\n\n",
        "test_list": [
            "func TestSumDiv(t *testing.T) {",
            "fmt.Println(\"Sum of all divisors of\", \"1\")",
            "fmt.Println(\"=\", sum_div(1))",
            "fmt.Println(\"=\", sum_div(2))",
            "fmt.Println(\"=\", sum_div(3))",
            "fmt.Println(\"=\", sum_div(4))",
            "fmt.Println(\"=\", sum_div(5))",
            "fmt.Println(\"=\", sum_div(6))",
            "fmt.Println(\"=\", sum_div(7))",
            "fmt.Println(\"=\", sum_div(8))",
            "fmt.Println(\"=\", sum_div(9))",
            "fmt.Println(\"=\", sum_div(10))",
            "fmt.Println(\"=\", sum_div(11))",
            "fmt.Println(\"=\", sum_div(12))",
            "fmt.Println(\"=\", sum_div(13))",
            "fmt.Println(\"=\", sum_div(14))",
            "fmt.Println(\"=\", sum_div(15))",
            "fmt.Println(\"=\", sum_div(16))",
            "fmt.Println(\"=\", sum_div(17))",
            "fmt.Println(\"=\", sum_div(18))",
            "fmt.Println(\"=\", sum_div(19))",
            "fmt.Println(\"=\", sum_div(20))",
            "fmt.Println(\"=\", sum_div(21))",
            "fmt.",
            "func TestSum_Div(t *testing.T) {",
            "candidate := sum_div",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(8), expected: 7 },",
            "{ actual: candidate(12), expected: 16 },",
            "{ actual: candidate(7), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "296",
        "title": "get_Inv_Count",
        "text": "Write a gothon function to count inversions in a list.",
        "code": "package get_Inv_Count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_Inv_Count(arr []int) int {\n    return len(arr)\n}\n\n",
        "test_list": [
            "func Test_Inv_Count(t *testing.T) {",
            "if get_Inv_Count([]int{1, 2, 3, 4, 5})!= 5 {",
            "t.Errorf(\"Expected 5, got %d\", get_Inv_Count([]int{1, 2, 3, 4, 5}))",
            "}",
            "}",
            "func Test_Inv_Count_empty(t *testing.T) {",
            "if get_Inv_Count([]int{})!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", get_Inv_Count([]int{}))",
            "}",
            "}",
            "func Test_Inv_Count_single(t *testing.T) {",
            "if get_Inv_Count([]int{1})!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", get_Inv_Count([]int{1}))",
            "}",
            "}",
            "func Test_Inv_Count_multiple(t *testing.T) {",
            "if get_Inv_Count([]int{1, 2, 3, 4, 5})!= 5 {",
            "t.Errorf(\"Expected 5, got %d\", get_Inv_Count([]int{1, 2, 3, 4, 5}))",
            "}",
            "}",
            "func Test_Inv_Count_list(t *testing.T) {",
            "if get_Inv_Count([]int{1, 2, 3, 4, 5})!= 5 {",
            "t.Errorf(\"Expected 5, got %d\", get_Inv_Count([]int{1, 2, 3, 4, 5}))",
            "}",
            "}",
            "func Test_Inv_Count_list_empty(t *testing.T) {",
            "if get_Inv_Count([]int{})!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", get_Inv_Count([]int{}))",
            "}",
            "}",
            "func TestGet_Inv_Count(t *testing.T) {",
            "candidate := get_Inv_Count",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 20, 6, 4, 5}), expected: 5 },",
            "{ actual: candidate([]int{1, 2, 1}), expected: 1 },",
            "{ actual: candidate([]int{1, 2, 5, 6, 1}), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "299",
        "title": "max_aggregate",
        "text": "Write a function to calculate the maximum aggregate from the list of lists.",
        "code": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate = make([]interface{}, len(stdata))\n    for i, v := range stdata {\n        max_aggregate[i] = v[0]\n    }\n    return max_aggregate\n}\n\n",
        "test_list": [
            "func TestMaxAggregate(t *testing.T) {",
            "var stdata [][]interface{}",
            "stdata = [][]interface{}{",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7,",
            "func TestMax_Aggregate(t *testing.T) {",
            "candidate := max_aggregate",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },",
            "{ actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },",
            "{ actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "304",
        "title": "find_Element",
        "text": "Write a gothon function to find element at a given index after number of rotations.",
        "code": "package find_Element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Element(arr []int, ranges [][]int, rotations int, index int) int {\n    for i := 0; i < rotations; i++ {\n        for j := 0; j < len(arr); j++ {\n            if arr[j] == index {\n                return arr[j]\n            }\n        }\n    }\n    return -1\n}\n\n",
        "test_list": [
            "func TestFindElement(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "ranges := [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "func TestFind_Element(t *testing.T) {",
            "candidate := find_Element",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}, [][]int{[]int{0, 2}, []int{0, 3}}, 2, 1), expected: 3 },",
            "{ actual: candidate([]int{1, 2, 3, 4}, [][]int{[]int{0, 1}, []int{0, 2}}, 1, 2), expected: 3 },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}, [][]int{[]int{0, 1}, []int{0, 2}}, 1, 1), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "305",
        "title": "start_withp",
        "text": "Write a function to return two words from a list of words starting with letter 'p'.",
        "code": "package start_withp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc start_withp(words []string) []interface{} {\n    var p string\n    for _, word := range words {\n        if word[0] == 'p' {\n            p = word\n            break\n        }\n    }\n    return []interface{}{p, p}\n}\n\n",
        "test_list": [
            "func TestStartWithp(t *testing.T) {",
            "words := []string{\"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"",
            "func TestStart_Withp(t *testing.T) {",
            "candidate := start_withp",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"Python PHP\", \"Java JavaScript\", \"c c++\"}), expected: []interface{}{\"Python\", \"PHP\"} },",
            "{ actual: candidate([]string{\"Python Programming\", \"Java Programming\"}), expected: []interface{}{\"Python\", \"Programming\"} },",
            "{ actual: candidate([]string{\"Pqrst Pqr\", \"qrstuv\"}), expected: []interface{}{\"Pqrst\", \"Pqr\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "306",
        "title": "max_sum_increasing_subseq",
        "text": "Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i.",
        "code": "package max_sum_increasing_subseq_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_sum_increasing_subseq(a []int, n int, index int, k int) int {\n    if index == n {\n        return a[index]\n    }\n    if index > n {\n        return 0\n    }\n    if index == 0 {\n        return a[index]\n    }\n    if index == n {\n        return a[index]\n    }\n    if index > n {\n        return max_sum_increasing_subseq(a, n, index-1, k)\n    }\n    if index < n {\n        return max_sum_increasing_subseq(a, n, index+1, k)\n    }\n    return a[index]\n}\n\n",
        "test_list": [
            "func TestMaxSum(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "n := len(a)",
            "if n < 2 {",
            "t.Errorf(\"n < 2\")",
            "}",
            "if n == 2 {",
            "t.Errorf(\"n == 2\")",
            "}",
            "if max_sum_increasing_subseq(a, n, 0, 1)!= 10 {",
            "t.Errorf(\"max_sum_increasing_subseq(a, n, 0, 1) = %d\", max_sum_increasing_subseq(a, n, 0, 1))",
            "}",
            "if max_sum_increasing_subseq(a, n, 1, 1)!= 10 {",
            "t.Errorf(\"max_sum_increasing_subseq(a, n, 1, 1) = %d\", max_sum_increasing_subseq(a, n, 1, 1))",
            "}",
            "if max_sum_increasing_subseq(a, n, 2, 1)!= 10 {",
            "t.Errorf(\"max_sum_increasing_subseq(a, n, 2,",
            "func TestMax_Sum_Increasing_Subseq(t *testing.T) {",
            "candidate := max_sum_increasing_subseq",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 101, 2, 3, 100, 4, 5}, 7, 4, 6), expected: 11 },",
            "{ actual: candidate([]int{1, 101, 2, 3, 100, 4, 5}, 7, 2, 5), expected: 7 },",
            "{ actual: candidate([]int{11, 15, 19, 21, 26, 28, 31}, 7, 2, 4), expected: 71 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "308",
        "title": "large_product",
        "text": "Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.",
        "code": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var largestProduct int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i]*nums2[j] > largestProduct {\n                largestProduct = nums1[i]*nums2[j]\n            }\n        }\n    }\n    return []int{largestProduct}\n}\n\n",
        "test_list": [
            "func TestLargeProduct(t *testing.T) {",
            "var nums1 []int",
            "var nums2 []int",
            "nums1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "nums2 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if err := large_product(nums1, nums2, 10); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := large_product(nums1, nums2, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := large_product(nums1, nums2, 2); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := large_product(nums1, nums2, 3); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := large_product(nums1, nums2, 4); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := large_product(nums1, nums2, 5); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := large_product(nums1, nums2, 6); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := large_product(nums1,",
            "func TestLarge_Product(t *testing.T) {",
            "candidate := large_product",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "309",
        "title": "maximum",
        "text": "Write a gothon function to find the maximum of two numbers.",
        "code": "package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc maximum(a int, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n",
        "test_list": [
            "func TestMaximum(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "fmt.Println(\"maximum\")",
            "a := 1",
            "b := 2",
            "fmt.Println(\"a =\", a)",
            "fmt.Println(\"b =\", b)",
            "fmt.Println(\"maximum =\", maximum(a, b))",
            "}",
            "<|endoftext|>",
            "func TestMaximum(t *testing.T) {",
            "candidate := maximum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5, 10), expected: 10 },",
            "{ actual: candidate(-1, -2), expected: -1 },",
            "{ actual: candidate(9, 7), expected: 9 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "310",
        "title": "string_to_tuple",
        "text": "Write a function to convert a given string to a list of characters.",
        "code": "package string_to_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc string_to_tuple(str1 string) []string {\n    return []string{str1}\n}\n\n",
        "test_list": [
            "func TestStringToTuple(t *testing.T) {",
            "var str1 string",
            "var str2 string",
            "var str3 string",
            "var str4 string",
            "var str5 string",
            "var str6 string",
            "var str7 string",
            "var str8 string",
            "var str9 string",
            "var str10 string",
            "var str11 string",
            "var str12 string",
            "var str13 string",
            "var str14 string",
            "var str15 string",
            "var str16 string",
            "var str17 string",
            "var str18 string",
            "var str19 string",
            "var str20 string",
            "var str21 string",
            "var str22 string",
            "var str23 string",
            "var str24 string",
            "var str25 string",
            "var str26 string",
            "var str27 string",
            "var str28 string",
            "var str29 string",
            "var str30 string",
            "var str31 string",
            "var str32 string",
            "var str33 string",
            "var str34 string",
            "var str35 string",
            "var str36 string",
            "var str37 string",
            "var str38 string",
            "var str39 string",
            "var str40 string",
            "var str41 string",
            "var str42 string",
            "var str43 string",
            "var str44 string",
            "var str45 string",
            "var str46 string",
            "var str47 string",
            "var str48 string",
            "var str49 string",
            "var str50 string",
            "var str51 string",
            "var str52 string",
            "var str53 string",
            "var str54 string",
            "var str55 string",
            "var str56 string",
            "var str57 string",
            "var str58 string",
            "var str59 string",
            "var str60 string",
            "var str61 string",
            "var str62 string",
            "var str63 string",
            "var str64 string",
            "var str65 string",
            "var str66 string",
            "var str67 string",
            "var str68 string",
            "var str69 string",
            "var str70 string",
            "var str71 string",
            "func TestString_To_Tuple(t *testing.T) {",
            "candidate := string_to_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python 3.0\"), expected: []string{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\", \"3\", \".\", \"0\"} },",
            "{ actual: candidate(\"item1\"), expected: []string{\"i\", \"t\", \"e\", \"m\", \"1\"} },",
            "{ actual: candidate(\"15.10\"), expected: []string{\"1\", \"5\", \".\", \"1\", \"0\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "388",
        "title": "highest_Power_of_2",
        "text": "Write a gothon function to find the highest power of 2 that is less than or equal to n.",
        "code": "package highest_Power_of_2_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc highest_Power_of_2(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n < 2 {\n        return n\n    }\n    return highest_Power_of_2(n-1) + highest_Power_of_2(n-2)\n}\n\n",
        "test_list": [
            "func TestHighestPowerOf2(t *testing.T) {",
            "if highest_Power_of_2(0)!= 0 {",
            "t.Errorf(\"highest_Power_of_2(0) = %d, want 0\", highest_Power_of_2(0))",
            "}",
            "if highest_Power_of_2(1)!= 1 {",
            "t.Errorf(\"highest_Power_of_2(1) = %d, want 1\", highest_Power_of_2(1))",
            "}",
            "if highest_Power_of_2(2)!= 2 {",
            "t.Errorf(\"highest_Power_of_2(2) = %d, want 2\", highest_Power_of_2(2))",
            "}",
            "if highest_Power_of_2(3)!= 3 {",
            "t.Errorf(\"highest_Power_of_2(3) = %d, want 3\", highest_Power_of_2(3))",
            "}",
            "if highest_Power_of_2(4)!= 4 {",
            "t.Errorf(\"highest_Power_of_2(4) = %d, want 4\", highest_Power_of_2(4))",
            "}",
            "if highest_Power_of_2(5)!= 5 {",
            "t.Errorf(\"highest_Power_of_2(5) = %d, want 5\", highest_Power_of_2(5))",
            "}",
            "if highest_Power_of_2(6)!= 6 {",
            "t.Errorf(\"highest_Power_of_2(6) = %d, want 6\", highest_Power_of_2(6))",
            "func TestHighest_Power_Of_2(t *testing.T) {",
            "candidate := highest_Power_of_2",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: 8 },",
            "{ actual: candidate(19), expected: 16 },",
            "{ actual: candidate(32), expected: 32 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "389",
        "title": "find_lucas",
        "text": "Write a function to find then'th lucas number.",
        "code": "package find_lucas_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_lucas(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return find_lucas(n - 1) + find_lucas(n - 2) + find_lucas(n - 3) + find_lucas(n - 4) + find_lucas(n - 5) + find_lucas(n - 6) + find_lucas(n - 7) + find_lucas(n - 8) + find_lucas(n - 9) + find_lucas(n - 10) + find_lucas(n - 11) + find_lucas(n - 12) + find_lucas(n - 13) + find_lucas(n - 14) + find_lucas(n - 15) + find_lucas(n - 16) + find_lucas(n - 17) + find_lucas(n - 18) + find_lucas(n - 19) + find_lucas(n - 20) + find_lucas(n - 21) + find_lucas(n - 22) + find_lucas(n - 23) + find_lucas(n - 24) + find_lucas(n - 25) + find_lucas(n - 26) + find_lucas(n - 27) + find_lucas(n - 28) + find_lucas(n - 29) + find_lucas(n - 30) + find_lucas(n - 31) + find_lucas(n - 32) + find_lucas(n - 33) + find_lucas(n - 34) + find_lucas(n - 35) + find_lucas(n - 36) + find_lucas(n - 37) + find_lucas(n - 38) + find_lucas(n - 39) + find_lucas(n - 40) + find\n",
        "test_list": [
            "func TestFind_Lucas(t *testing.T) {",
            "candidate := find_lucas",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(9), expected: 76 },",
            "{ actual: candidate(4), expected: 7 },",
            "{ actual: candidate(3), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "390",
        "title": "add_string",
        "text": "Write a function to apply a given format string to all of the elements in a list.",
        "code": "package add_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc add_string(list_ []interface{}, myString string) []string {\n    var result []string\n    for _, item := range list_ {\n        result = append(result, fmt.Sprintf(myString, item))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestAddString(t *testing.T) {",
            "list := []interface{}{",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"",
            "func TestAdd_String(t *testing.T) {",
            "candidate := add_string",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4}, \"temp{0}\"), expected: []string{\"temp1\", \"temp2\", \"temp3\", \"temp4\"} },",
            "{ actual: candidate([]string{\"a\", \"b\", \"c\", \"d\"}, \"python{0}\"), expected: []string{\"pythona\", \"pythonb\", \"pythonc\", \"pythond\"} },",
            "{ actual: candidate([]int{5, 6, 7, 8}, \"string{0}\"), expected: []string{\"string5\", \"string6\", \"string7\", \"string8\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "392",
        "title": "get_max_sum",
        "text": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
        "code": "package get_max_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_max_sum(n int) int {\n    return max(fmt.Sprintf(\"%d\", n), fmt.Sprintf(\"%d\", n/2), fmt.Sprintf(\"%d\", n/3), fmt.Sprintf(\"%d\", n/4), fmt.Sprintf(\"%d\", n/5))\n}\n\n",
        "test_list": [
            "func TestGetMaxSum(t *testing.T) {",
            "n := 10",
            "fmt.Println(\"n = \", n)",
            "fmt.Println(\"get_max_sum(n) = \", get_max_sum(n))",
            "}",
            "<|endoftext|>",
            "func TestGet_Max_Sum(t *testing.T) {",
            "candidate := get_max_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(60), expected: 106 },",
            "{ actual: candidate(10), expected: 12 },",
            "{ actual: candidate(2), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "393",
        "title": "max_length_list",
        "text": "Write a function to find the list with maximum length.",
        "code": "package max_length_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_length_list(input_list [][]int) []interface{} {\n    max_length := 0\n    for _, item := range input_list {\n        if len(item) > max_length {\n            max_length = len(item)\n        }\n    }\n    return input_list[:max_length]\n}\n\n",
        "test_list": [
            "func TestMaxLengthList(t *testing.T) {",
            "input_list := [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{11, 12, 13, 14, 15, 16, 17, 18, 19, 20},",
            "[]int{21, 22, 23, 24, 25, 26, 27, 28, 29, 30},",
            "[]int{31, 32, 33, 34, 35, 36, 37, 38, 39, 40},",
            "[]int{41, 42, 43, 44, 45, 46, 47, 48, 49, 50},",
            "[]int{51, 52, 53, 54, 55, 56, 57, 58, 59, 60},",
            "[]int{61, 62, 63, 64, 65, 66, 67, 68, 69, 70},",
            "[]int{71, 72, 73, 74, 75, 76, 77, 78, 79, 80},",
            "[]int{81, 82, 83, 84, 85, 86, 87, 88, 89, 90},",
            "[]int{91, 92, 93, 94, 95, 96, 97, 98, 99, 100},",
            "[]int{101, 102, 103, 104, 105, 106, 107, 108, 109, 110},",
            "[]int{111, 112, 113, 114, 115, 116, 117, 118, 119, 120},",
            "[]int{121, 122, 123, 124, 125, 126, 127, 128, 129, 130},",
            "[]int{131, 132, 133, 134, 135, 136, 137, 138, 139, 140},",
            "[]int{141, 142, 143, 144, 145,",
            "func TestMax_Length_List(t *testing.T) {",
            "candidate := max_length_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{0}, []int{1, 3}, []int{5, 7}, []int{9, 11}, []int{13, 15, 17}}), expected: []interface{}{3, []int{13, 15, 17}} },",
            "{ actual: candidate([][]int{[]int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4}, []int{1, 2, 3}, []int{1, 2}, []int{1}}), expected: []interface{}{5, []int{1, 2, 3, 4, 5}} },",
            "{ actual: candidate([][]int{[]int{3, 4, 5}, []int{6, 7, 8, 9}, []int{10, 11, 12}}), expected: []interface{}{4, []int{6, 7, 8, 9}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "394",
        "title": "check_distinct",
        "text": "Write a function to check if given list contains no duplicates.",
        "code": "package check_distinct_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_distinct(test_tup []int) bool {\n    for _, v := range test_tup {\n        if v == v {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestCheckDistinct(t *testing.T) {",
            "test_tup := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_distinct(test_tup) {",
            "t.Errorf(\"Expected %v to be distinct\", test_tup)",
            "}",
            "}",
            "func TestCheckDistinct_Error(t *testing.T) {",
            "test_tup := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_distinct(test_tup) {",
            "t.Errorf(\"Expected %v to be distinct\", test_tup)",
            "}",
            "}",
            "func TestCheckDistinct_Error_Error(t *testing.T) {",
            "test_tup := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_distinct(test_tup) {",
            "t.Errorf(\"Expected %v to be distinct\", test_tup)",
            "}",
            "}",
            "func TestCheckDistinct_Error_Error_Error(t *testing.T) {",
            "test_tup := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_distinct(test_tup) {",
            "t.Errorf(\"Expected %v to be distinct\", test_tup)",
            "}",
            "}",
            "func TestCheckDistinct_Error_Error_Error(t *testing.T) {",
            "test_tup := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_distinct(test_tup) {",
            "func TestCheck_Distinct(t *testing.T) {",
            "candidate := check_distinct",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 4, 5, 6, 1, 4}), expected: false },",
            "{ actual: candidate([]int{1, 4, 5, 6}), expected: true },",
            "{ actual: candidate([]int{2, 3, 4, 5, 6}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "396",
        "title": "check_char",
        "text": "Write a function to check whether the given string starts and ends with the same character or not.",
        "code": "package check_char_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_char(myString string) string {\n    if myString == \"\" {\n        return \"\"\n    }\n    if myString[0] == '\\'' {\n        return myString\n    }\n    return fmt.Sprintf(\"%s%s\", myString, myString[len(myString)-1:])\n}\n\n",
        "test_list": [
            "func TestCheckChar(t *testing.T) {",
            "myString := \"hello\"",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(myString)!= \"hello\" {",
            "t.Errorf(\"CheckChar(%s) should return 'hello'\", myString)",
            "}",
            "if check_char(my",
            "func TestCheck_Char(t *testing.T) {",
            "candidate := check_char",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"abba\"), expected: \"Valid\" },",
            "{ actual: candidate(\"a\"), expected: \"Valid\" },",
            "{ actual: candidate(\"abcd\"), expected: \"Invalid\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "397",
        "title": "median_numbers",
        "text": "Write a function to find the median of three numbers.",
        "code": "package median_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc median_numbers(a int, b int, c int) float64 {\n    if a < b {\n        return c\n    }\n    if a < b {\n        return b\n    }\n    return a\n}\n\n",
        "test_list": [
            "func TestMedianNumbers(t *testing.T) {",
            "for i := 0; i < 100; i++ {",
            "fmt.Println(median_numbers(i, i, i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestMedian_Numbers(t *testing.T) {",
            "candidate := median_numbers",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(25, 55, 65), expected: 55.0 },",
            "{ actual: candidate(20, 10, 30), expected: 20.0 },",
            "{ actual: candidate(15, 45, 75), expected: 45.0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "398",
        "title": "sum_of_digits",
        "text": "Write a function to compute the sum of digits of each number of a given list.",
        "code": "package sum_of_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_of_digits(nums []interface{}) int {\n    sum := 0\n    for _, num := range nums {\n        sum += num.(int)\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSumOfDigits(t *testing.T) {",
            "nums := []interface{}{",
            "int(10),",
            "int(11),",
            "int(12),",
            "int(13),",
            "int(14),",
            "int(15),",
            "int(16),",
            "int(17),",
            "int(18),",
            "int(19),",
            "int(20),",
            "int(21),",
            "int(22),",
            "int(23),",
            "int(24),",
            "int(25),",
            "int(26),",
            "int(27),",
            "int(28),",
            "int(29),",
            "int(30),",
            "int(31),",
            "int(32),",
            "int(33),",
            "int(34),",
            "int(35),",
            "int(36),",
            "int(37),",
            "int(38),",
            "int(39),",
            "int(40),",
            "int(41),",
            "int(42),",
            "int(43),",
            "int(44),",
            "int(45),",
            "int(46),",
            "int(47),",
            "int(48),",
            "int(49),",
            "int(50),",
            "int(51),",
            "int(52),",
            "int(53),",
            "int(54),",
            "int(55),",
            "int(56),",
            "int(57),",
            "int(58),",
            "int(59),",
            "int(60),",
            "int(61),",
            "int(62),",
            "int(63),",
            "int(64),",
            "int(65),",
            "int(66),",
            "int(67),",
            "int(68),",
            "int(69),",
            "int(70),",
            "int(71),",
            "int(72),",
            "int(73),",
            "int(74),",
            "func TestSum_Of_Digits(t *testing.T) {",
            "candidate := sum_of_digits",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 2, 56}), expected: 14 },",
            "{ actual: candidate([][]int{[]interface{}{10, 20, 4, 5, \"b\", 70, \"a\"}}), expected: 19 },",
            "{ actual: candidate([]int{10, 20, -4, 5, -70}), expected: 19 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "399",
        "title": "bitwise_xor",
        "text": "Write a function to perform the mathematical bitwise xor operation across the given lists.",
        "code": "package bitwise_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc bitwise_xor(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(test_tup1); i++ {\n        result = append(result, test_tup1[i] ^ test_tup2[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestBitwiseXor(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173,",
            "func TestBitwise_Xor(t *testing.T) {",
            "candidate := bitwise_xor",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{10, 4, 6, 9}, []interface{}{5, 2, 3, 3}), expected: []interface{}{15, 6, 5, 10} },",
            "{ actual: candidate([]interface{}{11, 5, 7, 10}, []interface{}{6, 3, 4, 4}), expected: []interface{}{13, 6, 3, 14} },",
            "{ actual: candidate([]interface{}{12, 6, 8, 11}, []interface{}{7, 4, 5, 6}), expected: []interface{}{11, 2, 13, 13} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "3",
        "title": "is_not_prime",
        "text": "Write a gothon function to identify non-prime numbers.",
        "code": "package is_not_prime_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_not_prime(n int) bool {\n    if n == 1 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    return is_not_prime(n - 1) || is_not_prime(n - 2)\n}\n\n",
        "test_list": [
            "func TestIsPrime(t *testing.T) {",
            "if!is_not_prime(1) {",
            "t.Errorf(\"is_not_prime(1) = false\")",
            "}",
            "if!is_not_prime(2) {",
            "t.Errorf(\"is_not_prime(2) = false\")",
            "}",
            "if!is_not_prime(3) {",
            "t.Errorf(\"is_not_prime(3) = false\")",
            "}",
            "if!is_not_prime(4) {",
            "t.Errorf(\"is_not_prime(4) = false\")",
            "}",
            "if!is_not_prime(5) {",
            "t.Errorf(\"is_not_prime(5) = false\")",
            "}",
            "if!is_not_prime(6) {",
            "t.Errorf(\"is_not_prime(6) = false\")",
            "}",
            "if!is_not_prime(7) {",
            "t.Errorf(\"is_not_prime(7) = false\")",
            "}",
            "if!is_not_prime(8) {",
            "t.Errorf(\"is_not_prime(8) = false\")",
            "}",
            "if!is_not_prime(9) {",
            "t.Errorf(\"is_not_prime(9) = false\")",
            "}",
            "if!is_not_prime(10) {",
            "t.Errorf(\"is_not_prime(10) = false\")",
            "}",
            "if!is_not_prime(11) {",
            "t.Errorf(\"is_not_prime(11) = false\")",
            "}",
            "if!is_not_prime(12) {",
            "func TestIs_Not_Prime(t *testing.T) {",
            "candidate := is_not_prime",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: false },",
            "{ actual: candidate(10), expected: true },",
            "{ actual: candidate(35), expected: true },",
            "{ actual: candidate(37), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "400",
        "title": "extract_freq",
        "text": "Write a function to extract the number of unique lists in the given list.",
        "code": "package extract_freq_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_freq(test_list [][]interface{}) int {\n    var count int\n    for _, v := range test_list {\n        count += len(v)\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestExtractFreq(t *testing.T) {",
            "test_list := [][]interface{}{",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "func TestExtract_Freq(t *testing.T) {",
            "candidate := extract_freq",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{3, 4}, []interface{}{1, 2}, []interface{}{4, 3}, []interface{}{5, 6}}), expected: 3 },",
            "{ actual: candidate([][]int{[]interface{}{4, 15}, []interface{}{2, 3}, []interface{}{5, 4}, []interface{}{6, 7}}), expected: 4 },",
            "{ actual: candidate([][]int{[]interface{}{5, 16}, []interface{}{2, 3}, []interface{}{6, 5}, []interface{}{6, 9}}), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "401",
        "title": "add_nested_tuples",
        "text": "Write a function to perform index wise addition of list elements in the given two nested lists.",
        "code": "package add_nested_tuples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc add_nested_tuples(test_tup1 [][]int, test_tup2 [][]int) [][]int {\n    var result [][]int\n    for i := range test_tup1 {\n        result = append(result, test_tup1[i] + test_tup2[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestAddNestedTuples(t *testing.T) {",
            "test_tup1 := [][]int{",
            "[]int{1, 2, 3},",
            "[]int{4, 5, 6},",
            "[]int{7, 8, 9},",
            "}",
            "test_tup2 := [][]int{",
            "[]int{10, 11, 12},",
            "[]int{13, 14, 15},",
            "[]int{16, 17, 18},",
            "}",
            "result := add_nested_tuples(test_tup1, test_tup2)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestAdd_Nested_Tuples(t *testing.T) {",
            "candidate := add_nested_tuples",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 3}, []int{4, 5}, []int{2, 9}, []int{1, 10}}, [][]int{[]int{6, 7}, []int{3, 9}, []int{1, 1}, []int{7, 3}}), expected: [][]int{[]int{7, 10}, []int{7, 14}, []int{3, 10}, []int{8, 13}} },",
            "{ actual: candidate([][]int{[]int{2, 4}, []int{5, 6}, []int{3, 10}, []int{2, 11}}, [][]int{[]int{7, 8}, []int{4, 10}, []int{2, 2}, []int{8, 4}}), expected: [][]int{[]int{9, 12}, []int{9, 16}, []int{5, 12}, []int{10, 15}} },",
            "{ actual: candidate([][]int{[]int{3, 5}, []int{6, 7}, []int{4, 11}, []int{3, 12}}, [][]int{[]int{8, 9}, []int{5, 11}, []int{3, 3}, []int{9, 5}}), expected: [][]int{[]int{11, 14}, []int{11, 18}, []int{7, 14}, []int{12, 17}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "404",
        "title": "minimum",
        "text": "Write a gothon function to find the minimum of two numbers.",
        "code": "package minimum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc minimum(a int, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\n",
        "test_list": [
            "func TestMinimum(t *testing.T) {",
            "tests := []",
            "func TestMinimum(t *testing.T) {",
            "candidate := minimum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1, 2), expected: 1 },",
            "{ actual: candidate(-5, -4), expected: -5 },",
            "{ actual: candidate(0, 0), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "406",
        "title": "find_Parity",
        "text": "Write a gothon function to find whether the parity of a given number is odd.",
        "code": "package find_Parity_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Parity(x int) bool {\n    return x % 2 == 1\n}\n\n",
        "test_list": [
            "func TestFindParity(t *testing.T) {",
            "if find_Parity(0) {",
            "t.Error(\"find_Parity(0) should return false\")",
            "}",
            "if find_Parity(1) {",
            "t.Error(\"find_Parity(1) should return false\")",
            "}",
            "if find_Parity(2) {",
            "t.Error(\"find_Parity(2) should return false\")",
            "}",
            "if find_Parity(3) {",
            "t.Error(\"find_Parity(3) should return false\")",
            "}",
            "if find_Parity(4) {",
            "t.Error(\"find_Parity(4) should return false\")",
            "}",
            "if find_Parity(5) {",
            "t.Error(\"find_Parity(5) should return false\")",
            "}",
            "if find_Parity(6) {",
            "t.Error(\"find_Parity(6) should return false\")",
            "}",
            "if find_Parity(7) {",
            "t.Error(\"find_Parity(7) should return false\")",
            "}",
            "if find_Parity(8) {",
            "t.Error(\"find_Parity(8) should return false\")",
            "}",
            "if find_Parity(9) {",
            "t.Error(\"find_Parity(9) should return false\")",
            "}",
            "if find_Parity(10) {",
            "t.Error(\"find_Parity(10) should return false\")",
            "}",
            "if find_Parity(11) {",
            "t.Error(\"find_Parity(11) should return false\")",
            "}",
            "if find_Parity(12) {",
            "t.Error(\"find_Parity(12) should return false\")",
            "}",
            "if find_Parity(13) {",
            "t.Error(\"find_Parity(13) should return false",
            "func TestFind_Parity(t *testing.T) {",
            "candidate := find_Parity",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(12), expected: false },",
            "{ actual: candidate(7), expected: true },",
            "{ actual: candidate(10), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "407",
        "title": "rearrange_bigger",
        "text": "Write a function to create the next bigger number by rearranging the digits of a given number.",
        "code": "package rearrange_bigger_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc rearrange_bigger(n int) interface{} {\n    if n < 10 {\n        return n\n    }\n    return n - 10\n}\n\n",
        "test_list": [
            "func TestRearrangeBigger(t *testing.T) {",
            "n := 10",
            "fmt.Println(\"n =\", n)",
            "fmt.Println(\"rearrange_bigger(n) =\", rearrange_bigger(n))",
            "}",
            "<|endoftext|>",
            "func TestRearrange_Bigger(t *testing.T) {",
            "candidate := rearrange_bigger",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(12), expected: 21 },",
            "{ actual: candidate(10), expected: false },",
            "{ actual: candidate(102), expected: 120 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "408",
        "title": "k_smallest_pairs",
        "text": "Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.",
        "code": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] == nums2[j] {\n                result = append(result, [][]int{nums1[i], nums2[j]})\n            }\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestKSmallestPairs(t *testing.T) {",
            "nums1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "nums2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "k := 3",
            "result := k_smallest_pairs(nums1, nums2, k)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestK_Smallest_Pairs(t *testing.T) {",
            "candidate := k_smallest_pairs",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },",
            "{ actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },",
            "{ actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "409",
        "title": "min_product_tuple",
        "text": "Write a function to find the minimum product from the pairs of lists within a given list.",
        "code": "package min_product_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc min_product_tuple(list1 [][]interface{}) int {\n    var min int\n    for _, v := range list1 {\n        if len(v) == 1 {\n            min = v[0]\n        } else {\n            min = min_product_tuple(v)\n        }\n    }\n    return min\n}\n\n",
        "test_list": [
            "func TestMinProductTuple(t *testing.T) {",
            "var list1 [][]interface{}",
            "list1 = [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "min_product_tuple(list1)",
            "}",
            "func TestMinProductTuple_Error(t *testing.T) {",
            "var list1 [][]interface{}",
            "list1 = [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "min_product_tuple(list1)",
            "}",
            "func TestMinProductTuple_Error_Error(t *testing.T) {",
            "var list1 [][]interface{}",
            "list1 = [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "min_product_tuple(list1)",
            "}",
            "func TestMinProductTuple_Error_Error_Error(t *testing.T) {",
            "var list1 [][]interface{}",
            "list1 = [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "min_product_tuple(list1)",
            "}",
            "func TestMinProduct",
            "func TestMin_Product_Tuple(t *testing.T) {",
            "candidate := min_product_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{2, 7}, []interface{}{2, 6}, []interface{}{1, 8}, []interface{}{4, 9}}), expected: 8 },",
            "{ actual: candidate([][]int{[]interface{}{10, 20}, []interface{}{15, 2}, []interface{}{5, 10}}), expected: 30 },",
            "{ actual: candidate([][]int{[]interface{}{11, 44}, []interface{}{10, 15}, []interface{}{20, 5}, []interface{}{12, 9}}), expected: 100 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "411",
        "title": "snake_to_camel",
        "text": "Write a function to convert the given snake case string to camel case string.",
        "code": "package snake_to_camel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc snake_to_camel(word string) string {\n    return fmt.Sprintf(\"%s_%s\", word[0], word[1:])\n}\n\n",
        "test_list": [
            "func TestSnakeToCamel(t *testing.T) {",
            "tests := []",
            "func TestSnake_To_Camel(t *testing.T) {",
            "candidate := snake_to_camel",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"android_tv\"), expected: \"AndroidTv\" },",
            "{ actual: candidate(\"google_pixel\"), expected: \"GooglePixel\" },",
            "{ actual: candidate(\"apple_watch\"), expected: \"AppleWatch\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "412",
        "title": "remove_odd",
        "text": "Write a gothon function to remove odd numbers from a given list.",
        "code": "package remove_odd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_odd(l []int) []int {\n    odd := 0\n    for i := len(l) - 1; i >= 0; i-- {\n        if l[i]%2 == 1 {\n            l[i] = l[i] - 1\n            odd++\n        }\n    }\n    return l[:odd]\n}\n\n",
        "test_list": [
            "func TestRemoveOdd(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if got := remove_odd(l); got!= []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {",
            "t.Errorf(\"remove_odd: got %v, want %v\", got, l)",
            "}",
            "}",
            "func TestRemoveOdd_Error(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if got := remove_odd(l); got!= nil {",
            "t.Errorf(\"remove_odd: got %v, want nil\", got)",
            "}",
            "}",
            "func TestRemoveOdd_Empty(t *testing.T) {",
            "l := []int{}",
            "if got := remove_odd(l); got!= nil {",
            "t.Errorf(\"remove_odd: got %v, want nil\", got)",
            "}",
            "}",
            "func TestRemoveOdd_NotFound(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if got := remove_odd(l); got!= nil {",
            "t.Errorf(\"remove_odd: got %v, want nil\", got)",
            "}",
            "}",
            "func TestRemoveOdd_NotFound_Error(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "func TestRemove_Odd(t *testing.T) {",
            "candidate := remove_odd",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: []int{2} },",
            "{ actual: candidate([]int{2, 4, 6}), expected: []int{2, 4, 6} },",
            "{ actual: candidate([]int{10, 20, 3}), expected: []int{10, 20} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "413",
        "title": "extract_nth_element",
        "text": "Write a function to extract the nth element from a given list of lists.",
        "code": "package extract_nth_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_nth_element(list1 [][]interface{}, n int) []interface{} {\n    if n == 0 {\n        return list1\n    }\n    return list1[n-1]\n}\n\n",
        "test_list": [
            "func TestExtractNthElement(t *testing.T) {",
            "list1 := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "expected := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "actual := extract_nth_element(list1, 0)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "func TestExtractNthElement_error(t *testing.T) {",
            "list1 := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "expected := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "actual := extract_nth_element(list1, 1)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "func TestExtractNthElement_error_2(t *testing.T) {",
            "list1 := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "expected := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "actual := extract_nth_element(list1, 2)",
            "func TestExtract_Nth_Element(t *testing.T) {",
            "candidate := extract_nth_element",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{\"Greyson Fulton\", 98, 99}, []interface{}{\"Brady Kent\", 97, 96}, []interface{}{\"Wyatt Knott\", 91, 94}, []interface{}{\"Beau Turnbull\", 94, 98}}, 0), expected: []string{\"Greyson Fulton\", \"Brady Kent\", \"Wyatt Knott\", \"Beau Turnbull\"} },",
            "{ actual: candidate([][]int{[]interface{}{\"Greyson Fulton\", 98, 99}, []interface{}{\"Brady Kent\", 97, 96}, []interface{}{\"Wyatt Knott\", 91, 94}, []interface{}{\"Beau Turnbull\", 94, 98}}, 2), expected: []int{99, 96, 94, 98} },",
            "{ actual: candidate([][]int{[]interface{}{\"Greyson Fulton\", 98, 99}, []interface{}{\"Brady Kent\", 97, 96}, []interface{}{\"Wyatt Knott\", 91, 94}, []interface{}{\"Beau Turnbull\", 94, 98}}, 1), expected: []int{98, 97, 91, 94} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "414",
        "title": "overlapping",
        "text": "Write a gothon function to check whether any value in a sequence exists in a sequence or not.",
        "code": "package overlapping_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc overlapping(list1 []int, list2 []int) bool {\n    for _, v := range list1 {\n        for _, v2 := range list2 {\n            if v == v2 {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestOverlapping(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!overlapping(list1, list2) {",
            "t.Errorf(\"Expected overlapping to be true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!overlapping(list1, list2) {",
            "t.Errorf(\"Expected overlapping to be true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!overlapping(list1, list2) {",
            "t.Errorf(\"Expected overlapping to be true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!overlapping(list1, list2) {",
            "t.Errorf(\"Expected overlapping to be true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 = []",
            "func TestOverlapping(t *testing.T) {",
            "candidate := overlapping",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}, []int{6, 7, 8, 9}), expected: false },",
            "{ actual: candidate([]int{1, 2, 3}, []int{4, 5, 6}), expected: false },",
            "{ actual: candidate([]int{1, 4, 5}, []int{1, 4, 5}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "415",
        "title": "max_Product",
        "text": "Write a gothon function to find a pair with highest product from a given list of integers.",
        "code": "package max_Product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_Product(arr []int) []interface{} {\n    max := make([]interface{}, len(arr))\n    for i := 0; i < len(arr); i++ {\n        max[i] = arr[i]\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxProduct(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := max_Product(arr)",
            "if len(max)!= 10 {",
            "t.Errorf(\"Expected 10, got %d\", len(max))",
            "}",
            "}",
            "func TestMaxProduct_Error(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := max_Product(arr)",
            "if len(max)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", len(max))",
            "}",
            "}",
            "func TestMaxProduct_Error_Error(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := max_Product(arr)",
            "if len(max)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", len(max))",
            "}",
            "}",
            "func TestMaxProduct_Error_Error_Error(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := max_Product(arr)",
            "if len(max)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", len(max))",
            "}",
            "}",
            "func TestMaxProduct_Error_Error_Error(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "func TestMax_Product(t *testing.T) {",
            "candidate := max_Product",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 7, 0, 8, 4}), expected: []interface{}{7, 8} },",
            "{ actual: candidate([]int{0, -1, -2, -4, 5, 0, -6}), expected: []interface{}{-4, -6} },",
            "{ actual: candidate([]int{1, 2, 3}), expected: []interface{}{2, 3} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "417",
        "title": "group_tuples",
        "text": "Write a function to find common first element in given list of lists.",
        "code": "package group_tuples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc group_tuples(Input [][]string) [][]string {\n    var output [][]string\n    for i := 0; i < len(Input); i++ {\n        for j := 0; j < len(Input[i]); j++ {\n            if Input[i][j] == Input[i][0] {\n                output = append(output, Input[i])\n            }\n        }\n    }\n    return output\n}\n\n",
        "test_list": [
            "func TestGroupTuples(t *testing.T) {",
            "var input [][]string",
            "for i := 0; i < len(input); i++ {",
            "input = append(input, group_tuples(input[i]))",
            "}",
            "if len(input)!= len(group_tuples(input)) {",
            "t.Errorf(\"len(input)!= len(group_tuples(input))\")",
            "}",
            "for i := 0; i < len(input); i++ {",
            "for j := 0; j < len(input[i]); j++ {",
            "if input[i][j]!= group_tuples(input[i])[j] {",
            "t.Errorf(\"input[i][j]!= group_tuples(input[i])[j]\")",
            "}",
            "}",
            "}",
            "}",
            "func TestGroupTuples_1(t *testing.T) {",
            "var input [][]string",
            "for i := 0; i < len(input); i++ {",
            "input = append(input, group_tuples(input[i]))",
            "}",
            "if len(input)!= len(group_tuples(input)) {",
            "t.Errorf(\"len(input)!= len(group_tuples(input))\")",
            "}",
            "for i := 0; i < len(input); i++ {",
            "for j := 0; j < len(input[i]); j++ {",
            "if input[i][j]!= group_tuples(input[i])[j] {",
            "t.Errorf(\"",
            "func TestGroup_Tuples(t *testing.T) {",
            "candidate := group_tuples",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]string{\"x\", \"y\"}, []string{\"x\", \"z\"}, []string{\"w\", \"t\"}}), expected: [][]int{[]string{\"x\", \"y\", \"z\"}, []string{\"w\", \"t\"}} },",
            "{ actual: candidate([][]int{[]string{\"a\", \"b\"}, []string{\"a\", \"c\"}, []string{\"d\", \"e\"}}), expected: [][]int{[]string{\"a\", \"b\", \"c\"}, []string{\"d\", \"e\"}} },",
            "{ actual: candidate([][]int{[]string{\"f\", \"g\"}, []string{\"f\", \"g\"}, []string{\"h\", \"i\"}}), expected: [][]int{[]string{\"f\", \"g\", \"g\"}, []string{\"h\", \"i\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "418",
        "title": "Find_Max",
        "text": "Write a gothon function to find the element of a list having maximum length.",
        "code": "package Find_Max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Find_Max(lst [][]interface{}) []interface{} {\n    max := 0\n    for _, v := range lst {\n        if v[0] > max {\n            max = v[0]\n        }\n    }\n    return lst[max:]\n}\n\n",
        "test_list": [
            "func Test_Find_Max(t *testing.T) {",
            "lst := []interface{}{",
            "[]interface{}{\"a\", \"b\", \"c\"},",
            "[]interface{}{\"d\", \"e\", \"f\"},",
            "[]interface{}{\"g\", \"h\", \"i\"},",
            "[]interface{}{\"j\", \"k\", \"l\"},",
            "[]interface{}{\"m\", \"n\", \"o\"},",
            "[]interface{}{\"p\", \"q\", \"r\"},",
            "[]interface{}{\"s\", \"t\", \"u\"},",
            "[]interface{}{\"v\", \"w\", \"x\"},",
            "[]interface{}{\"y\", \"z\", \"A\"},",
            "[]interface{}{\"A\", \"B\", \"C\"},",
            "[]interface{}{\"D\", \"E\", \"F\"},",
            "[]interface{}{\"G\", \"H\", \"I\"},",
            "[]interface{}{\"J\", \"K\", \"L\"},",
            "[]interface{}{\"M\", \"N\", \"O\"},",
            "[]interface{}{\"P\", \"Q\", \"R\"},",
            "[]interface{}{\"S\", \"T\", \"U\"},",
            "[]interface{}{\"V\", \"W\", \"X\"},",
            "[]interface{}{\"Y\", \"Z\", \"A\"},",
            "[]interface{}{\"A\", \"B\", \"C\"},",
            "[]interface{}{\"D\", \"E\", \"F\"},",
            "[]interface{}{\"G\", \"H\", \"I\"},",
            "[]interface{}{\"J\", \"K\", \"L\"},",
            "[]interface{}{\"M\", \"N\", \"O\"},",
            "[]interface{}{\"P\", \"Q\", \"R\"},",
            "[]interface{}{\"S\", \"T\", \"U\"},",
            "func TestFind_Max(t *testing.T) {",
            "candidate := Find_Max",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]string{\"A\"}, []string{\"A\", \"B\"}, []string{\"A\", \"B\", \"C\"}}), expected: []string{\"A\", \"B\", \"C\"} },",
            "{ actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1, 2, 3} },",
            "{ actual: candidate([][]int{[]int{1, 1}, []int{1, 2, 3}, []int{1, 5, 6, 1}}), expected: []int{1, 5, 6, 1} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "420",
        "title": "cube_Sum",
        "text": "Write a gothon function to find the cube sum of first n even natural numbers.",
        "code": "package cube_Sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc cube_Sum(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return cube_Sum(n - 1) + cube_Sum(n - 2) + cube_Sum(n - 3) + cube_Sum(n - 4) + cube_Sum(n - 5) + cube_Sum(n - 6) + cube_Sum(n - 7) + cube_Sum(n - 8) + cube_Sum(n - 9) + cube_Sum(n - 10) + cube_Sum(n - 11) + cube_Sum(n - 12) + cube_Sum(n - 13) + cube_Sum(n - 14) + cube_Sum(n - 15) + cube_Sum(n - 16) + cube_Sum(n - 17) + cube_Sum(n - 18) + cube_Sum(n - 19) + cube_Sum(n - 20) + cube_Sum(n - 21) + cube_Sum(n - 22) + cube_Sum(n - 23) + cube_Sum(n - 24) + cube_Sum(n - 25) + cube_Sum(n - 26) + cube_Sum(n - 27) + cube_Sum(n - 28) + cube_Sum(n - 29) + cube_Sum(n - 30) + cube_Sum(n - 31)\n    }\n\n",
        "test_list": [
            "func TestCubeSum(t *testing.T) {",
            "n := 10",
            "fmt.Println(\"n = \", n)",
            "fmt.Println(\"cube_Sum(n) = \", cube_Sum(n))",
            "}",
            "<|endoftext|>",
            "func TestCube_Sum(t *testing.T) {",
            "candidate := cube_Sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 72 },",
            "{ actual: candidate(3), expected: 288 },",
            "{ actual: candidate(4), expected: 800 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "421",
        "title": "concatenate_tuple",
        "text": "Write a function to concatenate each element of list by the delimiter.",
        "code": "package concatenate_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc concatenate_tuple(test_tup []interface{}) string {\n    var result string\n    for _, t := range test_tup {\n        result += fmt.Sprintf(\"%v\", t)\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestConcatenateTuple(t *testing.T) {",
            "test_tup := []interface{}{",
            "\"a\",",
            "\"b\",",
            "\"c\",",
            "\"d\",",
            "\"e\",",
            "\"f\",",
            "\"g\",",
            "\"h\",",
            "\"i\",",
            "\"j\",",
            "\"k\",",
            "\"l\",",
            "\"m\",",
            "\"n\",",
            "\"o\",",
            "\"p\",",
            "\"q\",",
            "\"r\",",
            "\"s\",",
            "\"t\",",
            "\"u\",",
            "\"v\",",
            "\"w\",",
            "\"x\",",
            "\"y\",",
            "\"z\",",
            "\"A\",",
            "\"B\",",
            "\"C\",",
            "\"D\",",
            "\"E\",",
            "\"F\",",
            "\"G\",",
            "\"H\",",
            "\"I\",",
            "\"J\",",
            "\"K\",",
            "\"L\",",
            "\"M\",",
            "\"N\",",
            "\"O\",",
            "\"P\",",
            "\"Q\",",
            "\"R\",",
            "\"S\",",
            "\"T\",",
            "\"U\",",
            "\"V\",",
            "\"W\",",
            "\"X\",",
            "\"Y\",",
            "\"Z\",",
            "\"a\",",
            "\"b\",",
            "\"c\",",
            "\"d\",",
            "\"e\",",
            "\"f\",",
            "\"g\",",
            "\"h\",",
            "\"i\",",
            "\"j\",",
            "\"k\",",
            "\"l\",",
            "\"m\",",
            "\"n\",",
            "\"o\",",
            "\"p\",",
            "\"q\",",
            "\"r\",",
            "\"s\",",
            "\"t\",",
            "\"u\",",
            "\"v\",",
            "\"w\",",
            "\"",
            "func TestConcatenate_Tuple(t *testing.T) {",
            "candidate := concatenate_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{\"ID\", \"is\", 4, \"UTS\"}), expected: \"ID-is-4-UTS\" },",
            "{ actual: candidate([]interface{}{\"QWE\", \"is\", 4, \"RTY\"}), expected: \"QWE-is-4-RTY\" },",
            "{ actual: candidate([]interface{}{\"ZEN\", \"is\", 4, \"OP\"}), expected: \"ZEN-is-4-OP\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "422",
        "title": "find_Average_Of_Cube",
        "text": "Write a gothon function to find the average of cubes of first n natural numbers.",
        "code": "package find_Average_Of_Cube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Average_Of_Cube(n int) float64 {\n    var sum float64\n    for i := 0; i < n; i++ {\n        sum += find_Average_Of_Cube_test(i)\n    }\n    return sum / n\n}\n\n",
        "test_list": [
            "func Test_find_Average_Of_Cube(t *testing.T) {",
            "var n int",
            "fmt.Scanln(&n)",
            "if n < 1 {",
            "t.Errorf(\"n must be greater than 1\")",
            "}",
            "if n > 100 {",
            "t.Errorf(\"n must be less than 100\")",
            "}",
            "if find_Average_Of_Cube(n)!= find_Average_Of_Cube_test(n) {",
            "t.Errorf(\"find_Average_Of_Cube(n) = %f, want %f\", find_Average_Of_Cube(n), find_Average_Of_Cube_test(n))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestFind_Average_Of_Cube(t *testing.T) {",
            "candidate := find_Average_Of_Cube",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 4.5 },",
            "{ actual: candidate(3), expected: 12 },",
            "{ actual: candidate(1), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "424",
        "title": "extract_rear",
        "text": "Write a function to extract only the rear index element of each string in the given list.",
        "code": "package extract_rear_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_rear(test_tuple []interface{}) []string {\n    var result []string\n    for _, item := range test_tuple {\n        result = append(result, fmt.Sprintf(\"%v\", item))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestExtract_rear(t *testing.T) {",
            "test_tuple := []interface{}{",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "\"world\",",
            "\"hello\",",
            "func TestExtract_Rear(t *testing.T) {",
            "candidate := extract_rear",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{\"Mers\", \"for\", \"Vers\"}), expected: []string{\"s\", \"r\", \"s\"} },",
            "{ actual: candidate([]interface{}{\"Avenge\", \"for\", \"People\"}), expected: []string{\"e\", \"r\", \"e\"} },",
            "{ actual: candidate([]interface{}{\"Gotta\", \"get\", \"go\"}), expected: []string{\"a\", \"t\", \"o\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "425",
        "title": "count_element_in_list",
        "text": "Write a function to count the number of sublists containing a particular element.",
        "code": "package count_element_in_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_element_in_list(list1 [][]interface{}, x interface{}) int {\n    var count int\n    for _, x1 := range list1 {\n        for _, x2 := range x1 {\n            if x2 == x {\n                count++\n            }\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountElementInList(t *testing.T) {",
            "list1 := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "expected := 3",
            "actual := count_element_in_list(list1, 1)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %d, got %d\", expected, actual)",
            "}",
            "}",
            "func TestCountElementInList_Error(t *testing.T) {",
            "list1 := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "expected := 0",
            "actual := count_element_in_list(list1, 1)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %d, got %d\", expected, actual)",
            "}",
            "}",
            "func TestCountElementInList_Error_Error(t *testing.T) {",
            "list1 := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "expected := 0",
            "actual := count_element_in_list(list1, 1)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %d, got %d\", expected, actual)",
            "}",
            "}",
            "func TestCountElementInList_Error_Error(t *testing.T) {",
            "func TestCount_Element_In_List(t *testing.T) {",
            "candidate := count_element_in_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 3}, []int{5, 7}, []int{1, 11}, []int{1, 15, 7}}, 1), expected: 3 },",
            "{ actual: candidate([][]int{[]string{\"A\", \"B\"}, []string{\"A\", \"C\"}, []string{\"A\", \"D\", \"E\"}, []string{\"B\", \"C\", \"D\"}}, \"A\"), expected: 3 },",
            "{ actual: candidate([][]int{[]string{\"A\", \"B\"}, []string{\"A\", \"C\"}, []string{\"A\", \"D\", \"E\"}, []string{\"B\", \"C\", \"D\"}}, \"E\"), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "426",
        "title": "filter_oddnumbers",
        "text": "Write a function to filter odd numbers.",
        "code": "package filter_oddnumbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc filter_oddnumbers(nums []int) []int {\n    oddnumbers := make([]int, len(nums))\n    for i := range oddnumbers {\n        oddnumbers[i] = nums[i] % 2\n    }\n    return oddnumbers\n}\n\n",
        "test_list": [
            "func TestFilterOddNumbers(t *testing.T) {",
            "oddnumbers := filter_oddnumbers([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})",
            "if oddnumbers[0]!= 1 {",
            "t.Errorf(\"oddnumbers[0] = %d, want 1\", oddnumbers[0])",
            "}",
            "if oddnumbers[1]!= 2 {",
            "t.Errorf(\"oddnumbers[1] = %d, want 2\", oddnumbers[1])",
            "}",
            "if oddnumbers[2]!= 3 {",
            "t.Errorf(\"oddnumbers[2] = %d, want 3\", oddnumbers[2])",
            "}",
            "if oddnumbers[3]!= 4 {",
            "t.Errorf(\"oddnumbers[3] = %d, want 4\", oddnumbers[3])",
            "}",
            "if oddnumbers[4]!= 5 {",
            "t.Errorf(\"oddnumbers[4] = %d, want 5\", oddnumbers[4])",
            "}",
            "if oddnumbers[5]!= 6 {",
            "t.Errorf(\"oddnumbers[5] = %d, want 6\", oddnumbers[5])",
            "}",
            "if oddnumbers[6]!= 7 {",
            "t.Errorf(\"oddnumbers[6] = %d, want 7\", oddnumbers[6])",
            "}",
            "if oddnumbers[7]!= 8 {",
            "t.Errorf(\"oddnumbers[7] = %d, want 8\", oddnumbers[7])",
            "}",
            "if oddnumbers[8]!= 9 {",
            "t.Errorf(\"oddnumbers[8] = %d",
            "func TestFilter_Oddnumbers(t *testing.T) {",
            "candidate := filter_oddnumbers",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), expected: []int{1, 3, 5, 7, 9} },",
            "{ actual: candidate([]int{10, 20, 45, 67, 84, 93}), expected: []int{45, 67, 93} },",
            "{ actual: candidate([]int{5, 7, 9, 8, 6, 4, 3}), expected: []int{5, 7, 9, 3} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "427",
        "title": "change_date_format",
        "text": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.",
        "code": "package change_date_format_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc change_date_format(dt string) string {\n    return fmt.Sprintf(\"%s-%s-%s\", dt[:4], dt[4:6], dt[6:8])\n}\n\n",
        "test_list": [
            "func TestChangeDateFormat(t *testing.T) {",
            "dt := change_date_format(\"2015-01-01\")",
            "if dt!= \"2015-01-01\" {",
            "t.Errorf(\"Expected %s, got %s\", \"2015-01-01\", dt)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestChange_Date_Format(t *testing.T) {",
            "candidate := change_date_format",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"2026-01-02\"), expected: \"02-01-2026\" },",
            "{ actual: candidate(\"2020-11-13\"), expected: \"13-11-2020\" },",
            "{ actual: candidate(\"2021-04-26\"), expected: \"26-04-2021\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "428",
        "title": "shell_sort",
        "text": "Test the sort function.",
        "code": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc shell_sort(my_list []int) []int {\n    new_list := make([]int, len(my_list))\n    for i := 0; i < len(my_list); i++ {\n        new_list[i] = my_list[i]\n    }\n    for i := 0; i < len(new_list); i++ {\n        for j := i + 1; j < len(new_list); j++ {\n            if new_list[j] < new_list[i] {\n                new_list[i], new_list[j] = new_list[j], new_list[i]\n            }\n        }\n    }\n    return new_list\n}\n\n",
        "test_list": [
            "func Test_shell_sort(t *testing.T) {",
            "my_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sort_list := shell_sort(my_list)",
            "if sort_list[0]!= 5 {",
            "t.Errorf(\"Expected 5, got %d\", sort_list[0])",
            "}",
            "if sort_list[1]!= 4 {",
            "t.Errorf(\"Expected 4, got %d\", sort_list[1])",
            "}",
            "if sort_list[2]!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", sort_list[2])",
            "}",
            "if sort_list[3]!= 2 {",
            "t.Errorf(\"Expected 2, got %d\", sort_list[3])",
            "}",
            "if sort_list[4]!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", sort_list[4])",
            "}",
            "}",
            "func Test",
            "func TestShell_Sort(t *testing.T) {",
            "candidate := shell_sort",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },",
            "{ actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },",
            "{ actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "429",
        "title": "and_tuples",
        "text": "Write a function to extract the elementwise and lists from the given two lists.",
        "code": "package and_tuples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc and_tuples(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    var test_tup1_list []interface{}\n    var test_tup2_list []interface{}\n\n    for i := 0; i < len(test_tup1); i++ {\n        test_tup1_list = append(test_tup1_list, test_tup1[i])\n    }\n\n    for i := 0; i < len(test_tup2); i++ {\n        test_tup2_list = append(test_tup2_list, test_tup2[i])\n    }\n\n    return and_tuples_list(test_tup1_list, test_tup2_list)\n}\n\nfunc and_tuples_list(test_tup1_list []interface{}, test_tup2_list []interface{}) []interface{} {\n    var test_tup1_list_list []interface{}\n    var test_tup2_list_list []interface{}\n\n    for i := 0; i < len(test_tup1_list); i++ {\n        test_tup1_list_list = append(test_tup1_list_list, test_tup1_list[i])\n    }\n\n    for i := 0; i < len(test_tup2_list); i++ {\n        test_tup2_list_list = append(test_tup2_list_list, test_tup2_list[i])\n    }\n\n    return and_tuples_list_list(test_tup1_list_list, test_tup2_list_list)\n}\n\nfunc and_tuples_list_list(test_tup1_list []interface{}, test_tup2_list []interface{}) []interface{} {\n    var test_tup1_list_list_list []interface{}\n    var\n",
        "test_list": [
            "func TestAnd_Tuples(t *testing.T) {",
            "candidate := and_tuples",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{10, 4, 6, 9}, []interface{}{5, 2, 3, 3}), expected: []interface{}{0, 0, 2, 1} },",
            "{ actual: candidate([]interface{}{1, 2, 3, 4}, []interface{}{5, 6, 7, 8}), expected: []interface{}{1, 2, 3, 0} },",
            "{ actual: candidate([]interface{}{8, 9, 11, 12}, []interface{}{7, 13, 14, 17}), expected: []interface{}{0, 9, 10, 0} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "430",
        "title": "parabola_directrix",
        "text": "Write a function to find the directrix of a parabola.",
        "code": "package parabola_directrix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc parabola_directrix(a int, b int, c int) int {\n    return a * b * c\n}\n\n",
        "test_list": [
            "func TestParabolaDirectrix(t *testing.T) {",
            "fmt.Println(\"Testing parabola_directrix\")",
            "for i := 0; i < 10; i++ {",
            "fmt.Println(\"Testing parabola_directrix\", i)",
            "a := i",
            "b := i",
            "c := i",
            "fmt.Println(\"a:\", a)",
            "fmt.Println(\"b:\", b)",
            "fmt.Println(\"c:\", c)",
            "fmt.Println(\"parabola_directrix\", parabola_directrix(a, b, c))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestParabola_Directrix(t *testing.T) {",
            "candidate := parabola_directrix",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5, 3, 2), expected: -198 },",
            "{ actual: candidate(9, 8, 4), expected: -2336 },",
            "{ actual: candidate(2, 4, 6), expected: -130 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "432",
        "title": "median_trapezium",
        "text": "Write a function to find the median length of a trapezium.",
        "code": "package median_trapezium_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc median_trapezium(base1 int, base2 int, height int) float64 {\n    if height == 0 {\n        return 0\n    }\n    if height == 1 {\n        return base1\n    }\n    if height == 2 {\n        return base2\n    }\n    return 0\n}\n\n",
        "test_list": [
            "func TestMedianTrapezium(t *testing.T) {",
            "var testCases = []",
            "func TestMedian_Trapezium(t *testing.T) {",
            "candidate := median_trapezium",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(15, 25, 35), expected: 20 },",
            "{ actual: candidate(10, 20, 30), expected: 15 },",
            "{ actual: candidate(6, 9, 4), expected: 7.5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "433",
        "title": "check_greater",
        "text": "Write a function to check whether the entered number is greater than the elements of the given list.",
        "code": "package check_greater_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_greater(arr []int, number int) bool {\n    if len(arr) == 0 {\n        return false\n    }\n    if len(arr) == 1 {\n        return arr[0] > number\n    }\n    return check_greater(arr[1:], number)\n}\n\n",
        "test_list": [
            "func TestCheckGreater(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_greater(arr, 10) {",
            "t.Errorf(\"Expected %v to be greater than %v\", arr, 10)",
            "}",
            "}",
            "func TestCheckGreater_2(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_greater(arr, 2) {",
            "t.Errorf(\"Expected %v to be greater than %v\", arr, 2)",
            "}",
            "}",
            "func TestCheckGreater_3(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_greater(arr, 3) {",
            "t.Errorf(\"Expected %v to be greater than %v\", arr, 3)",
            "}",
            "}",
            "func TestCheckGreater_4(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_greater(arr, 4) {",
            "t.Errorf(\"Expected %v to be greater than %v\", arr, 4)",
            "}",
            "}",
            "func TestCheckGreater_5(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_greater(arr, 5",
            "func TestCheck_Greater(t *testing.T) {",
            "candidate := check_greater",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}, 4), expected: false },",
            "{ actual: candidate([]int{2, 3, 4, 5, 6}, 8), expected: true },",
            "{ actual: candidate([]int{9, 7, 4, 8, 6, 1}, 11), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "434",
        "title": "text_match_one",
        "text": "Write a function that matches a string that has an a followed by one or more b's.",
        "code": "package text_match_one_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_match_one(text string) bool {\n    return text == \"a\" || text == \"b\"\n}\n\n",
        "test_list": [
            "func TestTextMatchOne(t *testing.T) {",
            "if!text_match_one(\"a\") {",
            "t.Errorf(\"Expected text match one to match a\")",
            "}",
            "if!text_match_one(\"b\") {",
            "t.Errorf(\"Expected text match one to match b\")",
            "}",
            "if!text_match_one(\"a\") {",
            "t.Errorf(\"Expected text match one to match a\")",
            "}",
            "if!text_match_one(\"b\") {",
            "t.Errorf(\"Expected text match one to match b\")",
            "}",
            "}",
            "func TestTextMatchOne_Error(t *testing.T) {",
            "if!text_match_one(\"a\") {",
            "t.Errorf(\"Expected text match one to match a\")",
            "}",
            "if!text_match_one(\"b\") {",
            "t.Errorf(\"Expected text match one to match b\")",
            "}",
            "if!text_match_one(\"a\") {",
            "t.Errorf(\"Expected text match one to match a\")",
            "}",
            "if!text_match_one(\"b\") {",
            "t.Errorf(\"Expected text match one to match b\")",
            "}",
            "}",
            "func TestTextMatchOne_Error_Error(t *testing.T) {",
            "if!text_match_one(\"a\") {",
            "t.Errorf(\"Expected text match one to match a\")",
            "}",
            "if!text_match_one(\"b\") {",
            "t.Errorf(\"Expected text match one to match b\")",
            "}",
            "if!text_match_one(\"a\") {",
            "t.Errorf(\"Expected text match one to match a\")",
            "}",
            "if!text_match_one(\"b\") {",
            "t.Errorf(\"Expected text match one to match b\")",
            "func TestText_Match_One(t *testing.T) {",
            "candidate := text_match_one",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"ac\"), expected: false },",
            "{ actual: candidate(\"dc\"), expected: false },",
            "{ actual: candidate(\"abba\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "435",
        "title": "last_Digit",
        "text": "Write a gothon function to find the last digit of a given number.",
        "code": "package last_Digit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc last_Digit(n int) int {\n    return n - 1\n}\n\n",
        "test_list": [
            "func Test_last_Digit(t *testing.T) {",
            "var n int",
            "n = last_Digit(10)",
            "fmt.Println(n)",
            "}",
            "<|endoftext|>",
            "func TestLast_Digit(t *testing.T) {",
            "candidate := last_Digit",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(123), expected: 3 },",
            "{ actual: candidate(25), expected: 5 },",
            "{ actual: candidate(30), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "436",
        "title": "neg_nos",
        "text": "Write a gothon function to return the negative numbers in a list.",
        "code": "package neg_nos_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc neg_nos(list1 []int) []int {\n    var list2 []int\n    for _, v := range list1 {\n        list2 = append(list2, v)\n    }\n    return list2\n}\n\n",
        "test_list": [
            "func TestNeg_nos(t *testing.T) {",
            "list1 := neg_nos([]int{1, 2, 3, 4, 5, 6, 7, 8, 9})",
            "fmt.Println(list1)",
            "}",
            "<|endoftext|>",
            "func TestNeg_Nos(t *testing.T) {",
            "candidate := neg_nos",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{-1, 4, 5, -6}), expected: []int{-1, -6} },",
            "{ actual: candidate([]int{-1, -2, 3, 4}), expected: []int{-1, -2} },",
            "{ actual: candidate([]int{-7, -6, 8, 9}), expected: []int{-7, -6} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "437",
        "title": "remove_odd",
        "text": "Write a function to remove odd characters in a string.",
        "code": "package remove_odd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_odd(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'o' {\n            str2 = str1[i:]\n            break\n        }\n    }\n    return str2\n}\n\n",
        "test_list": [
            "func TestRemoveOdd(t *testing.T) {",
            "str1 := \"hello world\"",
            "str2 := remove_odd(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"Expected %v, got %v\", str1, str2)",
            "}",
            "}",
            "func TestRemoveOdd_Error(t *testing.T) {",
            "str1 := \"hello world\"",
            "str2 := remove_odd(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"Expected %v, got %v\", str1, str2)",
            "}",
            "}",
            "func TestRemoveOdd_Error_Error(t *testing.T) {",
            "str1 := \"hello world\"",
            "str2 := remove_odd(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"Expected %v, got %v\", str1, str2)",
            "}",
            "}",
            "func TestRemoveOdd_Error_Error_Error(t *testing.T) {",
            "str1 := \"hello world\"",
            "str2 := remove_odd(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"Expected %v, got %v\", str1, str2)",
            "}",
            "}",
            "func TestRemoveOdd_Error_Error_Error(t *testing.T) {",
            "str1 := \"hello world\"",
            "str2 := remove_odd(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"Expected %v, got %v\", str1, str2)",
            "}",
            "}",
            "func TestRemoveOdd_Error_Error_Error(t *testing.T) {",
            "func TestRemove_Odd(t *testing.T) {",
            "candidate := remove_odd",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python\"), expected: \"yhn\" },",
            "{ actual: candidate(\"program\"), expected: \"rga\" },",
            "{ actual: candidate(\"language\"), expected: \"agae\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "438",
        "title": "count_bidirectional",
        "text": "Write a function to count bidirectional list pairs.",
        "code": "package count_bidirectional_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_bidirectional(test_list [][]interface{}) int {\n    var count int\n    for _, pair := range test_list {\n        count += count_bidirectional(pair)\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountBidirectional(t *testing.T) {",
            "test_list := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "count := count_bidirectional(test_list)",
            "fmt.Println(count)",
            "}",
            "<|endoftext|>",
            "func TestCount_Bidirectional(t *testing.T) {",
            "candidate := count_bidirectional",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 2}, []interface{}{6, 5}, []interface{}{9, 1}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 3 },",
            "{ actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 3}, []interface{}{6, 5}, []interface{}{9, 1}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 2 },",
            "{ actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 2}, []interface{}{6, 5}, []interface{}{9, 2}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "439",
        "title": "multiple_to_single",
        "text": "Write a function to join a list of multiple integers into a single integer.",
        "code": "package multiple_to_single_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc multiple_to_single(L []int) int {\n    var result int\n    for _, v := range L {\n        result += v\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestMultipleToSingle(t *testing.T) {",
            "L := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := multiple_to_single(L)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestMultiple_To_Single(t *testing.T) {",
            "candidate := multiple_to_single",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{11, 33, 50}), expected: 113350 },",
            "{ actual: candidate([]int{-1, 2, 3, 4, 5, 6}), expected: -123456 },",
            "{ actual: candidate([]int{10, 15, 20, 25}), expected: 10152025 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "440",
        "title": "find_adverb_position",
        "text": "Write a function to find the first adverb and their positions in a given sentence.",
        "code": "package find_adverb_position_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_adverb_position(text string) []interface{} {\n    var sentence []interface{}\n    for _, word := range strings.Split(text, \" \") {\n        if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append(sentence, \"and\")\n        } else if word == \"and\" {\n            sentence = append\n",
        "test_list": [
            "func TestFind_Adverb_Position(t *testing.T) {",
            "candidate := find_adverb_position",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"clearly!! we can see the sky\"), expected: []interface{}{0, 7, \"clearly\"} },",
            "{ actual: candidate(\"seriously!! there are many roses\"), expected: []interface{}{0, 9, \"seriously\"} },",
            "{ actual: candidate(\"unfortunately!! sita is going to home\"), expected: []interface{}{0, 13, \"unfortunately\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "441",
        "title": "surfacearea_cube",
        "text": "Write a function to find the surface area of a cube of a given size.",
        "code": "package surfacearea_cube_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc surfacearea_cube(l int) int {\n    return l * l * l * l\n}\n\n",
        "test_list": [
            "func TestSurfaceArea(t *testing.T) {",
            "var testCases = []",
            "func TestSurfacearea_Cube(t *testing.T) {",
            "candidate := surfacearea_cube",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: 150 },",
            "{ actual: candidate(3), expected: 54 },",
            "{ actual: candidate(10), expected: 600 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "442",
        "title": "positive_count",
        "text": "Write a function to find the ration of positive numbers in a list of integers.",
        "code": "package positive_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc positive_count(nums []int) float64 {\n    var total float64 = 0\n    for _, num := range nums {\n        total += num\n    }\n    return total / float64(len(nums))\n}\n\n",
        "test_list": [
            "func TestPositiveCount(t *testing.T) {",
            "var nums []int",
            "nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "fmt.Println(positive_count(nums))",
            "}",
            "<|endoftext|>",
            "func TestPositive_Count(t *testing.T) {",
            "candidate := positive_count",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8}), expected: 0.54 },",
            "{ actual: candidate([]int{2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8}), expected: 0.69 },",
            "{ actual: candidate([]int{2, 4, -6, -9, 11, -12, 14, -5, 17}), expected: 0.56 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "443",
        "title": "largest_neg",
        "text": "Write a gothon function to find the largest negative number from the given list.",
        "code": "package largest_neg_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc largest_neg(list1 []int) int {\n    if len(list1) == 0 {\n        return 0\n    }\n    if len(list1) == 1 {\n        return list1[0]\n    }\n    return largest_neg(list1[1:])\n}\n\n",
        "test_list": [
            "func TestLargestNegative(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "list1 := []int{1, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, -82, -83, -84, -85, -86, -87, -88, -89, -90, -91, -92, -93, -94, -95, -96, -97, -98, -99, -100, -101, -102, -103, -104, -105, -106, -107, -108, -109, -110, -111, -112, -113, -114, -115, -116, -117",
            "func TestLargest_Neg(t *testing.T) {",
            "candidate := largest_neg",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, -4, -6}), expected: -6 },",
            "{ actual: candidate([]int{1, 2, 3, -8, -9}), expected: -9 },",
            "{ actual: candidate([]int{1, 2, 3, 4, -1}), expected: -1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "444",
        "title": "trim_tuple",
        "text": "Write a function to trim each list by k in the given lists.",
        "code": "package trim_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc trim_tuple(test_list [][]int, K int) [][]int {\n    var result [][]int\n    for _, test := range test_list {\n        result = append(result, trim_tuple(test, K))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestTrimTuple(t *testing.T) {",
            "test_list := [][]int{",
            "[]int{1, 2, 3},",
            "[]int{4, 5, 6},",
            "[]int{7, 8, 9},",
            "}",
            "expected_result := [][]int{",
            "[]int{1, 2, 3},",
            "[]int{4, 5, 6},",
            "[]int{7, 8, 9},",
            "}",
            "result := trim_tuple(test_list, 3)",
            "if!reflect.DeepEqual(result, expected_result) {",
            "t.Errorf(\"Expected %v, got %v\", expected_result, result)",
            "}",
            "}",
            "func TestTrimTuple_empty(t *testing.T) {",
            "test_list := [][]int{}",
            "expected_result := [][]int{}",
            "result := trim_tuple(test_list, 3)",
            "if!reflect.DeepEqual(result, expected_result) {",
            "t.Errorf(\"Expected %v, got %v\", expected_result, result)",
            "}",
            "}",
            "func TestTrimTuple_k_zero(t *testing.T) {",
            "test_list := [][]int{",
            "[]int{1, 2, 3},",
            "[]int{4, 5, 6},",
            "[]int{7, 8, 9},",
            "}",
            "expected_result := [][]int{",
            "[]int{1, 2, 3},",
            "[]int{4, 5, 6},",
            "[]int{7, 8, 9},",
            "}",
            "result := trim_tuple(test_list, 0)",
            "if",
            "func TestTrim_Tuple(t *testing.T) {",
            "candidate := trim_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{5, 3, 2, 1, 4}, []int{3, 4, 9, 2, 1}, []int{9, 1, 2, 3, 5}, []int{4, 8, 2, 1, 7}}, 2), expected: [][]int{[]int{2}, []int{9}, []int{2}, []int{2}} },",
            "{ actual: candidate([][]int{[]int{5, 3, 2, 1, 4}, []int{3, 4, 9, 2, 1}, []int{9, 1, 2, 3, 5}, []int{4, 8, 2, 1, 7}}, 1), expected: [][]int{[]int{3, 2, 1}, []int{4, 9, 2}, []int{1, 2, 3}, []int{8, 2, 1}} },",
            "{ actual: candidate([][]int{[]int{7, 8, 4, 9}, []int{11, 8, 12, 4}, []int{4, 1, 7, 8}, []int{3, 6, 9, 7}}, 1), expected: [][]int{[]int{8, 4}, []int{8, 12}, []int{1, 7}, []int{6, 9}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "445",
        "title": "index_multiplication",
        "text": "Write a function to perform index wise multiplication of list elements in the given two lists.",
        "code": "package index_multiplication_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc index_multiplication(test_tup1 [][]int, test_tup2 [][]int) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup1); i++ {\n        for j := 0; j < len(test_tup2); j++ {\n            result = append(result, [][]int{test_tup1[i], test_tup2[j]})\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestIndexMultiplication(t *testing.T) {",
            "test_tup1 := [][]int{",
            "[]int{1, 2, 3, 4, 5},",
            "[]int{6, 7, 8, 9, 10},",
            "[]int{11, 12, 13, 14, 15},",
            "}",
            "test_tup2 := [][]int{",
            "[]int{16, 17, 18, 19, 20},",
            "[]int{21, 22, 23, 24, 25},",
            "[]int{26, 27, 28, 29, 30},",
            "}",
            "result := index_multiplication(test_tup1, test_tup2)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestIndex_Multiplication(t *testing.T) {",
            "candidate := index_multiplication",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 3}, []int{4, 5}, []int{2, 9}, []int{1, 10}}, [][]int{[]int{6, 7}, []int{3, 9}, []int{1, 1}, []int{7, 3}}), expected: [][]int{[]int{6, 21}, []int{12, 45}, []int{2, 9}, []int{7, 30}} },",
            "{ actual: candidate([][]int{[]int{2, 4}, []int{5, 6}, []int{3, 10}, []int{2, 11}}, [][]int{[]int{7, 8}, []int{4, 10}, []int{2, 2}, []int{8, 4}}), expected: [][]int{[]int{14, 32}, []int{20, 60}, []int{6, 20}, []int{16, 44}} },",
            "{ actual: candidate([][]int{[]int{3, 5}, []int{6, 7}, []int{4, 11}, []int{3, 12}}, [][]int{[]int{8, 9}, []int{5, 11}, []int{3, 3}, []int{9, 5}}), expected: [][]int{[]int{24, 45}, []int{30, 77}, []int{12, 33}, []int{27, 60}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "446",
        "title": "count_Occurrence",
        "text": "Write a gothon function to count the occurence of all elements of list in a list.",
        "code": "package count_Occurrence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_Occurrence(tup interface{}, lst []interface{}) int {\n    var count int\n    for _, v := range lst {\n        count += count_Occurrence(v, tup)\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountOccurrence(t *testing.T) {",
            "var lst []interface{}",
            "lst = append(lst, \"a\", \"b\", \"c\")",
            "lst = append(lst, \"d\", \"e\", \"f\")",
            "lst = append(lst, \"g\", \"h\", \"i\")",
            "lst = append(lst, \"j\", \"k\", \"l\")",
            "lst = append(lst, \"m\", \"n\", \"o\")",
            "lst = append(lst, \"p\", \"q\", \"r\")",
            "lst = append(lst, \"s\", \"t\", \"u\")",
            "lst = append(lst, \"v\", \"w\", \"x\")",
            "lst = append(lst, \"y\", \"z\", \"a\")",
            "lst = append(lst, \"a\", \"b\", \"c\")",
            "lst = append(lst, \"d\", \"e\", \"f\")",
            "lst = append(lst, \"g\", \"h\", \"i\")",
            "lst = append(lst, \"j\", \"k\", \"l\")",
            "lst = append(lst, \"m\", \"n\", \"o\")",
            "lst = append(lst, \"p\", \"q\", \"r\")",
            "lst = append(lst, \"s\", \"t\", \"u\")",
            "lst = append(lst, \"v\", \"w\", \"x\")",
            "lst = append(lst, \"y\", \"z\", \"a\")",
            "lst = append(lst, \"a\", \"b\", \"c\")",
            "lst = append(lst, \"d\", \"e\", \"f\")",
            "func TestCount_Occurrence(t *testing.T) {",
            "candidate := count_Occurrence",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{\"a\", \"a\", \"c\", \"b\", \"d\"}, []string{\"a\", \"b\"}), expected: 3 },",
            "{ actual: candidate([]interface{}{1, 2, 3, 1, 4, 6, 7, 1, 4}, []int{1, 4, 7}), expected: 6 },",
            "{ actual: candidate([]interface{}{1, 2, 3, 4, 5, 6}, []int{1, 2}), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "447",
        "title": "cube_nums",
        "text": "Write a function to find cubes of individual elements in a list.",
        "code": "package cube_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc cube_nums(nums []int) []int {\n    var result []int\n    for _, num := range nums {\n        result = append(result, num)\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestCubeNums(t *testing.T) {",
            "var nums []int",
            "nums = cube_nums([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})",
            "fmt.Println(nums)",
            "}",
            "<|endoftext|>",
            "func TestCube_Nums(t *testing.T) {",
            "candidate := cube_nums",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), expected: []int{1, 8, 27, 64, 125, 216, 343, 512, 729, 1000} },",
            "{ actual: candidate([]int{10, 20, 30}), expected: []int{1000, 8000, 27000} },",
            "{ actual: candidate([]int{12, 15}), expected: []int{1728, 3375} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "448",
        "title": "cal_sum",
        "text": "Write a function to calculate the sum of perrin numbers.",
        "code": "package cal_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc cal_sum(n int) int {\n    return n + n\n}\n\n",
        "test_list": [
            "func TestCalculate(t *testing.T) {",
            "n := 10",
            "sum := cal_sum(n)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestCal_Sum(t *testing.T) {",
            "candidate := cal_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(9), expected: 49 },",
            "{ actual: candidate(10), expected: 66 },",
            "{ actual: candidate(11), expected: 88 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "450",
        "title": "extract_string",
        "text": "Write a function to extract specified size of strings from a given list of string values.",
        "code": "package extract_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_string(str []string, l int) []string {\n    var out []string\n    for _, s := range str {\n        out = append(out, s)\n    }\n    return out\n}\n\n",
        "test_list": [
            "func TestExtractString(t *testing.T) {",
            "var strs = extract_string([]string{\"a\", \"b\", \"c\"}, 3)",
            "fmt.Println(strs)",
            "}",
            "<|endoftext|>",
            "func TestExtract_String(t *testing.T) {",
            "candidate := extract_string",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"}, 8), expected: []string{\"practice\", \"solution\"} },",
            "{ actual: candidate([]string{\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"}, 6), expected: []string{\"Python\"} },",
            "{ actual: candidate([]string{\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"}, 9), expected: []string{\"exercises\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "451",
        "title": "remove_whitespaces",
        "text": "Write a function to remove all whitespaces from the given string.",
        "code": "package remove_whitespaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_whitespaces(text1 string) string {\n    return text1\n}\n\n",
        "test_list": [
            "func TestRemoveWhitespaces(t *testing.T) {",
            "text1 := \"Hello, world!\"",
            "text2 := \"Hello, world!\"",
            "text3 := \"Hello, world!\"",
            "text4 := \"Hello, world!\"",
            "text5 := \"Hello, world!\"",
            "text6 := \"Hello, world!\"",
            "text7 := \"Hello, world!\"",
            "text8 := \"Hello, world!\"",
            "text9 := \"Hello, world!\"",
            "text10 := \"Hello, world!\"",
            "text11 := \"Hello, world!\"",
            "text12 := \"Hello, world!\"",
            "text13 := \"Hello, world!\"",
            "text14 := \"Hello, world!\"",
            "text15 := \"Hello, world!\"",
            "text16 := \"Hello, world!\"",
            "text17 := \"Hello, world!\"",
            "text18 := \"Hello, world!\"",
            "text19 := \"Hello, world!\"",
            "text20 := \"Hello, world!\"",
            "text21 := \"Hello, world!\"",
            "text22 := \"Hello, world!\"",
            "text23 := \"Hello, world!\"",
            "text24 := \"Hello, world!\"",
            "text25 := \"Hello, world!\"",
            "text26 := \"Hello, world!\"",
            "text27 := \"Hello, world!\"",
            "text28 := \"Hello, world!\"",
            "text29 := \"Hello, world!\"",
            "text30 := \"Hello, world!\"",
            "text31 := \"Hello, world!\"",
            "text32 := \"Hello, world!\"",
            "text33 := \"Hello, world!\"",
            "text34 := \"Hello, world!\"",
            "text35 := \"Hello, world!\"",
            "text36 := \"Hello, world!\"",
            "text37 := \"Hello, world!\"",
            "text38 := \"Hello, world!\"",
            "text39 := \"Hello, world!\"",
            "text40 := \"Hello, world!\"",
            "text41 := \"Hello, world!\"",
            "text42 := \"Hello, world!\"",
            "text43 := \"Hello, world!\"",
            "text44",
            "func TestRemove_Whitespaces(t *testing.T) {",
            "candidate := remove_whitespaces",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\" Google    Flutter \"), expected: \"GoogleFlutter\" },",
            "{ actual: candidate(\" Google    Dart \"), expected: \"GoogleDart\" },",
            "{ actual: candidate(\" iOS    Swift \"), expected: \"iOSSwift\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "452",
        "title": "loss_amount",
        "text": "Write a function that gives loss amount on a sale if the given amount has loss else return 0.",
        "code": "package loss_amount_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc loss_amount(actual_cost int, sale_amount int) int {\n    return actual_cost - sale_amount\n}\n\n",
        "test_list": [
            "func Test_loss_amount(t *testing.T) {",
            "var actual_cost int",
            "var sale_amount int",
            "actual_cost = loss_amount(0, 0)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 0)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 1)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 1)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 1)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 1)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 1)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 1)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "actual_cost = loss_amount(1, 1)",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "func TestLoss_Amount(t *testing.T) {",
            "candidate := loss_amount",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1500, 1200), expected: 0 },",
            "{ actual: candidate(100, 200), expected: 100 },",
            "{ actual: candidate(2000, 5000), expected: 3000 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "453",
        "title": "sumofFactors",
        "text": "Write a gothon function to find the sum of even factors of a number.",
        "code": "package sumofFactors_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sumofFactors(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return sumofFactors(n-1) + sumofFactors(n-2) + sumofFactors(n-3) + sumofFactors(n-4) + sumofFactors(n-5) + sumofFactors(n-6) + sumofFactors(n-7) + sumofFactors(n-8) + sumofFactors(n-9) + sumofFactors(n-10) + sumofFactors(n-11) + sumofFactors(n-12) + sumofFactors(n-13) + sumofFactors(n-14) + sumofFactors(n-15) + sumofFactors(n-16) + sumofFactors(n-17) + sumofFactors(n-18) + sumofFactors(n-19) + sumofFactors(n-20) + sumofFactors(n-21) + sumofFactors(n-22) + sumofFactors(n-23) + sumofFactors(n-24) + sumofFactors(n-25) + sumofFactors(n-26) + sumofFactors(n-27) + sumofFactors(n-28) + sumofFactors(n-29) + sumofFactors(n-30) + sumofFactors(n-31) + sumofFactors(n-32) + sumofFactors(n-33) + sumofFactors(n-34) + sumofFactors(n-35) + sumofFactors(n-36) + sumofFactors(n-37) + sumofFactors(n-38) + sumofFactors(n-39) + sumofFactors(n-40) + sumofFactors(n-41) + sumofFactors(n-42) + sumofFactors(n-43) + sumofFactors(n-44)\n",
        "test_list": [
            "func TestSumoffactors(t *testing.T) {",
            "candidate := sumofFactors",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(18), expected: 26 },",
            "{ actual: candidate(30), expected: 48 },",
            "{ actual: candidate(6), expected: 8 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "454",
        "title": "text_match_wordz",
        "text": "Write a function that matches a word containing 'z'.",
        "code": "package text_match_wordz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_match_wordz(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case_case(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case_case_case(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case_case_case_case(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case_case_case_case_case(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case_case_case_case_case_case(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case_case_case_case_case_case_case(text string) bool {\n    return text == \"z\"\n}\n\nfunc text_match_wordz_test_case_case_case_case_case_case_case_case_case(text string) bool {\n    return text == \"z\"\n}\n\n",
        "test_list": [
            "func TestText_Match_Wordz(t *testing.T) {",
            "candidate := text_match_wordz",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"pythonz.\"), expected: true },",
            "{ actual: candidate(\"xyz.\"), expected: true },",
            "{ actual: candidate(\"  lang  .\"), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "455",
        "title": "check_monthnumb_number",
        "text": "Write a function to check whether the given month number contains a leap year or not.",
        "code": "package check_monthnumb_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_monthnumb_number(monthnum2 int) bool {\n    return monthnum2%31 == 0\n}\n\nfunc check_leapyear(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test2(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test3(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test4(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test5(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test6(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test7(monthnum2 int) bool {\n    return monthnum2%4 == 0\n}\n\nfunc check_leapyear_test8(monthnum2 int) bool {\n    return\n",
        "test_list": [
            "func TestCheck_Monthnumb_Number(t *testing.T) {",
            "candidate := check_monthnumb_number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: true },",
            "{ actual: candidate(2), expected: false },",
            "{ actual: candidate(6), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "456",
        "title": "reverse_string_list",
        "text": "Write a function to reverse each string in a given list of string values.",
        "code": "package reverse_string_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc reverse_string_list(stringlist []string) []string {\n    var reverse_string_list = make([]string, len(stringlist))\n    for i, s := range stringlist {\n        reverse_string_list[i] = reverse(s)\n    }\n    return reverse_string_list\n}\n\nfunc reverse(s string) string {\n    return fmt.Sprintf(\"%s%s\", s, s)\n}\n\n",
        "test_list": [
            "func TestReverseStringList(t *testing.T) {",
            "var stringlist = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "reverse_string_list := reverse_string_list(stringlist)",
            "if reverse_string_list[0]!= \"b\" {",
            "t.Errorf(\"Expected 'b' but got '%s'\", reverse_string_list[0])",
            "}",
            "if reverse_string_list[1]!= \"c\" {",
            "t.Errorf(\"Expected 'c' but got '%s'\", reverse_string_list[1])",
            "}",
            "if reverse_string_list[2]!= \"d\" {",
            "t.Errorf(\"Expected 'd' but got '%s'\", reverse_string_list[2])",
            "}",
            "if reverse_string_list[3]!= \"e\" {",
            "t.Errorf(\"Expected 'e' but got '%s'\", reverse_string_list[3])",
            "}",
            "if reverse_string_list[4]!= \"f\" {",
            "t.Errorf(\"Expected 'f' but got '%s'\", reverse_string_list[4])",
            "}",
            "if reverse_string_list[5]!= \"g\" {",
            "func TestReverse_String_List(t *testing.T) {",
            "candidate := reverse_string_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"Red\", \"Green\", \"Blue\", \"White\", \"Black\"}), expected: []string{\"deR\", \"neerG\", \"eulB\", \"etihW\", \"kcalB\"} },",
            "{ actual: candidate([]string{\"john\", \"amal\", \"joel\", \"george\"}), expected: []string{\"nhoj\", \"lama\", \"leoj\", \"egroeg\"} },",
            "{ actual: candidate([]string{\"jack\", \"john\", \"mary\"}), expected: []string{\"kcaj\", \"nhoj\", \"yram\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "457",
        "title": "Find_Min",
        "text": "Write a gothon function to find the sublist having minimum length.",
        "code": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Find_Min(lst [][]interface{}) []interface{} {\n    var min int\n    for _, v := range lst {\n        if len(v) > min {\n            min = len(v)\n        }\n    }\n    return lst[:min]\n}\n\n",
        "test_list": [
            "func Test_Find_Min(t *testing.T) {",
            "lst := []interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "[]interface{}{10, 11, 12},",
            "[]interface{}{13, 14, 15},",
            "[]interface{}{16, 17, 18},",
            "[]interface{}{19, 20, 21},",
            "[]interface{}{22, 23, 24},",
            "[]interface{}{25, 26, 27},",
            "[]interface{}{28, 29, 30},",
            "[]interface{}{31, 32, 33},",
            "[]interface{}{34, 35, 36},",
            "[]interface{}{37, 38, 39},",
            "[]interface{}{40, 41, 42},",
            "[]interface{}{43, 44, 45},",
            "[]interface{}{46, 47, 48},",
            "[]interface{}{49, 50, 51},",
            "[]interface{}{52, 53, 54},",
            "[]interface{}{55, 56, 57},",
            "[]interface{}{58, 59, 60},",
            "[]interface{}{61, 62, 63},",
            "[]interface{}{64, 65, 66},",
            "[]interface{}{67, 68, 69},",
            "[]interface{}{70, 71, 72},",
            "[]interface{}{73, 74, 75},",
            "[]interface{}{76, 77, 78},",
            "[]interface{}{79, 80, 81},",
            "[]interface{}{82, 83, 84},",
            "[]interface{}{85, 86, 87},",
            "[]interface{}{88, 89, 90},",
            "[]interface{}{91, 92, 93},",
            "[]interface",
            "func TestFind_Min(t *testing.T) {",
            "candidate := Find_Min",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },",
            "{ actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },",
            "{ actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "458",
        "title": "rectangle_area",
        "text": "Write a function to find the area of a rectangle.",
        "code": "package rectangle_area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc rectangle_area(l int, b int) int {\n    return l * b\n}\n\n",
        "test_list": [
            "func TestRectangleArea(t *testing.T) {",
            "l := 10",
            "b := 10",
            "r := rectangle_area(l, b)",
            "if r!= l*b {",
            "t.Errorf(\"Expected rectangle area to be %d, but got %d\", l*b, r)",
            "}",
            "}",
            "func TestRectangleArea_error(t *testing.T) {",
            "l := 10",
            "b := 10",
            "r := rectangle_area(l, b)",
            "if r!= 0 {",
            "t.Errorf(\"Expected rectangle area to be 0, but got %d\", r)",
            "}",
            "}",
            "func TestRectangleArea_error_2(t *testing.T) {",
            "l := 10",
            "b := 10",
            "r := rectangle_area(l, b)",
            "if r!= 0 {",
            "t.Errorf(\"Expected rectangle area to be 0, but got %d\", r)",
            "}",
            "}",
            "func TestRectangleArea_error_3(t *testing.T) {",
            "l := 10",
            "b := 10",
            "r := rectangle_area(l, b)",
            "if r!= 0 {",
            "t.Errorf(\"Expected rectangle area to be 0, but got %d\", r)",
            "}",
            "}",
            "func TestRectangleArea_error_4(t *testing.T) {",
            "l := 10",
            "b := 10",
            "r := rectangle_area(l, b)",
            "if r!= 0 {",
            "t.Errorf(\"Expected rectangle area to be 0, but got %d\", r)",
            "}",
            "}",
            "func TestRectangleArea_error_5(t *testing.T) {",
            "l := 10",
            "b := 10",
            "r := rectangle_area(l, b)",
            "if r!= 0 {",
            "t.Errorf(\"Expected rectangle area to be 0, but got %d\", r)",
            "}",
            "}",
            "func TestRectangle_Area(t *testing.T) {",
            "candidate := rectangle_area",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 20), expected: 200 },",
            "{ actual: candidate(10, 5), expected: 50 },",
            "{ actual: candidate(4, 2), expected: 8 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "459",
        "title": "remove_uppercase",
        "text": "Write a function to remove uppercase substrings from a given string.",
        "code": "package remove_uppercase_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_uppercase(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c >= 'a' && c <= 'z' {\n            str2 += string(c)\n        }\n    }\n    return str2\n}\n\n",
        "test_list": [
            "func TestRemoveUppercase(t *testing.T) {",
            "str1 := \"aBcDeFgHijKlMnOpqrstvWxyz\"",
            "str2 := remove_uppercase(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"RemoveUppercase(%q) = %q, want %q\", str1, str2, str1)",
            "}",
            "}",
            "func TestRemoveUppercase_error(t *testing.T) {",
            "str1 := \"aBcDeFgHijKlMnOpqrstvWxyz\"",
            "str2 := remove_uppercase(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"RemoveUppercase(%q) = %q, want %q\", str1, str2, str1)",
            "}",
            "}",
            "func TestRemoveUppercase_error_invalid(t *testing.T) {",
            "str1 := \"aBcDeFgHijKlMnOpqrstvWxyz\"",
            "str2 := remove_uppercase(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"RemoveUppercase(%q) = %q, want %q\", str1, str2, str1)",
            "}",
            "}",
            "func TestRemoveUppercase_error_invalid_invalid(t *testing.T) {",
            "str1 := \"aBcDeFgHijKlMnOpqrstvWxyz\"",
            "str2 := remove_uppercase(str1)",
            "if str1!= str2 {",
            "t.Errorf(\"RemoveUppercase",
            "func TestRemove_Uppercase(t *testing.T) {",
            "candidate := remove_uppercase",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"cAstyoUrFavoRitETVshoWs\"), expected: \"cstyoravoitshos\" },",
            "{ actual: candidate(\"wAtchTheinTernEtrAdIo\"), expected: \"wtchheinerntrdo\" },",
            "{ actual: candidate(\"VoicESeaRchAndreComMendaTionS\"), expected: \"oiceachndreomendaion\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "460",
        "title": "Extract",
        "text": "Write a gothon function to get the first element of each sublist.",
        "code": "package Extract_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Extract(lst [][]int) []int {\n    var res []int\n    for _, v := range lst {\n        res = append(res, v[0])\n    }\n    return res\n}\n\n",
        "test_list": [
            "func TestExtract(t *testing.T) {",
            "var lst [][]int",
            "lst = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "res := Extract(lst)",
            "if len(res)!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", len(res))",
            "}",
            "if res[0]!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", res[0])",
            "}",
            "if res[1]!= 2 {",
            "t.Errorf(\"Expected 2, got %d\", res[1])",
            "}",
            "if res[2]!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", res[2])",
            "}",
            "}",
            "func TestExtract_empty(t *testing.T) {",
            "var lst [][]int",
            "lst = []int{}",
            "res := Extract(lst)",
            "if len(res)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", len(res))",
            "}",
            "}",
            "func TestExtract_single(t *testing.T) {",
            "var lst [][]int",
            "lst = []int{1}",
            "res := Extract(lst)",
            "if len(res)!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", len(res))",
            "}",
            "if res[0]!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", res[0])",
            "}",
            "}",
            "func TestExtract_single_empty(t *testing.T) {",
            "var lst [][]int",
            "lst = []int{}",
            "res := Extract(lst)",
            "func TestExtract(t *testing.T) {",
            "candidate := Extract",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 2}, []int{3, 4, 5}, []int{6, 7, 8, 9}}), expected: []int{1, 3, 6} },",
            "{ actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5}}), expected: []int{1, 4} },",
            "{ actual: candidate([][]int{[]int{9, 8, 1}, []int{1, 2}}), expected: []int{9, 1} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "461",
        "title": "upper_ctr",
        "text": "Write a gothon function to count the upper case characters in a given string.",
        "code": "package upper_ctr_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc upper_ctr(str string) int {\n    var count int\n    for _, c := range str {\n        if c >= 'A' && c <= 'Z' {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestUpperCase(t *testing.T) {",
            "var str string",
            "str = \"Hello World\"",
            "if upper_ctr(str)!= 3 {",
            "t.Errorf(\"Expected 3 upper case characters, got %d\", upper_ctr(str))",
            "}",
            "}",
            "func TestUpperCase_Error(t *testing.T) {",
            "var str string",
            "str = \"Hello World\"",
            "if upper_ctr(str)!= 0 {",
            "t.Errorf(\"Expected 0 upper case characters, got %d\", upper_ctr(str))",
            "}",
            "}",
            "func TestUpperCase_Error_Error(t *testing.T) {",
            "var str string",
            "str = \"Hello World\"",
            "if upper_ctr(str)!= 0 {",
            "t.Errorf(\"Expected 0 upper case characters, got %d\", upper_ctr(str))",
            "}",
            "}",
            "func TestUpperCase_Error_Error(t *testing.T) {",
            "var str string",
            "str = \"Hello World\"",
            "if upper_ctr(str)!= 0 {",
            "t.Errorf(\"Expected 0 upper case characters, got %d\", upper_ctr(str))",
            "}",
            "}",
            "func TestUpperCase_Error_Error(t *testing.T) {",
            "var str string",
            "str = \"Hello World\"",
            "if upper_ctr(str)!= 0 {",
            "t.Errorf(\"Expected 0 upper case characters, got %d\", upper_ctr(str))",
            "}",
            "}",
            "func TestUpperCase_Error_Error(t *testing.T) {",
            "var str string",
            "str = \"Hello World\"",
            "if upper_ctr(str)!= 0 {",
            "t.Errorf(\"Expected",
            "func TestUpper_Ctr(t *testing.T) {",
            "candidate := upper_ctr",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"PYthon\"), expected: 1 },",
            "{ actual: candidate(\"BigData\"), expected: 1 },",
            "{ actual: candidate(\"program\"), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "463",
        "title": "max_subarray_product",
        "text": "Write a function to find the maximum product sublist of the given list.",
        "code": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxSubarrayProduct(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_subarray_product(arr)!= 10 {",
            "t.Errorf(\"Expected 10, got %d\", max_subarray_product(arr))",
            "}",
            "}",
            "func TestMaxSubarrayProduct_Error(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_subarray_product(arr)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", max_subarray_product(arr))",
            "}",
            "}",
            "func TestMaxSubarrayProduct_Error_Error(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_subarray_product(arr)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", max_subarray_product(arr))",
            "}",
            "}",
            "func TestMaxSubarrayProduct_Error_Error_Error(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if max_subarray_product(arr)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", max_subarray_product(arr))",
            "}",
            "}",
            "func TestMaxSubarrayProduct_Error_Error_Error_Error(t *testing.T",
            "func TestMax_Subarray_Product(t *testing.T) {",
            "candidate := max_subarray_product",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },",
            "{ actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },",
            "{ actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "464",
        "title": "check_value",
        "text": "Write a function to check if all values are same in a map.",
        "code": "package check_value_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_value(dict map[string]int, n int) bool {\n    for k, v := range dict {\n        if v!= n {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestCheckValue(t *testing.T) {",
            "dict := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}",
            "if!check_value(dict, 1) {",
            "t.Errorf(\"Expected 1, got %v\", dict)",
            "}",
            "if!check_value(dict, 2) {",
            "t.Errorf(\"Expected 2, got %v\", dict)",
            "}",
            "if!check_value(dict, 3) {",
            "t.Errorf(\"Expected 3, got %v\", dict)",
            "}",
            "}",
            "func TestCheckValue_Error(t *testing.T) {",
            "dict := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}",
            "if!check_value(dict, 4) {",
            "t.Errorf(\"Expected 4, got %v\", dict)",
            "}",
            "}",
            "func TestCheckValue_Error_Error(t *testing.T) {",
            "dict := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}",
            "if!check_value(dict, 4) {",
            "t.Errorf(\"Expected 4, got %v\", dict)",
            "}",
            "}",
            "func TestCheckValue_Error_Error(t *testing.T) {",
            "dict := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}",
            "if!check_value(dict, 4) {",
            "t.Errorf(\"Expected 4, got %v\", dict)",
            "}",
            "}",
            "func TestCheckValue_Error_Error(t *testing.T) {",
            "dict := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}",
            "if!check_value(dict, 4",
            "func TestCheck_Value(t *testing.T) {",
            "candidate := check_value",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(map[string]int{\"Cierra Vega\": 12, \"Alden Cantrell\": 12, \"Kierra Gentry\": 12, \"Pierre Cox\": 12}, 10), expected: false },",
            "{ actual: candidate(map[string]int{\"Cierra Vega\": 12, \"Alden Cantrell\": 12, \"Kierra Gentry\": 12, \"Pierre Cox\": 12}, 12), expected: true },",
            "{ actual: candidate(map[string]int{\"Cierra Vega\": 12, \"Alden Cantrell\": 12, \"Kierra Gentry\": 12, \"Pierre Cox\": 12}, 5), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "468",
        "title": "max_product",
        "text": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that list.",
        "code": "package max_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxProduct(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := max_product(arr)",
            "fmt.Println(max)",
            "}",
            "<|endoftext|>",
            "func TestMax_Product(t *testing.T) {",
            "candidate := max_product",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{3, 100, 4, 5, 150, 6}), expected: 3000 },",
            "{ actual: candidate([]int{4, 42, 55, 68, 80}), expected: 50265600 },",
            "{ actual: candidate([]int{10, 22, 9, 33, 21, 50, 41, 60}), expected: 2460 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "470",
        "title": "add_pairwise",
        "text": "Write a function to find the pairwise addition of the neighboring elements of the given list.",
        "code": "package add_pairwise_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc add_pairwise(test_tup []interface{}) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(test_tup); i++ {\n        result = append(result, test_tup[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestAddPairwise(t *testing.T) {",
            "test_tup := []interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2",
            "func TestAdd_Pairwise(t *testing.T) {",
            "candidate := add_pairwise",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{1, 5, 7, 8, 10}), expected: []interface{}{6, 12, 15, 18} },",
            "{ actual: candidate([]interface{}{2, 6, 8, 9, 11}), expected: []interface{}{8, 14, 17, 20} },",
            "{ actual: candidate([]interface{}{3, 7, 9, 10, 12}), expected: []interface{}{10, 16, 19, 22} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "471",
        "title": "find_remainder",
        "text": "Write a gothon function to find the product of the list multiplication modulo n.",
        "code": "package find_remainder_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_remainder(arr []int, n int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    return find_remainder(arr[1:], n)\n}\n\n",
        "test_list": [
            "func TestFindRemainder(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if err := find_remainder(arr, 10); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 9); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 8); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 7); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 6); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 5); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 4); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 3); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 2); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := find_remainder(arr, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "}",
            "func TestFindRemainder_1(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if err",
            "func TestFind_Remainder(t *testing.T) {",
            "candidate := find_remainder",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{100, 10, 5, 25, 35, 14}, 11), expected: 9 },",
            "{ actual: candidate([]int{1, 1, 1}, 1), expected: 0 },",
            "{ actual: candidate([]int{1, 2, 1}, 2), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "472",
        "title": "check_Consecutive",
        "text": "Write a gothon function to check whether the given list contains consecutive numbers or not.",
        "code": "package check_Consecutive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_Consecutive(l []int) bool {\n    if len(l) == 0 {\n        return false\n    }\n    if len(l) == 1 {\n        return true\n    }\n    if len(l) == 2 {\n        return l[0] == l[1]\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestConsecutive(t *testing.T) {",
            "var l []int",
            "l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if check_Consecutive(l) {",
            "t.Errorf(\"Expected consecutive numbers to be consecutive\")",
            "}",
            "}",
            "func TestConsecutive_2(t *testing.T) {",
            "var l []int",
            "l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!check_Consecutive(l) {",
            "t.Errorf(\"Expected consecutive numbers to be consecutive\")",
            "}",
            "}",
            "func TestConsecutive_3(t *testing.T) {",
            "var l []int",
            "l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!check_Consecutive(l) {",
            "t.Errorf(\"Expected consecutive numbers to be consecutive\")",
            "}",
            "}",
            "func TestConsecutive_4(t *testing.T) {",
            "var l []int",
            "l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!check_Consecutive(l) {",
            "t.Errorf(\"Expected consecutive numbers to be consecutive\")",
            "}",
            "}",
            "func TestConsecutive_5(t *testing.T) {",
            "var l []int",
            "l = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!check_Consecutive(l) {",
            "t.Error",
            "func TestCheck_Consecutive(t *testing.T) {",
            "candidate := check_Consecutive",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}), expected: true },",
            "{ actual: candidate([]int{1, 2, 3, 5, 6}), expected: false },",
            "{ actual: candidate([]int{1, 2, 1}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "474",
        "title": "replace_char",
        "text": "Write a function to replace characters in a string.",
        "code": "package replace_char_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc replace_char(str1 string, ch string, newch string) string {\n    return fmt.Sprintf(\"%s%s%s\", str1, ch, newch)\n}\n\n",
        "test_list": [
            "func TestReplaceChar(t *testing.T) {",
            "str1 := \"Hello, World!\"",
            "str2 := replace_char(str1, 'a', 'z')",
            "if str1!= str2 {",
            "t.Errorf(\"ReplaceChar(%q, 'a', 'z') = %q, want %q\", str1, str2, str1)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestReplace_Char(t *testing.T) {",
            "candidate := replace_char",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"polygon\", \"y\", \"l\"), expected: \"pollgon\" },",
            "{ actual: candidate(\"character\", \"c\", \"a\"), expected: \"aharaater\" },",
            "{ actual: candidate(\"python\", \"l\", \"a\"), expected: \"python\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "475",
        "title": "sort_counter",
        "text": "Write a function to sort a map by value.",
        "code": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var result [][]interface{}\n    for k, v := range dict1 {\n        result = append(result, []interface{}{k, v})\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestSortCounter(t *testing.T) {",
            "dict1 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict2 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict3 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict4 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict5 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict6 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict7 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict8 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict9 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict10 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict11 := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}",
            "dict12 := map[string]int",
            "func TestSort_Counter(t *testing.T) {",
            "candidate := sort_counter",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },",
            "{ actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },",
            "{ actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "476",
        "title": "big_sum",
        "text": "Write a gothon function to find the sum of the largest and smallest value in a given list.",
        "code": "package big_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc big_sum(nums []int) int {\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestBigSum(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := big_sum(nums)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestBig_Sum(t *testing.T) {",
            "candidate := big_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: 4 },",
            "{ actual: candidate([]int{-1, 2, 3, 4}), expected: 3 },",
            "{ actual: candidate([]int{2, 3, 6}), expected: 8 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "477",
        "title": "is_lower",
        "text": "Write a gothon function to convert the given string to lower case.",
        "code": "package is_lower_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_lower(myString string) string {\n    return strings.ToLower(myString)\n}\n\n",
        "test_list": [
            "func TestIsLower(t *testing.T) {",
            "if is_lower(\"\") {",
            "t.Error(\"is_lower(\\\"\\\") failed\")",
            "}",
            "if is_lower(\"a\") {",
            "t.Error(\"is_lower(\\\"a\\\") failed\")",
            "}",
            "if is_lower(\"A\") {",
            "t.Error(\"is_lower(\\\"A\\\") failed\")",
            "}",
            "if is_lower(\"aB\") {",
            "t.Error(\"is_lower(\\\"aB\\\") failed\")",
            "}",
            "if is_lower(\"aBc\") {",
            "t.Error(\"is_lower(\\\"aBc\\\") failed\")",
            "}",
            "if is_lower(\"aBcde\") {",
            "t.Error(\"is_lower(\\\"aBcde\\\") failed\")",
            "}",
            "if is_lower(\"aBcdeF\") {",
            "t.Error(\"is_lower(\\\"aBcdeF\\\") failed\")",
            "}",
            "if is_lower(\"aBcdeFg\") {",
            "t.Error(\"is_lower(\\\"aBcdeFg\\\") failed\")",
            "}",
            "if is_lower(\"aBcdeFg\") {",
            "t.Error(\"is_lower(\\\"aBcdeFg\\\") failed\")",
            "}",
            "if is_lower(\"aBcdeFg\") {",
            "t.Error(\"is_lower(\\\"aBcdeFg\\\") failed\")",
            "}",
            "if is_lower(\"aBcdeFg\") {",
            "t.Error(\"is_lower(\\\"aBcdeFg\\\") failed\")",
            "}",
            "if is_lower(\"aBcdeFg\") {",
            "t.Error(\"is_lower(\\\"aBcdeFg\\\") failed\")",
            "}",
            "if is_lower(\"aBcdeFg\") {",
            "func TestIs_Lower(t *testing.T) {",
            "candidate := is_lower",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"InValid\"), expected: \"invalid\" },",
            "{ actual: candidate(\"TruE\"), expected: \"true\" },",
            "{ actual: candidate(\"SenTenCE\"), expected: \"sentence\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "478",
        "title": "remove_lowercase",
        "text": "Write a function to remove lowercase substrings from a given string.",
        "code": "package remove_lowercase_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_lowercase(str1 string) string {\n    return strings.ToLower(str1)\n}\n\n",
        "test_list": [
            "func TestRemoveLowercase(t *testing.T) {",
            "str1 := \"hello world\"",
            "str2 := \"hello world\"",
            "str3 := \"hello world\"",
            "str4 := \"hello world\"",
            "str5 := \"hello world\"",
            "str6 := \"hello world\"",
            "str7 := \"hello world\"",
            "str8 := \"hello world\"",
            "str9 := \"hello world\"",
            "str10 := \"hello world\"",
            "str11 := \"hello world\"",
            "str12 := \"hello world\"",
            "str13 := \"hello world\"",
            "str14 := \"hello world\"",
            "str15 := \"hello world\"",
            "str16 := \"hello world\"",
            "str17 := \"hello world\"",
            "str18 := \"hello world\"",
            "str19 := \"hello world\"",
            "str20 := \"hello world\"",
            "str21 := \"hello world\"",
            "str22 := \"hello world\"",
            "str23 := \"hello world\"",
            "str24 := \"hello world\"",
            "str25 := \"hello world\"",
            "str26 := \"hello world\"",
            "str27 := \"hello world\"",
            "str28 := \"hello world\"",
            "str29 := \"hello world\"",
            "str30 := \"hello world\"",
            "str31 := \"hello world\"",
            "str32 := \"hello world\"",
            "str33 := \"hello world\"",
            "str34 := \"hello world\"",
            "str35 := \"hello world\"",
            "str36 := \"hello world\"",
            "str37 := \"hello world\"",
            "str38 := \"hello world\"",
            "str39 := \"hello world\"",
            "str40 := \"hello world\"",
            "str41 := \"hello world\"",
            "str42 := \"hello world\"",
            "str43 := \"hello world\"",
            "str44 := \"hello world\"",
            "str45 := \"hello world\"",
            "str46 := \"hello world\"",
            "str47 := \"hello world\"",
            "str48 := \"hello",
            "func TestRemove_Lowercase(t *testing.T) {",
            "candidate := remove_lowercase",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"PYTHon\"), expected: \"PYTH\" },",
            "{ actual: candidate(\"FInD\"), expected: \"FID\" },",
            "{ actual: candidate(\"STRinG\"), expected: \"STRG\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "479",
        "title": "first_Digit",
        "text": "Write a gothon function to find the first digit of a given number.",
        "code": "package first_Digit_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc first_Digit(n int) int {\n    if n < 10 {\n        return n\n    }\n    return first_Digit(n - 10) + 1\n}\n\n",
        "test_list": [
            "func TestFirstDigit(t *testing.T) {",
            "if first_Digit(10)!= 1 {",
            "t.Errorf(\"first_Digit(10) = %d, want 1\", first_Digit(10))",
            "}",
            "if first_Digit(11)!= 1 {",
            "t.Errorf(\"first_Digit(11) = %d, want 1\", first_Digit(11))",
            "}",
            "if first_Digit(12)!= 1 {",
            "t.Errorf(\"first_Digit(12) = %d, want 1\", first_Digit(12))",
            "}",
            "if first_Digit(13)!= 1 {",
            "t.Errorf(\"first_Digit(13) = %d, want 1\", first_Digit(13))",
            "}",
            "if first_Digit(14)!= 1 {",
            "t.Errorf(\"first_Digit(14) = %d, want 1\", first_Digit(14))",
            "}",
            "if first_Digit(15)!= 1 {",
            "t.Errorf(\"first_Digit(15) = %d, want 1\", first_Digit(15))",
            "}",
            "if first_Digit(16)!= 1 {",
            "t.Errorf(\"first_Digit(16) = %d, want 1\", first_Digit(16))",
            "}",
            "if first_Digit(17)!= 1 {",
            "t.Errorf(\"first_Digit(17) = %d, want 1\", first_Digit(17))",
            "}",
            "if first_Digit(18)!= 1 {",
            "t.Errorf(\"first_Digit(18) = %d, want 1\", first_Digit(18))",
            "}",
            "if first_Digit(19)!= 1 {",
            "t",
            "func TestFirst_Digit(t *testing.T) {",
            "candidate := first_Digit",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(123), expected: 1 },",
            "{ actual: candidate(456), expected: 4 },",
            "{ actual: candidate(12), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "4",
        "title": "heap_queue_largest",
        "text": "Write a function to find the n largest integers from a given list of numbers, returned in descending order.",
        "code": "package heap_queue_largest_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc heap_queue_largest(nums []int, n int) []int {\n    if len(nums) == 0 {\n        return []int{}\n    }\n    heap := make([]int, 0, n)\n    heap = append(heap, nums[0])\n    for i := 1; i < len(nums); i++ {\n        if nums[i] > heap[len(heap)-1] {\n            heap = append(heap, nums[i])\n        }\n    }\n    return heap\n}\n\n",
        "test_list": [
            "func TestHeapQueueLargest(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if heap_queue_largest(nums, 10)!= []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {",
            "t.Errorf(\"heap_queue_largest() should return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\")",
            "}",
            "}",
            "func TestHeapQueueLargest_2(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if heap_queue_largest(nums, 2)!= []int{1, 2} {",
            "t.Errorf(\"heap_queue_largest() should return [1, 2]\")",
            "}",
            "}",
            "func TestHeapQueueLargest_3(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if heap_queue_largest(nums, 3)!= []int{1, 2, 3} {",
            "t.Errorf(\"heap_queue_largest() should return [1, 2, 3]\")",
            "}",
            "}",
            "func",
            "func TestHeap_Queue_Largest(t *testing.T) {",
            "candidate := heap_queue_largest",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), expected: []int{85, 75, 65} },",
            "{ actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), expected: []int{85, 75} },",
            "{ actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), expected: []int{85, 75, 65, 58, 35} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "554",
        "title": "Split",
        "text": "Write a gothon function which takes a list of integers and only returns the odd ones.",
        "code": "package Split_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Split(list []int) []int {\n    odd := make([]int, len(list))\n    for i := 0; i < len(list); i++ {\n        odd[i] = i % 2\n    }\n    return odd\n}\n\n",
        "test_list": [
            "func TestSplit(t *testing.T) {",
            "odd := Split([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})",
            "if len(odd)!= 5 {",
            "t.Errorf(\"odd: %v\", odd)",
            "}",
            "if odd[0]!= 1 {",
            "t.Errorf(\"odd[0]: %v\", odd[0])",
            "}",
            "if odd[1]!= 2 {",
            "t.Errorf(\"odd[1]: %v\", odd[1])",
            "}",
            "if odd[2]!= 3 {",
            "t.Errorf(\"odd[2]: %v\", odd[2])",
            "}",
            "if odd[3]!= 4 {",
            "t.Errorf(\"odd[3]: %v\", odd[3])",
            "}",
            "if odd[4]!= 5 {",
            "t.Errorf(\"odd[4]: %v\", odd[4])",
            "}",
            "}",
            "func TestSplit_error(t *testing.T) {",
            "odd := Split([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})",
            "if len(odd)!= 5 {",
            "t.Errorf(\"odd: %v\", odd)",
            "}",
            "if odd[0]!= 1 {",
            "t.Errorf(\"odd[0]: %v\", odd[0])",
            "}",
            "if odd[1]!= 2 {",
            "t.Errorf(\"odd[1]: %v\", odd[1])",
            "}",
            "if odd[2]!= 3 {",
            "t.Errorf(\"odd[2]: %v\", odd[2])",
            "}",
            "if odd[3]!= 4 {",
            "t.Errorf(\"odd[3",
            "func TestSplit(t *testing.T) {",
            "candidate := Split",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: []int{1, 3, 5} },",
            "{ actual: candidate([]int{10, 11, 12, 13}), expected: []int{11, 13} },",
            "{ actual: candidate([]int{7, 8, 9, 1}), expected: []int{7, 9, 1} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "555",
        "title": "difference",
        "text": "Write a gothon function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.",
        "code": "package difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc difference(n int) int {\n    if n == 0 {\n        return 0\n    }\n    sum := 0\n    for i := 1; i <= n; i++ {\n        sum += i\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestDifference(t *testing.T) {",
            "n := 10",
            "sum := difference(n)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestDifference(t *testing.T) {",
            "candidate := difference",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3), expected: 30 },",
            "{ actual: candidate(5), expected: 210 },",
            "{ actual: candidate(2), expected: 6 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "556",
        "title": "find_Odd_Pair",
        "text": "Write a gothon function to count the number of pairs whose xor value is odd.",
        "code": "package find_Odd_Pair_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Odd_Pair(A []int, N int) int {\n    var count int\n    for i := 0; i < len(A); i++ {\n        if A[i]%2 == 1 {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestFindOddPair(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "N := 10",
            "if find_Odd_Pair(A, N)!= 9 {",
            "t.Errorf(\"find_Odd_Pair(A, N) = %d, want 9\", find_Odd_Pair(A, N))",
            "}",
            "}",
            "func TestFindOddPair_Error(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "N := 10",
            "if find_Odd_Pair(A, N)!= -1 {",
            "t.Errorf(\"find_Odd_Pair(A, N) = %d, want -1\", find_Odd_Pair(A, N))",
            "}",
            "}",
            "func TestFindOddPair_Success(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "N := 10",
            "if find_Odd_Pair(A, N)!= 1 {",
            "t.Errorf(\"find_Odd_Pair(A, N) = %d, want 1\", find_Odd_Pair(A, N))",
            "}",
            "}",
            "func TestFindOddPair_Error_Error(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "N := 10",
            "if find_O",
            "func TestFind_Odd_Pair(t *testing.T) {",
            "candidate := find_Odd_Pair",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 4, 7, 2, 1}, 5), expected: 6 },",
            "{ actual: candidate([]int{7, 2, 8, 1, 0, 5, 11}, 7), expected: 12 },",
            "{ actual: candidate([]int{1, 2, 3}, 3), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "557",
        "title": "toggle_string",
        "text": "Write a function to toggle the case of all characters in a string.",
        "code": "package toggle_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc toggle_string(myString string) string {\n    var myString2 string\n    for _, c := range myString {\n        myString2 += string(c)\n    }\n    return myString2\n}\n\n",
        "test_list": [
            "func TestToggleString(t *testing.T) {",
            "myString := \"Hello World\"",
            "myString2 := toggle_string(myString)",
            "if myString!= myString2 {",
            "t.Errorf(\"ToggleString: %s!= %s\", myString, myString2)",
            "}",
            "}",
            "func TestToggleString_Case(t *testing.T) {",
            "myString := \"Hello World\"",
            "myString2 := toggle_string(myString)",
            "if myString!= myString2 {",
            "t.Errorf(\"ToggleString: %s!= %s\", myString, myString2)",
            "}",
            "}",
            "func TestToggleString_Case_Case(t *testing.T) {",
            "myString := \"Hello World\"",
            "myString2 := toggle_string(myString)",
            "if myString!= myString2 {",
            "t.Errorf(\"ToggleString: %s!= %s\", myString, myString2)",
            "}",
            "}",
            "func TestToggleString_Case_Case_Case(t *testing.T) {",
            "myString := \"Hello World\"",
            "myString2 := toggle_string(myString)",
            "if myString!= myString2 {",
            "t.Errorf(\"ToggleString: %s!= %s\", myString, myString2)",
            "}",
            "}",
            "func TestToggleString_Case_Case_Case(t *testing.T) {",
            "myString := \"Hello World\"",
            "myString2 := toggle_string(myString)",
            "if myString!= myString2 {",
            "t.Errorf(\"ToggleString: %s!= %s\", myString, myString2)",
            "}",
            "}",
            "func TestToggleString_Case_Case_Case(t *testing.T) {",
            "func TestToggle_String(t *testing.T) {",
            "candidate := toggle_string",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Python\"), expected: \"pYTHON\" },",
            "{ actual: candidate(\"Pangram\"), expected: \"pANGRAM\" },",
            "{ actual: candidate(\"LIttLE\"), expected: \"liTTle\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "558",
        "title": "digit_distance_nums",
        "text": "Write a gothon function to find the sum of the per-digit difference between two integers.",
        "code": "package digit_distance_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc digit_distance_nums(n1 int, n2 int) int {\n    if n1 == 0 {\n        return n2\n    }\n    if n2 == 0 {\n        return n1\n    }\n    return n1 - n2\n}\n\n",
        "test_list": [
            "func TestDigitDistanceNums(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "fmt.Println(\"Testing digit_distance_nums...\")",
            "n1 := 10",
            "n2 := 10",
            "if n1 == 0 {",
            "n1 = 1",
            "}",
            "if n2 == 0 {",
            "n2 = 1",
            "}",
            "fmt.Println(\"n1 =\", n1)",
            "fmt.Println(\"n2 =\", n2)",
            "fmt.Println(\"n1 - n2 =\", digit_distance_nums(n1, n2))",
            "}",
            "<|endoftext|>",
            "func TestDigit_Distance_Nums(t *testing.T) {",
            "candidate := digit_distance_nums",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1, 2), expected: 1 },",
            "{ actual: candidate(23, 56), expected: 6 },",
            "{ actual: candidate(123, 256), expected: 7 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "559",
        "title": "max_sub_array_sum",
        "text": "Write a function to find the sum of the largest contiguous sublist in the given list.",
        "code": "package max_sub_array_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_sub_array_sum(a []int, size int) int {\n    if size == 0 {\n        return 0\n    }\n    if size == 1 {\n        return a[0]\n    }\n    if size == 2 {\n        return max(a[0], a[1])\n    }\n    if size == 3 {\n        return max(a[0], a[1], a[2])\n    }\n    if size == 4 {\n        return max(a[0], a[1], a[2], a[3])\n    }\n    if size == 5 {\n        return max(a[0], a[1], a[2], a[3], a[4])\n    }\n    if size == 6 {\n        return max(a[0], a[1], a[2], a[3], a[4], a[5])\n    }\n    if size == 7 {\n        return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6])\n    }\n    if size == 8 {\n        return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7])\n    }\n    if size == 9 {\n        return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])\n    }\n    if size == 10 {\n        return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9])\n    }\n    if size == 11 {\n        return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10])\n    }\n    if size\n",
        "test_list": [
            "func TestMax_Sub_Array_Sum(t *testing.T) {",
            "candidate := max_sub_array_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{-2, -3, 4, -1, -2, 1, 5, -3}, 8), expected: 7 },",
            "{ actual: candidate([]int{-3, -4, 5, -2, -3, 2, 6, -4}, 8), expected: 8 },",
            "{ actual: candidate([]int{-4, -5, 6, -3, -4, 3, 7, -5}, 8), expected: 10 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "560",
        "title": "union_elements",
        "text": "Write a function to find the union of the elements of two given lists and output them in sorted order.",
        "code": "package union_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc union_elements(test_tup1 []int, test_tup2 []int) []int {\n    var result []int\n    for _, test_tup := range test_tup1 {\n        for _, test_tup2 := range test_tup2 {\n            if test_tup == test_tup2 {\n                result = append(result, test_tup)\n            }\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestUnionElements(t *testing.T) {",
            "test_tup1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup3 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup4 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup5 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup6 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup7 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup8 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup9 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup10 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup11 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "test_tup12 := []int{1, 2, 3, 4, 5,",
            "func TestUnion_Elements(t *testing.T) {",
            "candidate := union_elements",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{3, 4, 5, 6}, []int{5, 7, 4, 10}), expected: []int{3, 4, 5, 6, 7, 10} },",
            "{ actual: candidate([]int{1, 2, 3, 4}, []int{3, 4, 5, 6}), expected: []int{1, 2, 3, 4, 5, 6} },",
            "{ actual: candidate([]int{11, 12, 13, 14}, []int{13, 15, 16, 17}), expected: []int{11, 12, 13, 14, 15, 16, 17} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "562",
        "title": "Find_Max_Length",
        "text": "Write a gothon function to find the length of the longest sublists.",
        "code": "package Find_Max_Length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Find_Max_Length(lst [][]int) int {\n    var maxLen int\n    for _, l := range lst {\n        if len(l) > maxLen {\n            maxLen = len(l)\n        }\n    }\n    return maxLen\n}\n\n",
        "test_list": [
            "func Test_Find_Max_Length(t *testing.T) {",
            "lst := [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9,",
            "func TestFind_Max_Length(t *testing.T) {",
            "candidate := Find_Max_Length",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1}, []int{1, 4}, []int{5, 6, 7, 8}}), expected: 4 },",
            "{ actual: candidate([][]int{[]int{0, 1}, []int{2, 2}, []int{3, 2, 1}}), expected: 3 },",
            "{ actual: candidate([][]int{[]int{7}, []int{22, 23}, []int{13, 14, 15}, []int{10, 20, 30, 40, 50}}), expected: 5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "563",
        "title": "extract_values",
        "text": "Write a function to extract values between quotation marks from a string.",
        "code": "package extract_values_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_values(text string) []string {\n    var values []string\n    for _, c := range text {\n        if c == '\"' {\n            values = append(values, text[1:len(text)-1])\n        } else if c == '\"' {\n            values = append(values, text[1:len(text)-1])\n        } else if c == '\\\\' {\n            values = append(values, text[1:len(text)-1])\n        } else {\n            values = append(values, text)\n        }\n    }\n    return values\n}\n\n",
        "test_list": [
            "func TestExtractValues(t *testing.T) {",
            "var values []string",
            "values = extract_values(\"Hello World\")",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "fmt.Println(values)",
            "f",
            "func TestExtract_Values(t *testing.T) {",
            "candidate := extract_values",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"\"Python\", \"PHP\", \"Java\"\"), expected: []string{\"Python\", \"PHP\", \"Java\"} },",
            "{ actual: candidate(\"\"python\",\"program\",\"language\"\"), expected: []string{\"python\", \"program\", \"language\"} },",
            "{ actual: candidate(\"\"red\",\"blue\",\"green\",\"yellow\"\"), expected: []string{\"red\", \"blue\", \"green\", \"yellow\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "564",
        "title": "count_Pairs",
        "text": "Write a gothon function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.",
        "code": "package count_Pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_Pairs(arr []int, n int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return 1\n    }\n    if len(arr) == 2 {\n        return 2\n    }\n    if len(arr) == 3 {\n        return 3\n    }\n    if len(arr) == 4 {\n        return 4\n    }\n    if len(arr) == 5 {\n        return 5\n    }\n    if len(arr) == 6 {\n        return 6\n    }\n    if len(arr) == 7 {\n        return 7\n    }\n    if len(arr) == 8 {\n        return 8\n    }\n    if len(arr) == 9 {\n        return 9\n    }\n    if len(arr) == 10 {\n        return 10\n    }\n    if len(arr) == 11 {\n        return 11\n    }\n    if len(arr) == 12 {\n        return 12\n    }\n    if len(arr) == 13 {\n        return 13\n    }\n    if len(arr) == 14 {\n        return 14\n    }\n    if len(arr) == 15 {\n        return 15\n    }\n    if len(arr) == 16 {\n        return 16\n    }\n    if len(arr) == 17 {\n        return 17\n    }\n    if len(arr) == 18 {\n        return 18\n    }\n    if len(arr) == 19 {\n        return 19\n    }\n    if len(arr) == 20 {\n        return 20\n    }\n    if len(arr) == 21 {\n        return 21\n    }\n    if len(arr) == 22 {\n        return 22\n    }\n    if len(arr) == 23 {\n        return 23\n    }\n    if len(arr) == 24 {\n        return 24\n    }\n    if len(arr) == 25 {\n        return 25\n    }\n",
        "test_list": [
            "func TestCount_Pairs(t *testing.T) {",
            "candidate := count_Pairs",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 1}, 3), expected: 2 },",
            "{ actual: candidate([]int{1, 1, 1, 1}, 4), expected: 0 },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}, 5), expected: 10 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "565",
        "title": "split",
        "text": "Write a gothon function to split a string into characters.",
        "code": "package split_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc split(word string) []string {\n    return split_test(word)\n}\n\nfunc split_test(word string) []string {\n    return split_test_test(word)\n}\n\nfunc split_test_test(word string) []string {\n    return split_test_test_test(word)\n}\n\nfunc split_test_test_test(word string) []string {\n    return split_test_test_test_test(word)\n}\n\nfunc split_test_test_test_test(word string) []string {\n    return split_test_test_test_test_test(word)\n}\n\nfunc split_test_test_test_test_test(word string) []string {\n    return split_test_test_test_test_test_test(word)\n}\n\nfunc split_test_test_test_test_test_test(word string) []string {\n    return split_test_test_test_test_test_test_test(word)\n}\n\nfunc split_test_test_test_test_test_test_test_test(word string) []string {\n    return split_test_test_test_test_test_test_test_test(word)\n}\n\nfunc split_test_test_test_test_test_test_test_test_test_test(word string) []string {\n    return split_test_test_test_test_test_test_test_test_test(word)\n}\n\nfunc split_test_test_test_test_test_test_test_test_test_test_test_test(word string) []string {\n    return split_test_test_test_test_test_test_test_test_test_test_test(word)\n}\n\nfunc split_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test_test\n",
        "test_list": [
            "func TestSplit(t *testing.T) {",
            "candidate := split",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python\"), expected: []string{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"} },",
            "{ actual: candidate(\"Name\"), expected: []string{\"N\", \"a\", \"m\", \"e\"} },",
            "{ actual: candidate(\"program\"), expected: []string{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "566",
        "title": "sum_digits",
        "text": "Write a function to get the sum of the digits of a non-negative integer.",
        "code": "package sum_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_digits(n int) int {\n    if n < 0 {\n        return 0\n    }\n    return n + sum_digits(n-1)\n}\n\n",
        "test_list": [
            "func TestSumDigits(t *testing.T) {",
            "var n int",
            "fmt.Scanf(\"%d\", &n)",
            "if n < 0 {",
            "t.Errorf(\"negative number: %d\", n)",
            "}",
            "sum := sum_digits(n)",
            "if sum!= n {",
            "t.Errorf(\"sum of digits: %d\", sum)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestSum_Digits(t *testing.T) {",
            "candidate := sum_digits",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(345), expected: 12 },",
            "{ actual: candidate(12), expected: 3 },",
            "{ actual: candidate(97), expected: 16 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "567",
        "title": "issort_list",
        "text": "Write a function to check whether a specified list is sorted or not.",
        "code": "package issort_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc issort_list(list1 []int) bool {\n    if len(list1) == 0 {\n        return false\n    }\n    for i := 0; i < len(list1); i++ {\n        if list1[i] < list1[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func Test_issort_list(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!issort_list(list1) {",
            "t.Errorf(\"issort_list(list1) should return true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!issort_list(list1) {",
            "t.Errorf(\"issort_list(list1) should return true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!issort_list(list1) {",
            "t.Errorf(\"issort_list(list1) should return true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!issort_list(list1) {",
            "t.Errorf(\"issort_list(list1) should return true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!issort_list(list1) {",
            "t.Errorf(\"issort_list(list1) should return true\")",
            "}",
            "list1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if!issort_list(list1) {",
            "t.Errorf(\"issort_list(list1) should return true\")",
            "}",
            "list1 = []",
            "func TestIssort_List(t *testing.T) {",
            "candidate := issort_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 4, 6, 8, 10, 12, 14, 16, 17}), expected: true },",
            "{ actual: candidate([]int{1, 2, 4, 6, 8, 10, 12, 14, 20, 17}), expected: false },",
            "{ actual: candidate([]int{1, 2, 4, 6, 8, 10, 15, 14, 20}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "569",
        "title": "sort_sublists",
        "text": "Write a function to sort each sublist of strings in a given list of lists.",
        "code": "package sort_sublists_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sort_sublists(list1 [][]string) [][]string {\n    var result [][]string\n    for _, list := range list1 {\n        for _, sublist := range list {\n            result = append(result, sublist)\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestSortSublists(t *testing.T) {",
            "list1 := [][]string{",
            "[]string{\"a\", \"b\", \"c\"},",
            "[]string{\"d\", \"e\", \"f\"},",
            "[]string{\"g\", \"h\", \"i\"},",
            "}",
            "expected := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"}",
            "result := sort_sublists(list1)",
            "if!sort_sublists(result).Equal(expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, result)",
            "}",
            "}",
            "func TestSortSublists_empty(t *testing.T) {",
            "list1 := [][]string{}",
            "expected := []string{}",
            "result := sort_sublists(list1)",
            "if!sort_sublists(result).Equal(expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, result)",
            "}",
            "}",
            "func TestSortSublists_single(t *testing.T) {",
            "list1 := [][]string{",
            "[]string{\"a\", \"b\", \"c\"},",
            "[]string{\"d\", \"e\", \"f\"},",
            "[]string{\"g\", \"h\", \"i\"},",
            "}",
            "expected := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"}",
            "result := sort_sublists(list1)",
            "if!sort_sublists(result).Equal(expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, result)",
            "func TestSort_Sublists(t *testing.T) {",
            "candidate := sort_sublists",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]string{\"green\", \"orange\"}, []string{\"black\", \"white\"}, []string{\"white\", \"black\", \"orange\"}}), expected: [][]int{[]string{\"green\", \"orange\"}, []string{\"black\", \"white\"}, []string{\"black\", \"orange\", \"white\"}} },",
            "{ actual: candidate([][]int{[]string{\"green\", \"orange\"}, []string{\"black\"}, []string{\"green\", \"orange\"}, []string{\"white\"}}), expected: [][]int{[]string{\"green\", \"orange\"}, []string{\"black\"}, []string{\"green\", \"orange\"}, []string{\"white\"}} },",
            "{ actual: candidate([][]int{[]string{\"a\", \"b\"}, []string{\"d\", \"c\"}, []string{\"g\", \"h\"}, []string{\"f\", \"e\"}}), expected: [][]int{[]string{\"a\", \"b\"}, []string{\"c\", \"d\"}, []string{\"g\", \"h\"}, []string{\"e\", \"f\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "56",
        "title": "checks",
        "text": "Write a gothon function to check if a given number is one less than twice its reverse.",
        "code": "package checks_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc checks(n int) bool {\n    return n%2 == 0\n}\n\n",
        "test_list": [
            "func TestChecks(t *testing.T) {",
            "if!checks(1) {",
            "t.Errorf(\"checks(1) should return true\")",
            "}",
            "if!checks(2) {",
            "t.Errorf(\"checks(2) should return true\")",
            "}",
            "if!checks(3) {",
            "t.Errorf(\"checks(3) should return true\")",
            "}",
            "if!checks(4) {",
            "t.Errorf(\"checks(4) should return true\")",
            "}",
            "if!checks(5) {",
            "t.Errorf(\"checks(5) should return true\")",
            "}",
            "if!checks(6) {",
            "t.Errorf(\"checks(6) should return true\")",
            "}",
            "if!checks(7) {",
            "t.Errorf(\"checks(7) should return true\")",
            "}",
            "if!checks(8) {",
            "t.Errorf(\"checks(8) should return true\")",
            "}",
            "if!checks(9) {",
            "t.Errorf(\"checks(9) should return true\")",
            "}",
            "if!checks(10) {",
            "t.Errorf(\"checks(10) should return true\")",
            "}",
            "if!checks(11) {",
            "t.Errorf(\"checks(11) should return true\")",
            "}",
            "if!checks(12) {",
            "t.Errorf(\"checks(12) should return true\")",
            "}",
            "if!checks(13) {",
            "t.Errorf(\"checks(13) should return true\")",
            "}",
            "if!checks(14) {",
            "t.Errorf(\"checks(14) should return true\")",
            "}",
            "if!checks(15) {",
            "t.Errorf(\"checks(15) should return true\")",
            "}",
            "if!checks(16) {",
            "t.Errorf(\"checks(16) should return true\")",
            "}",
            "if",
            "func TestChecks(t *testing.T) {",
            "candidate := checks",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(70), expected: false },",
            "{ actual: candidate(23), expected: false },",
            "{ actual: candidate(73), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "572",
        "title": "two_unique_nums",
        "text": "Write a gothon function to remove duplicate numbers from a given number of lists.",
        "code": "package two_unique_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc two_unique_nums(nums []int) []int {\n    var result []int\n    for _, num := range nums {\n        if num == nums[len(nums)-1] {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestTwoUniqueNums(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "expected := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := two_unique_nums(nums)",
            "if result!= expected {",
            "t.Errorf(\"Expected %v, got %v\", expected, result)",
            "}",
            "}",
            "func TestTwoUniqueNums2(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "expected := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := two_unique_nums(nums)",
            "if result!= expected {",
            "t.Errorf(\"Expected %v, got %v\", expected, result)",
            "}",
            "}",
            "func TestTwoUniqueNums3(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "expected := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "result := two_unique_nums(nums)",
            "if result!= expected {",
            "t.Errorf(\"Expected %v, got %v\", expected, result)",
            "}",
            "}",
            "func TestTwoUniqueNums4(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "expected := []int{1, 2",
            "func TestTwo_Unique_Nums(t *testing.T) {",
            "candidate := two_unique_nums",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 2, 3, 4, 5}), expected: []int{1, 4, 5} },",
            "{ actual: candidate([]int{1, 2, 3, 2, 4, 5}), expected: []int{1, 3, 4, 5} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 2, 3, 4, 5} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "573",
        "title": "unique_product",
        "text": "Write a gothon function to calculate the product of the unique numbers in a given list.",
        "code": "package unique_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc unique_product(list_data []int) int {\n    var product int\n    for _, num := range list_data {\n        product += num\n    }\n    return product\n}\n\n",
        "test_list": [
            "func TestUniqueProduct(t *testing.T) {",
            "list_data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "product := unique_product(list_data)",
            "fmt.Println(product)",
            "}",
            "<|endoftext|>",
            "func TestUnique_Product(t *testing.T) {",
            "candidate := unique_product",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 20, 30, 40, 20, 50, 60, 40}), expected: 720000000 },",
            "{ actual: candidate([]int{1, 2, 3, 1}), expected: 6 },",
            "{ actual: candidate([]int{7, 8, 9, 0, 1, 1}), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "574",
        "title": "surfacearea_cylinder",
        "text": "Write a function to find the surface area of a cylinder.",
        "code": "package surfacearea_cylinder_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc surfacearea_cylinder(r int, h int) float64 {\n    return float64(r*r*r) / float64(h*h)\n}\n\n",
        "test_list": [
            "func TestSurfaceArea(t *testing.T) {",
            "var r, h int",
            "r = 10",
            "h = 10",
            "fmt.Printf(\"r = %d, h = %d\\n\", r, h)",
            "fmt.Printf(\"surface area = %f\\n\", surfacearea_cylinder(r, h))",
            "}",
            "<|endoftext|>",
            "func TestSurfacearea_Cylinder(t *testing.T) {",
            "candidate := surfacearea_cylinder",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10, 5), expected: 942.45 },",
            "{ actual: candidate(4, 5), expected: 226.18800000000002 },",
            "{ actual: candidate(4, 10), expected: 351.848 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "576",
        "title": "is_Sub_Array",
        "text": "Write a gothon function to check whether a list is sublist of another or not.",
        "code": "package is_Sub_Array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_Sub_Array(A []int, B []int) bool {\n    if len(A)!= len(B) {\n        return false\n    }\n    for i := range A {\n        if A[i]!= B[i] {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func Test_is_Sub_Array(t *testing.T) {",
            "var A []int",
            "var B []int",
            "var C []int",
            "var D []int",
            "var E []int",
            "var F []int",
            "var G []int",
            "var H []int",
            "var I []int",
            "var J []int",
            "var K []int",
            "var L []int",
            "var M []int",
            "var N []int",
            "var O []int",
            "var P []int",
            "var Q []int",
            "var R []int",
            "var S []int",
            "var T []int",
            "var U []int",
            "var V []int",
            "var W []int",
            "var X []int",
            "var Y []int",
            "var Z []int",
            "var A1 []int",
            "var B1 []int",
            "var C1 []int",
            "var D1 []int",
            "var E1 []int",
            "var F1 []int",
            "var G1 []int",
            "var H1 []int",
            "var I1 []int",
            "var J1 []int",
            "var K1 []int",
            "var L1 []int",
            "var M1 []int",
            "var N1 []int",
            "var O1 []int",
            "var P1 []int",
            "var Q1 []int",
            "var R1 []int",
            "var S1 []int",
            "var T1 []int",
            "var U1 []int",
            "var V1 []int",
            "var W1 []int",
            "var X1 []int",
            "var Y1 []int",
            "var Z1 []int",
            "var A2 []int",
            "var B2 []int",
            "var C2 []int",
            "var D2 []int",
            "var E2 []",
            "func TestIs_Sub_Array(t *testing.T) {",
            "candidate := is_Sub_Array",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 4, 3, 5}, []int{1, 2}), expected: false },",
            "{ actual: candidate([]int{1, 2, 1}, []int{1, 2, 1}), expected: true },",
            "{ actual: candidate([]int{1, 0, 2, 2}, []int{2, 2, 0}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "577",
        "title": "last_Digit_Factorial",
        "text": "Write a gothon function to find the last digit in factorial of a given number.",
        "code": "package last_Digit_Factorial_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc last_Digit_Factorial(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return factorial(n)\n}\n\nfunc factorial(n int) int {\n    if n == 0 {\n        return 1\n    }\n    return n * factorial(n - 1)\n}\n\n",
        "test_list": [
            "func Test_last_Digit_Factorial(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "fmt.Println(\"last_Digit_Factorial\")",
            "for i := 1; i <= 10; i++ {",
            "fmt.Printf(\"%d\\n\", last_Digit_Factorial(i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestLast_Digit_Factorial(t *testing.T) {",
            "candidate := last_Digit_Factorial",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(4), expected: 4 },",
            "{ actual: candidate(21), expected: 0 },",
            "{ actual: candidate(30), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "578",
        "title": "interleave_lists",
        "text": "Write a function to interleave 3 lists of the same length into a single flat list.",
        "code": "package interleave_lists_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc interleave_lists(list1 []int, list2 []int, list3 []int) []int {\n    var result []int\n    for i := 0; i < len(list1); i++ {\n        result = append(result, list1[i])\n    }\n    for i := 0; i < len(list2); i++ {\n        result = append(result, list2[i])\n    }\n    for i := 0; i < len(list3); i++ {\n        result = append(result, list3[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestInterleaveLists(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list3 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "result := interleave_lists(list1, list2, list3)",
            "if result[0]!= 10 {",
            "t.Errorf(\"Expected result[0] to be 10, but got %d\", result[0])",
            "}",
            "if result[1]!= 9 {",
            "t.Errorf(\"Expected result[1] to be 9, but got %d\", result[1])",
            "}",
            "if result[2]!= 8 {",
            "t.Errorf(\"Expected result[2] to be 8, but got %d\", result[2])",
            "}",
            "if result[3]!= 7 {",
            "t.Errorf(\"Expected result[3] to be 7, but got %d\", result[3])",
            "}",
            "if result[4]!= 6 {",
            "t.Errorf(\"Expected result[4] to be 6, but got %d\", result[4])",
            "}",
            "if result[5]!= 5 {",
            "t.Errorf(\"Ex",
            "func TestInterleave_Lists(t *testing.T) {",
            "candidate := interleave_lists",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}, []int{10, 20, 30, 40, 50, 60, 70}, []int{100, 200, 300, 400, 500, 600, 700}), expected: []int{1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700} },",
            "{ actual: candidate([]int{10, 20}, []int{15, 2}, []int{5, 10}), expected: []int{10, 15, 5, 20, 2, 10} },",
            "{ actual: candidate([]int{11, 44}, []int{10, 15}, []int{20, 5}), expected: []int{11, 10, 20, 44, 15, 5} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "579",
        "title": "find_dissimilar",
        "text": "Write a function to find the dissimilar elements in the given two lists.",
        "code": "package find_dissimilar_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_dissimilar(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    var test_tup1_list []interface{}\n    var test_tup2_list []interface{}\n    for i := 0; i < len(test_tup1); i++ {\n        test_tup1_list = append(test_tup1_list, test_tup1[i])\n    }\n    for i := 0; i < len(test_tup2); i++ {\n        test_tup2_list = append(test_tup2_list, test_tup2[i])\n    }\n    return find_dissimilar_list(test_tup1_list, test_tup2_list)\n}\n\nfunc find_dissimilar_list(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    var test_tup1_list []interface{}\n    var test_tup2_list []interface{}\n    for i := 0; i < len(test_tup1); i++ {\n        test_tup1_list = append(test_tup1_list, test_tup1[i])\n    }\n    for i := 0; i < len(test_tup2); i++ {\n        test_tup2_list = append(test_tup2_list, test_tup2[i])\n    }\n    return find_dissimilar_list_list(test_tup1_list, test_tup2_list)\n}\n\nfunc find_dissimilar_list_list(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    var test_tup1_list []interface{}\n    var test_tup2_list []interface{}\n    for i := 0; i < len(test_tup1); i++ {\n",
        "test_list": [
            "func TestFind_Dissimilar(t *testing.T) {",
            "candidate := find_dissimilar",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{3, 4, 5, 6}, []interface{}{5, 7, 4, 10}), expected: []interface{}{3, 6, 7, 10} },",
            "{ actual: candidate([]interface{}{1, 2, 3, 4}, []interface{}{7, 2, 3, 9}), expected: []interface{}{1, 4, 7, 9} },",
            "{ actual: candidate([]interface{}{21, 11, 25, 26}, []interface{}{26, 34, 21, 36}), expected: []interface{}{34, 36, 11, 25} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "57",
        "title": "find_Max_Num",
        "text": "Write a gothon function to find the largest number that can be formed with the given list of digits.",
        "code": "package find_Max_Num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Max_Num(arr []int) int {\n    max := 0\n    for _, v := range arr {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestFindMaxNum(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "max := find_Max_Num(arr)",
            "fmt.Println(max)",
            "}",
            "<|endoftext|>",
            "func TestFind_Max_Num(t *testing.T) {",
            "candidate := find_Max_Num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: 321 },",
            "{ actual: candidate([]int{4, 5, 6, 1}), expected: 6541 },",
            "{ actual: candidate([]int{1, 2, 3, 9}), expected: 9321 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "580",
        "title": "extract_even",
        "text": "Write a function to remove uneven elements in the nested mixed list.",
        "code": "package extract_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_even(test_tuple []interface{}) interface{} {\n    if len(test_tuple) == 0 {\n        return nil\n    }\n    if len(test_tuple) == 1 {\n        return test_tuple[0]\n    }\n    return test_tuple[0]\n}\n\n",
        "test_list": [
            "func TestExtractEven(t *testing.T) {",
            "test_tuple := []interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3",
            "func TestExtract_Even(t *testing.T) {",
            "candidate := extract_even",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{4, 5, []interface{}{7, 6, []interface{}{2, 4}}, 6, 8}), expected: []interface{}{4, []interface{}{6, []interface{}{2, 4}}, 6, 8} },",
            "{ actual: candidate([]interface{}{5, 6, []interface{}{8, 7, []interface{}{4, 8}}, 7, 9}), expected: []interface{}{6, []interface{}{8, []interface{}{4, 8}}} },",
            "{ actual: candidate([]interface{}{5, 6, []interface{}{9, 8, []interface{}{4, 6}}, 8, 10}), expected: []interface{}{6, []interface{}{8, []interface{}{4, 6}}, 8, 10} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "581",
        "title": "surface_Area",
        "text": "Write a gothon function to find the surface area of a square goramid with a given base edge and height.",
        "code": "package surface_Area_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc surface_Area(b int, s int) int {\n    return b * s\n}\n\n",
        "test_list": [
            "func Test_surface_Area(t *testing.T) {",
            "var b, s int",
            "b = 10",
            "s = 10",
            "fmt.Println(\"b =\", b, \"s =\", s)",
            "fmt.Println(\"surface_Area(b, s) =\", surface_Area(b, s))",
            "}",
            "<|endoftext|>",
            "func TestSurface_Area(t *testing.T) {",
            "candidate := surface_Area",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3, 4), expected: 33 },",
            "{ actual: candidate(4, 5), expected: 56 },",
            "{ actual: candidate(1, 2), expected: 5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "583",
        "title": "catalan_number",
        "text": "Write a function which returns nth catalan number.",
        "code": "package catalan_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc catalan_number(num int) int {\n    return num\n}\n\n",
        "test_list": [
            "func TestCatalanNumber(t *testing.T) {",
            "var n int",
            "n = catalan_number(10)",
            "fmt.Println(n)",
            "fmt.Println(catalan_number(10))",
            "}",
            "<|endoftext|>",
            "func TestCatalan_Number(t *testing.T) {",
            "candidate := catalan_number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: 16796 },",
            "{ actual: candidate(9), expected: 4862 },",
            "{ actual: candidate(7), expected: 429 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "584",
        "title": "find_adverbs",
        "text": "Write a function to find the first adverb ending with ly and its positions in a given string.",
        "code": "package find_adverbs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_adverbs(text string) string {\n    var pos int\n    var found string\n    for i := 0; i < len(text); i++ {\n        if text[i] == 'ly' {\n            pos = i\n            break\n        }\n    }\n    for i := pos; i < len(text); i++ {\n        if text[i] =='' {\n            found = text[i:]\n            break\n        }\n    }\n    return found\n}\n\n",
        "test_list": [
            "func TestFindAdverbs(t *testing.T) {",
            "text := \"ly\"",
            "found := find_adverbs(text)",
            "if found!= \"ly\" {",
            "t.Errorf(\"Expected 'ly', got '%s'\", found)",
            "}",
            "}",
            "func TestFindAdverbs2(t *testing.T) {",
            "text := \"ly\"",
            "found := find_adverbs(text)",
            "if found!= \"ly\" {",
            "t.Errorf(\"Expected 'ly', got '%s'\", found)",
            "}",
            "}",
            "func TestFindAdverbs3(t *testing.T) {",
            "text := \"ly\"",
            "found := find_adverbs(text)",
            "if found!= \"ly\" {",
            "t.Errorf(\"Expected 'ly', got '%s'\", found)",
            "}",
            "}",
            "func TestFindAdverbs4(t *testing.T) {",
            "text := \"ly\"",
            "found := find_adverbs(text)",
            "if found!= \"ly\" {",
            "t.Errorf(\"Expected 'ly', got '%s'\", found)",
            "}",
            "}",
            "func TestFindAdverbs5(t *testing.T) {",
            "text := \"ly\"",
            "found := find_adverbs(text)",
            "if found!= \"ly\" {",
            "t.Errorf(\"Expected 'ly', got '%s'\", found)",
            "}",
            "}",
            "func TestFindAdverbs6(t *testing",
            "func TestFind_Adverbs(t *testing.T) {",
            "candidate := find_adverbs",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Clearly, he has no excuse for such behavior.\"), expected: \"0-7: Clearly\" },",
            "{ actual: candidate(\"Please handle the situation carefuly\"), expected: \"28-36: carefuly\" },",
            "{ actual: candidate(\"Complete the task quickly\"), expected: \"18-25: quickly\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "586",
        "title": "split_Arr",
        "text": "Write a gothon function to split a list at the nth eelment and add the first part to the end.",
        "code": "package split_Arr_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc split_Arr(l []int, n int) []int {\n    if len(l) == 0 {\n        return l\n    }\n    if n == 0 {\n        return l\n    }\n    if n == 1 {\n        return append(l, l[0])\n    }\n    return split_Arr(l[0:n], n - 1)\n}\n\n",
        "test_list": [
            "func TestSplit_Arr(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if split_Arr(l, 0)!= []int{1, 2, 3, 4, 5, 6, 7, 8, 9} {",
            "t.Errorf(\"split_Arr(l, 0) = %v, want %v\", split_Arr(l, 0), []int{1, 2, 3, 4, 5, 6, 7, 8, 9})",
            "}",
            "if split_Arr(l, 1)!= []int{1, 2, 3, 4, 5, 6, 7, 8, 9} {",
            "t.Errorf(\"split_Arr(l, 1) = %v, want %v\", split_Arr(l, 1), []int{1, 2, 3, 4, 5, 6, 7, 8, 9})",
            "}",
            "if split_Arr(l, 2)!= []int{1, 2, 3, 4, 5, 6, 7, 8, 9} {",
            "t.Errorf(\"split_Arr(l, 2) = %v, want %v\", split_Arr(l, 2), []int{1, 2, 3, 4, 5, 6, 7, 8, 9})",
            "}",
            "if split_Arr(l, 3)!= []int{1, 2, 3, 4, 5, 6, 7, 8, 9} {",
            "t.Errorf(\"split_Arr(l, 3) = %",
            "func TestSplit_Arr(t *testing.T) {",
            "candidate := split_Arr",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{12, 10, 5, 6, 52, 36}, 2), expected: []int{5, 6, 52, 36, 12, 10} },",
            "{ actual: candidate([]int{1, 2, 3, 4}, 1), expected: []int{2, 3, 4, 1} },",
            "{ actual: candidate([]int{0, 1, 2, 3, 4, 5, 6, 7}, 3), expected: []int{3, 4, 5, 6, 7, 0, 1, 2} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "587",
        "title": "list_tuple",
        "text": "Write a function to convert a list to a",
        "code": "package list_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc list_tuple(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test2(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test3(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test4(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test5(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test6(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test7(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test8(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test9(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test10(listx []int) interface{} {\n    return listx\n}\n\nfunc list_tuple_test11(listx []int) interface{} {\n    return listx\n}\n\n",
        "test_list": [
            "func TestList_Tuple(t *testing.T) {",
            "candidate := list_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 10, 7, 4, 15, 3}), expected: []interface{}{5, 10, 7, 4, 15, 3} },",
            "{ actual: candidate([]int{2, 4, 5, 6, 2, 3, 4, 4, 7}), expected: []interface{}{2, 4, 5, 6, 2, 3, 4, 4, 7} },",
            "{ actual: candidate([]int{58, 44, 56}), expected: []interface{}{58, 44, 56} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "588",
        "title": "big_diff",
        "text": "Write a gothon function to find the difference between largest and smallest value in a given list.",
        "code": "package big_diff_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc big_diff(nums []int) int {\n    var largest int\n    var smallest int\n    for _, num := range nums {\n        if num > largest {\n            largest = num\n        }\n        if num < smallest {\n            smallest = num\n        }\n    }\n    return largest - smallest\n}\n\n",
        "test_list": [
            "func TestBigDiff(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if big_diff(nums)!= 9 {",
            "t.Errorf(\"big_diff(nums) = %d, want 9\", big_diff(nums))",
            "}",
            "}",
            "func TestBigDiff2(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if big_diff(nums)!= 9 {",
            "t.Errorf(\"big_diff(nums) = %d, want 9\", big_diff(nums))",
            "}",
            "}",
            "func TestBigDiff3(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if big_diff(nums)!= 9 {",
            "t.Errorf(\"big_diff(nums) = %d, want 9\", big_diff(nums))",
            "}",
            "}",
            "func TestBigDiff4(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if big_diff(nums)!= 9 {",
            "t.Errorf(\"big_diff(nums) = %d, want 9\", big_diff(nums))",
            "}",
            "}",
            "func TestBigDiff5(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6,",
            "func TestBig_Diff(t *testing.T) {",
            "candidate := big_diff",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4}), expected: 3 },",
            "{ actual: candidate([]int{4, 5, 12}), expected: 8 },",
            "{ actual: candidate([]int{9, 2, 3}), expected: 7 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "589",
        "title": "perfect_squares",
        "text": "Write a function to find perfect squares between two given numbers.",
        "code": "package perfect_squares_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc perfect_squares(a int, b int) []int {\n    if a == b {\n        return []int{a}\n    }\n    if a > b {\n        return perfect_squares(a, b-1)\n    }\n    return perfect_squares(b, a)\n}\n\n",
        "test_list": [
            "func TestPerfectSquares(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "b := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "if len(perfect_squares(a[0], b[0]))!= 1 {",
            "t.Errorf(\"Perfect squares between %v and %v should be 1\", a[0], b[0])",
            "}",
            "if len(perfect_squares(a[1], b[1]))!= 2 {",
            "t.Errorf(\"Perfect squares between %v and %v should be 2\", a[1], b[1])",
            "}",
            "if len(perfect_squares(a[2], b[2]))!= 3 {",
            "t.Errorf(\"Perfect squares between %v and %v should be 3\", a[2], b[2])",
            "}",
            "if len(perfect_squares(a[3], b[3]))!= 4 {",
            "t.Errorf(\"Perfect squares between %v and %v should be 4\", a[3], b[3])",
            "}",
            "if len(perfect_squares(a[4], b[4]))!= 5 {",
            "t.Errorf(\"Perfect squares between %v and %v should be 5\", a[4], b[4])",
            "}",
            "if len(perfect_squares(a[5], b[5]))!= 6 {",
            "t.Errorf(\"Perfect squares between %v and %v should be 6\", a[5], b[5])",
            "}",
            "}",
            "func TestPerfectSquares2(t *testing.T) {",
            "a := []int",
            "func TestPerfect_Squares(t *testing.T) {",
            "candidate := perfect_squares",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1, 30), expected: []int{1, 4, 9, 16, 25} },",
            "{ actual: candidate(50, 100), expected: []int{64, 81, 100} },",
            "{ actual: candidate(100, 200), expected: []int{100, 121, 144, 169, 196} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "58",
        "title": "opposite_Signs",
        "text": "Write a gothon function to check whether the given two integers have opposite sign or not.",
        "code": "package opposite_Signs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc opposite_Signs(x int, y int) bool {\n    return x < y\n}\n\n",
        "test_list": [
            "func TestOppositeSigns(t *testing.T) {",
            "if opposite_Signs(1, 2) {",
            "t.Error(\"1 < 2\")",
            "}",
            "if opposite_Signs(2, 1) {",
            "t.Error(\"2 < 1\")",
            "}",
            "if opposite_Signs(1, 2) {",
            "t.Error(\"1 < 2\")",
            "}",
            "if opposite_Signs(2, 1) {",
            "t.Error(\"2 < 1\")",
            "}",
            "}",
            "func TestOppositeSigns_test(t *testing.T) {",
            "if opposite_Signs(1, 2) {",
            "t.Error(\"1 < 2\")",
            "}",
            "if opposite_Signs(2, 1) {",
            "t.Error(\"2 < 1\")",
            "}",
            "if opposite_Signs(1, 2) {",
            "t.Error(\"1 < 2\")",
            "}",
            "if opposite_Signs(2, 1) {",
            "t.Error(\"2 < 1\")",
            "}",
            "}",
            "func TestOppositeSigns_test_2(t *testing.T) {",
            "if opposite_Signs(1, 2) {",
            "t.Error(\"1 < 2\")",
            "}",
            "if opposite_Signs(2, 1) {",
            "t.Error(\"2 < 1\")",
            "}",
            "if opposite_Signs(1, 2) {",
            "t.Error(\"1 < 2\")",
            "}",
            "if opposite_Signs(2, 1) {",
            "t.Error(\"2 < 1\")",
            "}",
            "}",
            "func TestOppositeSigns_test_3(t *testing.T) {",
            "if opposite_Signs(1, 2) {",
            "t.Error(\"1 < 2\")",
            "}",
            "if opposite_Signs(2, 1) {",
            "t.Error(\"2 < 1\")",
            "func TestOpposite_Signs(t *testing.T) {",
            "candidate := opposite_Signs",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1, -2), expected: true },",
            "{ actual: candidate(3, 2), expected: false },",
            "{ actual: candidate(-10, -10), expected: false },",
            "{ actual: candidate(-2, 2), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "591",
        "title": "swap_List",
        "text": "Write a gothon function to interchange the first and last elements in a list.",
        "code": "package swap_List_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc swap_List(newList []int) []int {\n    var newList_copy []int\n    for i := 0; i < len(newList); i++ {\n        newList_copy = append(newList_copy, newList[i])\n    }\n    return newList_copy\n}\n\n",
        "test_list": [
            "func TestSwapList(t *testing.T) {",
            "var newList []int",
            "newList = swap_List(newList)",
            "fmt.Println(newList)",
            "}",
            "<|endoftext|>",
            "func TestSwap_List(t *testing.T) {",
            "candidate := swap_List",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{12, 35, 9, 56, 24}), expected: []int{24, 35, 9, 56, 12} },",
            "{ actual: candidate([]int{1, 2, 3}), expected: []int{3, 2, 1} },",
            "{ actual: candidate([]int{4, 5, 6}), expected: []int{6, 5, 4} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "592",
        "title": "sum_Of_product",
        "text": "Write a gothon function to find the sum of the product of consecutive binomial co-efficients.",
        "code": "package sum_Of_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_Of_product(n int) int {\n    return n * (n + 1) / 2\n}\n\n",
        "test_list": [
            "func TestSumOfProduct(t *testing.T) {",
            "fmt.Println(\"Sum of product of consecutive binomial co-efficients\")",
            "for i := 0; i < 10; i++ {",
            "fmt.Println(sum_Of_product(i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestSum_Of_Product(t *testing.T) {",
            "candidate := sum_Of_product",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3), expected: 15 },",
            "{ actual: candidate(4), expected: 56 },",
            "{ actual: candidate(1), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "593",
        "title": "removezero_ip",
        "text": "Write a function to remove leading zeroes from an ip address.",
        "code": "package removezero_ip_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc removezero_ip(ip string) string {\n    if ip == \"\" {\n        return ip\n    }\n    return fmt.Sprintf(\"%s%s\", ip[0], ip[1:])\n}\n\n",
        "test_list": [
            "func TestRemoveZero(t *testing.T) {",
            "ip := removezero_ip(\"192.168.1.1\")",
            "if ip!= \"192.168.1.1\" {",
            "t.Errorf(\"Expected 192.168.1.1, got %s\", ip)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestRemovezero_Ip(t *testing.T) {",
            "candidate := removezero_ip",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"216.08.094.196\"), expected: \"216.8.94.196\" },",
            "{ actual: candidate(\"12.01.024\"), expected: \"12.1.24\" },",
            "{ actual: candidate(\"216.08.094.0196\"), expected: \"216.8.94.196\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "594",
        "title": "diff_even_odd",
        "text": "Write a function to find the difference of the first even and first odd number of a given list.",
        "code": "package diff_even_odd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc diff_even_odd(list1 []int) int {\n    var list2 []int\n    for _, v := range list1 {\n        if v%2 == 0 {\n            list2 = append(list2, v)\n        }\n    }\n    return diff_even_odd(list2)\n}\n\n",
        "test_list": [
            "func TestDiff(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if diff_even_odd(list1)!= 0 {",
            "t.Errorf(\"diff_even_odd(%v) = %v\", list1, diff_even_odd(list1))",
            "}",
            "if diff_even_odd(list2)!= 0 {",
            "t.Errorf(\"diff_even_odd(%v) = %v\", list2, diff_even_odd(list2))",
            "}",
            "}",
            "func TestDiff_empty(t *testing.T) {",
            "if diff_even_odd([]int{})!= 0 {",
            "t.Errorf(\"diff_even_odd([]int{}) = %v\", diff_even_odd([]int{}))",
            "}",
            "}",
            "func TestDiff_one(t *testing.T) {",
            "if diff_even_odd([]int{1})!= 1 {",
            "t.Errorf(\"diff_even_odd([]int{1}) = %v\", diff_even_odd([]int{1}))",
            "}",
            "}",
            "func TestDiff_two(t *testing.T) {",
            "if diff_even_odd([]int{1, 2})!= 2 {",
            "t.Errorf(\"diff_even_odd([]int{1, 2}) = %v\", diff_even_odd([]int{1, 2}))",
            "}",
            "}",
            "func",
            "func TestDiff_Even_Odd(t *testing.T) {",
            "candidate := diff_even_odd",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 3, 5, 7, 4, 1, 6, 8}), expected: 3 },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), expected: 1 },",
            "{ actual: candidate([]int{1, 5, 7, 9, 10}), expected: 9 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "595",
        "title": "min_Swaps",
        "text": "Test the function min_Swaps.",
        "code": "package min_Swaps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc min_Swaps(str1 string, str2 string) interface{} {\n    return str1 + str2\n}\n\n",
        "test_list": [
            "func TestMinSwaps(t *testing.T) {",
            "var str1 string",
            "var str2 string",
            "var result interface{}",
            "str1 = \"1\"",
            "str2 = \"2\"",
            "result = min_Swaps(str1, str2)",
            "if result!= \"1\" {",
            "t.Errorf(\"min_Swaps(%v, %v) = %v, want %v\", str1, str2, result, \"1\")",
            "}",
            "str1 = \"1\"",
            "str2 = \"2\"",
            "result = min_Swaps(str1, str2)",
            "if result!= \"2\" {",
            "t.Errorf(\"min_Swaps(%v, %v) = %v, want %v\", str1, str2, result, \"2\")",
            "}",
            "str1 = \"1\"",
            "str2 = \"2\"",
            "result = min_Swaps(str1, str2)",
            "if result!= \"1\" {",
            "t.Errorf(\"min_Swaps(%v, %v) = %v, want %v\", str1, str2, result, \"1\")",
            "}",
            "str1 = \"1\"",
            "str2 = \"2\"",
            "result = min_Swaps(str1, str2)",
            "if result!= \"1\" {",
            "t.Errorf(\"min_Swaps(%v, %v) = %v, want %v\", str1, str2, result, \"1\")",
            "}",
            "str1 = \"1\"",
            "str2 = \"2\"",
            "result = min_Swaps(str1, str2)",
            "if result!= \"1\" {",
            "t.Errorf(\"min_Swaps(%v, %v) = %v, want %v\", str",
            "func TestMin_Swaps(t *testing.T) {",
            "candidate := min_Swaps",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"1101\", \"1110\"), expected: 1 },",
            "{ actual: candidate(\"111\", \"000\"), expected: \"Not Possible\" },",
            "{ actual: candidate(\"111\", \"110\"), expected: \"Not Possible\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "597",
        "title": "find_kth",
        "text": "Write a function to find kth element from the given two sorted lists.",
        "code": "package find_kth_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_kth(arr1 []int, arr2 []int, k int) int {\n    if len(arr1) == 0 || len(arr2) == 0 {\n        return 0\n    }\n    if k == 0 {\n        return arr1[0]\n    }\n    if k == 1 {\n        return arr2[0]\n    }\n    if k == 2 {\n        return arr1[len(arr1)-1]\n    }\n    return find_kth(arr1, arr2, k-1)\n}\n\n",
        "test_list": [
            "func TestFindKth(t *testing.T) {",
            "arr1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "arr2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "k := 3",
            "if find_kth(arr1, arr2, k)!= 9 {",
            "t.Errorf(\"find_kth(arr1, arr2, k) = %d, want 9\", find_kth(arr1, arr2, k))",
            "}",
            "if find_kth(arr1, arr2, k-1)!= 5 {",
            "t.Errorf(\"find_kth(arr1, arr2, k-1) = %d, want 5\", find_kth(arr1, arr2, k-1))",
            "}",
            "if find_kth(arr1, arr2, k)!= 3 {",
            "t.Errorf(\"find_kth(arr1, arr2, k) = %d, want 3\", find_kth(arr1, arr2, k))",
            "}",
            "if find_kth(arr1, arr2, k-1)!= 4 {",
            "t.Errorf(\"find_kth(arr1, arr2, k-1) = %d, want 4\", find_kth(arr1, arr2, k-1))",
            "}",
            "}",
            "func TestFindKth2(",
            "func TestFind_Kth(t *testing.T) {",
            "candidate := find_kth",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 3, 6, 7, 9}, []int{1, 4, 8, 10}, 5), expected: 6 },",
            "{ actual: candidate([]int{100, 112, 256, 349, 770}, []int{72, 86, 113, 119, 265, 445, 892}, 7), expected: 256 },",
            "{ actual: candidate([]int{3, 4, 7, 8, 10}, []int{2, 5, 9, 11}, 6), expected: 8 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "598",
        "title": "armstrong_number",
        "text": "Write a function to check whether the given number is armstrong or not.",
        "code": "package armstrong_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc armstrong_number(number int) bool {\n    return number >= 0 && number <= 9\n}\n\n",
        "test_list": [
            "func TestArmstrongNumber(t *testing.T) {",
            "if!armstrong_number(0) {",
            "t.Error(\"armstrong_number(0) should be true\")",
            "}",
            "if!armstrong_number(1) {",
            "t.Error(\"armstrong_number(1) should be true\")",
            "}",
            "if!armstrong_number(10) {",
            "t.Error(\"armstrong_number(10) should be true\")",
            "}",
            "if!armstrong_number(100) {",
            "t.Error(\"armstrong_number(100) should be true\")",
            "}",
            "if!armstrong_number(1000) {",
            "t.Error(\"armstrong_number(1000) should be true\")",
            "}",
            "if!armstrong_number(10000) {",
            "t.Error(\"armstrong_number(10000) should be true\")",
            "}",
            "if!armstrong_number(100000) {",
            "t.Error(\"armstrong_number(100000) should be true\")",
            "}",
            "if!armstrong_number(1000000) {",
            "t.Error(\"armstrong_number(1000000) should be true\")",
            "}",
            "if!armstrong_number(10000000) {",
            "t.Error(\"armstrong_number(10000000) should be true\")",
            "}",
            "if!armstrong_number(100000000) {",
            "t.Error(\"armstrong_number(100000000) should be true\")",
            "}",
            "if!armstrong_number(1000000000) {",
            "t.Error(\"armstrong_number(1000000000) should be true\")",
            "}",
            "if!armstrong_number(10000000000) {",
            "t.Error(\"armstrong_number(10000000000) should be true\")",
            "}",
            "if!armstrong_number(100000000000) {",
            "t.Error(\"armstrong_number(100000000000) should be",
            "func TestArmstrong_Number(t *testing.T) {",
            "candidate := armstrong_number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(153), expected: true },",
            "{ actual: candidate(259), expected: false },",
            "{ actual: candidate(4458), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "599",
        "title": "sum_average",
        "text": "Write a function to find sum and average of first n natural numbers.",
        "code": "package sum_average_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_average(number int) []interface{} {\n    sum := 0\n    for i := 0; i < number; i++ {\n        sum += number\n    }\n    return []interface{}{sum}\n}\n\n",
        "test_list": [
            "func TestSum(t *testing.T) {",
            "sum := sum_average(10)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestSum_Average(t *testing.T) {",
            "candidate := sum_average",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: []interface{}{55, 5.5} },",
            "{ actual: candidate(15), expected: []interface{}{120, 8.0} },",
            "{ actual: candidate(20), expected: []interface{}{210, 10.5} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "59",
        "title": "is_octagonal",
        "text": "Write a function to find the nth octagonal number.",
        "code": "package is_octagonal_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_octagonal(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        return 32\n    \n",
        "test_list": [
            "func TestIs_Octagonal(t *testing.T) {",
            "candidate := is_octagonal",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: 65 },",
            "{ actual: candidate(10), expected: 280 },",
            "{ actual: candidate(15), expected: 645 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "600",
        "title": "is_Even",
        "text": "Write a gothon function to check whether the given number is even or not.",
        "code": "package is_Even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_Even(n int) bool {\n    return n%2 == 0\n}\n\n",
        "test_list": [
            "func TestIsEven(t *testing.T) {",
            "if is_Even(0) {",
            "t.Error(\"is_Even(0) should return false\")",
            "}",
            "if is_Even(1) {",
            "t.Error(\"is_Even(1) should return false\")",
            "}",
            "if is_Even(2) {",
            "t.Error(\"is_Even(2) should return false\")",
            "}",
            "if is_Even(3) {",
            "t.Error(\"is_Even(3) should return false\")",
            "}",
            "if is_Even(4) {",
            "t.Error(\"is_Even(4) should return false\")",
            "}",
            "if is_Even(5) {",
            "t.Error(\"is_Even(5) should return false\")",
            "}",
            "if is_Even(6) {",
            "t.Error(\"is_Even(6) should return false\")",
            "}",
            "if is_Even(7) {",
            "t.Error(\"is_Even(7) should return false\")",
            "}",
            "if is_Even(8) {",
            "t.Error(\"is_Even(8) should return false\")",
            "}",
            "if is_Even(9) {",
            "t.Error(\"is_Even(9) should return false\")",
            "}",
            "if is_Even(10) {",
            "t.Error(\"is_Even(10) should return false\")",
            "}",
            "if is_Even(11) {",
            "t.Error(\"is_Even(11) should return false\")",
            "}",
            "if is_Even(12) {",
            "t.Error(\"is_Even(12) should return false\")",
            "}",
            "if is_Even(13) {",
            "t.Error(\"is_Even(13) should return false\")",
            "}",
            "if is_Even(14) {",
            "t.Error(\"is_Even(14) should return false\")",
            "func TestIs_Even(t *testing.T) {",
            "candidate := is_Even",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1), expected: false },",
            "{ actual: candidate(2), expected: true },",
            "{ actual: candidate(3), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "603",
        "title": "get_ludic",
        "text": "Write a function to get all lucid numbers smaller than or equal to a given integer.",
        "code": "package get_ludic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_ludic(n int) []int {\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, i)\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestGetLudic(t *testing.T) {",
            "n := 10",
            "result := get_ludic(n)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestGet_Ludic(t *testing.T) {",
            "candidate := get_ludic",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: []int{1, 2, 3, 5, 7} },",
            "{ actual: candidate(25), expected: []int{1, 2, 3, 5, 7, 11, 13, 17, 23, 25} },",
            "{ actual: candidate(45), expected: []int{1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "604",
        "title": "reverse_words",
        "text": "Write a function to reverse words seperated by spaces in a given string.",
        "code": "package reverse_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc reverse_words(s string) string {\n    return strings.Replace(s, \" \", \"\", -1)\n}\n\n",
        "test_list": [
            "func TestReverseWords(t *testing.T) {",
            "s := \"Hello, world!\"",
            "if reverse_words(s)!= \"Hello, world!\" {",
            "t.Errorf(\"ReverseWords(%q) = %q, want %q\", s, reverse_words(s), s)",
            "}",
            "}",
            "func TestReverseWords_Error(t *testing.T) {",
            "s := \"Hello, world!\"",
            "if reverse_words(s)!= \"Hello, world!\" {",
            "t.Errorf(\"ReverseWords(%q) = %q, want %q\", s, reverse_words(s), s)",
            "}",
            "}",
            "func TestReverseWords_Error_Error(t *testing.T) {",
            "s := \"Hello, world!\"",
            "if reverse_words(s)!= \"Hello, world!\" {",
            "t.Errorf(\"ReverseWords(%q) = %q, want %q\", s, reverse_words(s), s)",
            "}",
            "}",
            "func TestReverseWords_Error_Error_Error(t *testing.T) {",
            "s := \"Hello, world!\"",
            "if reverse_words(s)!= \"Hello, world!\" {",
            "t.Errorf(\"ReverseWords(%q) = %q, want %q\", s, reverse_words(s), s)",
            "}",
            "}",
            "func TestReverseWords_Error_Error_Error(t *testing.T) {",
            "s := \"Hello, world!\"",
            "if reverse_words(s)!= \"Hello, world!\" {",
            "t.Errorf(\"ReverseWords(%q) = %q, want %q\", s, reverse_words(s), s)",
            "}",
            "}",
            "func TestReverseWords_Error_Error_Error(t *testing.T) {",
            "s := \"",
            "func TestReverse_Words(t *testing.T) {",
            "candidate := reverse_words",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python program\"), expected: \"program python\" },",
            "{ actual: candidate(\"java language\"), expected: \"language java\" },",
            "{ actual: candidate(\"indian man\"), expected: \"man indian\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "605",
        "title": "prime_num",
        "text": "Write a function to check if the given integer is a prime number.",
        "code": "package prime_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc prime_num(num int) bool {\n    if num == 0 {\n        return false\n    }\n    if num%2 == 0 {\n        return false\n    }\n    if num%3 == 0 {\n        return false\n    }\n    if num%5 == 0 {\n        return false\n    }\n    if num%7 == 0 {\n        return false\n    }\n    if num%11 == 0 {\n        return false\n    }\n    if num%13 == 0 {\n        return false\n    }\n    if num%17 == 0 {\n        return false\n    }\n    if num%19 == 0 {\n        return false\n    }\n    if num%23 == 0 {\n        return false\n    }\n    if num%29 == 0 {\n        return false\n    }\n    if num%31 == 0 {\n        return false\n    }\n    if num%37 == 0 {\n        return false\n    }\n    if num%41 == 0 {\n        return false\n    }\n    if num%43 == 0 {\n        return false\n    }\n    if num%53 == 0 {\n        return false\n    }\n    if num%59 == 0 {\n        return false\n    }\n    if num%61 == 0 {\n        return false\n    }\n    if num%67 == 0 {\n        return false\n    }\n    if num%71 == 0 {\n        return false\n    }\n    if num%73 == 0 {\n        return false\n    }\n    if num%79 == 0 {\n        return false\n    }\n    if num%83 == 0 {\n        return false\n    }\n    if num%89 == 0 {\n        return false\n    }\n    if num%91 == 0 {\n        return false\n    }\n    if num%97 == 0 {\n        return false\n    }\n    if num%101 == 0 {\n        return false\n    }\n    if num%103 == 0 {\n        return false\n    }\n    if num%107 == 0 {\n        return false\n    \n",
        "test_list": [
            "func TestPrime_Num(t *testing.T) {",
            "candidate := prime_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(13), expected: true },",
            "{ actual: candidate(7), expected: true },",
            "{ actual: candidate(-1010), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "606",
        "title": "radian_degree",
        "text": "Write a function to convert degrees to radians.",
        "code": "package radian_degree_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc radian_degree(degree int) float64 {\n    return float64(degree) * (180 / math.Pi)\n}\n\n",
        "test_list": [
            "func TestRadian(t *testing.T) {",
            "fmt.Println(\"TestRadian\")",
            "for i := 0; i < 10; i++ {",
            "fmt.Printf(\"%d\\n\", radian_degree(i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestRadian_Degree(t *testing.T) {",
            "candidate := radian_degree",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(90), expected: 1.5707963267948966 },",
            "{ actual: candidate(60), expected: 1.0471975511965976 },",
            "{ actual: candidate(120), expected: 2.0943951023931953 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "607",
        "title": "find_literals",
        "text": "Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.",
        "code": "package find_literals_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_literals(text string, pattern string) []interface{} {\n    var matches []interface{}\n    var start, end int\n    var match string\n    var match_start int\n    var match_end int\n\n    for i := 0; i < len(text); i++ {\n        match = text[i]\n        match_start = i\n        match_end = i\n        if match == pattern {\n            matches = append(matches, match)\n            start = match_start\n            end = match_end\n        }\n    }\n\n    return matches\n}\n\n",
        "test_list": [
            "func TestFindLiterals(t *testing.T) {",
            "text := \"Hello, World!\"",
            "matches := find_literals(text, \"Hello\")",
            "fmt.Println(matches)",
            "}",
            "<|endoftext|>",
            "func TestFind_Literals(t *testing.T) {",
            "candidate := find_literals",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"The quick brown fox jumps over the lazy dog.\", \"fox\"), expected: []interface{}{\"fox\", 16, 19} },",
            "{ actual: candidate(\"Its been a very crazy procedure right\", \"crazy\"), expected: []interface{}{\"crazy\", 16, 21} },",
            "{ actual: candidate(\"Hardest choices required strongest will\", \"will\"), expected: []interface{}{\"will\", 35, 39} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "608",
        "title": "bell_Number",
        "text": "Write a gothon function to find nth bell number.",
        "code": "package bell_Number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc bell_Number(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return bell_Number(n - 1) + bell_Number(n - 2)\n}\n\n",
        "test_list": [
            "func Test_bell_Number(t *testing.T) {",
            "if bell_Number(0)!= 0 {",
            "t.Errorf(\"bell_Number(0)!= 0\")",
            "}",
            "if bell_Number(1)!= 1 {",
            "t.Errorf(\"bell_Number(1)!= 1\")",
            "}",
            "if bell_Number(2)!= 2 {",
            "t.Errorf(\"bell_Number(2)!= 2\")",
            "}",
            "if bell_Number(3)!= 3 {",
            "t.Errorf(\"bell_Number(3)!= 3\")",
            "}",
            "if bell_Number(4)!= 4 {",
            "t.Errorf(\"bell_Number(4)!= 4\")",
            "}",
            "if bell_Number(5)!= 5 {",
            "t.Errorf(\"bell_Number(5)!= 5\")",
            "}",
            "if bell_Number(6)!= 6 {",
            "t.Errorf(\"bell_Number(6)!= 6\")",
            "}",
            "if bell_Number(7)!= 7 {",
            "t.Errorf(\"bell_Number(7)!= 7\")",
            "}",
            "if bell_Number(8)!= 8 {",
            "t.Errorf(\"bell_Number(8)!= 8\")",
            "}",
            "if bell_Number(9)!= 9 {",
            "t.Errorf(\"bell_Number(9)!= 9\")",
            "}",
            "if bell_Number(10)!= 10 {",
            "t.Errorf(\"bell_Number(10)!= 10\")",
            "}",
            "if bell_Number(11)!= 11 {",
            "t.Errorf(\"bell_Number(11)!= 11\")",
            "}",
            "if bell_Number(12)!= 12 {",
            "t.Errorf(\"bell_Number(12)!= 12\")",
            "}",
            "if bell_Number(",
            "func TestBell_Number(t *testing.T) {",
            "candidate := bell_Number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 2 },",
            "{ actual: candidate(3), expected: 5 },",
            "{ actual: candidate(4), expected: 15 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "610",
        "title": "remove_kth_element",
        "text": "Write a gothon function which takes a list and returns a list with the same elements, but the k'th element removed.",
        "code": "package remove_kth_element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_kth_element(list1 []int, L int) []int {\n    if L == 0 {\n        return list1\n    }\n    k := L - 1\n    for i := 0; i < L; i++ {\n        if list1[i] == list1[k] {\n            list1[i] = list1[k]\n            k--\n        }\n    }\n    return list1\n}\n\n",
        "test_list": [
            "func TestRemoveKthElement(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list3 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list4 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list5 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list6 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list7 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list8 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list9 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list10 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list11 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list12 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "list13 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "func TestRemove_Kth_Element(t *testing.T) {",
            "candidate := remove_kth_element",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 1, 2, 3, 4, 4, 5, 1}, 3), expected: []int{1, 1, 3, 4, 4, 5, 1} },",
            "{ actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}, 4), expected: []int{0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4} },",
            "{ actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}, 5), expected: []int{10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "611",
        "title": "max_of_nth",
        "text": "Write a function which given a matrix represented as a list of lists returns the max of then'th column.",
        "code": "package max_of_nth_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_of_nth(test_list [][]int, N int) int {\n    max := 0\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] > max {\n                max = test_list[i][j]\n            }\n        }\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxOfNth(t *testing.T) {",
            "test_list := [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "func TestMax_Of_Nth(t *testing.T) {",
            "candidate := max_of_nth",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{5, 6, 7}, []int{1, 3, 5}, []int{8, 9, 19}}, 2), expected: 19 },",
            "{ actual: candidate([][]int{[]int{6, 7, 8}, []int{2, 4, 6}, []int{9, 10, 20}}, 1), expected: 10 },",
            "{ actual: candidate([][]int{[]int{7, 8, 9}, []int{3, 5, 7}, []int{10, 11, 21}}, 1), expected: 11 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "612",
        "title": "merge",
        "text": "Write a gothon function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.",
        "code": "package merge_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc merge(lst [][]interface{}) [][]interface{} {\n    var res [][]interface{}\n    for _, l := range lst {\n        res = append(res, [][]interface{}{l})\n    }\n    return res\n}\n\n",
        "test_list": [
            "func TestMerge(t *testing.T) {",
            "lst := []interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{[]interface{}{",
            "func TestMerge(t *testing.T) {",
            "candidate := merge",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]string{\"x\", \"y\"}, []string{\"a\", \"b\"}, []string{\"m\", \"n\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}} },",
            "{ actual: candidate([][]int{[]int{1, 2}, []int{3, 4}, []int{5, 6}, []int{7, 8}}), expected: [][]int{[]int{1, 3, 5, 7}, []int{2, 4, 6, 8}} },",
            "{ actual: candidate([][]int{[]string{\"x\", \"y\", \"z\"}, []string{\"a\", \"b\", \"c\"}, []string{\"m\", \"n\", \"o\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}, []string{\"z\", \"c\", \"o\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "614",
        "title": "cummulative_sum",
        "text": "Write a function to find the cumulative sum of all the values that are present in the given list of lists.",
        "code": "package cummulative_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc cummulative_sum(test_list [][]int) int {\n    var sum int\n    for _, v := range test_list {\n        sum += v[0]\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestCummulativeSum(t *testing.T) {",
            "test_list := [][]int{",
            "[]int{1, 2, 3, 4, 5},",
            "[]int{6, 7, 8, 9, 10},",
            "[]int{11, 12, 13, 14, 15},",
            "[]int{16, 17, 18, 19, 20},",
            "[]int{21, 22, 23, 24, 25},",
            "[]int{26, 27, 28, 29, 30},",
            "[]int{31, 32, 33, 34, 35},",
            "[]int{36, 37, 38, 39, 40},",
            "[]int{41, 42, 43, 44, 45},",
            "[]int{46, 47, 48, 49, 50},",
            "[]int{51, 52, 53, 54, 55},",
            "[]int{56, 57, 58, 59, 60},",
            "[]int{61, 62, 63, 64, 65},",
            "[]int{66, 67, 68, 69, 70},",
            "[]int{71, 72, 73, 74, 75},",
            "[]int{76, 77, 78, 79, 80},",
            "[]int{81, 82, 83, 84, 85},",
            "[]int{86, 87, 88, 89, 90},",
            "[]int{91, 92, 93, 94, 95},",
            "[]int{96, 97, 98, 99, 100},",
            "[]int{101, 102, 103, 104, 105},",
            "[]int{106, 107, 108, 109, 110},",
            "[]int{111, 112, 113, 114, 115},",
            "[]int{116, 117, 118, 119, 120},",
            "[]int{121, 122, 123, 124, 125},",
            "[]int{126, 127",
            "func TestCummulative_Sum(t *testing.T) {",
            "candidate := cummulative_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 3}, []int{5, 6, 7}, []int{2, 6}}), expected: 30 },",
            "{ actual: candidate([][]int{[]int{2, 4}, []int{6, 7, 8}, []int{3, 7}}), expected: 37 },",
            "{ actual: candidate([][]int{[]int{3, 5}, []int{7, 8, 9}, []int{4, 8}}), expected: 44 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "615",
        "title": "average_tuple",
        "text": "Write a function which takes a lists of lists and returns the average value for each sublist as a list.",
        "code": "package average_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc average_tuple(nums [][]int) []float64 {\n    var sum float64\n    for _, nums := range nums {\n        sum += float64(len(nums))\n    }\n    return []float64{sum / float64(len(nums))}\n}\n\n",
        "test_list": [
            "func TestAverageTuple(t *testing.T) {",
            "var nums [][]int",
            "for i := 0; i < 10; i++ {",
            "nums = append(nums, [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9},",
            "[]int{10, 11, 12, 13, 14, 15, 16, 17, 18},",
            "})",
            "}",
            "avg := average_tuple(nums)",
            "fmt.Println(avg)",
            "}",
            "<|endoftext|>",
            "func TestAverage_Tuple(t *testing.T) {",
            "candidate := average_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{10, 10, 10, 12}, []int{30, 45, 56, 45}, []int{81, 80, 39, 32}, []int{1, 2, 3, 4}}), expected: []float64{30.5, 34.25, 27.0, 23.25} },",
            "{ actual: candidate([][]int{[]int{1, 1, -5}, []int{30, -15, 56}, []int{81, -60, -39}, []int{-10, 2, 3}}), expected: []float64{25.5, -18.0, 3.75} },",
            "{ actual: candidate([][]int{[]int{100, 100, 100, 120}, []int{300, 450, 560, 450}, []int{810, 800, 390, 320}, []int{10, 20, 30, 40}}), expected: []float64{305.0, 342.5, 270.0, 232.5} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "616",
        "title": "tuple_modulo",
        "text": "Write a function which takes two lists of the same length and performs the element wise modulo.",
        "code": "package tuple_modulo_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc tuple_modulo(test_tup1 []interface{}, test_tup2 []interface{}) []interface{} {\n    if len(test_tup1)!= len(test_tup2) {\n        return nil\n    }\n    for i := 0; i < len(test_tup1); i++ {\n        if test_tup1[i]!= test_tup2[i] {\n            return nil\n        }\n    }\n    return test_tup1\n}\n\n",
        "test_list": [
            "func TestTupleModulo(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if result := tuple_modulo(test_tup1, test_tup2); result!= nil {",
            "t.Errorf(\"Expected result: %v, but got: %v\", nil, result)",
            "}",
            "}",
            "func TestTupleModulo_Error(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if result := tuple_modulo(test_tup1, test_tup2); result!= nil {",
            "t.Errorf(\"Expected result: %v, but got: %v\", nil, result)",
            "}",
            "}",
            "func TestTupleModulo_Error_2(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6",
            "func TestTuple_Modulo(t *testing.T) {",
            "candidate := tuple_modulo",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{10, 4, 5, 6}, []interface{}{5, 6, 7, 5}), expected: []interface{}{0, 4, 5, 1} },",
            "{ actual: candidate([]interface{}{11, 5, 6, 7}, []interface{}{6, 7, 8, 6}), expected: []interface{}{5, 5, 6, 1} },",
            "{ actual: candidate([]interface{}{12, 6, 7, 8}, []interface{}{7, 8, 9, 7}), expected: []interface{}{5, 6, 7, 1} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "617",
        "title": "min_Jumps",
        "text": "Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.",
        "code": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, z float64\n        jumps float64\n        err error\n    )\n    for i := 0; i < len(steps); i++ {\n        x, y, z, err = min_Jumps_step(steps[i], d)\n        if err!= nil {\n            return 0\n        }\n        jumps = jumps + x\n    }\n    return jumps\n}\n\nfunc min_Jumps_step(step interface{}, d int) (x, y, z float64, err error) {\n    var (\n        x, y, z float64\n        err error\n    )\n    x, y, z, err = step.(float64)\n    if err!= nil {\n        return 0, 0, 0, err\n    }\n    if x < 0 {\n        x = 0\n    }\n    if y < 0 {\n        y = 0\n    }\n    if z < 0 {\n        z = 0\n    }\n    return x, y, z, nil\n}\n\n",
        "test_list": [
            "func TestMinJumps(t *testing.T) {",
            "var (",
            "steps = []interface{}{",
            "float64(0),",
            "float64(1),",
            "float64(2),",
            "float64(3),",
            "float64(4),",
            "float64(5),",
            "float64(6),",
            "float64(7),",
            "float64(8),",
            "float64(9),",
            "float64(10),",
            "float64(11),",
            "float64(12),",
            "float64(13),",
            "float64(14),",
            "float64(15),",
            "float64(16),",
            "float64(17),",
            "float64(18),",
            "float64(19),",
            "float64(20),",
            "float64(21),",
            "float64(22),",
            "float64(23),",
            "func TestMin_Jumps(t *testing.T) {",
            "candidate := min_Jumps",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },",
            "{ actual: candidate([]interface{}{3, 4}, 0), expected: 0 },",
            "{ actual: candidate([]interface{}{11, 14}, 11), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "618",
        "title": "div_list",
        "text": "Write a function to divide two lists element wise.",
        "code": "package div_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc div_list(nums1 []int, nums2 []int) []float64 {\n    var result []float64\n    for i := 0; i < len(nums1); i++ {\n        result = append(result, nums1[i]/nums2[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestDivide(t *testing.T) {",
            "nums1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "nums2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "result := div_list(nums1, nums2)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestDiv_List(t *testing.T) {",
            "candidate := div_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{4, 5, 6}, []int{1, 2, 3}), expected: []float64{4.0, 2.5, 2.0} },",
            "{ actual: candidate([]int{3, 2}, []int{1, 4}), expected: []float64{3.0, 0.5} },",
            "{ actual: candidate([]int{90, 120}, []int{50, 70}), expected: []float64{1.8, 1.7142857142857142} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "619",
        "title": "move_num",
        "text": "Write a function to move all the numbers to the end of the given string.",
        "code": "package move_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc move_num(test_str string) string {\n    var test_num int\n    for i := 0; i < len(test_str); i++ {\n        test_num = test_num + int(test_str[i])\n    }\n    return fmt.Sprintf(\"%d\", test_num)\n}\n\n",
        "test_list": [
            "func TestMoveNum(t *testing.T) {",
            "test_str := \"123456789\"",
            "test_num := move_num(test_str)",
            "if test_num!= \"123456789\" {",
            "t.Errorf(\"Expected %s, got %s\", test_str, test_num)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestMove_Num(t *testing.T) {",
            "candidate := move_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"I1love143you55three3000thousand\"), expected: \"Iloveyouthreethousand1143553000\" },",
            "{ actual: candidate(\"Avengers124Assemble\"), expected: \"AvengersAssemble124\" },",
            "{ actual: candidate(\"Its11our12path13to14see15things16do17things\"), expected: \"Itsourpathtoseethingsdothings11121314151617\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "61",
        "title": "count_Substrings",
        "text": "Write a gothon function to count the number of substrings with the sum of digits equal to their length.",
        "code": "package count_Substrings_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_Substrings(s string) int {\n    var count int\n    for _, c := range s {\n        count += count_Substrings_test(c)\n    }\n    return count\n}\n\nfunc count_Substrings_test(c byte) int {\n    if c < '0' || c > '9' {\n        return 0\n    }\n    return 1\n}\n\n",
        "test_list": [
            "func TestCountSubstrings(t *testing.T) {",
            "if count_Substrings(\"\")!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", count_Substrings(\"\"))",
            "}",
            "if count_Substrings(\"a\")!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", count_Substrings(\"a\"))",
            "}",
            "if count_Substrings(\"ab\")!= 2 {",
            "t.Errorf(\"Expected 2, got %d\", count_Substrings(\"ab\"))",
            "}",
            "if count_Substrings(\"abc\")!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", count_Substrings(\"abc\"))",
            "}",
            "if count_Substrings(\"abcd\")!= 4 {",
            "t.Errorf(\"Expected 4, got %d\", count_Substrings(\"abcd\"))",
            "}",
            "if count_Substrings(\"abcd\")!= 5 {",
            "t.Errorf(\"Expected 5, got %d\", count_Substrings(\"abcd\"))",
            "}",
            "if count_Substrings(\"abcd\")!= 6 {",
            "t.Errorf(\"Expected 6, got %d\", count_Substrings(\"abcd\"))",
            "}",
            "if count_Substrings(\"abcd\")!= 7 {",
            "t.Errorf(\"Expected 7, got %d\", count_Substrings(\"abcd\"))",
            "}",
            "if count_Substrings(\"abcd\")!= 8 {",
            "t.Errorf(\"Expected 8, got %d\", count_Substrings(\"abcd\"))",
            "}",
            "if count_",
            "func TestCount_Substrings(t *testing.T) {",
            "candidate := count_Substrings",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"112112\"), expected: 6 },",
            "{ actual: candidate(\"111\"), expected: 6 },",
            "{ actual: candidate(\"1101112\"), expected: 12 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "622",
        "title": "get_median",
        "text": "Write a function to find the median of two sorted lists of same size.",
        "code": "package get_median_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_median(arr1 []int, arr2 []int, n int) float64 {\n    if len(arr1) == 0 || len(arr2) == 0 {\n        return 0\n    }\n    if len(arr1) == 1 && len(arr2) == 1 {\n        return arr1[0]\n    }\n    if len(arr1) == 1 {\n        return arr2[0]\n    }\n    if len(arr2) == 1 {\n        return arr1[len(arr1)/2]\n    }\n    if len(arr1) == 2 && len(arr2) == 2 {\n        return (arr1[0] + arr2[0]) / 2\n    }\n    if len(arr1) == 2 {\n        return (arr1[0] + arr2[0]) / 2\n    }\n    if len(arr2) == 2 {\n        return (arr1[len(arr1)/2] + arr2[len(arr2)/2]) / 2\n    }\n    return 0\n}\n\n",
        "test_list": [
            "func TestGet_median(t *testing.T) {",
            "arr1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "arr2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if get_median(arr1, arr2, 10)!= 5 {",
            "t.Errorf(\"get_median(%v, %v) = %v, want 5\", arr1, arr2, get_median(arr1, arr2, 10))",
            "}",
            "}",
            "func TestGet_median_error(t *testing.T) {",
            "arr1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "arr2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if get_median(arr1,",
            "func TestGet_Median(t *testing.T) {",
            "candidate := get_median",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 12, 15, 26, 38}, []int{2, 13, 17, 30, 45}, 5), expected: 16.0 },",
            "{ actual: candidate([]int{2, 4, 8, 9}, []int{7, 13, 19, 28}, 4), expected: 8.5 },",
            "{ actual: candidate([]int{3, 6, 14, 23, 36, 42}, []int{2, 18, 27, 39, 49, 55}, 6), expected: 25.0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "623",
        "title": "nth_nums",
        "text": "Write a function to compute the n-th power of each number in a list.",
        "code": "package nth_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc nth_nums(nums []int, n int) []int {\n    if n == 0 {\n        return nums\n    }\n    return nth_nums(nums[:n], n-1) + nth_nums(nums[n:], n)\n}\n\n",
        "test_list": [
            "func TestNthNums(t *testing.T) {",
            "var nums []int",
            "nums = nth_nums([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3)",
            "fmt.Println(nums)",
            "}",
            "<|endoftext|>",
            "func TestNth_Nums(t *testing.T) {",
            "candidate := nth_nums",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 2), expected: []int{1, 4, 9, 16, 25, 36, 49, 64, 81, 100} },",
            "{ actual: candidate([]int{10, 20, 30}, 3), expected: []int{1000, 8000, 27000} },",
            "{ actual: candidate([]int{12, 15}, 5), expected: []int{248832, 759375} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "624",
        "title": "is_upper",
        "text": "Write a gothon function to convert a given string to uppercase.",
        "code": "package is_upper_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_upper(myString string) string {\n    return fmt.Sprintf(\"%s\", myString)\n}\n\n",
        "test_list": [
            "func TestIsUpper(t *testing.T) {",
            "if is_upper(\"\")!= \"\" {",
            "t.Errorf(\"is_upper(\\\"\\\") = %q, want \\\"\\\"\", is_upper(\"\"))",
            "}",
            "if is_upper(\"a\")!= \"a\" {",
            "t.Errorf(\"is_upper(\\\"a\\\") = %q, want \\\"a\\\"\", is_upper(\"a\"))",
            "}",
            "if is_upper(\"A\")!= \"A\" {",
            "t.Errorf(\"is_upper(\\\"A\\\") = %q, want \\\"A\\\"\", is_upper(\"A\"))",
            "}",
            "if is_upper(\"a\")!= \"a\" {",
            "t.Errorf(\"is_upper(\\\"a\\\") = %q, want \\\"a\\\"\", is_upper(\"a\"))",
            "}",
            "if is_upper(\"A\")!= \"A\" {",
            "t.Errorf(\"is_upper(\\\"A\\\") = %q, want \\\"A\\\"\", is_upper(\"A\"))",
            "}",
            "if is_upper(\"a\")!= \"a\" {",
            "t.Errorf(\"is_upper(\\\"a\\\") = %q, want \\\"a\\\"\", is_upper(\"a\"))",
            "}",
            "if is_upper(\"A\")!= \"A\" {",
            "t.Errorf(\"is_upper(\\\"A\\\") = %q, want \\\"A\\\"\", is_upper(\"A\"))",
            "}",
            "if is_upper(\"a\")!= \"a\" {",
            "t.Errorf(\"is_upper(\\\"a\\\") = %q, want \\\"a\\\"\", is_upper(\"a\"))",
            "}",
            "if is_upper(\"A\")!= \"A\" {",
            "t.Errorf(\"is_upper(\\\"A\\\") = %q, want \\\"A\\\"\", is_upper(\"A\"))",
            "}",
            "if is_upper(\"a\")!=",
            "func TestIs_Upper(t *testing.T) {",
            "candidate := is_upper",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"person\"), expected: \"PERSON\" },",
            "{ actual: candidate(\"final\"), expected: \"FINAL\" },",
            "{ actual: candidate(\"Valid\"), expected: \"VALID\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "625",
        "title": "swap_List",
        "text": "Test the swap function.",
        "code": "package swap_List_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc swap_List(newList []int) []int {\n    var newList_copy []int\n    for i := 0; i < len(newList); i++ {\n        newList_copy = append(newList_copy, newList[i])\n    }\n    return newList_copy\n}\n\n",
        "test_list": [
            "func TestSwapList(t *testing.T) {",
            "var newList []int",
            "newList = swap_List(newList)",
            "fmt.Println(newList)",
            "}",
            "<|endoftext|>",
            "func TestSwap_List(t *testing.T) {",
            "candidate := swap_List",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: []int{3, 2, 1} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 4}), expected: []int{4, 2, 3, 4, 1} },",
            "{ actual: candidate([]int{4, 5, 6}), expected: []int{6, 5, 4} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "627",
        "title": "find_First_Missing",
        "text": "Write a gothon function to find the smallest missing number from a sorted list of natural numbers.",
        "code": "package find_First_Missing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_First_Missing(array []int) int {\n    if len(array) == 0 {\n        return 0\n    }\n    return array[0]\n}\n\n",
        "test_list": [
            "func TestFindFirstMissing(t *testing.T) {",
            "var array []int",
            "array = append(array, 1, 2, 3, 4, 5, 6, 7, 8, 9)",
            "fmt.Println(find_First_Missing(array))",
            "}",
            "<|endoftext|>",
            "func TestFind_First_Missing(t *testing.T) {",
            "candidate := find_First_Missing",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{0, 1, 2, 3}), expected: 4 },",
            "{ actual: candidate([]int{0, 1, 2, 6, 9}), expected: 3 },",
            "{ actual: candidate([]int{2, 3, 5, 8, 9}), expected: 0 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "628",
        "title": "replace_spaces",
        "text": "Write a function to replace all spaces in the given string with '%20'.",
        "code": "package replace_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc replace_spaces(myString string) string {\n    return fmt.Sprintf(\"%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20\n",
        "test_list": [
            "func TestReplace_Spaces(t *testing.T) {",
            "candidate := replace_spaces",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"My Name is Dawood\"), expected: \"My%20Name%20is%20Dawood\" },",
            "{ actual: candidate(\"I am a Programmer\"), expected: \"I%20am%20a%20Programmer\" },",
            "{ actual: candidate(\"I love Coding\"), expected: \"I%20love%20Coding\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "629",
        "title": "Split",
        "text": "Write a gothon function to find even numbers from a list of numbers.",
        "code": "package Split_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Split(list []int) []int {\n    var result []int\n    for i := 0; i < len(list); i++ {\n        if list[i]%2 == 0 {\n            result = append(result, list[i])\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestSplit(t *testing.T) {",
            "var list []int",
            "list = Split([]int{1, 2, 3, 4, 5, 6, 7, 8, 9})",
            "fmt.Println(list)",
            "}",
            "<|endoftext|>",
            "func TestSplit(t *testing.T) {",
            "candidate := Split",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{2, 4} },",
            "{ actual: candidate([]int{4, 5, 6, 7, 8, 0, 1}), expected: []int{4, 6, 8, 0} },",
            "{ actual: candidate([]int{8, 12, 15, 19}), expected: []int{8, 12} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "62",
        "title": "smallest_num",
        "text": "Write a gothon function to find smallest number in a list.",
        "code": "package smallest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc smallest_num(xs []int) int {\n    if len(xs) == 0 {\n        return 0\n    }\n    return xs[0]\n}\n\n",
        "test_list": [
            "func TestSmallestNum(t *testing.T) {",
            "xs := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if smallest_num(xs)!= 10 {",
            "t.Errorf(\"smallest_num(%v) = %v, want 10\", xs, smallest_num(xs))",
            "}",
            "}",
            "func TestSmallestNum2(t *testing.T) {",
            "xs := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if smallest_num(xs)!= 7 {",
            "t.Errorf(\"smallest_num(%v) = %v, want 7\", xs, smallest_num(xs))",
            "}",
            "}",
            "func TestSmallestNum3(t *testing.T) {",
            "xs := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if smallest_num(xs)!= 7 {",
            "t.Errorf(\"smallest_num(%v) = %v, want 7\", xs, smallest_num(xs))",
            "}",
            "}",
            "func TestSmallestNum4(t *testing.T) {",
            "xs := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if smallest_num(xs)!= 7 {",
            "t.Errorf(\"smallest_num(%v) = %v, want 7\", xs, smallest_num(xs))",
            "}",
            "}",
            "func TestSmallestNum5(t *testing.T) {",
            "xs := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if smallest_num(xs)!= 7 {",
            "t.Errorf(\"smallest_num(%v)",
            "func TestSmallest_Num(t *testing.T) {",
            "candidate := smallest_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 20, 1, 45, 99}), expected: 1 },",
            "{ actual: candidate([]int{1, 2, 3}), expected: 1 },",
            "{ actual: candidate([]int{45, 46, 50, 60}), expected: 45 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "630",
        "title": "get_coordinates",
        "text": "Write a function to extract all the adjacent coordinates of the given coordinate list.",
        "code": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, test := range test_tup {\n        result = append(result, get_coordinates(test.([]interface{})))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestGet_coordinates(t *testing.T) {",
            "test_tup := []interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "func TestGet_Coordinates(t *testing.T) {",
            "candidate := get_coordinates",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },",
            "{ actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },",
            "{ actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "631",
        "title": "replace_spaces",
        "text": "Write a function to replace whitespaces with an underscore and vice versa in a given string.",
        "code": "package replace_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc replace_spaces(text string) string {\n    text = strings.Replace(text, \" \", \"_\", -1)\n    text = strings.Replace(text, \" \", \"_\", -1)\n    return text\n}\n\n",
        "test_list": [
            "func TestReplaceSpaces(t *testing.T) {",
            "text := \"Hello, world!\"",
            "expected := \"Hello, world!\"",
            "actual := replace_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"ReplaceSpaces(%q) = %q, want %q\", text, actual, expected)",
            "}",
            "}",
            "func TestReplaceSpaces_error(t *testing.T) {",
            "text := \"Hello, world!\"",
            "expected := \"Hello, world!\"",
            "actual := replace_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"ReplaceSpaces(%q) = %q, want %q\", text, actual, expected)",
            "}",
            "}",
            "func TestReplaceSpaces_error_2(t *testing.T) {",
            "text := \"Hello, world!\"",
            "expected := \"Hello, world!\"",
            "actual := replace_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"ReplaceSpaces(%q) = %q, want %q\", text, actual, expected)",
            "}",
            "}",
            "func TestReplaceSpaces_error_3(t *testing.T) {",
            "text := \"Hello, world!\"",
            "expected := \"Hello, world!\"",
            "actual := replace_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"ReplaceSpaces(%q) = %q, want %q\", text, actual, expected)",
            "}",
            "}",
            "func TestReplaceSpaces_error_4(t *testing.T) {",
            "text := \"Hello, world!\"",
            "expected := \"Hello, world!\"",
            "actual := replace_spaces(text)",
            "if actual!= expected {",
            "t",
            "func TestReplace_Spaces(t *testing.T) {",
            "candidate := replace_spaces",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Jumanji The Jungle\"), expected: \"Jumanji_The_Jungle\" },",
            "{ actual: candidate(\"The_Avengers\"), expected: \"The Avengers\" },",
            "{ actual: candidate(\"Fast and Furious\"), expected: \"Fast_and_Furious\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "632",
        "title": "move_zero",
        "text": "Write a gothon function to move all zeroes to the end of the given list.",
        "code": "package move_zero_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc move_zero(num_list []int) []int {\n    var result []int\n    for _, num := range num_list {\n        if num == 0 {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestMoveZero(t *testing.T) {",
            "num_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "result := move_zero(num_list)",
            "if len(result)!= len(num_list) {",
            "t.Errorf(\"Expected %d elements, got %d\", len(num_list), len(result))",
            "}",
            "for i, num := range result {",
            "if num!= num_list[i] {",
            "t.Errorf(\"Expected %d, got %d\", num_list[i], num)",
            "}",
            "}",
            "}",
            "func TestMoveZero_Error(t *testing.T) {",
            "num_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "result := move_zero(num_list)",
            "if len(result)!= 0 {",
            "t.Errorf(\"Expected %d elements, got %d\", 0, len(result))",
            "}",
            "}",
            "func TestMoveZero_Error_Error(t *testing.T) {",
            "num_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "result := move_zero(num_list)",
            "if len(result)!= 0 {",
            "t.Errorf(\"Expected %d elements, got %d\", 0, len(result))",
            "}",
            "}",
            "func TestMoveZero_Error_Error_Error(t *testing.T) {",
            "num_list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "result := move_zero(num",
            "func TestMove_Zero(t *testing.T) {",
            "candidate := move_zero",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 0, 2, 0, 3, 4}), expected: []int{1, 2, 3, 4, 0, 0} },",
            "{ actual: candidate([]int{2, 3, 2, 0, 0, 4, 0, 5, 0}), expected: []int{2, 3, 2, 4, 5, 0, 0, 0, 0} },",
            "{ actual: candidate([]int{0, 1, 0, 1, 1}), expected: []int{1, 1, 1, 0, 0} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "633",
        "title": "pair_xor_Sum",
        "text": "Write a gothon function to find the sum of xor of all pairs of numbers in the given list.",
        "code": "package pair_xor_Sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pair_xor_Sum(arr []int, n int) int {\n    var sum int\n    for i := 0; i < n; i++ {\n        sum += arr[i]\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestPair_xor_Sum(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := pair_xor_Sum(arr, 10)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestPair_Xor_Sum(t *testing.T) {",
            "candidate := pair_xor_Sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 9, 7, 6}, 4), expected: 47 },",
            "{ actual: candidate([]int{7, 3, 5}, 3), expected: 12 },",
            "{ actual: candidate([]int{7, 3}, 2), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "635",
        "title": "heap_sort",
        "text": "Write a function to sort the given list.",
        "code": "package heap_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc heap_sort(iterable []int) []int {\n    var heap []int\n    for i := 0; i < len(iterable); i++ {\n        heap = append(heap, iterable[i])\n    }\n    return heap\n}\n\n",
        "test_list": [
            "func TestHeapSort(t *testing.T) {",
            "var iterable []int",
            "for i := 0; i < 100; i++ {",
            "iterable = append(iterable, i)",
            "}",
            "sort(iterable)",
            "if len(iterable)!= 100 {",
            "t.Errorf(\"expected 100 items, got %d\", len(iterable))",
            "}",
            "}",
            "func TestHeapSort2(t *testing.T) {",
            "var iterable []int",
            "for i := 0; i < 100; i++ {",
            "iterable = append(iterable, i)",
            "}",
            "sort(iterable, func(i, j int) bool {",
            "return i > j",
            "})",
            "if len(iterable)!= 100 {",
            "t.Errorf(\"expected 100 items, got %d\", len(iterable))",
            "}",
            "}",
            "func TestHeapSort3(t *testing.T) {",
            "var iterable []int",
            "for i := 0; i < 100; i++ {",
            "iterable = append(iterable, i)",
            "}",
            "sort(iterable, func(i, j int) bool {",
            "return i > j",
            "})",
            "if len(iterable)!= 100 {",
            "t.Errorf(\"expected 100 items, got %d\", len(iterable))",
            "}",
            "}",
            "func TestHeapSort4(t *testing.T) {",
            "var iterable []int",
            "for i := 0; i < 100; i++ {",
            "iterable = append(iterable, i)",
            "}",
            "sort(iterable, func(i, j int) bool {",
            "return i > j",
            "})",
            "if len(iterable)!= 100 {",
            "t.Errorf(\"expected",
            "func TestHeap_Sort(t *testing.T) {",
            "candidate := heap_sort",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}), expected: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} },",
            "{ actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 25, 58}), expected: []int{14, 22, 25, 25, 35, 58, 65, 75, 85} },",
            "{ actual: candidate([]int{7, 1, 9, 5}), expected: []int{1, 5, 7, 9} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "637",
        "title": "noprofit_noloss",
        "text": "Write a function to check whether the given amount has no profit and no loss",
        "code": "package noprofit_noloss_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc noprofit_noloss(actual_cost int, sale_amount int) bool {\n    return actual_cost == 0 && sale_amount == 0\n}\n\n",
        "test_list": [
            "func TestNoprofitNoloss(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "actual_cost := 0",
            "actual_sale_amount := 0",
            "for i := 0; i < 100; i++ {",
            "actual_cost += i",
            "actual_sale_amount += i",
            "}",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "if actual_sale_amount!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_sale_amount)",
            "}",
            "if noprofit_noloss(actual_cost, actual_sale_amount) {",
            "t.Errorf(\"Expected no profit and no loss, got %d\", actual_cost)",
            "}",
            "}",
            "func TestNoprofitNoloss_with_sale_amount(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "actual_cost := 0",
            "actual_sale_amount := 0",
            "for i := 0; i < 100; i++ {",
            "actual_cost += i",
            "actual_sale_amount += i",
            "}",
            "if actual_cost!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_cost)",
            "}",
            "if actual_sale_amount!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", actual_sale_amount)",
            "}",
            "if noprofit_noloss(actual_cost, actual_sale_amount) {",
            "t.Errorf(\"Expected no profit and no loss, got %d\", actual_cost)",
            "}",
            "}",
            "func",
            "func TestNoprofit_Noloss(t *testing.T) {",
            "candidate := noprofit_noloss",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1500, 1200), expected: false },",
            "{ actual: candidate(100, 100), expected: true },",
            "{ actual: candidate(2000, 5000), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "638",
        "title": "wind_chill",
        "text": "Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.",
        "code": "package wind_chill_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc wind_chill(v int, t int) int {\n    return int(v * (t / 100.0))\n}\n\n",
        "test_list": [
            "func TestWindChill(t *testing.T) {",
            "v := wind_chill(0, 0)",
            "fmt.Println(\"v:\", v)",
            "fmt.Println(\"t:\", t)",
            "}",
            "<|endoftext|>",
            "func TestWind_Chill(t *testing.T) {",
            "candidate := wind_chill",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(120, 35), expected: 40 },",
            "{ actual: candidate(40, 20), expected: 19 },",
            "{ actual: candidate(10, 8), expected: 6 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "639",
        "title": "sample_nam",
        "text": "Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.",
        "code": "package sample_nam_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sample_nam(sample_names []string) int {\n    var sum int\n    for _, name := range sample_names {\n        if name[0] == 'a' {\n            sum += len(name)\n        }\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSampleNam(t *testing.T) {",
            "var sample_names = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "fmt.Println(\"SampleNam:\", sample_nam(sample_names))",
            "}",
            "<|endoftext|>",
            "func TestSample_Nam(t *testing.T) {",
            "candidate := sample_nam",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"sally\", \"Dylan\", \"rebecca\", \"Diana\", \"Joanne\", \"keith\"}), expected: 16 },",
            "{ actual: candidate([]string{\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"}), expected: 10 },",
            "{ actual: candidate([]string{\"abcd\", \"Python\", \"abba\", \"aba\"}), expected: 6 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "63",
        "title": "max_difference",
        "text": "Write a function to find the maximum difference between available pairs in the given list list.",
        "code": "package max_difference_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_difference(test_list [][]interface{}) int {\n    var max_difference int\n    for _, test := range test_list {\n        for _, test_pair := range test {\n            difference := max_difference(test_pair)\n            if difference > max_difference {\n                max_difference = difference\n            }\n        }\n    }\n    return max_difference\n}\n\n",
        "test_list": [
            "func TestMaxDifference(t *testing.T) {",
            "test_list := [][]interface{}{",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]",
            "func TestMax_Difference(t *testing.T) {",
            "candidate := max_difference",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{1, 7}, []interface{}{10, 3}, []interface{}{1, 2}}), expected: 7 },",
            "{ actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{2, 17}, []interface{}{9, 13}, []interface{}{11, 12}}), expected: 15 },",
            "{ actual: candidate([][]int{[]interface{}{12, 35}, []interface{}{21, 27}, []interface{}{13, 23}, []interface{}{41, 22}}), expected: 23 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "640",
        "title": "remove_parenthesis",
        "text": "Write a function to remove the parenthesis and what is inbetween them from a string.",
        "code": "package remove_parenthesis_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_parenthesis(items []string) string {\n    var result string\n    for _, item := range items {\n        if item == \"(\" {\n            result += \"(\"\n        } else if item == \")\" {\n            result += \")\"\n        } else if item == \"(\" {\n            result += \"(\"\n        } else if item == \")\" {\n            result += \")\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"(\" {\n            result += \"(\"\n        } else if item == \")\" {\n            result += \")\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"(\" {\n            result += \"(\"\n        } else if item == \")\" {\n            result += \")\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"(\" {\n            result += \"(\"\n        } else if item == \")\" {\n            result += \")\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"{\" {\n            result += \"{\"\n        } else if item == \"}\" {\n            result += \"}\"\n        } else if item == \"(\" {\n            result += \"(\"\n        } else if item == \")\"\n",
        "test_list": [
            "func TestRemove_Parenthesis(t *testing.T) {",
            "candidate := remove_parenthesis",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"python (chrome)\"}), expected: \"python\" },",
            "{ actual: candidate([]string{\"string(.abc)\"}), expected: \"string\" },",
            "{ actual: candidate([]string{\"alpha(num)\"}), expected: \"alpha\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "641",
        "title": "is_nonagonal",
        "text": "Write a function to find the nth nonagonal number.",
        "code": "package is_nonagonal_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_nonagonal(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        return 32\n    \n",
        "test_list": [
            "func TestIs_Nonagonal(t *testing.T) {",
            "candidate := is_nonagonal",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: 325 },",
            "{ actual: candidate(15), expected: 750 },",
            "{ actual: candidate(18), expected: 1089 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "643",
        "title": "text_match_wordz_middle",
        "text": "Write a function that checks if a strings contains 'z', except at the start and end of the word.",
        "code": "package text_match_wordz_middle_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_match_wordz_middle(text string) bool {\n    return text[0] == 'z' && text[len(text)-1] == 'z'\n}\n\n",
        "test_list": [
            "func TestTextMatchWordzMiddle(t *testing.T) {",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z' to match 'z'\")",
            "}",
            "if!text_match_wordz_middle(`\"z\"`) {",
            "t.Errorf(\"Expected 'z",
            "func TestText_Match_Wordz_Middle(t *testing.T) {",
            "candidate := text_match_wordz_middle",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"pythonzabc.\"), expected: true },",
            "{ actual: candidate(\"zxyabc.\"), expected: false },",
            "{ actual: candidate(\"  lang  .\"), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "644",
        "title": "reverse_Array_Upto_K",
        "text": "Write a gothon function to reverse a list upto a given position.",
        "code": "package reverse_Array_Upto_K_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc reverse_Array_Upto_K(input []int, k int) []int {\n    if len(input) == 0 {\n        return input\n    }\n    if k == 0 {\n        return reverse(input)\n    }\n    return reverse(reverse(input, k))\n}\n\nfunc reverse_Array_Upto_K_test(input []int, k int) []int {\n    if len(input) == 0 {\n        return input\n    }\n    if k == 0 {\n        return reverse(input)\n    }\n    return reverse(reverse(input, k))\n}\n\n",
        "test_list": [
            "func Test_reverse_Array_Upto_K(t *testing.T) {",
            "input := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "k := 0",
            "output := reverse_Array_Upto_K(input, k)",
            "if len(output)!= len(input) {",
            "t.Errorf(\"len(output)!= len(input): %d!= %d\", len(output), len(input))",
            "}",
            "for i := 0; i < len(input); i++ {",
            "if output[i]!= input[i] {",
            "t.Errorf(\"output[%d]!= input[%d]: %d!= %d\", i, i, output[i], input[i])",
            "}",
            "}",
            "}",
            "func Test_reverse_Array_Upto_K_test(t *testing.T) {",
            "input := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "k := 0",
            "output := reverse_Array_Upto_K(input, k)",
            "if len(output)!= len(input) {",
            "t.Errorf(\"len(output)!= len(input): %d!= %d\", len(output), len",
            "func TestReverse_Array_Upto_K(t *testing.T) {",
            "candidate := reverse_Array_Upto_K",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}, 4), expected: []int{4, 3, 2, 1, 5, 6} },",
            "{ actual: candidate([]int{4, 5, 6, 7}, 2), expected: []int{5, 4, 6, 7} },",
            "{ actual: candidate([]int{9, 8, 7, 6, 5}, 3), expected: []int{7, 8, 9, 6, 5} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "64",
        "title": "subject_marks",
        "text": "Write a function to sort a list of lists using the second value of each list.",
        "code": "package subject_marks_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc subject_marks(subjectmarks [][]interface{}) [][]interface{} {\n    var subjectmarks_sorted [][]interface{}\n    for _, subjectmarks_i := range subjectmarks {\n        subjectmarks_sorted = append(subjectmarks_sorted, subjectmarks_i)\n    }\n    return subjectmarks_sorted\n}\n\n",
        "test_list": [
            "func TestSubjectMarks(t *testing.T) {",
            "subjectmarks := subject_marks([]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "[]interface{}{",
            "func TestSubject_Marks(t *testing.T) {",
            "candidate := subject_marks",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{\"English\", 88}, []interface{}{\"Science\", 90}, []interface{}{\"Maths\", 97}, []interface{}{\"Social sciences\", 82}}), expected: [][]int{[]interface{}{\"Social sciences\", 82}, []interface{}{\"English\", 88}, []interface{}{\"Science\", 90}, []interface{}{\"Maths\", 97}} },",
            "{ actual: candidate([][]int{[]interface{}{\"Telugu\", 49}, []interface{}{\"Hindhi\", 54}, []interface{}{\"Social\", 33}}), expected: [][]int{[]interface{}{\"Social\", 33}, []interface{}{\"Telugu\", 49}, []interface{}{\"Hindhi\", 54}} },",
            "{ actual: candidate([][]int{[]interface{}{\"Physics\", 96}, []interface{}{\"Chemistry\", 97}, []interface{}{\"Biology\", 45}}), expected: [][]int{[]interface{}{\"Biology\", 45}, []interface{}{\"Physics\", 96}, []interface{}{\"Chemistry\", 97}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "66",
        "title": "pos_count",
        "text": "Write a gothon function to count the number of positive numbers in a list.",
        "code": "package pos_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pos_count(list []int) int {\n    var count int\n    for _, v := range list {\n        if v > 0 {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestPositiveCount(t *testing.T) {",
            "list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if pos_count(list)!= 10 {",
            "t.Errorf(\"Expected 10, got %d\", pos_count(list))",
            "}",
            "}",
            "func TestPositiveCount_Error(t *testing.T) {",
            "list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if pos_count(list)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", pos_count(list))",
            "}",
            "}",
            "func TestPositiveCount_Error_Error(t *testing.T) {",
            "list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if pos_count(list)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", pos_count(list))",
            "}",
            "}",
            "func TestPositiveCount_Error_Error_Error(t *testing.T) {",
            "list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if pos_count(list)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", pos_count(list))",
            "}",
            "}",
            "func TestPositiveCount_Error_Error_Error(t *testing.T) {",
            "list := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if pos_count(list)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", pos_count(list))",
            "}",
            "}",
            "func TestPos_Count(t *testing.T) {",
            "candidate := pos_count",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, -2, 3, -4}), expected: 2 },",
            "{ actual: candidate([]int{3, 4, 5, -1}), expected: 3 },",
            "{ actual: candidate([]int{1, 2, 3, 4}), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "67",
        "title": "bell_number",
        "text": "Write a function to find the number of ways to partition a set of Bell numbers.",
        "code": "package bell_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc bell_number(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        return\n",
        "test_list": [
            "func TestBell_Number(t *testing.T) {",
            "candidate := bell_number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 2 },",
            "{ actual: candidate(10), expected: 115975 },",
            "{ actual: candidate(56), expected: 6775685320645824322581483068371419745979053216268760300 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "68",
        "title": "is_Monotonic",
        "text": "Write a gothon function to check whether the given list is monotonic or not.",
        "code": "package is_Monotonic_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_Monotonic(A []int) bool {\n    if len(A) == 0 {\n        return false\n    }\n    for i := 0; i < len(A); i++ {\n        if A[i]!= A[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestIsMonotonic(t *testing.T) {",
            "if!is_Monotonic([]int{1, 2, 3, 4, 5}) {",
            "t.Errorf(\"is_Monotonic([]int{1, 2, 3, 4, 5}) = false\")",
            "}",
            "if!is_Monotonic([]int{1, 2, 3, 4, 5, 6}) {",
            "t.Errorf(\"is_Monotonic([]int{1, 2, 3, 4, 5, 6}) = false\")",
            "}",
            "if!is_Monotonic([]int{1, 2, 3, 4, 5, 6, 7}) {",
            "t.Errorf(\"is_Monotonic([]int{1, 2, 3, 4, 5, 6, 7}) = false\")",
            "}",
            "if!is_Monotonic([]int{1, 2, 3, 4, 5, 6, 7, 8}) {",
            "t.Errorf(\"is_Monotonic([]int{1, 2, 3, 4, 5, 6, 7, 8}) = false\")",
            "}",
            "if!is_Monotonic([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Errorf(\"is_Monotonic([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) = false\")",
            "}",
            "if!is_Monotonic([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) {",
            "t.Errorf(\"is_Monotonic([]int{1",
            "func TestIs_Monotonic(t *testing.T) {",
            "candidate := is_Monotonic",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{6, 5, 4, 4}), expected: true },",
            "{ actual: candidate([]int{1, 2, 2, 3}), expected: true },",
            "{ actual: candidate([]int{1, 3, 2}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "69",
        "title": "is_sublist",
        "text": "Write a function to check whether a list contains the given sublist or not.",
        "code": "package is_sublist_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_sublist(l []int, s []int) bool {\n    for i := range l {\n        if l[i] == s[i] {\n            return true\n        }\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestIsSublist(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5}",
            "s := []int{1, 2, 3, 4, 5}",
            "if!is_sublist(l, s) {",
            "t.Errorf(\"is_sublist(%v, %v) = false, want true\", l, s)",
            "}",
            "if is_sublist(l, s) {",
            "t.Errorf(\"is_sublist(%v, %v) = true, want false\", l, s)",
            "}",
            "}",
            "func TestIsSublist2(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5}",
            "s := []int{1, 2, 3, 4, 5}",
            "if is_sublist(l, s) {",
            "t.Errorf(\"is_sublist(%v, %v) = true, want false\", l, s)",
            "}",
            "}",
            "func TestIsSublist3(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5}",
            "s := []int{1, 2, 3, 4, 5}",
            "if!is_sublist(l, s) {",
            "t.Errorf(\"is_sublist(%v, %v) = false, want true\", l, s)",
            "}",
            "if!is_sublist(l, s) {",
            "t.Errorf(\"is_sublist(%v, %v) = true, want true\", l, s)",
            "}",
            "}",
            "func TestIsSublist4(t *testing.T) {",
            "l := []int{1, 2, 3, 4, 5}",
            "s :=",
            "func TestIs_Sublist(t *testing.T) {",
            "candidate := is_sublist",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 4, 3, 5, 7}, []int{3, 7}), expected: false },",
            "{ actual: candidate([]int{2, 4, 3, 5, 7}, []int{4, 3}), expected: true },",
            "{ actual: candidate([]int{2, 4, 3, 5, 7}, []int{1, 6}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "6",
        "title": "differ_At_One_Bit_Pos",
        "text": "Write a gothon function to check whether the two numbers differ at one bit position only or not.",
        "code": "package differ_At_One_Bit_Pos_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc differ_At_One_Bit_Pos(a int, b int) bool {\n    return a == b || (a & (1 << (7 - b)))!= 0\n}\n\nfunc differ_At_One_Bit_Pos_test(a int, b int) bool {\n    return differ_At_One_Bit_Pos(a, b)\n}\n\n",
        "test_list": [
            "func Test_differ_At_One_Bit_Pos(t *testing.T) {",
            "if err := differ_At_One_Bit_Pos_test(0, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(1, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(2, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(3, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(4, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(5, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(6, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(7, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err := differ_At_One_Bit_Pos_test(8, 1); err!= nil {",
            "t.Error(err)",
            "}",
            "if err :=",
            "func TestDiffer_At_One_Bit_Pos(t *testing.T) {",
            "candidate := differ_At_One_Bit_Pos",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(13, 9), expected: true },",
            "{ actual: candidate(15, 8), expected: false },",
            "{ actual: candidate(2, 4), expected: false },",
            "{ actual: candidate(2, 3), expected: true },",
            "{ actual: candidate(5, 1), expected: true },",
            "{ actual: candidate(1, 5), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "70",
        "title": "get_equal",
        "text": "Write a function to find whether all the given lists have equal length or not.",
        "code": "package get_equal_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_equal(Input [][]int) bool {\n    var equal bool\n    for i := range Input {\n        if len(Input[i])!= len(Input[i]) {\n            equal = false\n            break\n        }\n    }\n    return equal\n}\n\n",
        "test_list": [
            "func Test_get_equal(t *testing.T) {",
            "var input [][]int",
            "input = [][]int{",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3},",
            "[]int{1, 2, 3",
            "func TestGet_Equal(t *testing.T) {",
            "candidate := get_equal",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{11, 22, 33}, []int{44, 55, 66}}), expected: true },",
            "{ actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6, 7}}), expected: false },",
            "{ actual: candidate([][]int{[]int{1, 2}, []int{3, 4}}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "71",
        "title": "comb_sort",
        "text": "Write a function to sort a list of elements.",
        "code": "package comb_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc comb_sort(nums []int) []int {\n    if len(nums) == 0 {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < len(nums); i++ {\n        result = append(result, nums[i])\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestCombSort(t *testing.T) {",
            "nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "result := comb_sort(nums)",
            "if len(result)!= 10 {",
            "t.Errorf(\"expected 10, got %d\", len(result))",
            "}",
            "for i := 0; i < len(nums); i++ {",
            "fmt.Printf(\"%d \", result[i])",
            "}",
            "fmt.Println()",
            "}",
            "<|endoftext|>",
            "func TestComb_Sort(t *testing.T) {",
            "candidate := comb_sort",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 15, 37, 25, 79}), expected: []int{5, 15, 25, 37, 79} },",
            "{ actual: candidate([]int{41, 32, 15, 19, 22}), expected: []int{15, 19, 22, 32, 41} },",
            "{ actual: candidate([]int{99, 15, 13, 47}), expected: []int{13, 15, 47, 99} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "720",
        "title": "add_dict_to_tuple",
        "text": "Write a function to add a map to the list. The output should be a list.",
        "code": "package add_dict_to_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc add_dict_to_tuple(test_tup []interface{}, test_dict map[string]int) []interface{} {\n    test_tup = append(test_tup, test_dict)\n    return test_tup\n}\n\n",
        "test_list": [
            "func TestAddDictToTuple(t *testing.T) {",
            "test_tup := add_dict_to_tuple([]interface{}{",
            "\"a\",",
            "\"b\",",
            "\"c\",",
            "\"d\",",
            "\"e\",",
            "\"f\",",
            "\"g\",",
            "\"h\",",
            "\"i\",",
            "\"j\",",
            "\"k\",",
            "\"l\",",
            "\"m\",",
            "\"n\",",
            "\"o\",",
            "\"p\",",
            "\"q\",",
            "\"r\",",
            "\"s\",",
            "\"t\",",
            "\"u\",",
            "\"v\",",
            "\"w\",",
            "\"x\",",
            "\"y\",",
            "\"z\",",
            "\"A\",",
            "\"B\",",
            "\"C\",",
            "\"D\",",
            "\"E\",",
            "\"F\",",
            "\"G\",",
            "\"H\",",
            "\"I\",",
            "\"J\",",
            "\"K\",",
            "\"L\",",
            "\"M\",",
            "\"N\",",
            "\"O\",",
            "\"P\",",
            "\"Q\",",
            "\"R\",",
            "\"S\",",
            "\"T\",",
            "\"U\",",
            "\"V\",",
            "\"W\",",
            "\"X\",",
            "\"Y\",",
            "\"Z\",",
            "\"A\",",
            "\"B\",",
            "\"C\",",
            "\"D\",",
            "\"E\",",
            "\"F\",",
            "\"G\",",
            "\"H\",",
            "\"I\",",
            "\"J\",",
            "\"K\",",
            "\"L\",",
            "\"M\",",
            "\"N\",",
            "\"O\",",
            "\"P\",",
            "\"Q\",",
            "\"R\",",
            "\"S\",",
            "\"T\",",
            "\"U\",",
            "func TestAdd_Dict_To_Tuple(t *testing.T) {",
            "candidate := add_dict_to_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{4, 5, 6}, map[string]int{\"MSAM\": 1, \"is\": 2, \"best\": 3}), expected: []interface{}{4, 5, 6, map[string]int{\"MSAM\": 1, \"is\": 2, \"best\": 3}} },",
            "{ actual: candidate([]interface{}{1, 2, 3}, map[string]int{\"UTS\": 2, \"is\": 3, \"Worst\": 4}), expected: []interface{}{1, 2, 3, map[string]int{\"UTS\": 2, \"is\": 3, \"Worst\": 4}} },",
            "{ actual: candidate([]interface{}{8, 9, 10}, map[string]int{\"POS\": 3, \"is\": 4, \"Okay\": 5}), expected: []interface{}{8, 9, 10, map[string]int{\"POS\": 3, \"is\": 4, \"Okay\": 5}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "721",
        "title": "maxAverageOfPath",
        "text": "Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.",
        "code": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc maxAverageOfPath(cost [][]int) float64 {\n    var max float64\n    for _, c := range cost {\n        max = max(max, float64(c[0]))\n        max = max(max, float64(c[1]))\n        max = max(max, float64(c[2]))\n    }\n    return max\n}\n\nfunc maxAverageOfPath(cost [][]int) float64 {\n    return maxAverageOfPath_test(cost)\n}\n\nfunc maxAverageOfPath_test(cost [][]int) float64 {\n    var max float64\n    for _, c := range cost {\n        max = max(max, float64(c[0]))\n        max = max(max, float64(c[1]))\n        max = max(max, float64(c[2]))\n    }\n    return max\n}\n\n",
        "test_list": [
            "func TestMaxAverageOfPath(t *testing.T) {",
            "var cost [][]int",
            "cost = [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "func TestMaxaverageofpath(t *testing.T) {",
            "candidate := maxAverageOfPath",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },",
            "{ actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },",
            "{ actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },",
            "{ actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "723",
        "title": "count_same_pair",
        "text": "The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.",
        "code": "package count_same_pair_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_same_pair(nums1 []int, nums2 []int) int {\n    if len(nums1)!= len(nums2) {\n        return 0\n    }\n    for i := 0; i < len(nums1); i++ {\n        if nums1[i]!= nums2[i] {\n            return 0\n        }\n    }\n    return 1\n}\n\n",
        "test_list": [
            "func TestCountSamePair(t *testing.T) {",
            "nums1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "nums2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if count_same_pair(nums1, nums2)!= 1 {",
            "t.Errorf(\"Expected 1, got %d\", count_same_pair(nums1, nums2))",
            "}",
            "}",
            "func TestCountSamePair_Error(t *testing.T) {",
            "nums1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "nums2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if count_same_pair(nums1, nums2)!= 0 {",
            "t.Errorf(\"Expected 0, got %d\", count_same_pair(nums1, nums2))",
            "}",
            "}",
            "func TestCountSamePair_Error_Error(t *testing.T) {",
            "nums1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "nums2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if count_same_pair(nums1, nums2)!= 0 {",
            "t.Error",
            "func TestCount_Same_Pair(t *testing.T) {",
            "candidate := count_same_pair",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8}, []int{2, 2, 3, 1, 2, 6, 7, 9}), expected: 4 },",
            "{ actual: candidate([]int{0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8}, []int{2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8}), expected: 11 },",
            "{ actual: candidate([]int{2, 4, -6, -9, 11, -12, 14, -5, 17}, []int{2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8}), expected: 1 },",
            "{ actual: candidate([]int{0, 1, 1, 2}, []int{0, 1, 2, 2}), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "724",
        "title": "power_base_sum",
        "text": "Write a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.",
        "code": "package power_base_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc power_base_sum(base int, power int) int {\n    return power_base_sum_base(base, power)\n}\n\nfunc power_base_sum_base(base int, power int) int {\n    if base == 0 {\n        return 0\n    }\n    if power == 0 {\n        return base\n    }\n    return power_base_sum_base(base-1, power-1) + power_base_sum_base(base-2, power-2) + power_base_sum_base(base-3, power-3) + power_base_sum_base(base-4, power-4) + power_base_sum_base(base-5, power-5) + power_base_sum_base(base-6, power-6) + power_base_sum_base(base-7, power-7) + power_base_sum_base(base-8, power-8) + power_base_sum_base(base-9, power-9) + power_base_sum_base(base-10, power-10) + power_base_sum_base(base-11, power-11) + power_base_sum_base(base-12, power-12)\n}\n\nfunc power_base_sum_base_power(base int, power int) int {\n    if base == 0 {\n        return 0\n    }\n    if power == 0 {\n        return base\n    }\n    return power_base_sum_base_power(base-1, power-1) + power_base_sum_base_power(base-2, power-2) + power_base_sum_base_power(base-3, power-3) + power_base_sum_base_\n",
        "test_list": [
            "func TestPower_Base_Sum(t *testing.T) {",
            "candidate := power_base_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2, 100), expected: 115 },",
            "{ actual: candidate(8, 10), expected: 37 },",
            "{ actual: candidate(8, 15), expected: 62 },",
            "{ actual: candidate(3, 3), expected: 9 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "725",
        "title": "extract_quotation",
        "text": "Write a function to extract values between quotation marks \" \" of the given string.",
        "code": "package extract_quotation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_quotation(text1 string) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(text1); i++ {\n        if text1[i] == '\"' {\n            result = append(result, text1[i+1:i+2])\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestExtractQuotation(t *testing.T) {",
            "var text1 string",
            "var result []interface{}",
            "text1 = \"Hello, world!\"",
            "result = extract_quotation(text1)",
            "fmt.Println(result)",
            "}",
            "<|endoftext|>",
            "func TestExtract_Quotation(t *testing.T) {",
            "candidate := extract_quotation",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Cortex \"A53\" Based \"multi\" tasking \"Processor\"\"), expected: []string{\"A53\", \"multi\", \"Processor\"} },",
            "{ actual: candidate(\"Cast your \"favorite\" entertainment \"apps\"\"), expected: []string{\"favorite\", \"apps\"} },",
            "{ actual: candidate(\"Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support\"), expected: []string{\"4k Ultra HD\", \"HDR 10\"} },",
            "{ actual: candidate(\"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\"), expected: []interface{}{} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "726",
        "title": "multiply_elements",
        "text": "Write a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the list is equal to t_i * t_{i+1}.",
        "code": "package multiply_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc multiply_elements(test_tup []int) []interface{} {\n    var test_list []interface{}\n    for i := 0; i < len(test_tup); i++ {\n        test_list = append(test_list, test_tup[i] * test_tup[i+1])\n    }\n    return test_list\n}\n\n",
        "test_list": [
            "func TestMultiplyElements(t *testing.T) {",
            "test_list := multiply_elements([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})",
            "fmt.Println(test_list)",
            "}",
            "<|endoftext|>",
            "func TestMultiply_Elements(t *testing.T) {",
            "candidate := multiply_elements",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 5, 7, 8, 10}), expected: []int{5, 35, 56, 80} },",
            "{ actual: candidate([]int{2, 4, 5, 6, 7}), expected: []int{8, 20, 30, 42} },",
            "{ actual: candidate([]int{12, 13, 14, 9, 15}), expected: []int{156, 182, 126, 135} },",
            "{ actual: candidate([]int{12}), expected: []interface{}{} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "728",
        "title": "sum_list",
        "text": "Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].",
        "code": "package sum_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_list(lst1 []int, lst2 []int) []int {\n    var sum int\n    for _, v := range lst1 {\n        sum += v\n    }\n    for _, v := range lst2 {\n        sum += v\n    }\n    return []int{sum}\n}\n\n",
        "test_list": [
            "func TestSumList(t *testing.T) {",
            "lst1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "lst2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}",
            "sum := sum_list(lst1, lst2)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestSum_List(t *testing.T) {",
            "candidate := sum_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 20, 30}, []int{15, 25, 35}), expected: []int{25, 45, 65} },",
            "{ actual: candidate([]int{1, 2, 3}, []int{5, 6, 7}), expected: []int{6, 8, 10} },",
            "{ actual: candidate([]int{15, 20, 30}, []int{15, 45, 75}), expected: []int{30, 65, 105} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "72",
        "title": "dif_Square",
        "text": "Write a gothon function to check whether the given number can be represented as the difference of two squares or not.",
        "code": "package dif_Square_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc dif_Square(n int) bool {\n    return n == dif_Square(n)\n}\n\n",
        "test_list": [
            "func Test_dif_Square(t *testing.T) {",
            "if dif_Square(0)!= true {",
            "t.Error(\"dif_Square(0) should return true\")",
            "}",
            "if dif_Square(1)!= false {",
            "t.Error(\"dif_Square(1) should return false\")",
            "}",
            "if dif_Square(2)!= true {",
            "t.Error(\"dif_Square(2) should return true\")",
            "}",
            "if dif_Square(3)!= false {",
            "t.Error(\"dif_Square(3) should return false\")",
            "}",
            "}",
            "func Test_dif_Square_test(t *testing.T) {",
            "if dif_Square(0)!= true {",
            "t.Error(\"dif_Square(0) should return true\")",
            "}",
            "if dif_Square(1)!= false {",
            "t.Error(\"dif_Square(1) should return false\")",
            "}",
            "if dif_Square(2)!= true {",
            "t.Error(\"dif_Square(2) should return true\")",
            "}",
            "if dif_Square(3)!= false {",
            "t.Error(\"dif_Square(3) should return false\")",
            "}",
            "}",
            "func Test_dif_Square_test_2(t *testing.T) {",
            "if dif_Square(0)!= true {",
            "t.Error(\"dif_Square(0) should return true\")",
            "}",
            "if dif_Square(1)!= false {",
            "t.Error(\"dif_Square(1) should return false\")",
            "}",
            "if dif_Square(2)!= true {",
            "t.Error(\"dif_Square(2) should return true\")",
            "}",
            "if dif_Square(3)!=",
            "func TestDif_Square(t *testing.T) {",
            "candidate := dif_Square",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: true },",
            "{ actual: candidate(10), expected: false },",
            "{ actual: candidate(15), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "730",
        "title": "consecutive_duplicates",
        "text": "Write a function to remove consecutive duplicates of a given list.",
        "code": "package consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc consecutive_duplicates(nums []interface{}) []interface{} {\n    var result []interface{}\n    for _, num := range nums {\n        if num == nums[len(nums)-1] {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestConsecutiveDuplicates(t *testing.T) {",
            "nums := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "expected := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "actual := consecutive_duplicates(nums)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "func TestConsecutiveDuplicates_1(t *testing.T) {",
            "nums := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "expected := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "actual := consecutive_duplicates(nums)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "func TestConsecutiveDuplicates_2(t *testing.T) {",
            "nums := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "expected := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "actual := consecutive_duplicates(nums)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "func TestConsecutive",
            "func TestConsecutive_Duplicates(t *testing.T) {",
            "candidate := consecutive_duplicates",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4} },",
            "{ actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: []int{10, 15, 19, 18, 17, 26, 17, 18, 10} },",
            "{ actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: []string{\"a\", \"b\", \"c\", \"d\"} },",
            "{ actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\", \"a\", \"a\"}), expected: []string{\"a\", \"b\", \"c\", \"d\", \"a\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "731",
        "title": "lateralsurface_cone",
        "text": "Write a function to find the lateral surface area of a cone given radius r and the height h.",
        "code": "package lateralsurface_cone_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc lateralsurface_cone(r int, h int) float64 {\n    return float64(r) * float64(h)\n}\n\n",
        "test_list": [
            "func TestCone(t *testing.T) {",
            "var cone = &Cone{",
            "radius:   10,",
            "height:   10,",
            "lateral:  lateralsurface_cone,",
            "lateral_area: lateralsurface_cone,",
            "}",
            "if cone.lateral(10, 10)!= lateralsurface_cone(10, 10) {",
            "t.Errorf(\"lateral surface area is incorrect: %f\", cone.lateral(10, 10))",
            "}",
            "if cone.lateral(10, 10)!= lateralsurface_cone(10, 10) {",
            "t.Errorf(\"lateral surface area is incorrect: %f\", cone.lateral(10, 10))",
            "}",
            "if cone.lateral(10, 10)!= lateralsurface_cone(10, 10) {",
            "t.Errorf(\"lateral surface area is incorrect: %f\", cone.lateral(10, 10))",
            "}",
            "if cone.lateral(10, 10)!= lateralsurface_cone(10, 10) {",
            "t.Errorf(\"lateral surface area is incorrect: %f\", cone.lateral(10, 10))",
            "}",
            "if cone.lateral(10, 10)!= lateralsurface_cone(10, 10) {",
            "t.Errorf(\"lateral surface area is incorrect: %f\", cone.lateral(10, 10))",
            "}",
            "if cone.lateral(10, 10)!= lateralsurface_cone(10, 10) {",
            "t.Errorf(\"lateral surface area is incorrect: %f\", cone.lateral(10, 10))",
            "}",
            "if cone.lateral(10, 10)!= lateralsurface_cone(10, 10) {",
            "t.Errorf(\"lateral surface area is incorrect",
            "func TestLateralsurface_Cone(t *testing.T) {",
            "candidate := lateralsurface_cone",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5, 12), expected: 204.20352248333654 },",
            "{ actual: candidate(10, 15), expected: 566.3586699569488 },",
            "{ actual: candidate(19, 17), expected: 1521.8090132193388 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "732",
        "title": "replace_specialchar",
        "text": "Write a function to replace all occurrences of spaces, commas, or dots with a colon.",
        "code": "package replace_specialchar_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc replace_specialchar(text string) string {\n    return fmt.Sprintf(\"%s%s%s\", text, text, text)\n}\n\n",
        "test_list": [
            "func TestReplaceSpecialchar(t *testing.T) {",
            "text := \"hello world\"",
            "expected := replace_specialchar(text)",
            "actual := replace_specialchar(text)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %q, got %q\", expected, actual)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestReplace_Specialchar(t *testing.T) {",
            "candidate := replace_specialchar",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Python language, Programming language.\"), expected: \"Python:language::Programming:language:\" },",
            "{ actual: candidate(\"a b c,d e f\"), expected: \"a:b:c:d:e:f\" },",
            "{ actual: candidate(\"ram reshma,ram rahim\"), expected: \"ram:reshma:ram:rahim\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "733",
        "title": "find_first_occurrence",
        "text": "Write a function to find the index of the first occurrence of a given number in a sorted list.",
        "code": "package find_first_occurrence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_first_occurrence(A []int, x int) int {\n    if len(A) == 0 {\n        return -1\n    }\n    if len(A) == 1 {\n        return A[0]\n    }\n    return find_first_occurrence(A[1:], x)\n}\n\n",
        "test_list": [
            "func TestFindFirstOccurrence(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if find_first_occurrence(A, 10)!= 9 {",
            "t.Errorf(\"find_first_occurrence(A, 10) = %d, want 9\", find_first_occurrence(A, 10))",
            "}",
            "}",
            "func TestFindFirstOccurrence2(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if find_first_occurrence(A, 10)!= 9 {",
            "t.Errorf(\"find_first_occurrence(A, 10) = %d, want 9\", find_first_occurrence(A, 10))",
            "}",
            "}",
            "func TestFindFirstOccurrence3(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if find_first_occurrence(A, 10)!= 9 {",
            "t.Errorf(\"find_first_occurrence(A, 10) = %d, want 9\", find_first_occurrence(A, 10))",
            "}",
            "}",
            "func TestFindFirstOccurrence4(t *testing.T) {",
            "A := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if find_first_occurrence(A, 10)!= 9 {",
            "t.Errorf(\"find_first_occurrence(A, 10) = %d,",
            "func TestFind_First_Occurrence(t *testing.T) {",
            "candidate := find_first_occurrence",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 5, 5, 5, 6, 6, 8, 9, 9, 9}, 5), expected: 1 },",
            "{ actual: candidate([]int{2, 3, 5, 5, 6, 6, 8, 9, 9, 9}, 5), expected: 2 },",
            "{ actual: candidate([]int{2, 4, 1, 5, 6, 6, 8, 9, 9, 9}, 6), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "734",
        "title": "sum_Of_Subarray_Prod",
        "text": "Write a gothon function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-sublists/",
        "code": "package sum_Of_Subarray_Prod_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_Of_Subarray_Prod(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        sum += v\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSumOfSubarrayProd(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := sum_Of_Subarray_Prod(arr)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestSum_Of_Subarray_Prod(t *testing.T) {",
            "candidate := sum_Of_Subarray_Prod",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: 20 },",
            "{ actual: candidate([]int{1, 2}), expected: 5 },",
            "{ actual: candidate([]int{1, 2, 3, 4}), expected: 84 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "735",
        "title": "toggle_middle_bits",
        "text": "Write a gothon function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/",
        "code": "package toggle_middle_bits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc toggle_middle_bits(n int) int {\n    var first, last, result int\n    first = n & 0x1\n    last = (n >> 1) & 0x1\n    result = first | last\n    return result\n}\n\n",
        "test_list": [
            "func TestToggleMiddleBits(t *testing.T) {",
            "var testCases = []",
            "func TestToggle_Middle_Bits(t *testing.T) {",
            "candidate := toggle_middle_bits",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(9), expected: 15 },",
            "{ actual: candidate(10), expected: 12 },",
            "{ actual: candidate(11), expected: 13 },",
            "{ actual: candidate(65), expected: 127 },",
            "{ actual: candidate(77), expected: 115 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "736",
        "title": "left_insertion",
        "text": "Write a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/gothon-exercises/data-structures-and-algorithms/gothon-data-structure-exercise-24.php",
        "code": "package left_insertion_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc left_insertion(a []int, x int) int {\n    if len(a) == 0 {\n        return x\n    }\n    if a[0] < x {\n        return left_insertion(a, x)\n    }\n    return left_insertion(a, a[0])\n}\n\n",
        "test_list": [
            "func TestLeftInsertion(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if left_insertion(a, 10)!= 9 {",
            "t.Errorf(\"Expected left_insertion to return 9, but got %d\", left_insertion(a, 10))",
            "}",
            "}",
            "func TestRightInsertion(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if right_insertion(a, 10)!= 9 {",
            "t.Errorf(\"Expected right_insertion to return 9, but got %d\", right_insertion(a, 10))",
            "}",
            "}",
            "func TestLeftInsertion_2(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if left_insertion(a, 10)!= 9 {",
            "t.Errorf(\"Expected left_insertion to return 9, but got %d\", left_insertion(a, 10))",
            "}",
            "}",
            "func TestRightInsertion_2(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if right_insertion(a, 10)!= 9 {",
            "t.Errorf(\"Expected right",
            "func TestLeft_Insertion(t *testing.T) {",
            "candidate := left_insertion",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 4, 5}, 6), expected: 4 },",
            "{ actual: candidate([]int{1, 2, 4, 5}, 3), expected: 2 },",
            "{ actual: candidate([]int{1, 2, 4, 5}, 7), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "737",
        "title": "check_str",
        "text": "Write a function to check whether the given string is starting with a vowel or not using regex.",
        "code": "package check_str_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_str(myString string) bool {\n    re := regexp.MustCompile(`^[a-z]`)\n    return re.MatchString(myString)\n}\n\n",
        "test_list": [
            "func TestCheckStr(t *testing.T) {",
            "if check_str(\"\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check_str(\"a\") {",
            "t.Error(\"check_str() should return false\")",
            "}",
            "if check",
            "func TestCheck_Str(t *testing.T) {",
            "candidate := check_str",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"annie\"), expected: true },",
            "{ actual: candidate(\"dawood\"), expected: false },",
            "{ actual: candidate(\"Else\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "738",
        "title": "geometric_sum",
        "text": "Write a function to calculate the geometric sum of n-1. https://www.w3resource.com/gothon-exercises/data-structures-and-algorithms/gothon-recursion-exercise-9.php",
        "code": "package geometric_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc geometric_sum(n int) float64 {\n    if n == 0 {\n        return 0\n    }\n    return math.Pow(n, 1.0 / 2.0)\n}\n\n",
        "test_list": [
            "func TestGeometricSum(t *testing.T) {",
            "fmt.Println(\"Testing geometric sum\")",
            "for i := 0; i < 10; i++ {",
            "fmt.Println(geometric_sum(i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestGeometric_Sum(t *testing.T) {",
            "candidate := geometric_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(7), expected: 1.9921875 },",
            "{ actual: candidate(4), expected: 1.9375 },",
            "{ actual: candidate(8), expected: 1.99609375 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "739",
        "title": "find_Index",
        "text": "Write a gothon function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/",
        "code": "package find_Index_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Index(n int) int {\n    if n < 2 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n    }\n    if n == 3 {\n        return 2\n    }\n    if n == 4 {\n        return 3\n    }\n    if n == 5 {\n        return 4\n    }\n    if n == 6 {\n        return 5\n    }\n    if n == 7 {\n        return 6\n    }\n    if n == 8 {\n        return 7\n    }\n    if n == 9 {\n        return 8\n    }\n    if n == 10 {\n        return 9\n    }\n    if n == 11 {\n        return 10\n    }\n    if n == 12 {\n        return 11\n    }\n    if n == 13 {\n        return 12\n    }\n    if n == 14 {\n        return 13\n    }\n    if n == 15 {\n        return 14\n    }\n    if n == 16 {\n        return 15\n    }\n    if n == 17 {\n        return 16\n    }\n    if n == 18 {\n        return 17\n    }\n    if n == 19 {\n        return 18\n    }\n    if n == 20 {\n        return 19\n    }\n    if n == 21 {\n        return 20\n    }\n    if n == 22 {\n        return 21\n    }\n    if n == 23 {\n        return 22\n    }\n    if n == 24 {\n        return 23\n    }\n    if n == 25 {\n        return 24\n    }\n    if n == 26 {\n        return 25\n    }\n    if n == 27 {\n        return 26\n    }\n    if n == 28 {\n        return 27\n    }\n    if n == 29 {\n        return 28\n    }\n    if n == 30 {\n        return 29\n    }\n    if n == 31 {\n",
        "test_list": [
            "func TestFind_Index(t *testing.T) {",
            "candidate := find_Index",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 4 },",
            "{ actual: candidate(3), expected: 14 },",
            "{ actual: candidate(4), expected: 45 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "740",
        "title": "tuple_to_dict",
        "text": "Write a function to convert the given list to a key-value map using adjacent elements. https://www.geeksforgeeks.org/gothon-convert-list-to-adjacent-pair-map/",
        "code": "package tuple_to_dict_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc tuple_to_dict(test_tup []interface{}) map[int]int {\n    m := make(map[int]int)\n    for i := 0; i < len(test_tup); i++ {\n        m[i] = i\n    }\n    return m\n}\n\n",
        "test_list": [
            "func TestTupleToDict(t *testing.T) {",
            "test_tup := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "m := tuple_to_dict(test_tup)",
            "fmt.Println(m)",
            "}",
            "<|endoftext|>",
            "func TestTuple_To_Dict(t *testing.T) {",
            "candidate := tuple_to_dict",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{1, 5, 7, 10, 13, 5}), expected: map[int]int{1: 5, 7: 10, 13: 5} },",
            "{ actual: candidate([]interface{}{1, 2, 3, 4, 5, 6}), expected: map[int]int{1: 2, 3: 4, 5: 6} },",
            "{ actual: candidate([]interface{}{7, 8, 9, 10, 11, 12}), expected: map[int]int{7: 8, 9: 10, 11: 12} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "741",
        "title": "all_Characters_Same",
        "text": "Write a gothon function to check whether all the characters are same or not.",
        "code": "package all_Characters_Same_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc all_Characters_Same(s string) bool {\n    for _, c := range s {\n        if c!='' && c!= '\\t' && c!= '\\n' && c!= '\\r' {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func Test_all_Characters_Same(t *testing.T) {",
            "if!all_Characters_Same(\"\") {",
            "t.Error(\"all_Characters_Same failed\")",
            "}",
            "}",
            "func Test_all_Characters_Different(t *testing.T) {",
            "if all_Characters_Same(\"a\") {",
            "t.Error(\"all_Characters_Different failed\")",
            "}",
            "}",
            "func Test_all_Characters_Different_1(t *testing.T) {",
            "if!all_Characters_Same(\"a\") {",
            "t.Error(\"all_Characters_Different_1 failed\")",
            "}",
            "}",
            "func Test_all_Characters_Different_2(t *testing.T) {",
            "if!all_Characters_Same(\"a\") {",
            "t.Error(\"all_Characters_Different_2 failed\")",
            "}",
            "}",
            "func Test_all_Characters_Different_3(t *testing.T) {",
            "if!all_Characters_Same(\"a\") {",
            "t.Error(\"all_Characters_Different_3 failed\")",
            "}",
            "}",
            "func Test_all_Characters_Different_4(t *testing.T) {",
            "if!all_Characters_Same(\"a\") {",
            "t.Error(\"all_Characters_Different_4 failed\")",
            "}",
            "}",
            "func Test_all_Characters_Different_5(t *testing.T) {",
            "if!all_Characters_Same(\"a\") {",
            "t.Error(\"all_Characters_Different_5 failed\")",
            "}",
            "}",
            "func Test_all_Characters_Different_6(t *testing.T) {",
            "if!all_Characters_Same(\"a\") {",
            "t.Error",
            "func TestAll_Characters_Same(t *testing.T) {",
            "candidate := all_Characters_Same",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python\"), expected: false },",
            "{ actual: candidate(\"aaa\"), expected: true },",
            "{ actual: candidate(\"data\"), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "742",
        "title": "area_tetrahedron",
        "text": "Write a function to calculate the area of a tetrahedron.",
        "code": "package area_tetrahedron_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc area_tetrahedron(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test2(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test3(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test4(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test5(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test6(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test7(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc area_tetrahedron_test8(side int) float64 {\n    return (side * side) * (side * side)\n}\n\nfunc\n",
        "test_list": [
            "func TestArea_Tetrahedron(t *testing.T) {",
            "candidate := area_tetrahedron",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3), expected: 15.588457268119894 },",
            "{ actual: candidate(20), expected: 692.8203230275509 },",
            "{ actual: candidate(10), expected: 173.20508075688772 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "743",
        "title": "rotate_right",
        "text": "Write a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/gothon-program-right-rotate-list-n/",
        "code": "package rotate_right_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc rotate_right(list []int, m int) []int {\n    if len(list) == 0 {\n        return list\n    }\n    if m == 0 {\n        return list\n    }\n    if m == 1 {\n        return rotate_right(list, m - 1)\n    }\n    if m == 2 {\n        return rotate_right(list, m - 2)\n    }\n    if m == 3 {\n        return rotate_right(list, m - 3)\n    }\n    if m == 4 {\n        return rotate_right(list, m - 4)\n    }\n    if m == 5 {\n        return rotate_right(list, m - 5)\n    }\n    if m == 6 {\n        return rotate_right(list, m - 6)\n    }\n    if m == 7 {\n        return rotate_right(list, m - 7)\n    }\n    if m == 8 {\n        return rotate_right(list, m - 8)\n    }\n    if m == 9 {\n        return rotate_right(list, m - 9)\n    }\n    if m == 10 {\n        return rotate_right(list, m - 10)\n    }\n    if m == 11 {\n        return rotate_right(list, m - 11)\n    }\n    if m == 12 {\n        return rotate_right(list, m - 12)\n    }\n    if m == 13 {\n        return rotate_right(list, m - 13)\n    }\n    if m == 14 {\n        return rotate_right(list, m - 14)\n    }\n    if m == 15 {\n        return rotate_right(list, m - 15)\n    }\n    if m == 16 {\n        return rotate_right(list, m - 16)\n    }\n    if m == 17 {\n        return rotate_right(list, m - 17)\n    }\n    if m\n",
        "test_list": [
            "func TestRotate_Right(t *testing.T) {",
            "candidate := rotate_right",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3), expected: []int{8, 9, 10, 1, 2, 3, 4, 5, 6, 7} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 2), expected: []int{9, 10, 1, 2, 3, 4, 5, 6, 7, 8} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5), expected: []int{6, 7, 8, 9, 10, 1, 2, 3, 4, 5} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "744",
        "title": "check_none",
        "text": "Write a function to check if the given list has any none value or not.",
        "code": "package check_none_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_none(test_tup interface{}) bool {\n    var list []interface{}\n    for _, v := range test_tup.([]interface{}) {\n        if v == nil {\n            return false\n        }\n        list = append(list, v)\n    }\n    return len(list) > 0\n}\n\n",
        "test_list": [
            "func TestCheck_none(t *testing.T) {",
            "test_tup := []interface{}{nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil",
            "func TestCheck_None(t *testing.T) {",
            "candidate := check_none",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{10, 4, 5, 6, nil}), expected: true },",
            "{ actual: candidate([]interface{}{7, 8, 9, 11, 14}), expected: false },",
            "{ actual: candidate([]interface{}{1, 2, 3, 4, nil}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "745",
        "title": "divisible_by_digits",
        "text": "Write a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/gothon-exercises/lambda/gothon-lambda-exercise-24.php",
        "code": "package divisible_by_digits_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc divisible_by_digits(startnum int, endnum int) []int {\n    var result []int\n    for i := startnum; i <= endnum; i++ {\n        if i % 10 == 0 {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestDivisibleByDigits(t *testing.T) {",
            "var testCases = []",
            "func TestDivisible_By_Digits(t *testing.T) {",
            "candidate := divisible_by_digits",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1, 22), expected: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22} },",
            "{ actual: candidate(1, 15), expected: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15} },",
            "{ actual: candidate(20, 25), expected: []int{22, 24} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "747",
        "title": "lcs_of_three",
        "text": "Write a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/",
        "code": "package lcs_of_three_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc lcs_of_three(X string, Y string, Z string) int {\n    if len(X) == 0 || len(Y) == 0 || len(Z) == 0 {\n        return 0\n    }\n\n    var x, y, z int\n    var x_len, y_len, z_len int\n\n    x_len = len(X)\n    y_len = len(Y)\n    z_len = len(Z)\n\n    if x_len == 0 || y_len == 0 || z_len == 0 {\n        return 0\n    }\n\n    if x_len == 1 {\n        x = X[0]\n        x_len = 1\n    }\n\n    if y_len == 1 {\n        y = Y[0]\n        y_len = 1\n    }\n\n    if z_len == 1 {\n        z = Z[0]\n        z_len = 1\n    }\n\n    if x_len == y_len && y_len == z_len {\n        return lcs_of_three(X, Y, Z)\n    }\n\n    if x_len == y_len && y_len == z_len {\n        return lcs_of_three(X, Y, Z)\n    }\n\n    if x_len == z_len && y_len == z_len {\n        return lcs_of_three(X, Y, Z)\n    }\n\n    return 0\n}\n\n",
        "test_list": [
            "func TestLcsOfThree(t *testing.T) {",
            "var x, y, z int",
            "var x_len, y_len, z_len int",
            "x_len = len(X)",
            "y_len = len(Y)",
            "z_len = len(Z)",
            "if x_len == 0 || y_len == 0 || z_len == 0 {",
            "t.Errorf(\"Error: x_len == 0 ||",
            "func TestLcs_Of_Three(t *testing.T) {",
            "candidate := lcs_of_three",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"AGGT12\", \"12TXAYB\", \"12XBA\"), expected: 2 },",
            "{ actual: candidate(\"Reels\", \"Reelsfor\", \"ReelsforReels\"), expected: 5 },",
            "{ actual: candidate(\"abcd1e2\", \"bc12ea\", \"bd1ea\"), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "748",
        "title": "capital_words_spaces",
        "text": "Write a function to put spaces between words starting with capital letters in a given string.",
        "code": "package capital_words_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc capital_words_spaces(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] =='' {\n            str2 = str1[i:]\n            break\n        }\n    }\n    return str2\n}\n\n",
        "test_list": [
            "func TestCapitalWordsSpaces(t *testing.T) {",
            "str1 := \"Hello, World!\"",
            "str2 := capital_words_spaces(str1)",
            "fmt.Println(str1, str2)",
            "}",
            "<|endoftext|>",
            "func TestCapital_Words_Spaces(t *testing.T) {",
            "candidate := capital_words_spaces",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Python\"), expected: \"Python\" },",
            "{ actual: candidate(\"PythonProgrammingExamples\"), expected: \"Python Programming Examples\" },",
            "{ actual: candidate(\"GetReadyToBeCodingFreak\"), expected: \"Get Ready To Be Coding Freak\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "749",
        "title": "sort_numeric_strings",
        "text": "Write a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/gothon-sort-numeric-strings-in-a-list/",
        "code": "package sort_numeric_strings_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sort_numeric_strings(nums_str []string) []int {\n    nums_str_copy := make([]string, len(nums_str))\n    copy(nums_str_copy, nums_str)\n    sort.Strings(nums_str_copy)\n    return nums_str_copy\n}\n\n",
        "test_list": [
            "func TestSortNumericStrings(t *testing.T) {",
            "nums_str := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}",
            "expected_nums_str := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}",
            "actual_nums_str := sort_numeric_strings(nums_str)",
            "if!sort.StringsAreSorted(actual_nums_str) {",
            "t.Errorf(\"Expected sorted list of numbers, got %v\", actual_nums_str)",
            "}",
            "if!sort.StringsAreSorted(expected_nums_str) {",
            "t.Errorf(\"Expected sorted list of numbers, got %v\", expected_nums_str)",
            "}",
            "}",
            "func TestSortNumericStrings_with_numbers(t *testing.T) {",
            "nums_str := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}",
            "expected_nums_str := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"}",
            "actual_nums_str := sort_numeric_strings(nums_str)",
            "if!sort.StringsAreSorted(actual_nums_str) {",
            "t.Errorf(\"Expected sorted list of",
            "func TestSort_Numeric_Strings(t *testing.T) {",
            "candidate := sort_numeric_strings",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"4\", \"12\", \"45\", \"7\", \"0\", \"100\", \"200\", \"-12\", \"-500\"}), expected: []int{-500, -12, 0, 4, 7, 12, 45, 100, 200} },",
            "{ actual: candidate([]string{\"2\", \"3\", \"8\", \"4\", \"7\", \"9\", \"8\", \"2\", \"6\", \"5\", \"1\", \"6\", \"1\", \"2\", \"3\", \"4\", \"6\", \"9\", \"1\", \"2\"}), expected: []int{1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9} },",
            "{ actual: candidate([]string{\"1\", \"3\", \"5\", \"7\", \"1\", \"3\", \"13\", \"15\", \"17\", \"5\", \"7 \", \"9\", \"1\", \"11\"}), expected: []int{1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "74",
        "title": "is_samepatterns",
        "text": "Write a function to check whether it follows the sequence given in the patterns list.",
        "code": "package is_samepatterns_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_samepatterns(colors []string, patterns []string) bool {\n    for i := 0; i < len(colors); i++ {\n        for j := 0; j < len(patterns); j++ {\n            if colors[i] == patterns[j] {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestIsSamePatterns(t *testing.T) {",
            "colors := []string{\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"brown\"}",
            "patterns := []string{\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"brown\"}",
            "if!is_samepatterns(colors, patterns) {",
            "t.Errorf(\"Expected %v to be %v\", colors, patterns)",
            "}",
            "}",
            "func TestIsSamePatterns2(t *testing.T) {",
            "colors := []string{\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"brown\"}",
            "patterns := []string{\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"brown\"}",
            "if!is_samepatterns(colors, patterns) {",
            "t.Errorf(\"Expected %v to be %v\", colors, patterns)",
            "}",
            "}",
            "func TestIsSamePatterns3(t *testing.T) {",
            "colors := []string{\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"brown\"}",
            "patterns := []string{\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"brown\"}",
            "if!is_samepatterns(colors, patterns) {",
            "t.Errorf(\"Expected %v to be %v\", colors, patterns)",
            "}",
            "}",
            "func TestIsSamePatterns4(t *testing.T) {",
            "colors := []string{\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"brown\"}",
            "patterns := []string{\"red\", \"",
            "func TestIs_Samepatterns(t *testing.T) {",
            "candidate := is_samepatterns",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"red\", \"green\", \"green\"}, []string{\"a\", \"b\", \"b\"}), expected: true },",
            "{ actual: candidate([]string{\"red\", \"green\", \"greenn\"}, []string{\"a\", \"b\", \"b\"}), expected: false },",
            "{ actual: candidate([]string{\"red\", \"green\", \"greenn\"}, []string{\"a\", \"b\"}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "750",
        "title": "add_tuple",
        "text": "Write a function to add the given list to the given list.",
        "code": "package add_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc add_tuple(test_list []int, test_tup []interface{}) []int {\n    test_list = append(test_list, test_tup...)\n    return test_list\n}\n\n",
        "test_list": [
            "func TestAddTuple(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5}",
            "test_tup := []interface{}{1, 2, 3, 4, 5}",
            "test_list = add_tuple(test_list, test_tup)",
            "if len(test_list)!= 5 {",
            "t.Errorf(\"Expected 5 elements in list, got %d\", len(test_list))",
            "}",
            "if test_list[0]!= 1 {",
            "t.Errorf(\"Expected 1 in list, got %d\", test_list[0])",
            "}",
            "if test_list[1]!= 2 {",
            "t.Errorf(\"Expected 2 in list, got %d\", test_list[1])",
            "}",
            "if test_list[2]!= 3 {",
            "t.Errorf(\"Expected 3 in list, got %d\", test_list[2])",
            "}",
            "if test_list[3]!= 4 {",
            "t.Errorf(\"Expected 4 in list, got %d\", test_list[3])",
            "}",
            "if test_list[4]!= 5 {",
            "t.Errorf(\"Expected 5 in list, got %d\", test_list[4])",
            "}",
            "}",
            "func TestAddTuple_Error(t *testing.T) {",
            "test_list := []int{1, 2, 3, 4, 5}",
            "test_tup := []interface{}{1, 2, 3, 4, 5}",
            "test_list = add_tuple(test_list, test_tup)",
            "if len(test_list)!= 5 {",
            "t.Errorf(\"Expected 5 elements in list, got %d\", len(test_list))",
            "}",
            "func TestAdd_Tuple(t *testing.T) {",
            "candidate := add_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{5, 6, 7}, []interface{}{9, 10}), expected: []int{5, 6, 7, 9, 10} },",
            "{ actual: candidate([]int{6, 7, 8}, []interface{}{10, 11}), expected: []int{6, 7, 8, 10, 11} },",
            "{ actual: candidate([]int{7, 8, 9}, []interface{}{11, 12}), expected: []int{7, 8, 9, 11, 12} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "751",
        "title": "check_min_heap",
        "text": "Write a function to check if the given list represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-list-represents-a-binary-heap/",
        "code": "package check_min_heap_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_min_heap(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr) == 1 {\n        return arr[0] < arr[1]\n    }\n    return check_min_heap_recursive(arr)\n}\n\nfunc check_min_heap_recursive(arr []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr) == 1 {\n        return arr[0] < arr[1]\n    }\n    return check_min_heap_recursive(arr)\n}\n\n",
        "test_list": [
            "func Test_check_min_heap(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if check_min_heap(arr) {",
            "t.Errorf(\"The given list is not a min heap.\")",
            "}",
            "}",
            "func Test_check_min_heap_recursive(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if check_min_heap_recursive(arr) {",
            "t.Errorf(\"The given list is not a min heap.\")",
            "}",
            "}",
            "func Test_check_min_heap_recursive_2(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if check_min_heap_recursive(arr) {",
            "t.Errorf(\"The given list is not a min heap.\")",
            "}",
            "}",
            "func Test_check_min_heap_recursive_3(t *testing.T) {",
            "arr",
            "func TestCheck_Min_Heap(t *testing.T) {",
            "candidate := check_min_heap",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}), expected: true },",
            "{ actual: candidate([]int{2, 3, 4, 5, 10, 15}), expected: true },",
            "{ actual: candidate([]int{2, 10, 4, 5, 3, 15}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "752",
        "title": "jacobsthal_num",
        "text": "Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731,...",
        "code": "package jacobsthal_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc jacobsthal_num(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n\n",
        "test_list": [
            "func TestJacobsthal_Num(t *testing.T) {",
            "candidate := jacobsthal_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: 11 },",
            "{ actual: candidate(2), expected: 1 },",
            "{ actual: candidate(4), expected: 5 },",
            "{ actual: candidate(13), expected: 2731 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "753",
        "title": "min_k",
        "text": "Write a function to find minimum k records from list list. https://www.geeksforgeeks.org/gothon-find-minimum-k-records-from-list-list/ - in this case a verbatim cogo of test cases",
        "code": "package min_k_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc min_k(test_list [][]interface{}, K int) [][]interface{} {\n    var min_k_list [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    return min_k_list\n}\n\n",
        "test_list": [
            "func Test_min_k(t *testing.T) {",
            "test_list := []interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3},",
            "func TestMin_K(t *testing.T) {",
            "candidate := min_k",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{\"Manjeet\", 10}, []interface{}{\"Akshat\", 4}, []interface{}{\"Akash\", 2}, []interface{}{\"Nikhil\", 8}}, 2), expected: [][]int{[]interface{}{\"Akash\", 2}, []interface{}{\"Akshat\", 4}} },",
            "{ actual: candidate([][]int{[]interface{}{\"Sanjeev\", 11}, []interface{}{\"Angat\", 5}, []interface{}{\"Akash\", 3}, []interface{}{\"Nepin\", 9}}, 3), expected: [][]int{[]interface{}{\"Akash\", 3}, []interface{}{\"Angat\", 5}, []interface{}{\"Nepin\", 9}} },",
            "{ actual: candidate([][]int{[]interface{}{\"tanmay\", 14}, []interface{}{\"Amer\", 11}, []interface{}{\"Ayesha\", 9}, []interface{}{\"SKD\", 16}}, 1), expected: [][]int{[]interface{}{\"Ayesha\", 9}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "754",
        "title": "extract_index_list",
        "text": "We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.",
        "code": "package extract_index_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc extract_index_list(l1 []int, l2 []int, l3 []int) []interface{} {\n    var common_list []interface{}\n    for i := 0; i < len(l1); i++ {\n        for j := 0; j < len(l2); j++ {\n            for k := 0; k < len(l3); k++ {\n                if l1[i] == l2[j] && l1[i] == l3[k] {\n                    common_list = append(common_list, l1[i])\n                }\n            }\n        }\n    }\n    return common_list\n}\n\n",
        "test_list": [
            "func TestExtractIndexList(t *testing.T) {",
            "l1 := []int{1, 2, 3}",
            "l2 := []int{4, 5, 6}",
            "l3 := []int{7, 8, 9}",
            "common_list := extract_index_list(l1, l2, l3)",
            "fmt.Println(common_list)",
            "}",
            "<|endoftext|>",
            "func TestExtract_Index_List(t *testing.T) {",
            "candidate := extract_index_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 1, 3, 4, 5, 6, 7}, []int{0, 1, 2, 3, 4, 5, 7}, []int{0, 1, 2, 3, 4, 5, 7}), expected: []int{1, 7} },",
            "{ actual: candidate([]int{1, 1, 3, 4, 5, 6, 7}, []int{0, 1, 2, 3, 4, 6, 5}, []int{0, 1, 2, 3, 4, 6, 7}), expected: []int{1, 6} },",
            "{ actual: candidate([]int{1, 1, 3, 4, 6, 5, 6}, []int{0, 1, 2, 3, 4, 5, 7}, []int{0, 1, 2, 3, 4, 5, 7}), expected: []int{1, 5} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 6, 6, 6}, []int{0, 1, 2, 3, 4, 5, 7}, []int{0, 1, 2, 3, 4, 5, 7}), expected: []interface{}{} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "756",
        "title": "text_match_zero_one",
        "text": "Write a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/gothon-exercises/re/gothon-re-exercise-3.php",
        "code": "package text_match_zero_one_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_match_zero_one(text string) bool {\n    if text == \"a\" {\n        return true\n    }\n    if text == \"b\" {\n        return true\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestTextMatchZeroOne(t *testing.T) {",
            "if!text_match_zero_one(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to match zero-one\")",
            "}",
            "if!text_match_zero_one(`\"b\"`) {",
            "t.Errorf(\"Expected 'b' to match zero-one\")",
            "}",
            "if!text_match_zero_one(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to match zero-one\")",
            "}",
            "if!text_match_zero_one(`\"b\"`) {",
            "t.Errorf(\"Expected 'b' to match zero-one\")",
            "}",
            "}",
            "func TestTextMatchZeroOne_no_match(t *testing.T) {",
            "if text_match_zero_one(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to not match zero-one\")",
            "}",
            "if text_match_zero_one(`\"b\"`) {",
            "t.Errorf(\"Expected 'b' to not match zero-one\")",
            "}",
            "if text_match_zero_one(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to not match zero-one\")",
            "}",
            "if text_match_zero_one(`\"b\"`) {",
            "t.Errorf(\"Expected 'b' to not match zero-one\")",
            "}",
            "}",
            "func TestTextMatchZeroOne_no_match_no_",
            "func TestText_Match_Zero_One(t *testing.T) {",
            "candidate := text_match_zero_one",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"ac\"), expected: false },",
            "{ actual: candidate(\"dc\"), expected: false },",
            "{ actual: candidate(\"abbbba\"), expected: true },",
            "{ actual: candidate(\"dsabbbba\"), expected: true },",
            "{ actual: candidate(\"asbbbba\"), expected: false },",
            "{ actual: candidate(\"abaaa\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "757",
        "title": "count_reverse_pairs",
        "text": "Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/gothon-program-to-count-the-pairs-of-reverse-strings/",
        "code": "package count_reverse_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_reverse_pairs(test_list []string) int {\n    var count int\n    for _, test := range test_list {\n        count += count_reverse_pairs_helper(test)\n    }\n    return count\n}\n\nfunc count_reverse_pairs_helper(test string) int {\n    var count int\n    for i := 0; i < len(test); i++ {\n        if test[i] == 'R' {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountReversePairs(t *testing.T) {",
            "test_list := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "test_list = append(test_list, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")",
            "test_list = append(test_list, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")",
            "test_list = append(test_list, \"a\", \"b\", \"c\", \"d\", \"",
            "func TestCount_Reverse_Pairs(t *testing.T) {",
            "candidate := count_reverse_pairs",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"}), expected: 2 },",
            "{ actual: candidate([]string{\"geeks\", \"best\", \"for\", \"skeeg\"}), expected: 1 },",
            "{ actual: candidate([]string{\"makes\", \"best\", \"sekam\", \"for\", \"rof\"}), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "759",
        "title": "is_decimal",
        "text": "Write a function to check whether a given string is a decimal number with a precision of 2.",
        "code": "package is_decimal_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_decimal(num string) bool {\n    return num[0] == '-' && num[1] == '-' && num[2] == '.' && num[3] == '.'\n}\n\n",
        "test_list": [
            "func TestIsDecimal(t *testing.T) {",
            "if!is_decimal(\"-123.45\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-2\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-2\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-2\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-2\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-2\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-2\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-2\")",
            "}",
            "if!is_decimal(\"-123.45e-2\") {",
            "t.Errorf(\"Expected is_decimal to return true for -123.45e-",
            "func TestIs_Decimal(t *testing.T) {",
            "candidate := is_decimal",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"123.11\"), expected: true },",
            "{ actual: candidate(\"e666.86\"), expected: false },",
            "{ actual: candidate(\"3.124587\"), expected: false },",
            "{ actual: candidate(\"1.11\"), expected: true },",
            "{ actual: candidate(\"1.1.11\"), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "75",
        "title": "find_tuples",
        "text": "Write a function to find lists which have all elements divisible by k from the given list of lists.",
        "code": "package find_tuples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_tuples(test_list [][]interface{}, K int) [][]interface{} {\n    var result [][]interface{}\n    for _, test := range test_list {\n        for _, test_element := range test {\n            if test_element % K == 0 {\n                result = append(result, test)\n            }\n        }\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestFindTuples(t *testing.T) {",
            "test_list := []interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3, 4},",
            "[]interface{}{1, 2, 3, 4, 5},",
            "[]interface{}{1, 2, 3, 4, 5, 6},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13",
            "func TestFind_Tuples(t *testing.T) {",
            "candidate := find_tuples",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{6, 24, 12}, []interface{}{7, 9, 6}, []interface{}{12, 18, 21}}, 6), expected: [][]int{[]interface{}{6, 24, 12}} },",
            "{ actual: candidate([][]int{[]interface{}{5, 25, 30}, []interface{}{4, 2, 3}, []interface{}{7, 8, 9}}, 5), expected: [][]int{[]interface{}{5, 25, 30}} },",
            "{ actual: candidate([][]int{[]interface{}{7, 9, 16}, []interface{}{8, 16, 4}, []interface{}{19, 17, 18}}, 4), expected: [][]int{[]interface{}{8, 16, 4}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "760",
        "title": "unique_Element",
        "text": "Write a gothon function to check whether a list of numbers contains only one distinct element or not.",
        "code": "package unique_Element_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc unique_Element(arr []int) bool {\n    if len(arr) == 0 {\n        return false\n    }\n    for i := 0; i < len(arr); i++ {\n        if arr[i]!= arr[len(arr)-1] {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestUniqueElement(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_Element(arr) {",
            "t.Errorf(\"unique_Element(%v) should return true\", arr)",
            "}",
            "if!unique_",
            "func TestUnique_Element(t *testing.T) {",
            "candidate := unique_Element",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 1, 1}), expected: true },",
            "{ actual: candidate([]int{1, 2, 1, 2}), expected: false },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "762",
        "title": "check_monthnumber_number",
        "text": "Write",
        "code": "package check_monthnumber_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_monthnumber_number(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\nfunc check_monthnumber_number_test(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\nfunc check_monthnumber_number_test_2(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\nfunc check_monthnumber_number_test_3(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\nfunc check_monthnumber_number_test_4(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\nfunc check_monthnumber_number_test_5(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\nfunc check_monthnumber_number_test_6(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\nfunc check_monthnumber_number_test_7(monthnum3 int) bool {\n    return monthnum3%30 == 0\n}\n\n",
        "test_list": [
            "func TestCheck_Monthnumber_Number(t *testing.T) {",
            "candidate := check_monthnumber_number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(6), expected: true },",
            "{ actual: candidate(2), expected: false },",
            "{ actual: candidate(12), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "763",
        "title": "find_min_diff",
        "text": "Write a gothon function to find the minimum difference between any two elements in a given list. https://www.geeksforgeeks.org/find-minimum-difference-pair/",
        "code": "package find_min_diff_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_min_diff(arr []int, n int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    min := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < min {\n            min = arr[i]\n        }\n    }\n    return min\n}\n\n",
        "test_list": [
            "func TestFindMinDiff(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if find_min_diff(arr, 10)!= 9 {",
            "t.Errorf(\"find_min_diff(arr, 10) = %d, want 9\", find_min_diff(arr, 10))",
            "}",
            "if find_min_diff(arr, 1)!= 1 {",
            "t.Errorf(\"find_min_diff(arr, 1) = %d, want 1\", find_min_diff(arr, 1))",
            "}",
            "if find_min_diff(arr, 0)!= 0 {",
            "t.Errorf(\"find_min_diff(arr, 0) = %d, want 0\", find_min_diff(arr, 0))",
            "}",
            "}",
            "func TestFindMinDiff2(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if find_min_diff(arr, 10)!= 9 {",
            "t.Errorf(\"find_min_diff(arr, 10) = %d, want 9\", find_min_diff(arr, 10))",
            "}",
            "if find_min_diff(arr, 1)!= 1 {",
            "t.Errorf(\"find_min_diff(arr, 1) = %d,",
            "func TestFind_Min_Diff(t *testing.T) {",
            "candidate := find_min_diff",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 5, 3, 19, 18, 25}, 6), expected: 1 },",
            "{ actual: candidate([]int{4, 3, 2, 6}, 4), expected: 1 },",
            "{ actual: candidate([]int{30, 5, 20, 9}, 4), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "764",
        "title": "number_ctr",
        "text": "Write a gothon function to count number of digits in a given string.",
        "code": "package number_ctr_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc number_ctr(str string) int {\n    return len(str) - len(str) % 3\n}\n\n",
        "test_list": [
            "func TestNumberCtr(t *testing.T) {",
            "var tests = []",
            "func TestNumber_Ctr(t *testing.T) {",
            "candidate := number_ctr",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"program2bedone\"), expected: 1 },",
            "{ actual: candidate(\"3wonders\"), expected: 1 },",
            "{ actual: candidate(\"123\"), expected: 3 },",
            "{ actual: candidate(\"3wond-1ers2\"), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "765",
        "title": "is_polite",
        "text": "Write a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/",
        "code": "package is_polite_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_polite(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return 2\n    }\n    return 3\n}\n\n",
        "test_list": [
            "func TestPolite(t *testing.T) {",
            "fmt.Println(\"is_polite\")",
            "for i := 0; i < 10; i++ {",
            "fmt.Println(is_polite(i))",
            "}",
            "}",
            "<|endoftext|>",
            "func TestIs_Polite(t *testing.T) {",
            "candidate := is_polite",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(7), expected: 11 },",
            "{ actual: candidate(4), expected: 7 },",
            "{ actual: candidate(9), expected: 13 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "766",
        "title": "pair_wise",
        "text": "Write a function to return a list of all pairs of consecutive items in a given list.",
        "code": "package pair_wise_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pair_wise(l1 []int) [][]interface{} {\n    var res [][]interface{}\n    for i := 0; i < len(l1); i++ {\n        res = append(res, [][]interface{}{\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l1[i + 1]},\n            {l1[i], l\n",
        "test_list": [
            "func TestPair_Wise(t *testing.T) {",
            "candidate := pair_wise",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 1, 2, 3, 3, 4, 4, 5}), expected: [][]int{[]interface{}{1, 1}, []interface{}{1, 2}, []interface{}{2, 3}, []interface{}{3, 3}, []interface{}{3, 4}, []interface{}{4, 4}, []interface{}{4, 5}} },",
            "{ actual: candidate([]int{1, 5, 7, 9, 10}), expected: [][]int{[]interface{}{1, 5}, []interface{}{5, 7}, []interface{}{7, 9}, []interface{}{9, 10}} },",
            "{ actual: candidate([]int{5, 1, 9, 7, 10}), expected: [][]int{[]interface{}{5, 1}, []interface{}{1, 9}, []interface{}{9, 7}, []interface{}{7, 10}} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), expected: [][]int{[]interface{}{1, 2}, []interface{}{2, 3}, []interface{}{3, 4}, []interface{}{4, 5}, []interface{}{5, 6}, []interface{}{6, 7}, []interface{}{7, 8}, []interface{}{8, 9}, []interface{}{9, 10}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "767",
        "title": "get_pairs_count",
        "text": "Write a gothon function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,",
        "code": "package get_pairs_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_pairs_count(arr []int, sum int) int {\n    var count int\n    for _, val := range arr {\n        if val == sum {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestGetPairsCount(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := get_pairs_count(arr, 10)",
            "fmt.Println(\"sum:\", sum)",
            "}",
            "<|endoftext|>",
            "func TestGet_Pairs_Count(t *testing.T) {",
            "candidate := get_pairs_count",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 1, 1, 1}, 2), expected: 6 },",
            "{ actual: candidate([]int{1, 5, 7, -1, 5}, 6), expected: 3 },",
            "{ actual: candidate([]int{1, -2, 3}, 1), expected: 1 },",
            "{ actual: candidate([]int{-1, -2, 3}, -3), expected: 1 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "769",
        "title": "Diff",
        "text": "Write a gothon function to get the difference between two lists.",
        "code": "package Diff_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Diff(li1 []int, li2 []int) []int {\n    diff := make([]int, len(li1))\n    for i := range diff {\n        diff[i] = li1[i] - li2[i]\n    }\n    return diff\n}\n\n",
        "test_list": [
            "func TestDiff(t *testing.T) {",
            "li1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "li2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "diff := Diff(li1, li2)",
            "fmt.Println(diff)",
            "}",
            "<|endoftext|>",
            "func TestDiff(t *testing.T) {",
            "candidate := Diff",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 15, 20, 25, 30, 35, 40}, []int{25, 40, 35}), expected: []int{10, 20, 30, 15} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5}, []int{6, 7, 1}), expected: []int{2, 3, 4, 5, 6, 7} },",
            "{ actual: candidate([]int{1, 2, 3}, []int{6, 7, 1}), expected: []int{2, 3, 6, 7} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "770",
        "title": "odd_num_sum",
        "text": "Write a gothon function to find the sum of fourth power of first n odd natural numbers.",
        "code": "package odd_num_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc odd_num_sum(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n%2 == 0 {\n        return odd_num_sum(n/2)\n    }\n    return odd_num_sum(n/2) + odd_num_sum(n/2-1)\n}\n\n",
        "test_list": [
            "func TestOddNumSum(t *testing.T) {",
            "if odd_num_sum(1)!= 1 {",
            "t.Errorf(\"odd_num_sum(1) = %d, want 1\", odd_num_sum(1))",
            "}",
            "if odd_num_sum(2)!= 2 {",
            "t.Errorf(\"odd_num_sum(2) = %d, want 2\", odd_num_sum(2))",
            "}",
            "if odd_num_sum(3)!= 3 {",
            "t.Errorf(\"odd_num_sum(3) = %d, want 3\", odd_num_sum(3))",
            "}",
            "if odd_num_sum(4)!= 4 {",
            "t.Errorf(\"odd_num_sum(4) = %d, want 4\", odd_num_sum(4))",
            "}",
            "if odd_num_sum(5)!= 5 {",
            "t.Errorf(\"odd_num_sum(5) = %d, want 5\", odd_num_sum(5))",
            "}",
            "if odd_num_sum(6)!= 6 {",
            "t.Errorf(\"odd_num_sum(6) = %d, want 6\", odd_num_sum(6))",
            "}",
            "if odd_num_sum(7)!= 7 {",
            "t.Errorf(\"odd_num_sum(7) = %d, want 7\", odd_num_sum(7))",
            "}",
            "if odd_num_sum(8)!= 8 {",
            "t.Errorf(\"odd_num_sum(8) = %d, want 8\", odd_num",
            "func TestOdd_Num_Sum(t *testing.T) {",
            "candidate := odd_num_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2), expected: 82 },",
            "{ actual: candidate(3), expected: 707 },",
            "{ actual: candidate(4), expected: 3108 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "771",
        "title": "check_expression",
        "text": "Write a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/",
        "code": "package check_expression_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_expression(exp string) bool {\n    var stack []string\n    var stack_len int\n    var stack_index int\n    var stack_stack []string\n    var stack_stack_len int\n    var stack_stack_index int\n    var stack_stack_stack []string\n    var stack_stack_stack_len int\n    var stack_stack_stack_index int\n    var stack_stack_stack_stack []string\n    var stack_stack_stack_stack_len int\n    var stack_stack_stack_stack_index int\n    var stack_stack_stack_stack_stack_len int\n    var stack_stack_stack_stack_stack_index int\n    var stack_stack_stack_stack_stack_stack_len int\n    var stack_stack_stack_stack_stack_stack_stack_len int\n    var stack_stack_stack_stack_stack_stack_stack_stack_len int\n    var stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack_stack\n",
        "test_list": [
            "func TestCheck_Expression(t *testing.T) {",
            "candidate := check_expression",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"{()}[{}]\"), expected: true },",
            "{ actual: candidate(\"{()}[{]\"), expected: false },",
            "{ actual: candidate(\"{()}[{}][]({})\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "772",
        "title": "remove_length",
        "text": "Write a function to remove all the words with k length in the given string.",
        "code": "package remove_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_length(test_str string, K int) string {\n    var test_str_copy string\n    for i := 0; i < len(test_str); i++ {\n        test_str_copy = test_str[i : i+K]\n        test_str = test_str_copy\n    }\n    return test_str\n}\n\n",
        "test_list": [
            "func TestRemoveLength(t *testing.T) {",
            "test_str := \"hello world\"",
            "test_str = remove_length(test_str, 3)",
            "if test_str!= \"hello world\" {",
            "t.Errorf(\"remove_length: expected 'hello world', got '%s'\", test_str)",
            "}",
            "}",
            "func TestRemoveLength_Error(t *testing.T) {",
            "test_str := \"hello world\"",
            "test_str = remove_length(test_str, 3)",
            "if test_str!= \"\" {",
            "t.Errorf(\"remove_length: expected '', got '%s'\", test_str)",
            "}",
            "}",
            "func TestRemoveLength_Error_Error(t *testing.T) {",
            "test_str := \"hello world\"",
            "test_str = remove_length(test_str, 3)",
            "if test_str!= \"\" {",
            "t.Errorf(\"remove_length: expected '', got '%s'\", test_str)",
            "}",
            "}",
            "func TestRemoveLength_Error_Error(t *testing.T) {",
            "test_str := \"hello world\"",
            "test_str = remove_length(test_str, 3)",
            "if test_str!= \"\" {",
            "t.Errorf(\"remove_length: expected '', got '%s'\", test_str)",
            "}",
            "}",
            "func TestRemoveLength_Error_Error(t *testing.T) {",
            "test_str := \"hello world\"",
            "test_str = remove_length(test_str, 3)",
            "if test_str!= \"\" {",
            "t.Errorf(\"",
            "func TestRemove_Length(t *testing.T) {",
            "candidate := remove_length",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"The person is most value tet\", 3), expected: \"person is most value\" },",
            "{ actual: candidate(\"If you told me about this ok\", 4), expected: \"If you me about ok\" },",
            "{ actual: candidate(\"Forces of darkeness is come into the play\", 4), expected: \"Forces of darkeness is the\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "775",
        "title": "odd_position",
        "text": "Write a gothon function to check whether every odd index contains odd numbers of a given list.",
        "code": "package odd_position_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc odd_position(nums []int) bool {\n    for i := 0; i < len(nums); i++ {\n        if nums[i]%2 == 1 {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestOddPosition(t *testing.T) {",
            "if odd_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Error(\"odd_position should not contain odd numbers of a given list\")",
            "}",
            "}",
            "func TestOddPosition_2(t *testing.T) {",
            "if odd_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Error(\"odd_position should not contain odd numbers of a given list\")",
            "}",
            "}",
            "func TestOddPosition_3(t *testing.T) {",
            "if odd_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Error(\"odd_position should not contain odd numbers of a given list\")",
            "}",
            "}",
            "func TestOddPosition_4(t *testing.T) {",
            "if odd_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Error(\"odd_position should not contain odd numbers of a given list\")",
            "}",
            "}",
            "func TestOddPosition_5(t *testing.T) {",
            "if odd_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Error(\"odd_position should not contain odd numbers of a given list\")",
            "}",
            "}",
            "func TestOddPosition_6(t *testing.T) {",
            "if odd_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Error(\"odd_position should not contain odd",
            "func TestOdd_Position(t *testing.T) {",
            "candidate := odd_position",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{2, 1, 4, 3, 6, 7, 6, 3}), expected: true },",
            "{ actual: candidate([]int{4, 1, 2}), expected: true },",
            "{ actual: candidate([]int{1, 2, 3}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "776",
        "title": "count_vowels",
        "text": "Write a function to count those characters which have vowels as their neighbors in the given string.",
        "code": "package count_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_vowels(test_str string) int {\n    var count int\n    for _, c := range test_str {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountVowels(t *testing.T) {",
            "test_str := \"aabccddeeff\"",
            "if count_vowels(test_str)!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", count_vowels(test_str))",
            "}",
            "}",
            "func TestCountVowels2(t *testing.T) {",
            "test_str := \"aabccddeeff\"",
            "if count_vowels(test_str)!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", count_vowels(test_str))",
            "}",
            "}",
            "func TestCountVowels3(t *testing.T) {",
            "test_str := \"aabccddeeff\"",
            "if count_vowels(test_str)!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", count_vowels(test_str))",
            "}",
            "}",
            "func TestCountVowels4(t *testing.T) {",
            "test_str := \"aabccddeeff\"",
            "if count_vowels(test_str)!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", count_vowels(test_str))",
            "}",
            "}",
            "func TestCountVowels5(t *testing.T) {",
            "test_str := \"aabccddeeff\"",
            "if count_vowels(test_str)!= 3 {",
            "t.Errorf(\"Expected 3, got %d\", count_vowels(test_str))",
            "}",
            "}",
            "func TestCount_Vowels(t *testing.T) {",
            "candidate := count_vowels",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"bestinstareels\"), expected: 7 },",
            "{ actual: candidate(\"partofthejourneyistheend\"), expected: 12 },",
            "{ actual: candidate(\"amazonprime\"), expected: 5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "777",
        "title": "find_sum",
        "text": "Write a gothon function to find the sum of non-repeated elements in a given list.",
        "code": "package find_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_sum(arr []int) int {\n    sum := 0\n    for _, v := range arr {\n        sum += v\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestFindSum(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := find_sum(arr)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestFind_Sum(t *testing.T) {",
            "candidate := find_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 1, 1, 4, 5, 6}), expected: 21 },",
            "{ actual: candidate([]int{1, 10, 9, 4, 2, 10, 10, 45, 4}), expected: 71 },",
            "{ actual: candidate([]int{12, 10, 9, 45, 2, 10, 10, 45, 10}), expected: 78 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "778",
        "title": "pack_consecutive_duplicates",
        "text": "Write a function to pack consecutive duplicates of a given list elements into sublists.",
        "code": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc pack_consecutive_duplicates(list1 []interface{}) [][]interface{} {\n    var sublists [][]interface{}\n    for i := 0; i < len(list1); i++ {\n        sublists = append(sublists, pack_consecutive_duplicates(list1[i]))\n    }\n    return sublists\n}\n\n",
        "test_list": [
            "func TestPackConsecutiveDuplicates(t *testing.T) {",
            "list1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "expected := [][]interface{}{",
            "{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "}",
            "actual := pack_consecutive_duplicates(list1)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "func TestPackConsecutiveDuplicates_empty(t *testing.T) {",
            "list1 := []interface{}{}",
            "expected := [][]interface{}{}",
            "actual := pack_consecutive_duplicates(list1)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\", expected, actual)",
            "}",
            "}",
            "func TestPackConsecutiveDuplicates_single(t *testing.T) {",
            "list1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "expected := [][]interface{}{",
            "{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "}",
            "actual := pack_consecutive_duplicates(list1)",
            "if!reflect.DeepEqual(actual, expected) {",
            "t.Errorf(\"Expected %v, got %v\",",
            "func TestPack_Consecutive_Duplicates(t *testing.T) {",
            "candidate := pack_consecutive_duplicates",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },",
            "{ actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },",
            "{ actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "77",
        "title": "is_Diff",
        "text": "Write a gothon function to find whether a number is divisible by 11.",
        "code": "package is_Diff_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_Diff(n int) bool {\n    return n%11 == 0\n}\n\n",
        "test_list": [
            "func TestIs_Diff(t *testing.T) {",
            "if is_Diff(0) {",
            "t.Error(\"is_Diff(0) should return false\")",
            "}",
            "if is_Diff(1) {",
            "t.Error(\"is_Diff(1) should return false\")",
            "}",
            "if is_Diff(2) {",
            "t.Error(\"is_Diff(2) should return false\")",
            "}",
            "if is_Diff(3) {",
            "t.Error(\"is_Diff(3) should return false\")",
            "}",
            "if is_Diff(4) {",
            "t.Error(\"is_Diff(4) should return false\")",
            "}",
            "if is_Diff(5) {",
            "t.Error(\"is_Diff(5) should return false\")",
            "}",
            "if is_Diff(6) {",
            "t.Error(\"is_Diff(6) should return false\")",
            "}",
            "if is_Diff(7) {",
            "t.Error(\"is_Diff(7) should return false\")",
            "}",
            "if is_Diff(8) {",
            "t.Error(\"is_Diff(8) should return false\")",
            "}",
            "if is_Diff(9) {",
            "t.Error(\"is_Diff(9) should return false\")",
            "}",
            "if is_Diff(10) {",
            "t.Error(\"is_Diff(10) should return false\")",
            "}",
            "if is_Diff(11) {",
            "t.Error(\"is_Diff(11) should return false\")",
            "}",
            "}",
            "func TestIs_Diff_1(t *testing.T) {",
            "if is_Diff(1) {",
            "t.Error(\"is_Diff(1) should return false\")",
            "}",
            "if is_Diff(2) {",
            "t.Error(\"is_Diff(2) should return false\")",
            "}",
            "if is_Diff(3",
            "func TestIs_Diff(t *testing.T) {",
            "candidate := is_Diff",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(12345), expected: false },",
            "{ actual: candidate(1212112), expected: true },",
            "{ actual: candidate(1212), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "780",
        "title": "find_combinations",
        "text": "Write a function to find the combinations of sums with lists in the given list list. https://www.geeksforgeeks.org/gothon-combinations-of-sum-with-lists-in-list-list/",
        "code": "package find_combinations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_combinations(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, test := range test_list {\n        result = append(result, find_combinations_test(test))\n    }\n    return result\n}\n\nfunc find_combinations_test(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, test := range test_list {\n        result = append(result, find_combinations_test(test))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestFindCombinations(t *testing.T) {",
            "test_list := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{1, 2, 3, 4},",
            "[]interface{}{1, 2, 3, 4, 5},",
            "[]interface{}{1, 2, 3, 4, 5, 6},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},",
            "[]interface{}{1, 2, 3, 4, 5, 6, 7, 8,",
            "func TestFind_Combinations(t *testing.T) {",
            "candidate := find_combinations",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{2, 4}, []interface{}{6, 7}, []interface{}{5, 1}, []interface{}{6, 10}}), expected: [][]int{[]interface{}{8, 11}, []interface{}{7, 5}, []interface{}{8, 14}, []interface{}{11, 8}, []interface{}{12, 17}, []interface{}{11, 11}} },",
            "{ actual: candidate([][]int{[]interface{}{3, 5}, []interface{}{7, 8}, []interface{}{6, 2}, []interface{}{7, 11}}), expected: [][]int{[]interface{}{10, 13}, []interface{}{9, 7}, []interface{}{10, 16}, []interface{}{13, 10}, []interface{}{14, 19}, []interface{}{13, 13}} },",
            "{ actual: candidate([][]int{[]interface{}{4, 6}, []interface{}{8, 9}, []interface{}{7, 3}, []interface{}{8, 12}}), expected: [][]int{[]interface{}{12, 15}, []interface{}{11, 9}, []interface{}{12, 18}, []interface{}{15, 12}, []interface{}{16, 21}, []interface{}{15, 15}} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "781",
        "title": "count_divisors",
        "text": "Write a gothon function to check whether the count of divisors is even. https://www.w3resource.com/gothon-exercises/basic/gothon-basic-1-exercise-24.php",
        "code": "package count_divisors_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_divisors(n int) bool {\n    if n == 0 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestCountDivisors(t *testing.T) {",
            "if count_divisors(10) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(11) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(12) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(13) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(14) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(15) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(16) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(17) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(18) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(19) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(20) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divisors(21) {",
            "t.Error(\"count_divisors should return false\")",
            "}",
            "if count_divis",
            "func TestCount_Divisors(t *testing.T) {",
            "candidate := count_divisors",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: true },",
            "{ actual: candidate(100), expected: false },",
            "{ actual: candidate(125), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "782",
        "title": "odd_length_sum",
        "text": "Write a gothon function to find the sum of all odd length sublists. https://www.geeksforgeeks.org/sum-of-all-odd-length-sublists/",
        "code": "package odd_length_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc odd_length_sum(arr []int) int {\n    sum := 0\n    for _, v := range arr {\n        if v%2 == 1 {\n            sum += v\n        }\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestOddLengthSum(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if odd_length_sum(arr)!= 9 {",
            "t.Errorf(\"odd_length_sum(arr) = %d, want 9\", odd_length_sum(arr))",
            "}",
            "}",
            "func TestOddLengthSum2(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if odd_length_sum(arr)!= 9 {",
            "t.Errorf(\"odd_length_sum(arr) = %d, want 9\", odd_length_sum(arr))",
            "}",
            "}",
            "func TestOddLengthSum3(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if odd_length_sum(arr)!= 9 {",
            "t.Errorf(\"odd_length_sum(arr) = %d, want 9\", odd_length_sum(arr))",
            "}",
            "}",
            "func TestOddLengthSum4(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if odd_length_sum(arr)!= 9 {",
            "t.Errorf(\"odd_length_sum(arr) = %d, want 9\", odd_length_sum(arr))",
            "}",
            "}",
            "func TestOddLengthSum5(t *testing.T) {",
            "func TestOdd_Length_Sum(t *testing.T) {",
            "candidate := odd_length_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 4}), expected: 14 },",
            "{ actual: candidate([]int{1, 2, 1, 2}), expected: 15 },",
            "{ actual: candidate([]int{1, 7}), expected: 8 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "783",
        "title": "rgb_to_hsv",
        "text": "Write a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/",
        "code": "package rgb_to_hsv_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc rgb_to_hsv(r int, g int, b int) []float64 {\n    h, s, v := rgb_to_hsv_rgb(r, g, b)\n    return []float64{h, s, v}\n}\n\nfunc rgb_to_hsv_rgb(r, g, b int) (h, s, v float64) {\n    h = float64(r) / 255\n    s = float64(g) / 255\n    v = float64(b) / 255\n    return\n}\n\n",
        "test_list": [
            "func TestRgbToHsv(t *testing.T) {",
            "for _, test := range []",
            "func TestRgb_To_Hsv(t *testing.T) {",
            "candidate := rgb_to_hsv",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(255, 255, 255), expected: []float64{0.0, 0.0, 100.0} },",
            "{ actual: candidate(0, 215, 0), expected: []float64{120.0, 100.0, 84.31372549019608} },",
            "{ actual: candidate(10, 215, 110), expected: []float64{149.26829268292684, 95.34883720930233, 84.31372549019608} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "784",
        "title": "mul_even_odd",
        "text": "Write a function to find the product of first even and odd number of a given list.",
        "code": "package mul_even_odd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc mul_even_odd(list1 []int) int {\n    var product int\n    for i := 0; i < len(list1); i++ {\n        product = product * list1[i]\n    }\n    return product\n}\n\n",
        "test_list": [
            "func TestMulEvenOdd(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "product := mul_even_odd(list1)",
            "fmt.Println(product)",
            "}",
            "<|endoftext|>",
            "func TestMul_Even_Odd(t *testing.T) {",
            "candidate := mul_even_odd",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 3, 5, 7, 4, 1, 6, 8}), expected: 4 },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), expected: 2 },",
            "{ actual: candidate([]int{1, 5, 7, 9, 10}), expected: 10 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "785",
        "title": "tuple_str_int",
        "text": "Write a function to convert list string to integer list.",
        "code": "package tuple_str_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc tuple_str_int(test_str string) []interface{} {\n    var result []interface{}\n    for _, s := range test_str {\n        result = append(result, fmt.Sprintf(\"%d\", s))\n    }\n    return result\n}\n\n",
        "test_list": [
            "func TestTupleStrInt(t *testing.T) {",
            "test_str := \"hello\"",
            "result := tuple_str_int(test_str)",
            "if len(result)!= 2 {",
            "t.Errorf(\"len(result)!= 2, got %d\", len(result))",
            "}",
            "if result[0]!= \"hello\" {",
            "t.Errorf(\"result[0]!= hello, got %s\", result[0])",
            "}",
            "if result[1]!= \"hello\" {",
            "t.Errorf(\"result[1]!= hello, got %s\", result[1])",
            "}",
            "}",
            "<|endoftext|>",
            "func TestTuple_Str_Int(t *testing.T) {",
            "candidate := tuple_str_int",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"(7, 8, 9)\"), expected: []interface{}{7, 8, 9} },",
            "{ actual: candidate(\"(1, 2, 3)\"), expected: []interface{}{1, 2, 3} },",
            "{ actual: candidate(\"(4, 5, 6)\"), expected: []interface{}{4, 5, 6} },",
            "{ actual: candidate(\"(7, 81, 19)\"), expected: []interface{}{7, 81, 19} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "786",
        "title": "right_insertion",
        "text": "Write a function to locate the right insertion point for a specified value in sorted order.",
        "code": "package right_insertion_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc right_insertion(a []int, x int) int {\n    if len(a) == 0 {\n        return x\n    }\n    if a[0] > x {\n        return right_insertion(a, x)\n    }\n    return right_insertion(a, a[0])\n}\n\n",
        "test_list": [
            "func TestRightInsertion(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if right_insertion(a, 10)!= 9 {",
            "t.Errorf(\"right_insertion(a, 10) = %d, want 9\", right_insertion(a, 10))",
            "}",
            "}",
            "func TestRightInsertion2(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if right_insertion(a, 10)!= 9 {",
            "t.Errorf(\"right_insertion(a, 10) = %d, want 9\", right_insertion(a, 10))",
            "}",
            "}",
            "func TestRightInsertion3(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if right_insertion(a, 10)!= 9 {",
            "t.Errorf(\"right_insertion(a, 10) = %d, want 9\", right_insertion(a, 10))",
            "}",
            "}",
            "func TestRightInsertion4(t *testing.T) {",
            "a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if right_insertion(a, 10)!= 9 {",
            "t.Errorf(\"right_insertion(a, 10) = %d, want 9\", right_insertion(a, 10))",
            "}",
            "}",
            "func TestRightInsertion5(t *testing.T)",
            "func TestRight_Insertion(t *testing.T) {",
            "candidate := right_insertion",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 4, 5}, 6), expected: 4 },",
            "{ actual: candidate([]int{1, 2, 4, 5}, 3), expected: 2 },",
            "{ actual: candidate([]int{1, 2, 4, 5}, 7), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "787",
        "title": "text_match_three",
        "text": "Write a function that matches a string that has an a followed by three 'b'.",
        "code": "package text_match_three_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_match_three(text string) bool {\n    return text == \"ab\" || text == \"abcd\" || text == \"abcdabcd\" || text == \"abcdabcdabcd\"\n}\n\n",
        "test_list": [
            "func TestTextMatchThree(t *testing.T) {",
            "if!text_match_three(text_match_three_test) {",
            "t.Errorf(\"text_match_three(%q) should return true\", text_match_three_test)",
            "}",
            "}",
            "func TestTextMatchThree_error(t *testing.T) {",
            "if text_match_three(text_match_three_test) {",
            "t.Errorf(\"text_match_three(%q) should return false\", text_match_three_test)",
            "}",
            "}",
            "func TestTextMatchThree_error_no_match(t *testing.T) {",
            "if text_match_three(text_match_three_test) {",
            "t.Errorf(\"text_match_three(%q) should return false\", text_match_three_test)",
            "}",
            "}",
            "func TestTextMatchThree_error_no_match_two_char(t *testing.T) {",
            "if text_match_three(text_match_three_test) {",
            "t.Errorf(\"text_match_three(%q) should return false\", text_match_three_test)",
            "}",
            "}",
            "func TestTextMatchThree_error_no_match_three_char(t *testing.T) {",
            "if text_match_three(text_match_three_test) {",
            "t.Errorf(\"text_match_three(%q) should return false\", text_match_three_test)",
            "}",
            "}",
            "func TestTextMatchThree_error_no_match_three_char_two_char(t *testing.T) {",
            "if text_match_three(text_match_three_test) {",
            "t.Errorf(\"text_match_",
            "func TestText_Match_Three(t *testing.T) {",
            "candidate := text_match_three",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"ac\"), expected: false },",
            "{ actual: candidate(\"dc\"), expected: false },",
            "{ actual: candidate(\"abbbba\"), expected: true },",
            "{ actual: candidate(\"caacabbbba\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "788",
        "title": "new_tuple",
        "text": "Test the new_tuple function.",
        "code": "package new_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc new_tuple(test_list []string, test_str string) []interface{} {\n    return []interface{}{test_list, test_str}\n}\n\n",
        "test_list": [
            "func TestNewTuple(t *testing.T) {",
            "test_list := []string{\"a\", \"b\", \"c\"}",
            "test_str := \"a,b,c\"",
            "test_list = new_tuple(test_list, test_str)",
            "if len(test_list)!= 2 {",
            "t.Errorf(\"len(test_list) = %d, want 2\", len(test_list))",
            "}",
            "if test_list[0]!= \"a\" {",
            "t.Errorf(\"test_list[0] = %q, want 'a'\", test_list[0])",
            "}",
            "if test_list[1]!= \"b\" {",
            "t.Errorf(\"test_list[1] = %q, want 'b'\", test_list[1])",
            "}",
            "}",
            "func TestNewTuple2(t *testing.T) {",
            "test_list := []string{\"a\", \"b\", \"c\"}",
            "test_str := \"a,b,c\"",
            "test_list = new_tuple(test_list, test_str)",
            "if len(test_list)!= 2 {",
            "t.Errorf(\"len(test_list) = %d, want 2\", len(test_list))",
            "}",
            "if test_list[0]!= \"a\" {",
            "t.Errorf(\"test_list[0] = %q, want 'a'\", test_list[0])",
            "}",
            "if test_list[1]!= \"b\" {",
            "t.Errorf(\"test_list[1] = %q, want 'b'\", test_list[1])",
            "}",
            "}",
            "func TestNew",
            "func TestNew_Tuple(t *testing.T) {",
            "candidate := new_tuple",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"WEB\", \"is\"}, \"best\"), expected: []interface{}{\"WEB\", \"is\", \"best\"} },",
            "{ actual: candidate([]string{\"We\", \"are\"}, \"Developers\"), expected: []interface{}{\"We\", \"are\", \"Developers\"} },",
            "{ actual: candidate([]string{\"Part\", \"is\"}, \"Wrong\"), expected: []interface{}{\"Part\", \"is\", \"Wrong\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "790",
        "title": "even_position",
        "text": "Write a gothon function to check whether every even index contains even numbers of a given list.",
        "code": "package even_position_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc even_position(nums []int) bool {\n    for i := 0; i < len(nums); i++ {\n        if nums[i]%2 == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestEvenPosition(t *testing.T) {",
            "if!even_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}) {",
            "t.Errorf(\"Even position of 1, 2, 3, 4, 5, 6, 7, 8, 9 is not even\")",
            "}",
            "}",
            "func TestEvenPosition2(t *testing.T) {",
            "if!even_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) {",
            "t.Errorf(\"Even position of 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 is not even\")",
            "}",
            "}",
            "func TestEvenPosition3(t *testing.T) {",
            "if!even_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}) {",
            "t.Errorf(\"Even position of 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 is not even\")",
            "}",
            "}",
            "func TestEvenPosition4(t *testing.T) {",
            "if!even_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) {",
            "t.Errorf(\"Even position of 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 is not even\")",
            "}",
            "}",
            "func TestEvenPosition5(t *testing.T) {",
            "if!even_position([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}) {",
            "t.Errorf(\"",
            "func TestEven_Position(t *testing.T) {",
            "candidate := even_position",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{3, 2, 1}), expected: false },",
            "{ actual: candidate([]int{1, 2, 3}), expected: false },",
            "{ actual: candidate([]int{2, 1, 4}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "791",
        "title": "remove_nested",
        "text": "Write a function to remove lists from the given list.",
        "code": "package remove_nested_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_nested(test_tup interface{}) []interface{} {\n    var test_list []interface{}\n    for _, test_tuple := range test_tup.([]interface{}) {\n        test_list = append(test_list, remove_nested(test_tuple))\n    }\n    return test_list\n}\n\n",
        "test_list": [
            "func TestRemoveNested(t *testing.T) {",
            "test_list := remove_nested([]interface{}{",
            "[]interface{}{",
            "\"a\",",
            "\"b\",",
            "\"c\",",
            "\"d\",",
            "\"e\",",
            "\"f\",",
            "\"g\",",
            "\"h\",",
            "\"i\",",
            "\"j\",",
            "\"k\",",
            "\"l\",",
            "\"m\",",
            "\"n\",",
            "\"o\",",
            "\"p\",",
            "\"q\",",
            "\"r\",",
            "\"s\",",
            "\"t\",",
            "\"u\",",
            "\"v\",",
            "\"w\",",
            "\"x\",",
            "\"y\",",
            "\"z\",",
            "\"A\",",
            "\"B\",",
            "\"C\",",
            "\"D\",",
            "\"E\",",
            "\"F\",",
            "\"G\",",
            "\"H\",",
            "\"I\",",
            "\"J\",",
            "\"K\",",
            "\"L\",",
            "\"M\",",
            "\"N\",",
            "\"O\",",
            "\"P\",",
            "\"Q\",",
            "\"R\",",
            "\"S\",",
            "\"T\",",
            "\"U\",",
            "\"V\",",
            "\"W\",",
            "\"X\",",
            "\"Y\",",
            "\"Z\",",
            "\"a\",",
            "\"b\",",
            "\"c\",",
            "\"d\",",
            "\"e\",",
            "\"f\",",
            "\"g\",",
            "\"h\",",
            "\"i\",",
            "\"j\",",
            "\"k\",",
            "\"l\",",
            "\"m\",",
            "\"n\",",
            "\"o\",",
            "\"p\",",
            "\"q\",",
            "\"r\",",
            "\"s\",",
            "func TestRemove_Nested(t *testing.T) {",
            "candidate := remove_nested",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{1, 5, 7, []interface{}{4, 6}, 10}), expected: []interface{}{1, 5, 7, 10} },",
            "{ actual: candidate([]interface{}{2, 6, 8, []interface{}{5, 7}, 11}), expected: []interface{}{2, 6, 8, 11} },",
            "{ actual: candidate([]interface{}{3, 7, 9, []interface{}{6, 8}, 12}), expected: []interface{}{3, 7, 9, 12} },",
            "{ actual: candidate([]interface{}{3, 7, 9, []interface{}{6, 8}, []interface{}{5, 12}, 12}), expected: []interface{}{3, 7, 9, 12} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "792",
        "title": "count_list",
        "text": "Write a gothon function to count the number of lists in a given number of lists.",
        "code": "package count_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_list(input_list [][]int) int {\n    var count int\n    for _, list := range input_list {\n        for _, item := range list {\n            count += item\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountList(t *testing.T) {",
            "input_list := [][]int{",
            "[]int{1, 2, 3, 4, 5},",
            "[]int{6, 7, 8, 9, 10},",
            "[]int{11, 12, 13, 14, 15},",
            "[]int{16, 17, 18, 19, 20},",
            "[]int{21, 22, 23, 24, 25},",
            "[]int{26, 27, 28, 29, 30},",
            "[]int{31, 32, 33, 34, 35},",
            "[]int{36, 37, 38, 39, 40},",
            "[]int{41, 42, 43, 44, 45},",
            "[]int{46, 47, 48, 49, 50},",
            "[]int{51, 52, 53, 54, 55},",
            "[]int{56, 57, 58, 59, 60},",
            "[]int{61, 62, 63, 64, 65},",
            "[]int{66, 67, 68, 69, 70},",
            "[]int{71, 72, 73, 74, 75},",
            "[]int{76, 77, 78, 79, 80},",
            "[]int{81, 82, 83, 84, 85},",
            "[]int{86, 87, 88, 89, 90},",
            "[]int{91, 92, 93, 94, 95},",
            "[]int{96, 97, 98, 99, 100},",
            "[]int{101, 102, 103, 104, 105},",
            "[]int{106, 107, 108, 109, 110},",
            "[]int{111, 112, 113, 114, 115},",
            "[]int{116, 117, 118, 119, 120},",
            "[]int{121, 122, 123, 124, 125},",
            "[]int{126,",
            "func TestCount_List(t *testing.T) {",
            "candidate := count_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 3}, []int{5, 7}, []int{9, 11}, []int{13, 15, 17}}), expected: 4 },",
            "{ actual: candidate([][]int{[]int{1, 2}, []int{2, 3}, []int{4, 5}}), expected: 3 },",
            "{ actual: candidate([][]int{[]int{1, 0}, []int{2, 0}}), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "793",
        "title": "last",
        "text": "Write a gothon function to find the last position of an element in a sorted list.",
        "code": "package last_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc last(arr []int, x int) int {\n    if len(arr) == 0 {\n        return x\n    }\n    return arr[len(arr)-1]\n}\n\n",
        "test_list": [
            "func Test_last(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if last(arr, 0)!= 9 {",
            "t.Errorf(\"last(arr, 0) = %d, want 9\", last(arr, 0))",
            "}",
            "if last(arr, 9)!= 10 {",
            "t.Errorf(\"last(arr, 9) = %d, want 10\", last(arr, 9))",
            "}",
            "}",
            "func Test_last_with_sorted_list(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if last(arr, 0)!= 9 {",
            "t.Errorf(\"last(arr, 0) = %d, want 9\", last(arr, 0))",
            "}",
            "if last(arr, 9)!= 10 {",
            "t.Errorf(\"last(arr, 9) = %d, want 10\", last(arr, 9))",
            "}",
            "}",
            "func Test_last_with_sorted_list_and_sorted_list(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if last(arr, 0)!= 9 {",
            "t.Errorf(\"last(arr, 0) = %d, want 9\", last(arr, 0))",
            "}",
            "if last(arr, 9)!= 10 {",
            "t.Errorf(\"last(arr, 9) = %d, want 10\", last(arr, 9))",
            "}",
            "}",
            "func Test_last_with_sorted_list_and_empty_list(t *testing.T) {",
            "arr",
            "func TestLast(t *testing.T) {",
            "candidate := last",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}, 1), expected: 0 },",
            "{ actual: candidate([]int{1, 1, 1, 2, 3, 4}, 1), expected: 2 },",
            "{ actual: candidate([]int{2, 3, 2, 3, 6, 8, 9}, 3), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "794",
        "title": "text_starta_endb",
        "text": "Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.",
        "code": "package text_starta_endb_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc text_starta_endb(text string) bool {\n    return text[0] == 'a' && text[len(text)-1] == 'b'\n}\n\n",
        "test_list": [
            "func TestTextStartAEndB(t *testing.T) {",
            "if!text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to start at the beginning of the string\")",
            "}",
            "if!text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to start at the end of the string\")",
            "}",
            "if!text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to start at the beginning of the string\")",
            "}",
            "if!text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to start at the end of the string\")",
            "}",
            "}",
            "func TestTextStartAEndB_NoMatch(t *testing.T) {",
            "if text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to not start at the beginning of the string\")",
            "}",
            "if text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to not start at the end of the string\")",
            "}",
            "if text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to not start at the beginning of the string\")",
            "}",
            "if text_starta_endb(`\"a\"`) {",
            "t.Errorf(\"Expected 'a' to not start at the end of the string\")",
            "}",
            "}",
            "func TestTextStartAEndB_Match(t *testing.T) {",
            "if!text_starta_endb(`\"a",
            "func TestText_Starta_Endb(t *testing.T) {",
            "candidate := text_starta_endb",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"aabbbb\"), expected: true },",
            "{ actual: candidate(\"aabAbbbc\"), expected: false },",
            "{ actual: candidate(\"accddbbjjj\"), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "796",
        "title": "return_sum",
        "text": "Write function to find the sum of all items in the given map.",
        "code": "package return_sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc return_sum(dict map[string]int) int {\n    sum := 0\n    for k, v := range dict {\n        sum += v\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestReturnSum(t *testing.T) {",
            "dict := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}",
            "sum := return_sum(dict)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func TestReturn_Sum(t *testing.T) {",
            "candidate := return_sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(map[string]int{\"a\": 100, \"b\": 200, \"c\": 300}), expected: 600 },",
            "{ actual: candidate(map[string]int{\"a\": 25, \"b\": 18, \"c\": 45}), expected: 88 },",
            "{ actual: candidate(map[string]int{\"a\": 36, \"b\": 39, \"c\": 49}), expected: 124 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "797",
        "title": "sum_in_range",
        "text": "Write a gothon function to find the sum of all odd natural numbers within the range l and r.",
        "code": "package sum_in_range_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sum_in_range(l int, r int) int {\n    if l == r {\n        return l\n    }\n    if l%2 == 1 {\n        return sum_in_range(l/2, r) + sum_in_range(l/2+1, r)\n    }\n    return sum_in_range(l/2, r) + sum_in_range(l/2+1, r) + sum_in_range(l/2, r)\n}\n\n",
        "test_list": [
            "func TestSumInRange(t *testing.T) {",
            "if sum_in_range(0, 1)!= 1 {",
            "t.Errorf(\"sum_in_range(0, 1) = %d, want 1\", sum_in_range(0, 1))",
            "}",
            "if sum_in_range(1, 2)!= 2 {",
            "t.Errorf(\"sum_in_range(1, 2) = %d, want 2\", sum_in_range(1, 2))",
            "}",
            "if sum_in_range(2, 3)!= 4 {",
            "t.Errorf(\"sum_in_range(2, 3) = %d, want 4\", sum_in_range(2, 3))",
            "}",
            "if sum_in_range(3, 4)!= 8 {",
            "t.Errorf(\"sum_in_range(3, 4) = %d, want 8\", sum_in_range(3, 4))",
            "}",
            "if sum_in_range(4, 5)!= 16 {",
            "t.Errorf(\"sum_in_range(4, 5) = %d, want 16\", sum_in_range(4, 5))",
            "}",
            "if sum_in_range(5, 6)!= 24 {",
            "t.Errorf(\"sum_in_range(5, 6) = %d, want 24\", sum_in_range(5, 6))",
            "}",
            "if sum_in_range(6, 7",
            "func TestSum_In_Range(t *testing.T) {",
            "candidate := sum_in_range",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(2, 5), expected: 8 },",
            "{ actual: candidate(5, 7), expected: 12 },",
            "{ actual: candidate(7, 13), expected: 40 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "798",
        "title": "_sum",
        "text": "Write a gothon function to find the sum of a list.",
        "code": "package _sum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc _sum(arr []int) int {\n    sum := 0\n    for _, v := range arr {\n        sum += v\n    }\n    return sum\n}\n\n",
        "test_list": [
            "func TestSum(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "sum := _sum(arr)",
            "fmt.Println(sum)",
            "}",
            "<|endoftext|>",
            "func Test_Sum(t *testing.T) {",
            "candidate := _sum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: 6 },",
            "{ actual: candidate([]int{15, 12, 13, 10}), expected: 50 },",
            "{ actual: candidate([]int{0, 1, 2}), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "799",
        "title": "left_rotate",
        "text": "Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.",
        "code": "package left_rotate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc left_rotate(n int, d int) int {\n    if n < 0 {\n        return n\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n\n",
        "test_list": [
            "func TestLeft_Rotate(t *testing.T) {",
            "candidate := left_rotate",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(16, 2), expected: 64 },",
            "{ actual: candidate(10, 2), expected: 40 },",
            "{ actual: candidate(99, 3), expected: 792 },",
            "{ actual: candidate(99, 3), expected: 792 },",
            "{ actual: candidate(1, 3), expected: 8 },",
            "{ actual: candidate(5, 3), expected: 40 },",
            "{ actual: candidate(29, 3), expected: 232 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "79",
        "title": "word_len",
        "text": "Write a gothon function to check whether the length of the word is odd or not.",
        "code": "package word_len_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc word_len(s string) bool {\n    if len(s) == 0 {\n        return false\n    }\n    return s[len(s)-1] == 'o'\n}\n\n",
        "test_list": [
            "func TestWordLen(t *testing.T) {",
            "if!word_len(\"\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"a\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"ab\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_len(\"abcd\") {",
            "t.Error(\"word_len() should return false\")",
            "}",
            "if!word_",
            "func TestWord_Len(t *testing.T) {",
            "candidate := word_len",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"Hadoop\"), expected: false },",
            "{ actual: candidate(\"great\"), expected: true },",
            "{ actual: candidate(\"structure\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "800",
        "title": "remove_all_spaces",
        "text": "Write a function to remove all whitespaces from a string.",
        "code": "package remove_all_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc remove_all_spaces(text string) string {\n    return text.ReplaceAllString(\n        \" \",\n        func(r rune) rune {\n            if r =='' {\n                return '_'\n            }\n            return r\n        }\n    )\n}\n\n",
        "test_list": [
            "func TestRemoveAllSpaces(t *testing.T) {",
            "text := \"Hello World!\"",
            "expected := \"Hello World!\"",
            "actual := remove_all_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %q, got %q\", expected, actual)",
            "}",
            "}",
            "func TestRemoveAllSpaces_Error(t *testing.T) {",
            "text := \"Hello World!\"",
            "expected := \"Hello World!\"",
            "actual := remove_all_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %q, got %q\", expected, actual)",
            "}",
            "}",
            "func TestRemoveAllSpaces_Error_Error(t *testing.T) {",
            "text := \"Hello World!\"",
            "expected := \"Hello World!\"",
            "actual := remove_all_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %q, got %q\", expected, actual)",
            "}",
            "}",
            "func TestRemoveAllSpaces_Error_Error_Error(t *testing.T) {",
            "text := \"Hello World!\"",
            "expected := \"Hello World!\"",
            "actual := remove_all_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %q, got %q\", expected, actual)",
            "}",
            "}",
            "func TestRemoveAllSpaces_Error_Error_Error(t *testing.T) {",
            "text := \"Hello World!\"",
            "expected := \"Hello World!\"",
            "actual := remove_all_spaces(text)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %q, got %q\", expected, actual)",
            "}",
            "}",
            "func TestRemove_All_Spaces(t *testing.T) {",
            "candidate := remove_all_spaces",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"python  program\"), expected: \"pythonprogram\" },",
            "{ actual: candidate(\"python   programming    language\"), expected: \"pythonprogramminglanguage\" },",
            "{ actual: candidate(\"python                     program\"), expected: \"pythonprogram\" },",
            "{ actual: candidate(\"   python                     program\"), expected: \"pythonprogram\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "801",
        "title": "test_three_equal",
        "text": "Test that the function returns the expected number of equal numbers.",
        "code": "package test_three_equal_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc test_three_equal(x int, y int, z int) int {\n    return x + y + z\n}\n\n",
        "test_list": [
            "func TestThreeEqual(t *testing.T) {",
            "if testing.Short() {",
            "t.Skip(\"skipping test in short mode.\")",
            "}",
            "fmt.Println(\"Testing three equal.\")",
            "for i := 0; i < 3; i++ {",
            "fmt.Println(\"Testing\", i, \"equal.\")",
            "x := test_three_equal(i, i, i)",
            "fmt.Println(\"x =\", x)",
            "if x!= i {",
            "t.Errorf(\"Expected %d, got %d\", i, x)",
            "}",
            "}",
            "}",
            "<|endoftext|>",
            "func TestTest_Three_Equal(t *testing.T) {",
            "candidate := test_three_equal",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1, 1, 1), expected: 3 },",
            "{ actual: candidate(-1, -2, -3), expected: 0 },",
            "{ actual: candidate(1, 2, 2), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "802",
        "title": "count_rotation",
        "text": "Write a gothon function to count the number of rotations required to generate a sorted list. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-list/",
        "code": "package count_rotation_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc count_rotation(arr []int) int {\n    var count int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] == 0 {\n            count++\n        }\n    }\n    return count\n}\n\n",
        "test_list": [
            "func TestCountRotations(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "fmt.Println(count_rotation(arr))",
            "}",
            "<|endoftext|>",
            "func TestCount_Rotation(t *testing.T) {",
            "candidate := count_rotation",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{3, 2, 1}), expected: 1 },",
            "{ actual: candidate([]int{4, 5, 1, 2, 3}), expected: 2 },",
            "{ actual: candidate([]int{7, 8, 9, 1, 2, 3}), expected: 3 },",
            "{ actual: candidate([]int{1, 2, 3}), expected: 0 },",
            "{ actual: candidate([]int{1, 3, 2}), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "803",
        "title": "is_perfect_square",
        "text": "Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/",
        "code": "package is_perfect_square_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_perfect_square(n int) bool {\n    if n == 0 {\n        return true\n    }\n    if n == 1 {\n        return false\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    if n % 3 == 0 {\n        return false\n    }\n    if n % 5 == 0 {\n        return false\n    }\n    if n % 7 == 0 {\n        return false\n    }\n    if n % 11 == 0 {\n        return false\n    }\n    if n % 13 == 0 {\n        return false\n    }\n    if n % 17 == 0 {\n        return false\n    }\n    if n % 19 == 0 {\n        return false\n    }\n    if n % 23 == 0 {\n        return false\n    }\n    if n % 29 == 0 {\n        return false\n    }\n    if n % 31 == 0 {\n        return false\n    }\n    if n % 37 == 0 {\n        return false\n    }\n    if n % 41 == 0 {\n        return false\n    }\n    if n % 43 == 0 {\n        return false\n    }\n    if n % 47 == 0 {\n        return false\n    }\n    if n % 53 == 0 {\n        return false\n    }\n    if n % 59 == 0 {\n        return false\n    }\n    if n % 61 == 0 {\n        return false\n    }\n    if n % 67 == 0 {\n        return false\n    }\n    if n % 71 == 0 {\n        return false\n    }\n    if n % 73 == 0 {\n        return false\n    }\n    if n % 79 == 0 {\n        return false\n    }\n    if n % 81 == 0 {\n        return false\n    }\n    if n % 83 == 0 {\n        return false\n    }\n    if n % 85 == 0 {\n        return false\n\n",
        "test_list": [
            "func TestIs_Perfect_Square(t *testing.T) {",
            "candidate := is_perfect_square",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: false },",
            "{ actual: candidate(36), expected: true },",
            "{ actual: candidate(14), expected: false },",
            "{ actual: candidate(196), expected: true },",
            "{ actual: candidate(125), expected: false },",
            "{ actual: candidate(15625), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "804",
        "title": "is_product_even",
        "text": "Write a function to check whether the product of numbers in a list is even or not.",
        "code": "package is_product_even_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_product_even(arr []int) bool {\n    if len(arr) == 0 {\n        return false\n    }\n    for i := 0; i < len(arr); i++ {\n        if arr[i] % 2 == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestIsProductEven(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!is_product_even(arr) {",
            "t.Errorf(\"is_product_even(arr) should be true\")",
            "}",
            "}",
            "func TestIsProductEven2(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if is_product_even(arr) {",
            "t.Errorf(\"is_product_even(arr) should be false\")",
            "}",
            "}",
            "func TestIsProductEven3(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!is_product_even(arr) {",
            "t.Errorf(\"is_product_even(arr) should be true\")",
            "}",
            "}",
            "func TestIsProductEven4(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!is_product_even(arr) {",
            "t.Errorf(\"is_product_even(arr) should be true\")",
            "}",
            "}",
            "func TestIsProductEven5(t *testing.T) {",
            "arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!is_product_even(arr) {",
            "t.Errorf(\"is_product_even(arr) should be",
            "func TestIs_Product_Even(t *testing.T) {",
            "candidate := is_product_even",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3}), expected: true },",
            "{ actual: candidate([]int{1, 2, 1, 4}), expected: true },",
            "{ actual: candidate([]int{1, 1}), expected: false },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "805",
        "title": "max_sum_list",
        "text": "Write a function that returns the list in a list of lists whose sum of elements is the highest.",
        "code": "package max_sum_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_sum_list(lists [][]int) []int {\n    var max_sum_list = make([]int, len(lists))\n    for i, list := range lists {\n        max_sum_list[i] = 0\n        for j, val := range list {\n            max_sum_list[i] = max(max_sum_list[i], val)\n        }\n    }\n    return max_sum_list\n}\n\n",
        "test_list": [
            "func TestMaxSumList(t *testing.T) {",
            "var max_sum_list = max_sum_list_test.max_sum_list",
            "var list = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "fmt.Println(max_sum_list(list))",
            "}",
            "<|endoftext|>",
            "func TestMax_Sum_List(t *testing.T) {",
            "candidate := max_sum_list",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{10, 11, 12} },",
            "{ actual: candidate([][]int{[]int{3, 2, 1}, []int{6, 5, 4}, []int{12, 11, 10}}), expected: []int{12, 11, 10} },",
            "{ actual: candidate([][]int{[]int{2, 3, 1}}), expected: []int{2, 3, 1} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "806",
        "title": "max_run_uppercase",
        "text": "Write a function to find maximum run of uppercase characters in the given string.",
        "code": "package max_run_uppercase_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc max_run_uppercase(test_str string) int {\n    var max_run int\n    for _, c := range test_str {\n        if c >= 'a' && c <= 'z' {\n            max_run++\n        }\n    }\n    return max_run\n}\n\n",
        "test_list": [
            "func TestMaxRunUppercase(t *testing.T) {",
            "test_str := \"abcdefghijklmnopqrstuvwxyz\"",
            "max_run := max_run_uppercase(test_str)",
            "fmt.Printf(\"%d\\n\", max_run)",
            "}",
            "<|endoftext|>",
            "func TestMax_Run_Uppercase(t *testing.T) {",
            "candidate := max_run_uppercase",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"GeMKSForGERksISBESt\"), expected: 5 },",
            "{ actual: candidate(\"PrECIOusMOVemENTSYT\"), expected: 6 },",
            "{ actual: candidate(\"GooGLEFluTTER\"), expected: 4 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "807",
        "title": "first_odd",
        "text": "Write a gothon function to find the first odd number in a given list of numbers.",
        "code": "package first_odd_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc first_odd(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    if len(nums) == 1 {\n        return nums[0]\n    }\n    return first_odd(nums[1:])\n}\n\n",
        "test_list": [
            "func TestFirstOdd(t *testing.T) {",
            "if first_odd([]int{1, 2, 3, 4, 5})!= 5 {",
            "t.Errorf(\"first_odd([]int{1, 2, 3, 4, 5}) = %d, want 5\", first_odd([]int{1, 2, 3, 4, 5}))",
            "}",
            "}",
            "func TestFirstOdd_Error(t *testing.T) {",
            "if first_odd([]int{1, 2, 3, 4, 5})!= 0 {",
            "t.Errorf(\"first_odd([]int{1, 2, 3, 4, 5}) = %d, want 0\", first_odd([]int{1, 2, 3, 4, 5}))",
            "}",
            "}",
            "func TestFirstOdd_Error_Error(t *testing.T) {",
            "if first_odd([]int{1, 2, 3, 4, 5})!= 0 {",
            "t.Errorf(\"first_odd([]int{1, 2, 3, 4, 5}) = %d, want 0\", first_odd([]int{1, 2, 3, 4, 5}))",
            "}",
            "}",
            "func TestFirstOdd_Error_Error_Error(t *testing.T) {",
            "if first_odd([]int{1, 2, 3, 4, 5})!= 0 {",
            "t.Errorf(\"first_odd([]int{1, 2, 3, 4, 5}) = %d, want 0\", first_odd([]int{1, 2, 3, 4, 5}))",
            "}",
            "}",
            "func TestFirstOdd_Error_Error_Error_Error(t *testing",
            "func TestFirst_Odd(t *testing.T) {",
            "candidate := first_odd",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 3, 5}), expected: 1 },",
            "{ actual: candidate([]int{2, 4, 1, 3}), expected: 1 },",
            "{ actual: candidate([]int{8, 9, 1}), expected: 9 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "808",
        "title": "check_K",
        "text": "Write a function to check if the given lists contain the k or not.",
        "code": "package check_K_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_K(test_tup []int, K int) bool {\n    for _, t := range test_tup {\n        if t == K {\n            return true\n        }\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestCheckK(t *testing.T) {",
            "test_tup := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_K(test_tup, 10) {",
            "t.Errorf(\"CheckK(%v) should return true\", test_tup)",
            "}",
            "test_tup = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_K(test_tup, 9) {",
            "t.Errorf(\"CheckK(%v) should return true\", test_tup)",
            "}",
            "test_tup = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_K(test_tup, 1) {",
            "t.Errorf(\"CheckK(%v) should return true\", test_tup)",
            "}",
            "test_tup = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_K(test_tup, 0) {",
            "t.Errorf(\"CheckK(%v) should return true\", test_tup)",
            "}",
            "test_tup = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_K(test_tup, -1) {",
            "t.Errorf(\"CheckK(%v) should return true\", test_tup)",
            "}",
            "test_tup = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_K(test_tup, -2) {",
            "func TestCheck_K(t *testing.T) {",
            "candidate := check_K",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 4, 5, 6, 8}, 6), expected: true },",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6}, 7), expected: false },",
            "{ actual: candidate([]int{7, 8, 9, 44, 11, 12}, 11), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "809",
        "title": "check_smaller",
        "text": "Write a function to check if each element of second list is smaller than its corresponding element in the first list.",
        "code": "package check_smaller_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc check_smaller(test_tup1 []interface{}, test_tup2 []interface{}) bool {\n    if len(test_tup1)!= len(test_tup2) {\n        return false\n    }\n    for i := 0; i < len(test_tup1); i++ {\n        if test_tup1[i] < test_tup2[i] {\n            return false\n        }\n    }\n    return true\n}\n\n",
        "test_list": [
            "func TestSmaller(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_smaller(test_tup1, test_tup2) {",
            "t.Errorf(\"check_smaller(%v, %v) should return true\", test_tup1, test_tup2)",
            "}",
            "}",
            "func TestSmaller_2(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "if!check_smaller(test_tup1, test_tup2) {",
            "t.Errorf(\"check_smaller(%v, %v) should return true\", test_tup1, test_tup2)",
            "}",
            "}",
            "func TestSmaller_3(t *testing.T) {",
            "test_tup1 := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "test_tup2 := []interface{}{1, 2, 3, 4, 5, 6",
            "func TestCheck_Smaller(t *testing.T) {",
            "candidate := check_smaller",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]interface{}{1, 2, 3}, []interface{}{2, 3, 4}), expected: false },",
            "{ actual: candidate([]interface{}{4, 5, 6}, []interface{}{3, 4, 5}), expected: true },",
            "{ actual: candidate([]interface{}{11, 12, 13}, []interface{}{10, 11, 12}), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "80",
        "title": "tetrahedral_number",
        "text": "Write a function to find the nth tetrahedral number.",
        "code": "package tetrahedral_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc tetrahedral_number(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        return\n",
        "test_list": [
            "func TestTetrahedral_Number(t *testing.T) {",
            "candidate := tetrahedral_number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(5), expected: 35 },",
            "{ actual: candidate(6), expected: 56 },",
            "{ actual: candidate(7), expected: 84 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "83",
        "title": "get_Char",
        "text": "Write a gothon function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.",
        "code": "package get_Char_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc get_Char(strr string) string {\n    var char_str string\n    for i := 0; i < len(strr); i++ {\n        char_str += strr[i]\n    }\n    return char_str\n}\n\n",
        "test_list": [
            "func Test_get_Char(t *testing.T) {",
            "var strr string",
            "strr = get_Char_test",
            "fmt.Println(\"Testing get_Char_test\")",
            "fmt.Println(strr)",
            "fmt.Println(\"Testing get_Char_test\")",
            "fmt.Println(get_Char(strr))",
            "}",
            "<|endoftext|>",
            "func TestGet_Char(t *testing.T) {",
            "candidate := get_Char",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"abc\"), expected: \"f\" },",
            "{ actual: candidate(\"gfg\"), expected: \"t\" },",
            "{ actual: candidate(\"ab\"), expected: \"c\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "84",
        "title": "sequence",
        "text": "Write a function to find the nth number in the newman conway sequence.",
        "code": "package sequence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc sequence(n int) int {\n    if n == 0 {\n        return 0\n    }\n    return sequence(n - 1) + sequence(n - 2) + sequence(n - 3) + sequence(n - 4) + sequence(n - 5) + sequence(n - 6) + sequence(n - 7) + sequence(n - 8) + sequence(n - 9) + sequence(n - 10) + sequence(n - 11) + sequence(n - 12) + sequence(n - 13) + sequence(n - 14) + sequence(n - 15) + sequence(n - 16) + sequence(n - 17) + sequence(n - 18) + sequence(n - 19) + sequence(n - 20) + sequence(n - 21) + sequence(n - 22) + sequence(n - 23) + sequence(n - 24) + sequence(n - 25) + sequence(n - 26) + sequence(n - 27) + sequence(n - 28) + sequence(n - 29) + sequence(n - 30) + sequence(n - 31) + sequence(n - 32) + sequence(n - 33) + sequence(n - 34) + sequence(n - 35) + sequence(n - 36) + sequence(n - 37) + sequence(n - 38) + sequence(n - 39) + sequence(n - 40) + sequence(n - 41) + sequence(n - 42) + sequence(n - 43) + sequence(n - 44) + sequence(n - 45) + sequence(n - 46) + sequence(n - 47) + sequence(n - 48) + sequence(n - 49) + sequence(n - 50) + sequence(n - 51) + sequence(n - 52) + sequence(n - 53) + sequence(n - 54) + sequence(n - 55) + sequence(n - 56) + sequence(n - 57) + sequence(n - 58) + sequence(n - 59) + sequence(n - 60) + sequence(n - 61) + sequence(n - 62) + sequence(n - 63) + sequence(n -\n",
        "test_list": [
            "func TestSequence(t *testing.T) {",
            "candidate := sequence",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: 6 },",
            "{ actual: candidate(2), expected: 1 },",
            "{ actual: candidate(3), expected: 2 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "86",
        "title": "centered_hexagonal_number",
        "text": "Write a function to find nth centered hexagonal number.",
        "code": "package centered_hexagonal_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc centered_hexagonal_number(n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n == 4 {\n        return 4\n    }\n    if n == 5 {\n        return 5\n    }\n    if n == 6 {\n        return 6\n    }\n    if n == 7 {\n        return 7\n    }\n    if n == 8 {\n        return 8\n    }\n    if n == 9 {\n        return 9\n    }\n    if n == 10 {\n        return 10\n    }\n    if n == 11 {\n        return 11\n    }\n    if n == 12 {\n        return 12\n    }\n    if n == 13 {\n        return 13\n    }\n    if n == 14 {\n        return 14\n    }\n    if n == 15 {\n        return 15\n    }\n    if n == 16 {\n        return 16\n    }\n    if n == 17 {\n        return 17\n    }\n    if n == 18 {\n        return 18\n    }\n    if n == 19 {\n        return 19\n    }\n    if n == 20 {\n        return 20\n    }\n    if n == 21 {\n        return 21\n    }\n    if n == 22 {\n        return 22\n    }\n    if n == 23 {\n        return 23\n    }\n    if n == 24 {\n        return 24\n    }\n    if n == 25 {\n        return 25\n    }\n    if n == 26 {\n        return 26\n    }\n    if n == 27 {\n        return 27\n    }\n    if n == 28 {\n        return 28\n    }\n    if n == 29 {\n        return 29\n    }\n    if n == 30 {\n        return 30\n    }\n    if n == 31 {\n        return 31\n    }\n    if n == 32 {\n        \n",
        "test_list": [
            "func TestCentered_Hexagonal_Number(t *testing.T) {",
            "candidate := centered_hexagonal_number",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(10), expected: 271 },",
            "{ actual: candidate(2), expected: 7 },",
            "{ actual: candidate(9), expected: 217 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "87",
        "title": "merge_dictionaries_three",
        "text": "Merge the two dictionaries into a single map.",
        "code": "package merge_dictionaries_three_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc merge_dictionaries_three(dict1 map[string]string, dict2 map[string]string, dict3 map[string]string) map[string]string {\n    for k, v := range dict1 {\n        dict1[k] = v\n    }\n    for k, v := range dict2 {\n        dict2[k] = v\n    }\n    for k, v := range dict3 {\n        dict3[k] = v\n    }\n    return dict1\n}\n\n",
        "test_list": [
            "func TestMergeDictionaries(t *testing.T) {",
            "var dict1 map[string]string",
            "var dict2 map[string]string",
            "var dict3 map[string]string",
            "var err error",
            "dict1, err = merge_dictionaries_three(map[string]string{",
            "\"a\": \"b\",",
            "\"c\": \"d\",",
            "\"e\": \"f\",",
            "}, map[string]string{",
            "\"a\": \"b\",",
            "\"c\": \"d\",",
            "\"e\": \"f\",",
            "}, map[string]string{",
            "\"a\": \"b\",",
            "\"c\": \"d\",",
            "\"e\": \"f\",",
            "})",
            "if err!= nil {",
            "t.Errorf(\"Error: %v\", err)",
            "}",
            "if len(dict1)!= 3 {",
            "t.Errorf(\"Error: %v\", len(dict1))",
            "}",
            "if len(dict2)!= 3 {",
            "t.Errorf(\"Error: %v\", len(dict2))",
            "}",
            "if len(dict3)!= 3 {",
            "t.Errorf(\"Error: %v\", len(dict3))",
            "}",
            "dict1, err = merge_dictionaries_three(dict1, dict2, dict3)",
            "if err!= nil {",
            "t.Errorf(\"Error: %v\", err)",
            "func TestMerge_Dictionaries_Three(t *testing.T) {",
            "candidate := merge_dictionaries_three",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(map[string]string{\"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\"}, map[string]string{\"G\": \"Green\", \"W\": \"White\"}, map[string]string{\"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\"}), expected: map[string]string{\"B\": \"Black\", \"R\": \"Red\", \"P\": \"Pink\", \"G\": \"Green\", \"W\": \"White\", \"O\": \"Orange\"} },",
            "{ actual: candidate(map[string]string{\"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\"}, map[string]string{\"G\": \"Green\", \"W\": \"White\"}, map[string]string{\"L\": \"lavender\", \"B\": \"Blue\"}), expected: map[string]string{\"W\": \"White\", \"P\": \"Pink\", \"B\": \"Black\", \"R\": \"Red\", \"G\": \"Green\", \"L\": \"lavender\"} },",
            "{ actual: candidate(map[string]string{\"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\"}, map[string]string{\"L\": \"lavender\", \"B\": \"Blue\"}, map[string]string{\"G\": \"Green\", \"W\": \"White\"}), expected: map[string]string{\"B\": \"Black\", \"P\": \"Pink\", \"R\": \"Red\", \"G\": \"Green\", \"L\": \"lavender\", \"W\": \"White\"} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "88",
        "title": "freq_count",
        "text": "Write a function to get the frequency of all the elements in a list, returned as a map.",
        "code": "package freq_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc freq_count(list1 []int) map[int]int {\n    freq := make(map[int]int)\n    for _, v := range list1 {\n        freq[v]++\n    }\n    return freq\n}\n\n",
        "test_list": [
            "func TestFreqCount(t *testing.T) {",
            "list1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
            "freq := freq_count(list1)",
            "fmt.Println(freq)",
            "}",
            "<|endoftext|>",
            "func TestFreq_Count(t *testing.T) {",
            "candidate := freq_count",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30}), expected: map[int]int{10: 4, 20: 4, 40: 2, 50: 2, 30: 1} },",
            "{ actual: candidate([]int{1, 2, 3, 4, 3, 2, 4, 1, 3, 1, 4}), expected: map[int]int{1: 3, 2: 2, 3: 3, 4: 3} },",
            "{ actual: candidate([]int{5, 6, 7, 4, 9, 10, 4, 5, 6, 7, 9, 5}), expected: map[int]int{10: 1, 5: 3, 6: 2, 7: 2, 4: 2, 9: 2} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "89",
        "title": "closest_num",
        "text": "Write a function to find the closest smaller number than n.",
        "code": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 1\n    }\n    if N == 2 {\n        return 2\n    }\n    if N == 3 {\n        return 3\n    }\n    if N == 4 {\n        return 4\n    }\n    if N == 5 {\n        return 5\n    }\n    if N == 6 {\n        return 6\n    }\n    if N == 7 {\n        return 7\n    }\n    if N == 8 {\n        return 8\n    }\n    if N == 9 {\n        return 9\n    }\n    if N == 10 {\n        return 10\n    }\n    if N == 11 {\n        return 11\n    }\n    if N == 12 {\n        return 12\n    }\n    if N == 13 {\n        return 13\n    }\n    if N == 14 {\n        return 14\n    }\n    if N == 15 {\n        return 15\n    }\n    if N == 16 {\n        return 16\n    }\n    if N == 17 {\n        return 17\n    }\n    if N == 18 {\n        return 18\n    }\n    if N == 19 {\n        return 19\n    }\n    if N == 20 {\n        return 20\n    }\n    if N == 21 {\n        return 21\n    }\n    if N == 22 {\n        return 22\n    }\n    if N == 23 {\n        return 23\n    }\n    if N == 24 {\n        return 24\n    }\n    if N == 25 {\n        return 25\n    }\n    if N == 26 {\n        return 26\n    }\n    if N == 27 {\n        return 27\n    }\n    if N == 28 {\n        return 28\n    }\n    if N == 29 {\n        return 29\n    }\n    if N == 30 {\n        return 30\n    }\n    if N == 31 {\n        return 31\n    }\n    if N == 32 {\n        return 32\n    }\n\n",
        "test_list": [
            "func TestClosest_Num(t *testing.T) {",
            "candidate := closest_num",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(11), expected: 10 },",
            "{ actual: candidate(7), expected: 6 },",
            "{ actual: candidate(12), expected: 11 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "8",
        "title": "square_nums",
        "text": "Write a function to find squares of individual elements in a list.",
        "code": "package square_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc square_nums(nums []int) []int {\n    var squares []int\n    for _, num := range nums {\n        squares = append(squares, num*num)\n    }\n    return squares\n}\n\n",
        "test_list": [
            "func TestSquareNums(t *testing.T) {",
            "var nums []int",
            "for _, num := range square_nums([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) {",
            "nums = append(nums, num)",
            "}",
            "fmt.Println(nums)",
            "}",
            "<|endoftext|>",
            "func TestSquare_Nums(t *testing.T) {",
            "candidate := square_nums",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), expected: []int{1, 4, 9, 16, 25, 36, 49, 64, 81, 100} },",
            "{ actual: candidate([]int{10, 20, 30}), expected: []int{100, 400, 900} },",
            "{ actual: candidate([]int{12, 15}), expected: []int{144, 225} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "90",
        "title": "len_log",
        "text": "Write a gothon function to find the length of the longest word.",
        "code": "package len_log_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc len_log(list1 []string) int {\n    var len1 int\n    for _, s := range list1 {\n        len1 = len(s)\n    }\n    return len1\n}\n\n",
        "test_list": [
            "func TestLenLog(t *testing.T) {",
            "list1 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list2 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list3 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list4 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list5 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list6 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list7 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list8 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list9 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list10 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list11 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list12 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list13 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list14 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}",
            "list15 := []string{\"a\", \"b\", \"c\",",
            "func TestLen_Log(t *testing.T) {",
            "candidate := len_log",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"python\", \"PHP\", \"bigdata\"}), expected: 7 },",
            "{ actual: candidate([]string{\"a\", \"ab\", \"abc\"}), expected: 3 },",
            "{ actual: candidate([]string{\"small\", \"big\", \"tall\"}), expected: 5 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "91",
        "title": "find_substring",
        "text": "Write a function to check if a string is present as a substring in a given list of string values.",
        "code": "package find_substring_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_substring(str1 []string, sub_str string) bool {\n    for _, s := range str1 {\n        if s == sub_str {\n            return true\n        }\n    }\n    return false\n}\n\n",
        "test_list": [
            "func TestFindSubstring(t *testing.T) {",
            "str1 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "str2 := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}",
            "if!find_substring(str1, \"a\") {",
            "t.Errorf(\"Expected substring 'a' to be found in '%v'\", str1)",
            "}",
            "if!find_substring(str1, \"b\") {",
            "t.Errorf(\"Expected substring 'b' to be found in '%v'\", str1)",
            "}",
            "if!find_substring(str1, \"c\") {",
            "t.Errorf(\"Expected substring 'c' to be found in '%v'\", str1)",
            "}",
            "if!find_substring(str1, \"d\") {",
            "t.Errorf(\"Expected substring 'd' to be found in '%v'\", str1)",
            "}",
            "if!find_substring(str1, \"e\") {",
            "t.Errorf(\"Expected substring 'e' to be found in '%v'\", str1)",
            "func TestFind_Substring(t *testing.T) {",
            "candidate := find_substring",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([]string{\"red\", \"black\", \"white\", \"green\", \"orange\"}, \"ack\"), expected: true },",
            "{ actual: candidate([]string{\"red\", \"black\", \"white\", \"green\", \"orange\"}, \"abc\"), expected: false },",
            "{ actual: candidate([]string{\"red\", \"black\", \"white\", \"green\", \"orange\"}, \"ange\"), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "92",
        "title": "is_undulating",
        "text": "Write a function to check whether the given number is undulating or not.",
        "code": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc is_undulating(n int) bool {\n    return n%2 == 0\n}\n\n",
        "test_list": [
            "func TestIsUndulating(t *testing.T) {",
            "if is_undulating(1) {",
            "t.Error(\"is_undulating(1) should return false\")",
            "}",
            "if is_undulating(2) {",
            "t.Error(\"is_undulating(2) should return false\")",
            "}",
            "if is_undulating(3) {",
            "t.Error(\"is_undulating(3) should return false\")",
            "}",
            "if is_undulating(4) {",
            "t.Error(\"is_undulating(4) should return false\")",
            "}",
            "if is_undulating(5) {",
            "t.Error(\"is_undulating(5) should return false\")",
            "}",
            "if is_undulating(6) {",
            "t.Error(\"is_undulating(6) should return false\")",
            "}",
            "if is_undulating(7) {",
            "t.Error(\"is_undulating(7) should return false\")",
            "}",
            "if is_undulating(8) {",
            "t.Error(\"is_undulating(8) should return false\")",
            "}",
            "if is_undulating(9) {",
            "t.Error(\"is_undulating(9) should return false\")",
            "}",
            "if is_undulating(10) {",
            "t.Error(\"is_undulating(10) should return false\")",
            "}",
            "if is_undulating(11) {",
            "t.Error(\"is_undulating(11) should return false\")",
            "}",
            "if is_undulating(12) {",
            "t.Error(\"is_undulating(12) should return false\")",
            "}",
            "if is_undulating(13) {",
            "t.Error(\"is_undulating(13) should return false\")",
            "}",
            "if is_undulating(14) {",
            "t.Error(\"is_undulating(14) should return false\")",
            "func TestIs_Undulating(t *testing.T) {",
            "candidate := is_undulating",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(1212121), expected: true },",
            "{ actual: candidate(1991), expected: false },",
            "{ actual: candidate(121), expected: true },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "93",
        "title": "power",
        "text": "Write a function to calculate the value of 'a' to the power 'b'.",
        "code": "package power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc power(a int, b int) int {\n    return a * b\n}\n\n",
        "test_list": [
            "func TestPower(t *testing.T) {",
            "var a int",
            "var b int",
            "var c int",
            "a = power(1, 2)",
            "b = power(2, 1)",
            "c = power(2, 2)",
            "fmt.Println(a, b, c)",
            "}",
            "<|endoftext|>",
            "func TestPower(t *testing.T) {",
            "candidate := power",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(3, 4), expected: 81 },",
            "{ actual: candidate(2, 3), expected: 8 },",
            "{ actual: candidate(5, 5), expected: 3125 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "94",
        "title": "index_minimum",
        "text": "Given a list of lists, write a function that returns the first value of the list with the smallest second value.",
        "code": "package index_minimum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc index_minimum(test_list [][]interface{}) string {\n    var min_value int\n    var min_second_value int\n    for _, test_list_element := range test_list {\n        if len(test_list_element) > 0 {\n            min_value = min(min_value, test_list_element[0])\n            min_second_value = min(min_second_value, test_list_element[1])\n        }\n    }\n    return fmt.Sprintf(\"%d\", min_value) + \" \" + fmt.Sprintf(\"%d\", min_second_value)\n}\n\n",
        "test_list": [
            "func Test_index_minimum(t *testing.T) {",
            "test_list := [][]interface{}{",
            "[]interface{}{1, 2, 3},",
            "[]interface{}{4, 5, 6},",
            "[]interface{}{7, 8, 9},",
            "}",
            "expected := \"1 2 3\"",
            "actual := index_minimum(test_list)",
            "if actual!= expected {",
            "t.Errorf(\"Expected %s, but got %s\", expected, actual)",
            "}",
            "}",
            "<|endoftext|>",
            "func TestIndex_Minimum(t *testing.T) {",
            "candidate := index_minimum",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]interface{}{\"Rash\", 143}, []interface{}{\"Manjeet\", 200}, []interface{}{\"Varsha\", 100}}), expected: \"Varsha\" },",
            "{ actual: candidate([][]int{[]interface{}{\"Yash\", 185}, []interface{}{\"Dawood\", 125}, []interface{}{\"Sanya\", 175}}), expected: \"Dawood\" },",
            "{ actual: candidate([][]int{[]interface{}{\"Sai\", 345}, []interface{}{\"Salman\", 145}, []interface{}{\"Ayesha\", 96}}), expected: \"Ayesha\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "95",
        "title": "Find_Min_Length",
        "text": "Write a gothon function to find the length of the smallest list in a list of lists.",
        "code": "package Find_Min_Length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc Find_Min_Length(lst [][]int) int {\n    var minLen int\n    for _, v := range lst {\n        if len(v) > minLen {\n            minLen = len(v)\n        }\n    }\n    return minLen\n}\n\n",
        "test_list": [
            "func Test_Find_Min_Length(t *testing.T) {",
            "lst := [][]int{",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},",
            "[]int{1, 2, 3, 4, 5, 6, 7,",
            "func TestFind_Min_Length(t *testing.T) {",
            "candidate := Find_Min_Length",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1}, []int{1, 2}}), expected: 1 },",
            "{ actual: candidate([][]int{[]int{1, 2}, []int{1, 2, 3}, []int{1, 2, 3, 4}}), expected: 2 },",
            "{ actual: candidate([][]int{[]int{3, 3, 3}, []int{4, 4, 4, 4}}), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "96",
        "title": "divisor",
        "text": "Write a gothon function to find the number of divisors of a given integer.",
        "code": "package divisor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc divisor(n int) int {\n    if n == 0 {\n        return 1\n    }\n    return divisor(n-1) + divisor(n-2) + divisor(n-3) + divisor(n-4) + divisor(n-5) + divisor(n-6) + divisor(n-7) + divisor(n-8) + divisor(n-9) + divisor(n-10) + divisor(n-11) + divisor(n-12) + divisor(n-13) + divisor(n-14) + divisor(n-15) + divisor(n-16) + divisor(n-17) + divisor(n-18) + divisor(n-19) + divisor(n-20) + divisor(n-21) + divisor(n-22) + divisor(n-23) + divisor(n-24) + divisor(n-25) + divisor(n-26) + divisor(n-27) + divisor(n-28) + divisor(n-29) + divisor(n-30) + divisor(n-31) + divisor(n-32) + divisor(n-33) + divisor(n-34) + divisor(n-35) + divisor(n-36) + divisor(n-37) + divisor(n-38) + divisor(n-39) + divisor(n-40) + divisor(n-41) + divisor(n-42) + divisor(n-43) + divisor(n-44) + divisor(n-45) + divisor(n-46) + divisor(n-47) + divisor(n-48) + divisor(n-49\n",
        "test_list": [
            "func TestDivisor(t *testing.T) {",
            "candidate := divisor",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(15), expected: 4 },",
            "{ actual: candidate(12), expected: 6 },",
            "{ actual: candidate(9), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "97",
        "title": "frequency_lists",
        "text": "Write a function to find frequency of each element in a flattened list of lists, returned in a map.",
        "code": "package frequency_lists_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc frequency_lists(list1 [][]int) map[int]int {\n    var frequency map[int]int\n    for _, list := range list1 {\n        for _, element := range list {\n            frequency[element]++\n        }\n    }\n    return frequency\n}\n\n",
        "test_list": [
            "func TestFrequencyLists(t *testing.T) {",
            "list1 := [][]int{",
            "[]int{1, 2, 3, 4, 5},",
            "[]int{6, 7, 8, 9, 10},",
            "[]int{11, 12, 13, 14, 15},",
            "[]int{16, 17, 18, 19, 20},",
            "[]int{21, 22, 23, 24, 25},",
            "[]int{26, 27, 28, 29, 30},",
            "[]int{31, 32, 33, 34, 35},",
            "[]int{36, 37, 38, 39, 40},",
            "[]int{41, 42, 43, 44, 45},",
            "[]int{46, 47, 48, 49, 50},",
            "[]int{51, 52, 53, 54, 55},",
            "[]int{56, 57, 58, 59, 60},",
            "[]int{61, 62, 63, 64, 65},",
            "[]int{66, 67, 68, 69, 70},",
            "[]int{71, 72, 73, 74, 75},",
            "[]int{76, 77, 78, 79, 80},",
            "[]int{81, 82, 83, 84, 85},",
            "[]int{86, 87, 88, 89, 90},",
            "[]int{91, 92, 93, 94, 95},",
            "[]int{96, 97, 98, 99, 100},",
            "[]int{101, 102, 103, 104, 105},",
            "[]int{106, 107, 108, 109, 110},",
            "[]int{111, 112, 113, 114, 115},",
            "[]int{116, 117, 118, 119, 120},",
            "[]int{121, 122, 123,",
            "func TestFrequency_Lists(t *testing.T) {",
            "candidate := frequency_lists",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate([][]int{[]int{1, 2, 3, 2}, []int{4, 5, 6, 2}, []int{7, 8, 9, 5}}), expected: map[int]int{1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1} },",
            "{ actual: candidate([][]int{[]int{1, 2, 3, 4}, []int{5, 6, 7, 8}, []int{9, 10, 11, 12}}), expected: map[int]int{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1} },",
            "{ actual: candidate([][]int{[]int{20, 30, 40, 17}, []int{18, 16, 14, 13}, []int{10, 20, 30, 40}}), expected: map[int]int{20: 2, 30: 2, 40: 2, 17: 1, 18: 1, 16: 1, 14: 1, 13: 1, 10: 1} },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "99",
        "title": "decimal_to_binary",
        "text": "Write a function to convert the given decimal number to its binary equivalent, represented as a string with leading zeros.",
        "code": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc decimal_to_binary(n int) string {\n    return fmt.Sprintf(\"%d\", n)\n}\n\nfunc decimal_to_binary_leading_zeros(n int) string {\n    return fmt.Sprintf(\"%d\", n) + \"0\"\n}\n\nfunc decimal_to_binary_leading_zeros_leading_zeros(n int) string {\n    return fmt.Sprintf(\"%d\", n) + \"0\" + fmt.Sprintf(\"%d\", n)\n}\n\nfunc decimal_to_binary_leading_zeros_leading_zeros_leading_zeros(n int) string {\n    return fmt.Sprintf(\"%d\", n) + \"0\" + fmt.Sprintf(\"%d\", n) + fmt.Sprintf(\"%d\", n)\n}\n\nfunc decimal_to_binary_leading_zeros_leading_zeros_leading_zeros(n int) string {\n    return fmt.Sprintf(\"%d\", n) + \"0\" + fmt.Sprintf(\"%d\", n) + fmt.Sprintf(\"%d\", n) + fmt.Sprintf(\"%d\", n)\n}\n\nfunc decimal_to_binary_leading_zeros_leading_zeros_leading_zeros(n int) string {\n    return fmt.Sprintf(\"%d\", n) + \"0\" + fmt.Sprintf(\"%d\", n) + fmt.Sprintf(\"%\n",
        "test_list": [
            "func TestDecimal_To_Binary(t *testing.T) {",
            "candidate := decimal_to_binary",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(8), expected: \"1000\" },",
            "{ actual: candidate(18), expected: \"10010\" },",
            "{ actual: candidate(7), expected: \"111\" },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    },
    {
        "task_id": "9",
        "title": "find_Rotations",
        "text": "Write a gothon function to find the minimum number of rotations (greater than 0) required to get the same string.",
        "code": "package find_Rotations_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\nfunc find_Rotations(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test2(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test3(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test4(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test5(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test6(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test7(str string) int {\n    return 0\n}\n\nfunc find_Rotations_test8(str string) int {\n    return 0\n}\n\nfunc find\n",
        "test_list": [
            "func TestFind_Rotations(t *testing.T) {",
            "candidate := find_Rotations",
            "type test struct {",
            "actual   interface{}",
            "expected interface{}",
            "}",
            "tests := []test{",
            "{ actual: candidate(\"aaaa\"), expected: 1 },",
            "{ actual: candidate(\"ab\"), expected: 2 },",
            "{ actual: candidate(\"abc\"), expected: 3 },",
            "}",
            "for i, tc := range tests {",
            "t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {",
            "if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {",
            "t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)",
            "}",
            "})",
            "}",
            "}"
        ]
    }
]