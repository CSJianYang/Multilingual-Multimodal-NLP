[
    {
        "title": "Count Ways To Build Good Strings",
        "question_content": "Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\n\n\tAppend the character '0' zero times.\n\tAppend the character '1' one times.\n\nThis can be performed any number of times.\nA good string is a string constructed by the above process having a length between low and high (inclusive).\nReturn the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: low = 3, high = 3, zero = 1, one = 1\nOutput: 8\nExplanation: \nOne possible valid good string is \"011\". \nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \nAll binary strings from \"000\" to \"111\" are good strings in this example.\n\nExample 2:\n\nInput: low = 2, high = 3, zero = 1, one = 2\nOutput: 5\nExplanation: The good strings are \"00\", \"11\", \"000\", \"110\", and \"011\".\n\n&nbsp;\nConstraints:\n\n\t1 <= low&nbsp;<= high&nbsp;<= 105\n\t1 <= zero, one <= low",
        "solutions": [
            {
                "id": 3518124,
                "title": "python3-c-java-easy-and-understand-dp",
                "content": "The algorithm uses an array ``dp`` to keep track of the number of good strings that can be formed for each length up to the ``high`` value. The base case is when ``dp[0] = 1``, indicating that there is one good string of length zero.\\n\\nThe algorithm then iteratively fills in the rest of the ``dp`` array for all lengths between ``min(zero, one)`` and ``high``, inclusive. For each length i, the algorithm considers two cases:\\n\\n- The number of ``0`` digits is at least zero: In this case, the algorithm adds the number of good strings of length ``i - zero`` to ``dp[i]``.\\n- The number of ``1`` digits is at least one: In this case, the algorithm adds the number of good strings of length ``i - one`` to ``dp[i]``.\\n\\nFinally, the algorithm computes the sum of the ``dp`` array elements for lengths between ``low`` and ``high``, inclusive, and returns this sum as the result.\\n# Please Upvote \\uD83D\\uDE07\\n# Code\\n<iframe src=\"https://leetcode.com/playground/KgGvj3nn/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/686e141e-52e4-46ad-beb6-8a33cd3caf80_1681363181.6946194.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "The algorithm uses an array ``dp`` to keep track of the number of good strings that can be formed for each length up to the ``high`` value. The base case is when ``dp[0] = 1``, indicating that there is one good string of length zero.\\n\\nThe algorithm then iteratively fills in the rest of the ``dp`` array for all lengths between ``min(zero, one)`` and ``high``, inclusive. For each length i, the algorithm considers two cases:\\n\\n- The number of ``0`` digits is at least zero: In this case, the algorithm adds the number of good strings of length ``i - zero`` to ``dp[i]``.\\n- The number of ``1`` digits is at least one: In this case, the algorithm adds the number of good strings of length ``i - one`` to ``dp[i]``.\\n\\nFinally, the algorithm computes the sum of the ``dp`` array elements for lengths between ``low`` and ``high``, inclusive, and returns this sum as the result.\\n# Please Upvote \\uD83D\\uDE07\\n# Code\\n<iframe src=\"https://leetcode.com/playground/KgGvj3nn/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/686e141e-52e4-46ad-beb6-8a33cd3caf80_1681363181.6946194.png)",
                "codeTag": "Unknown"
            },
            {
                "id": 2807155,
                "title": "coin-change-problem-variant",
                "content": "```c++ \\n// Please upvote if you like the approach \\uD83D\\uDE0A\\n```\\n\\n##### This is similar to Coin change problem\\n<hr>\\n<b> Q] how is this similar ? </b>\\n\\nAns] Given we can append 0 `zero` number of times and 1 `one number of times`\\n\\nso if zero is 4 then 0000 is considered one string and one is 3 then 111 is considered one string\\n\\nnow using these two strings we will have to make some new string that has a length between low and high inclusive\\n\\nNow treat the  <b> length of final string </b> to make as a target that needs to be achieved\\n\\nand the length of strings from which the final string <b> to be made as coin values  </b>\\n\\n<hr>\\n<b> q] why will this work ? </b>\\n\\nwe can <b> `at once append` </b>  zero 0\\'s or  one 1\\'s to string . and our final objective is to make a length of string \\nthat lies in a range. ans is only dependent on  one and zero.\\n\\n<hr/>\\n\\n##### Conclusion :-\\n\\nSo all we have to do is to run a for loop from low to high and call the function that will return total number of ways to make a string of that length . And that is similar to coin change problem \\n\\nThis top down approach will see all possible ways to get a score k\\n<hr>\\n\\n#### code\\n\\n```c++\\n#define mod 1000000007\\nclass Solution {\\npublic:\\nint score(int target, vector<int>& dp, int one, int zero)\\n{\\n\\t// if target is 0 that means this target can be made so return 1\\n\\tif (target == 0)\\n\\t\\treturn 1;\\n\\t// target < 0 cannot be made \\n\\tif (target < 0)\\n\\t\\treturn 0;\\n\\t// if already computed eturn the value\\n\\tif (dp[target] != -1)\\n\\t\\treturn dp[target];\\n\\tlong long sum;\\n\\t// target - a is adding \\'a\\' 0\\'s to the string\\n\\t// target - b is adding \\'b\\' 1\\'s to string \\n\\tsum =  score(target - one, dp, one, zero) + score(target - zero, dp,one, zero);\\n\\treturn dp[target] = (sum % (mod));\\n}\\nint countGoodStrings(int low, int high, int zero, int one)\\n{\\n\\tvector<int> dp(high + 1, -1);\\n\\n\\tint ans = 0;\\n\\t// run a loop from low to high for every i get total number of ways to make that length\\n\\tfor (int i = low; i <= high; i++)\\n\\t{\\n\\t\\tans = ((ans % mod) + ( score(i, dp, one, zero) % mod )) % mod;\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```\\n<hr>\\n\\n#### bottom up\\n```c++\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 1; i <= high; ++i) {\\n            // if we can add 0 string then add \\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            // if we can add 1\\'s string i.e i >= len of 1\\'s string\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            // if i is in between low and high add \\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```\\n`TC : O(high)  \\nSC :- O(high)` for both approaches\\n<hr>\\nJava :-\\n\\n```java\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high + 1], res = 0, mod = 1000000007;\\n        dp[0] = 1;\\n        for (int i = 1; i <= high; ++i) {\\n            // if we can add 0 string then add \\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            // if we can add 1\\'s string i.e i >= len of 1\\'s string\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            // if i is in between low and high add \\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```c++ \\n// Please upvote if you like the approach \\uD83D\\uDE0A\\n```\n```c++\\n#define mod 1000000007\\nclass Solution {\\npublic:\\nint score(int target, vector<int>& dp, int one, int zero)\\n{\\n\\t// if target is 0 that means this target can be made so return 1\\n\\tif (target == 0)\\n\\t\\treturn 1;\\n\\t// target < 0 cannot be made \\n\\tif (target < 0)\\n\\t\\treturn 0;\\n\\t// if already computed eturn the value\\n\\tif (dp[target] != -1)\\n\\t\\treturn dp[target];\\n\\tlong long sum;\\n\\t// target - a is adding \\'a\\' 0\\'s to the string\\n\\t// target - b is adding \\'b\\' 1\\'s to string \\n\\tsum =  score(target - one, dp, one, zero) + score(target - zero, dp,one, zero);\\n\\treturn dp[target] = (sum % (mod));\\n}\\nint countGoodStrings(int low, int high, int zero, int one)\\n{\\n\\tvector<int> dp(high + 1, -1);\\n\\n\\tint ans = 0;\\n\\t// run a loop from low to high for every i get total number of ways to make that length\\n\\tfor (int i = low; i <= high; i++)\\n\\t{\\n\\t\\tans = ((ans % mod) + ( score(i, dp, one, zero) % mod )) % mod;\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 1; i <= high; ++i) {\\n            // if we can add 0 string then add \\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            // if we can add 1\\'s string i.e i >= len of 1\\'s string\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            // if i is in between low and high add \\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high + 1], res = 0, mod = 1000000007;\\n        dp[0] = 1;\\n        for (int i = 1; i <= high; ++i) {\\n            // if we can add 0 string then add \\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            // if we can add 1\\'s string i.e i >= len of 1\\'s string\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            // if i is in between low and high add \\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807169,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\n`dp[i] = dp[i - zero] + dp[i - one]`\\n<br>\\n\\n# **Complexity**\\nTime `O(high)`\\nSpace `O(high)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high + 1], res = 0, mod = 1000000007;\\n        dp[0] = 1;\\n        for (int i = 1; i <= high; ++i) {\\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 1; i <= high; ++i) {\\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = Counter({0: 1})\\n        mod = 10 ** 9 + 7\\n        for i in range(1, high + 1):\\n            dp[i] = (dp[i - zero] + dp[i - one]) % mod\\n        return sum(dp[i] for i in range(low, high + 1)) % mod\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high + 1], res = 0, mod = 1000000007;\\n        dp[0] = 1;\\n        for (int i = 1; i <= high; ++i) {\\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1;\\n        int res = 0, mod = 1e9 + 7;\\n        for (int i = 1; i <= high; ++i) {\\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = Counter({0: 1})\\n        mod = 10 ** 9 + 7\\n        for i in range(1, high + 1):\\n            dp[i] = (dp[i - zero] + dp[i - one]) % mod\\n        return sum(dp[i] for i in range(low, high + 1)) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3518018,
                "title": "c-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    ll mod=1e9+7;\\n    ll c(ll len,ll low,ll high,vector<ll>&dp,int zero,int one){\\n        if(len>high)return 0;\\n        if(dp[len]!=-1)return dp[len];\\n        ll ans=0;\\n        if(len>=low && len<=high)ans=1;\\n        ans += c(len+zero,low,high,dp,zero,one)%mod;\\n        ans =  (ans%mod + c(len+one,low,high,dp,zero,one)%mod)%mod;\\n        dp[len]=ans;\\n        return ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll>dp(high+1,-1);\\n        return c(0,low,high,dp,zero,one);   \\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d1dce1c3-06a1-44cc-81b3-f55fe0956b86_1683946391.4420965.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    ll mod=1e9+7;\\n    ll c(ll len,ll low,ll high,vector<ll>&dp,int zero,int one){\\n        if(len>high)return 0;\\n        if(dp[len]!=-1)return dp[len];\\n        ll ans=0;\\n        if(len>=low && len<=high)ans=1;\\n        ans += c(len+zero,low,high,dp,zero,one)%mod;\\n        ans =  (ans%mod + c(len+one,low,high,dp,zero,one)%mod)%mod;\\n        dp[len]=ans;\\n        return ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll>dp(high+1,-1);\\n        return c(0,low,high,dp,zero,one);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518216,
                "title": "java-easy-dp-memoization-striver-approach",
                "content": "**A cakewalk dp problem with just a subtle change. Basically the intuition behind the approach is we need to build string of all possible lengths between low and high (inclusive). So at a time we are told that we can append zero number of 0\\'s or one number of 1\\'s. So for every length between low and high (inclusive) I tried to build all possible strings and added that to the answer. Now observe what we did in function f, In function f I checked if the len of string (here it\\'s represented by ind) after subtracting with zero 0\\'s or one 1\\'s is zero or not and if it\\'s zero that means the string can be formed of desired length so we return 1 and if it\\'s less than zero that means the string can\\'t be formed of desired length so we return 0. Below we just recursively subtracted the zero number of 0\\'s and one number of 1\\'s from the length to check if zero number of 0\\'s are possible to append and if one number of 1\\'s are possible to append. Then atlast we just sum the all possible ways and store it in dp array.**\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%1000000007)+(f(i,dp,zero,one)%1000000007))%1000000007;\\n        }\\n        return ans;\\n    }\\n    public int f(int ind,int[] dp,int zero,int one){\\n        if(ind==0)\\n            return 1;\\n        if(ind<0)\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int forzero=f(ind-zero,dp,zero,one);\\n        int forone=f(ind-one,dp,zero,one);\\n        return dp[ind]=(forzero+forone)%1000000007;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/4e6af709-ab52-4c17-99c0-31329786d66a_1683950146.197456.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%1000000007)+(f(i,dp,zero,one)%1000000007))%1000000007;\\n        }\\n        return ans;\\n    }\\n    public int f(int ind,int[] dp,int zero,int one){\\n        if(ind==0)\\n            return 1;\\n        if(ind<0)\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int forzero=f(ind-zero,dp,zero,one);\\n        int forone=f(ind-one,dp,zero,one);\\n        return dp[ind]=(forzero+forone)%1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517765,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution \\n\\n# Search \\uD83D\\uDC49 `Count Ways To Build Good Strings By Tech Wired`\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\nThe problem can be solved using dynamic programming. We can define dp[i] as the total number of valid strings of length i. A valid string is one that contains no more than k consecutive identical characters, where k is the minimum of the number of zeros and the number of ones.\\n\\nWe can compute dp[i] by considering all the valid strings of length i-1. To count the number of valid strings of length i that end with a zero, we can count the number of valid strings of length i-1 that end with a one, and vice versa. We can then add these two values to get dp[i].\\n\\nFinally, we can compute the answer as the sum of dp[i] for i = low to high.\\n\\n# Intuition:\\n\\nWe can think of the problem as constructing a binary string of length between low and high, such that no more than k consecutive identical characters are allowed, where k is the minimum of the number of zeros and the number of ones. We can start by constructing the smallest valid string of length low, and then use dynamic programming to construct larger valid strings.\\n\\nWe can also observe that the maximum number of consecutive zeros or ones that we can have in a valid string is the minimum of the number of zeros and the number of ones. This is because we need to have at least one character of the other type between every pair of consecutive characters of the same type.\\n\\nUsing these observations, we can define dp[i] as the total number of valid strings of length i, and compute it as the sum of the number of valid strings of length i-1 that end with a zero and the number of valid strings of length i-1 that end with a one. We can then compute the answer as the sum of dp[i] for i = low to high.\\n\\n\\n\\n\\n\\n\\n```Python []\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = Counter({0: 1})\\n        mod = 10 ** 9 + 7\\n        for i in range(1, high + 1):\\n            \\n            z = dp[i - zero]\\n            \\n            o = dp[i - one]\\n            \\n            n = (z + o) % mod\\n           \\n            dp[i] = n\\n        \\n        \\n        ans = sum(dp[i] for i in range(low, high + 1)) % mod\\n        \\n     \\n        return ans\\n\\n```\\n```Java []\\n\\n\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        Map<Integer, Integer> dp = new HashMap<>();\\n        dp.put(0, 1);\\n        int mod = (int)1e9 + 7;\\n        for (int i = 1; i <= high; i++) {\\n            \\n            int z = dp.getOrDefault(i - zero, 0);\\n            \\n            \\n            int o = dp.getOrDefault(i - one, 0);\\n            \\n            \\n            int n = (z + o) % mod;\\n            \\n            \\n            dp.put(i, n);\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (int i = low; i <= high; i++) {\\n            ans = (ans + dp.getOrDefault(i, 0)) % mod;\\n        }\\n        \\n       \\n        return ans;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        unordered_map<int, int> dp;\\n        dp[0] = 1;\\n        int mod = 1e9 + 7;\\n        for (int i = 1; i <= high; i++) {\\n            \\n            int num_valid_strings_ending_with_zero = dp.count(i - zero) ? dp[i - zero] : 0;\\n            \\n            \\n            int num_valid_strings_ending_with_one = dp.count(i - one) ? dp[i - one] : 0;\\n            \\n            \\n            int num_valid_strings_of_length_i = (num_valid_strings_ending_with_zero + num_valid_strings_ending_with_one) % mod;\\n            \\n            \\n            dp[i] = num_valid_strings_of_length_i;\\n        }\\n        \\n        \\n        int total_num_valid_strings = 0;\\n        for (int i = low; i <= high; i++) {\\n            total_num_valid_strings = (total_num_valid_strings + (dp.count(i) ? dp[i] : 0)) % mod;\\n        }\\n        return total_num_valid_strings;\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = Counter({0: 1})\\n        mod = 10 ** 9 + 7\\n        for i in range(1, high + 1):\\n            \\n            z = dp[i - zero]\\n            \\n            o = dp[i - one]\\n            \\n            n = (z + o) % mod\\n           \\n            dp[i] = n\\n        \\n        \\n        ans = sum(dp[i] for i in range(low, high + 1)) % mod\\n        \\n     \\n        return ans\\n\\n```\n```Java []\\n\\n\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        Map<Integer, Integer> dp = new HashMap<>();\\n        dp.put(0, 1);\\n        int mod = (int)1e9 + 7;\\n        for (int i = 1; i <= high; i++) {\\n            \\n            int z = dp.getOrDefault(i - zero, 0);\\n            \\n            \\n            int o = dp.getOrDefault(i - one, 0);\\n            \\n            \\n            int n = (z + o) % mod;\\n            \\n            \\n            dp.put(i, n);\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (int i = low; i <= high; i++) {\\n            ans = (ans + dp.getOrDefault(i, 0)) % mod;\\n        }\\n        \\n       \\n        return ans;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        unordered_map<int, int> dp;\\n        dp[0] = 1;\\n        int mod = 1e9 + 7;\\n        for (int i = 1; i <= high; i++) {\\n            \\n            int num_valid_strings_ending_with_zero = dp.count(i - zero) ? dp[i - zero] : 0;\\n            \\n            \\n            int num_valid_strings_ending_with_one = dp.count(i - one) ? dp[i - one] : 0;\\n            \\n            \\n            int num_valid_strings_of_length_i = (num_valid_strings_ending_with_zero + num_valid_strings_ending_with_one) % mod;\\n            \\n            \\n            dp[i] = num_valid_strings_of_length_i;\\n        }\\n        \\n        \\n        int total_num_valid_strings = 0;\\n        for (int i = low; i <= high; i++) {\\n            total_num_valid_strings = (total_num_valid_strings + (dp.count(i) ? dp[i] : 0)) % mod;\\n        }\\n        return total_num_valid_strings;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518376,
                "title": "easy-solution-beats-100-0ms-java-c-c-python-c-javascript-kotlin-php-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefine dp[i] as the number of good strings of length i. Then we can use the following recurrence relation to calculate dp[i]:\\n\\ndp[i] = dp[i-zero] + dp[i-one]\\n\\nHere, dp[i-zero] represents the number of good strings of length i that end with a zero, and dp[i-one] represents the number of good strings of length i that end with a one. The total number of good strings of length i is the sum of these two.\\n\\nTo count the number of good strings in the given range, we can use dp[i] to calculate the answer for all i between low and high, and add them up\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an array dp[] of size high+1 with dp[0]=1, since there is only one good string of length 0, which is the empty string.\\n- Iterate from i=1 to high and use the recurrence relation to calculate dp[i].\\n- If i is between low and high, add dp[i] to the answer variable ans.\\nReturn the answer.\\n\\n# Complexity\\n- Time complexity:O(high)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(high)\\n\\n\\n\\n\\n```Java []\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high+1];\\n        dp[0]=1;\\n        int ans=0;\\n        for(int i=1;i<=high;i++){\\n            dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n            if(i>=low){\\n                ans = (ans+dp[i])%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```C []\\nint countGoodStrings(int low, int high, int zero, int one){\\n     int dp[1000000] ={0};\\n        dp[0]=1;\\n        int ans=0;\\n        for(int i=1;i<=high;i++){\\n            dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n            if(i>=low){\\n                ans = (ans+dp[i])%1000000007;\\n            }\\n        }\\n        return ans;\\n}\\n```\\n```python []\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0] * (high+1)\\n        dp[0] = 1\\n        ans = 0\\n        for i in range(1, high+1):\\n            dp[i] = ((dp[i-zero] if i-zero>=0 else 0) + (dp[i-one] if i-one>=0 else 0)) % 1000000007\\n            if i >= low:\\n                ans = (ans + dp[i]) % 1000000007\\n        return ans\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n         int dp[high+1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0]=1;\\n    int ans=0;\\n    for(int i=1;i<=high;i++){\\n        dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n        if(i>=low){\\n            ans = (ans+dp[i])%1000000007;\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int CountGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            dp[i] = ((i-zero >= 0 ? dp[i-zero] : 0) + (i-one >= 0 ? dp[i-one] : 0)) % 1000000007;\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % 1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```JavaScript []\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n    let dp = new Array(high+1).fill(0);\\n    dp[0] = 1;\\n    let ans = 0;\\n    for (let i = 1; i <= high; i++) {\\n        dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n        if (i >= low) {\\n            ans = (ans+dp[i])%1000000007;\\n        }\\n    }\\n    return ans;\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun countGoodStrings(low: Int, high: Int, zero: Int, one: Int): Int {\\n        val dp = IntArray(high+1)\\n        dp[0] = 1\\n        var ans = 0\\n        for (i in 1..high) {\\n            dp[i] = ((if (i-zero >= 0) dp[i-zero] else 0) + (if (i-one >= 0) dp[i-one] else 0)) % 1000000007\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % 1000000007\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n\\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $low\\n     * @param Integer $high\\n     * @param Integer $zero\\n     * @param Integer $one\\n     * @return Integer\\n     */\\n    function countGoodStrings($low, $high, $zero, $one) {\\n         $dp = array_fill(0, $high+1, 0);\\n        $dp[0] = 1;\\n        $ans = 0;\\n        for ($i = 1; $i <= $high; $i++) {\\n            $dp[$i] = (($i-$zero >= 0 ? $dp[$i-$zero] : 0) + ($i-$one >= 0 ? $dp[$i-$one] : 0)) % 1000000007;\\n            if ($i >= $low) {\\n                $ans = ($ans + $dp[$i]) % 1000000007;\\n            }\\n        }\\n        return $ans;\\n    }\\n}\\n```\\n\\nUpvotes Are Encouraging!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high+1];\\n        dp[0]=1;\\n        int ans=0;\\n        for(int i=1;i<=high;i++){\\n            dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n            if(i>=low){\\n                ans = (ans+dp[i])%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```C []\\nint countGoodStrings(int low, int high, int zero, int one){\\n     int dp[1000000] ={0};\\n        dp[0]=1;\\n        int ans=0;\\n        for(int i=1;i<=high;i++){\\n            dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n            if(i>=low){\\n                ans = (ans+dp[i])%1000000007;\\n            }\\n        }\\n        return ans;\\n}\\n```\n```python []\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0] * (high+1)\\n        dp[0] = 1\\n        ans = 0\\n        for i in range(1, high+1):\\n            dp[i] = ((dp[i-zero] if i-zero>=0 else 0) + (dp[i-one] if i-one>=0 else 0)) % 1000000007\\n            if i >= low:\\n                ans = (ans + dp[i]) % 1000000007\\n        return ans\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n         int dp[high+1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0]=1;\\n    int ans=0;\\n    for(int i=1;i<=high;i++){\\n        dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n        if(i>=low){\\n            ans = (ans+dp[i])%1000000007;\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int CountGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            dp[i] = ((i-zero >= 0 ? dp[i-zero] : 0) + (i-one >= 0 ? dp[i-one] : 0)) % 1000000007;\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % 1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```JavaScript []\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n    let dp = new Array(high+1).fill(0);\\n    dp[0] = 1;\\n    let ans = 0;\\n    for (let i = 1; i <= high; i++) {\\n        dp[i] = ((i-zero>=0 ? dp[i-zero]:0)+(i-one>=0 ? dp[i-one]:0))%1000000007;\\n        if (i >= low) {\\n            ans = (ans+dp[i])%1000000007;\\n        }\\n    }\\n    return ans;\\n};\\n```\n```Kotlin []\\nclass Solution {\\n    fun countGoodStrings(low: Int, high: Int, zero: Int, one: Int): Int {\\n        val dp = IntArray(high+1)\\n        dp[0] = 1\\n        var ans = 0\\n        for (i in 1..high) {\\n            dp[i] = ((if (i-zero >= 0) dp[i-zero] else 0) + (if (i-one >= 0) dp[i-one] else 0)) % 1000000007\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % 1000000007\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $low\\n     * @param Integer $high\\n     * @param Integer $zero\\n     * @param Integer $one\\n     * @return Integer\\n     */\\n    function countGoodStrings($low, $high, $zero, $one) {\\n         $dp = array_fill(0, $high+1, 0);\\n        $dp[0] = 1;\\n        $ans = 0;\\n        for ($i = 1; $i <= $high; $i++) {\\n            $dp[$i] = (($i-$zero >= 0 ? $dp[$i-$zero] : 0) + ($i-$one >= 0 ? $dp[$i-$one] : 0)) % 1000000007;\\n            if ($i >= $low) {\\n                $ans = ($ans + $dp[$i]) % 1000000007;\\n            }\\n        }\\n        return $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807396,
                "title": "python-c-iterative-recursive-dp-solutions-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a dynamic programming approach to count possible ways to build good strings. Time complexity is linear: **O(high)**. Space complexity is linear: **O(high)**.\\n\\n**Comment.** Number of ways we can get to a good string of length `k` is the sum of the respective number of ways from two child strings, one to which we added `zero` zeros (i.e., of length `k-zero`) and another to which we added `one` ones (i.e., of length `k-one`). This leads to a recursion relation with a decreasing length of the string. Finally, these recursive calls come to:\\n* either a string of length `zero` or `one` where we have just `1` way (for each of strings) to be generated\\n* or a non-existing string of negative length to which we assign `0` valid ways.\\n\\n**Python #1.** Iterative solution. Here, we do not check that `k >= zero` and `k >= one`. Think why :)\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        dp, mod  = [1] + [0] * high, 1_000_000_007\\n        \\n        for k in range(1, high + 1):\\n            dp[k] = (dp[k - zero] + dp[k - one]) % mod\\n            \\n        return sum(dp[low:]) % mod\\n```\\n\\n**Python #2.** Recursive solution.\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        mod = 1_000_000_007\\n        \\n        @lru_cache(None)\\n        def dfs(k):\\n            if k == 0 : return 1\\n            if k < 0  : return 0\\n            return (dfs(k-zero) + dfs(k-one)) % mod\\n        \\n        dfs(high)\\n        \\n        return sum(dfs(k) for k in range(low,high+1)) % mod\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        vector<int> dp(high+1,0);\\n        dp[0] = 1;\\n        int mod = 1000000007;\\n        \\n        for (int k = 1; k <= high; ++k)\\n        {\\n            if (k >= zero) dp[k] += dp[k-zero] % mod;\\n            if (k >= one)  dp[k] += dp[k-one]  % mod;\\n        }\\n        \\n        long long cnt = 0;\\n        for (int k = low; k <= high; ++k) cnt = (cnt + dp[k]) % mod;\\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        dp, mod  = [1] + [0] * high, 1_000_000_007\\n        \\n        for k in range(1, high + 1):\\n            dp[k] = (dp[k - zero] + dp[k - one]) % mod\\n            \\n        return sum(dp[low:]) % mod\\n```\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        mod = 1_000_000_007\\n        \\n        @lru_cache(None)\\n        def dfs(k):\\n            if k == 0 : return 1\\n            if k < 0  : return 0\\n            return (dfs(k-zero) + dfs(k-one)) % mod\\n        \\n        dfs(high)\\n        \\n        return sum(dfs(k) for k in range(low,high+1)) % mod\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        vector<int> dp(high+1,0);\\n        dp[0] = 1;\\n        int mod = 1000000007;\\n        \\n        for (int k = 1; k <= high; ++k)\\n        {\\n            if (k >= zero) dp[k] += dp[k-zero] % mod;\\n            if (k >= one)  dp[k] += dp[k-one]  % mod;\\n        }\\n        \\n        long long cnt = 0;\\n        for (int k = low; k <= high; ++k) cnt = (cnt + dp[k]) % mod;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518463,
                "title": "c-the-most-understandable-sollution-beast-90-runtime-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all we are creating the dp vector with size ```high + std::max(zero, one)``` and init it with zeros.\\nSet ```dp[high]``` to 1, because whe the length is equal to ```high``` we have at least one solution.\\nThen int the loop we iterating ```i``` from ```high-1``` to 0, here ```i``` means length of string. \\nIn ```int takeOne = dp[i + one];``` we are looking for a good strings with length ```i + one``` same on the next line but on the next line we are looking for a good string with length ```i + zero```\\nOn the last string in the loop ```dp[i] = ((takeOne + takeZero) + (i >= low)) % mod;``` we sum to values and add ```(i >= low)``` which means if the current length of the string is equal of higher the low value - this is a good string, i can\\'t be larger than high because in the loop we are gooing from ```high - 1```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        std::vector<int> dp(high + std::max(zero, one), 0);\\n\\n        dp[high]  = 1;\\n\\n        for(int i = high-1; i >= 0; --i) {\\n            int takeOne = dp[i + one];\\n            int takeZero = dp[i + zero];\\n            dp[i] = ((takeOne + takeZero) + (i >= low)) % mod;\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n![fotor_2023-4-7_9_8_42.jpg](https://assets.leetcode.com/users/images/5c36ba60-c648-4183-992c-797fa0b3d1bb_1683961461.7921994.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```high + std::max(zero, one)```\n```dp[high]```\n```high```\n```i```\n```high-1```\n```i```\n```int takeOne = dp[i + one];```\n```i + one```\n```i + zero```\n```dp[i] = ((takeOne + takeZero) + (i >= low)) % mod;```\n```(i >= low)```\n```high - 1```\n```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        std::vector<int> dp(high + std::max(zero, one), 0);\\n\\n        dp[high]  = 1;\\n\\n        for(int i = high-1; i >= 0; --i) {\\n            int takeOne = dp[i + one];\\n            int takeZero = dp[i + zero];\\n            dp[i] = ((takeOne + takeZero) + (i >= low)) % mod;\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807921,
                "title": "easier-recursive-memoization-technique-solution",
                "content": "Here I am using simple Recursive technique and use arr as my dp array.\\nif(i>=low && i<=high) condition check weather the length is in the range of low and high or not.\\nif they are in range we increament the value by 1 else we will not add anything in it (i.e +0)\\n\\n```\\nclass Solution {\\n\\tpublic:\\n\\t\\tconst int M = 1e9+7;\\n\\t\\tvector<int> arr;\\n\\t\\tint solve(int low,int high,int zero,int one,int i) {\\n            if(i>high) return 0;\\n            if(arr[i]!=-1) return arr[i];\\n            int ans = 0;\\n            if(i>=low && i<=high) {\\n                ans +=1 ;\\n            }\\n            return arr[i] = (ans + solve(low,high,zero,one,i+zero)+solve(low,high,zero,one,i+one))%M;\\n    }\\n\\t\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        arr.resize(high+1,-1);\\n        return solve(low,high,zero,one,0)%M;\\t\\t\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tconst int M = 1e9+7;\\n\\t\\tvector<int> arr;\\n\\t\\tint solve(int low,int high,int zero,int one,int i) {\\n            if(i>high) return 0;\\n            if(arr[i]!=-1) return arr[i];\\n            int ans = 0;\\n            if(i>=low && i<=high) {\\n                ans +=1 ;\\n            }\\n            return arr[i] = (ans + solve(low,high,zero,one,i+zero)+solve(low,high,zero,one,i+one))%M;\\n    }\\n\\t\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        arr.resize(high+1,-1);\\n        return solve(low,high,zero,one,0)%M;\\t\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519356,
                "title": "dp-recursive-iterative-brute-optimized-w-explanation",
                "content": "# Explanation\\n\\n- Let\\'s start with writing the recursive code.\\n- Let\\'s say that we start at index 0 and more forward. What will be the base case?\\n- If we happen to move above `high` index we know that we cannot get any good string from here. Hence we return `0`.\\n- Base Case :\\n ```\\nif current_index > high:\\n    return 0 \\n```\\n- Now, for conditions, we know if the current index is in the range `low <= current_index <= high` then the current index will also create a valid good string. \\n- Hence we take \\'1\\' as extra if above condition is satisfed.\\n\\n```\\nif current_index > high:\\n    return 0 \\nif current_index < low:\\n  extra = 0\\nif low <= current_index <= high:\\n  extra = 1\\n```\\n- For recursive calls, we call to `(current_index + zero)` and `(current_index + one)` signifying that we added zero number of 0s or one number of 1s respectively. We add the returns of these calls + extra to return the number of possible good string starting from `current_index`.\\n\\n\\n# Recursive + Memoized \\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = {}\\n        def rec(cur):\\n            if cur in dp:\\n                return dp[cur]\\n            if cur > high:\\n                return 0\\n            if cur < low:\\n                extra = 0\\n            if low <= cur <= high:\\n                extra = 1\\n            dp[cur] = extra + rec(cur+zero) + rec(cur+one)\\n            return dp[cur]\\n        return rec(0)%1000_000_007\\n```\\n\\n---\\n\\n\\n- The above solution gives TLE, even after adding a cache/memo named `dp` as shown.\\n- In order to get rid of TLE, we get rid of the recursive function calls entirely (too many function calls == slow code).\\n- To implement the same using loops, I have taken an array of length `high + 1`. We traverse through this array backwards and add 1 to the current index if it is in the range `low <= i <= high` just as we did in the recursive solution.\\n- Now for the recursive call part, we add the values of index (i+ zero) and (i + one) to the current index but we first check if they are in range i.e `if (i + one) <= high` and `if (i + zero) <= high`\\n\\n# Tabulation \\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0]*(high +1)\\n        for i in range(len(dp) -1, -1, -1):\\n            dp[i] += int(low <= i <= high)\\n            if i+zero <= high:\\n                dp[i] += dp[i+zero]\\n            if i+one <= high:\\n                dp[i] += dp[i+one]\\n        return dp[0] % 1000_000_007           \\n```\\n\\n---\\n\\n\\nSpace Complexity: O(high)\\nTime Complexity: O(high)\\n\\n---\\n\\nI apologize for possibly ambiguous writing.\\nHere are some memes for no reason:\\n\\n![aGzdpo7_460s.jpg](https://assets.leetcode.com/users/images/66e6bded-b854-4db3-8aac-974296a91b5d_1683975431.904735.jpeg)\\n\\n![download.jpeg](https://assets.leetcode.com/users/images/2075a88f-7cd6-4217-a671-250728faddbe_1683975455.6927636.jpeg)\\n\\n![works-doesnt-work.jpg](https://assets.leetcode.com/users/images/c44a804b-16b5-4b65-8aa5-2afa33bcdeee_1683975471.452632.jpeg)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nif current_index > high:\\n    return 0 \\n```\n```\\nif current_index > high:\\n    return 0 \\nif current_index < low:\\n  extra = 0\\nif low <= current_index <= high:\\n  extra = 1\\n```\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = {}\\n        def rec(cur):\\n            if cur in dp:\\n                return dp[cur]\\n            if cur > high:\\n                return 0\\n            if cur < low:\\n                extra = 0\\n            if low <= cur <= high:\\n                extra = 1\\n            dp[cur] = extra + rec(cur+zero) + rec(cur+one)\\n            return dp[cur]\\n        return rec(0)%1000_000_007\\n```\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0]*(high +1)\\n        for i in range(len(dp) -1, -1, -1):\\n            dp[i] += int(low <= i <= high)\\n            if i+zero <= high:\\n                dp[i] += dp[i+zero]\\n            if i+one <= high:\\n                dp[i] += dp[i+one]\\n        return dp[0] % 1000_000_007           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807180,
                "title": "dp-c-simple-solution",
                "content": "# Intuition\\nRecursive Intution\\n\\n# Approach\\nRecursive will take more time so thought about DP\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long solve(int length,int high,int low,int zero,int one,vector<long long>& dp){\\n        if(length>=high)return 0;\\n        if(dp[length]!=-1)return dp[length];\\n        \\n        long long a= solve(length+zero,high,low,zero,one,dp);\\n         if(zero+length>=low and zero+length<=high)a++;\\n        \\n        long long b= solve(length+one,high,low,zero,one,dp);\\n         if(one+length>=low and one+length<=high)b++;\\n        \\n        return dp[length]=(a+b)%mod;\\n        \\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long> dp(1e5+1,-1);\\n        return int(solve(0,high,low,zero,one,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long solve(int length,int high,int low,int zero,int one,vector<long long>& dp){\\n        if(length>=high)return 0;\\n        if(dp[length]!=-1)return dp[length];\\n        \\n        long long a= solve(length+zero,high,low,zero,one,dp);\\n         if(zero+length>=low and zero+length<=high)a++;\\n        \\n        long long b= solve(length+one,high,low,zero,one,dp);\\n         if(one+length>=low and one+length<=high)b++;\\n        \\n        return dp[length]=(a+b)%mod;\\n        \\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long> dp(1e5+1,-1);\\n        return int(solve(0,high,low,zero,one,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517778,
                "title": "easy-c-javacode-dp-beats-98",
                "content": "# Approach\\nA string is said to be good if it can be formed by appending either 0 zero times or 1 one time, or both, any number of times.\\n\\nWe can solve this problem using dynamic programming. Let dp[i] be the number of good strings of length i that can be formed using zero and one, with given values of zero and one. To obtain the number of good strings of length i, we can use the counts of good strings of length i-1, i-2, ..., i-zero (if i>=zero) and i-one (if i>=one). This is because, to form a good string of length i, we can append either 0 zero times, or 1 one time, or both, to a good string of length i-1, i-2, ..., i-zero, or i-one.\\n\\nTherefore, we can use the recurrence relation:\\n```\\ndp[i] = dp[i-1] + dp[i-2] + ... + dp[i-zero] (if i>=zero)\\n+ dp[i-one] (if i>=one)\\n```\\n\\nWe can use this recurrence relation to fill the dp array from dp[0] to dp[high]. We can then count the number of good strings of length i for each i between low and high (both inclusive) to obtain the final answer.\\n\\nHowever, since the value of high can be as large as 100000, this approach may take a lot of time to compute. To optimize this approach, we can use memoization to store the intermediate results of the recursion, so that we don\\'t have to compute them again\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O((high-low+1)*(high+1))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(high+1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp){\\n        // good string \\n        if(target==0)return 1;\\n        // not a goood string \\n        if(target<0)return 0;\\n        if(dp[target]!=-1)return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i] = dp[i-1] + dp[i-2] + ... + dp[i-zero] (if i>=zero)\\n+ dp[i-one] (if i>=one)\\n```\n```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp){\\n        // good string \\n        if(target==0)return 1;\\n        // not a goood string \\n        if(target<0)return 0;\\n        if(dp[target]!=-1)return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807423,
                "title": "simple-java-dp-memoisation-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int total=0;\\n       int dp[]=new int[high+1];\\n       Arrays.fill(dp,-1);\\n        for(int len=low;len<=high;len++){\\n            total=(total+healper(len,zero,one,len,dp))%1000000007;\\n        }\\n        return total;\\n    }\\n    public int healper(int n,int zero,int one,int len,int dp[]){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n<0){\\n            return 0;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        } \\n        //kaam \\n        int way1=healper(n-zero,zero,one,len,dp)%1000000007;\\n        int way2=healper(n-one,zero,one,len,dp)%1000000007;\\n        return dp[n]=(way1+way2)%1000000007;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int total=0;\\n       int dp[]=new int[high+1];\\n       Arrays.fill(dp,-1);\\n        for(int len=low;len<=high;len++){\\n            total=(total+healper(len,zero,one,len,dp))%1000000007;\\n        }\\n        return total;\\n    }\\n    public int healper(int n,int zero,int one,int len,int dp[]){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n<0){\\n            return 0;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        } \\n        //kaam \\n        int way1=healper(n-zero,zero,one,len,dp)%1000000007;\\n        int way2=healper(n-one,zero,one,len,dp)%1000000007;\\n        return dp[n]=(way1+way2)%1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807238,
                "title": "full-explanation-easy-to-understand",
                "content": "#The major focus of this question is \"**LENGTH OF STRING\"**\\n#**zero => denotes increase in length after appending 0\\'s**\\n zero = 3, length of string increases by 3\\n\\n#**one => denotes increase in length after appending 1\\'s**\\n one = 4, length of string increases by 4\\n//===============================================================================================\\n**Example : zero = 1, one = 2**\\n#By default we can we can make 1 string of length 0 \\n Strings = [\"\"] = 1 string\\n//==================================================================================================\\n**For making string of currLength = 1**\\nCASE - 1 : \\n   =>take all strings of length = (currLength - zero) and increase length by 1 (Zero = 1) by appending 1 zero\\n   =>take all strings of length = (1 - 1) and increase length by 1\\n   =>take all strings of length = 0  and increase length by 1 **[use strings of length = 0 from previous results]**\\n   =>Strings = (\"\" + 0) \\n\\nCASE - 2 : \\n  =>As we want to make strings of length 1, but by appending 2 one\\'s (one = 2) we will exceed length\\n  =>NOT POSSIBLE \\n\\n**TOTAL = [\"0\"]  = 1 string**\\n\\n//======================================================================================================\\n\\n**#For making string of currLength = 2**\\nCASE-1 : \\n   =>take all strings of length = (currLength - zero) and increase length by 1 (Zero = 1) by appending 1 zero\\n   =>take all strings of length = (2 - 1) and increase length by 1\\n   =>take all strings of length = 1  and increase length by 1 [**use strings of length = 1 from previous results]**\\n   =>Strings = (\"0\" + 0)\\n\\n\\n\\nCASE-2\\n   =>take all strings of length = (currLength - one) and increase length by 2 (one= 2) by appending 2 one\\'s\\n   =>take all strings of length = (2 - 2) and increase length by 2\\n   =>take all strings of length = 0  and increase length by 2\\n   =>Strings = (\"\" + 11) \\n**TOTAL = [\"00\", \"11\"] =  2 strings**\\n\\n//=================================================================================================================\\n\\n**#For making string of currLength = 3**\\nCASE-1 : \\n   =>take all strings of length = (currLength - zero) and increase length by 1 (Zero = 1) by appending 1 zero\\n   =>take all strings of length = (3 - 1) and increase length by 1\\n   =>take all strings of length = 2  and increase length by 1 **[use strings of length = 2 from previous results]**\\n   =>Strings = (\"00\" + 0) , (\"11\" + 0)\\n\\n\\n\\nCASE-2\\n   =>take all strings of length = (currLength - one) and increase length by 2 (one= 2) by appending 2 one\\'s\\n   =>take all strings of length = (3 - 2) and increase length by 2\\n \\xA0 =>take all strings of length = 1  and increase length by 2\\n \\xA0 =>Strings = (\"0\" + 11) \\n\\n**TOTAL = [\"000\", \"110\" , \"011\"] = 3 strings**\\n//==================================================================================================================\\n\\nFor answer add count of string of all required lengths :)\\n\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        vector<long long>dp(high + 1, 0);\\n        dp[0] = 1;\\n        long long ans = 0;\\n        long long MOD = 1000000007;\\n        for (int len = 1; len <= high; len++)\\n        {\\n            int prevZeroLen = len - zero;\\n            long long zeroWays = (prevZeroLen < 0)? 0 : dp[prevZeroLen];\\n            //=================================\\n            int prevOneLen = len - one;\\n            long long oneWays = (prevOneLen < 0)? 0 : dp[prevOneLen];\\n            //==================================\\n            dp[len] = (zeroWays + oneWays) % MOD;\\n            if (len >= low) ans = (ans + dp[len]) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        vector<long long>dp(high + 1, 0);\\n        dp[0] = 1;\\n        long long ans = 0;\\n        long long MOD = 1000000007;\\n        for (int len = 1; len <= high; len++)\\n        {\\n            int prevZeroLen = len - zero;\\n            long long zeroWays = (prevZeroLen < 0)? 0 : dp[prevZeroLen];\\n            //=================================\\n            int prevOneLen = len - one;\\n            long long oneWays = (prevOneLen < 0)? 0 : dp[prevOneLen];\\n            //==================================\\n            dp[len] = (zeroWays + oneWays) % MOD;\\n            if (len >= low) ans = (ans + dp[len]) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807179,
                "title": "dp-memoization-solution-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int helper(int idx, int zero, int one, vector<int> &dp)\\n    {\\n\\t\\t//base case\\n        if(idx == 0)\\n        {\\n            return 1;\\n        }\\n        if(idx < 0)\\n        {\\n            return 0;\\n        }\\n        if(dp[idx] != -1)\\n        {\\n            return dp[idx];\\n        }\\n        return dp[idx] =(helper(idx - zero, zero, one, dp) % mod + helper(idx - one, zero, one, dp) % mod) % mod;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        int ans = 0;\\n        for(int i = low; i <= high; i++)\\n        {\\n            ans = (ans + helper(i, zero, one, dp) % mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int helper(int idx, int zero, int one, vector<int> &dp)\\n    {\\n\\t\\t//base case\\n        if(idx == 0)\\n        {\\n            return 1;\\n        }\\n        if(idx < 0)\\n        {\\n            return 0;\\n        }\\n        if(dp[idx] != -1)\\n        {\\n            return dp[idx];\\n        }\\n        return dp[idx] =(helper(idx - zero, zero, one, dp) % mod + helper(idx - one, zero, one, dp) % mod) % mod;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        int ans = 0;\\n        for(int i = low; i <= high; i++)\\n        {\\n            ans = (ans + helper(i, zero, one, dp) % mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519602,
                "title": "c-o-n-time-complexity-solution-recursion-memoization-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion + Memoization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDescribed in the comments\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long  helper(int length,int high,vector<long long>& dp,int low,int zero,int one) {\\n        long long mod = 1e9 + 7; // mod\\n\\n        if(length > high) // base case if the current index overflows\\n            return 0;\\n\\n        if(dp[length] != -1) // check if the subproblem is already computed no need to perform recursion and return the count\\n            return dp[length];\\n        \\n        dp[length] = length >= low ? 1 : 0; // checking the length is greater than the lower bound \\n\\n        dp[length] += helper(length + zero,high,dp,low,zero,one) + helper(length + one,high,dp,low,zero,one);\\n        /* now calculating the total count of that index : length  which equals to the sum for the subproblem length  +  zero and length + one\\n        */\\n\\n        return dp[length] % mod; // now return the count with mod\\n\\n\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long> dp(high + 1,-1);\\n\\n        return helper(0,high,dp,low,zero,one);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long  helper(int length,int high,vector<long long>& dp,int low,int zero,int one) {\\n        long long mod = 1e9 + 7; // mod\\n\\n        if(length > high) // base case if the current index overflows\\n            return 0;\\n\\n        if(dp[length] != -1) // check if the subproblem is already computed no need to perform recursion and return the count\\n            return dp[length];\\n        \\n        dp[length] = length >= low ? 1 : 0; // checking the length is greater than the lower bound \\n\\n        dp[length] += helper(length + zero,high,dp,low,zero,one) + helper(length + one,high,dp,low,zero,one);\\n        /* now calculating the total count of that index : length  which equals to the sum for the subproblem length  +  zero and length + one\\n        */\\n\\n        return dp[length] % mod; // now return the count with mod\\n\\n\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long> dp(high + 1,-1);\\n\\n        return helper(0,high,dp,low,zero,one);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518156,
                "title": "beats-100-simple-easy-appraoch-9-lines-iterative",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Starts by initializing a dp of size `int[high+1]` .\\n2. A variable `mod = 1000000007` , as asked in the question to return modulo 1e9 + 7.\\n3. A variable `int ans = 0`, to store the answer and 0 by default as 0 good strings can be constructed initially.\\n3. Iterating `i`from `1 --> high` .\\n    -  adding 0 or 1 , until the limit reaches.`dp[i] = ((i-zero>=0 ? dp[i-zero] : 0) + (i-one>=0 ? dp[i-one] : 0))%mod;`\\n    - increamenting `ans` if the value if is `>=` to the lowest size (`low`) of the string which is given as input.`ans = (ans + dp[i])%mod;`\\n    \\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$ \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n>it will purely depend on the value of **high**. \\n\\n### Do ask your doubts in the comment section :)\\n\\n# Code\\n``` \\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high+1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        for(int i=1;i<=high;i++){\\n            dp[i] = ((i-zero>=0 ? dp[i-zero] : 0) + (i-one>=0 ? dp[i-one] : 0))%mod;\\n            if(i>=low){\\n                ans = (ans + dp[i])%mod;\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/2edc30f1-318f-4b76-a6af-6edfbc78626b_1683948697.6651847.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "``` \\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high+1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        for(int i=1;i<=high;i++){\\n            dp[i] = ((i-zero>=0 ? dp[i-zero] : 0) + (i-one>=0 ? dp[i-one] : 0))%mod;\\n            if(i>=low){\\n                ans = (ans + dp[i])%mod;\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814343,
                "title": "recursive-memoisation-tabulation",
                "content": "```\\n\\n<------------Recursive(TLE)-------------->\\n\\nclass Solution {\\npublic:\\n    int getcount(int length , int zero , int one , int n)\\n    {\\n        int count = 0;\\n        \\n        if(length == n)\\n            return 1;\\n        \\n        if(length > n)\\n            return 0;\\n        \\n        else\\n            return getcount(length + one , zero , one , n) + getcount(length + zero , zero ,one , n);\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int ans = 0;\\n        vector<int>dp(high,-1);\\n        \\n        for(int i = low ; i <= high ; i++)\\n        {\\n            ans += getcount(0 , zero , one , i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n<-----Memoisation----->\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int getcount(vector<int>&dp , int zero , int one , int n)\\n    {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = (getcount(dp,zero,one,n-zero) % mod + getcount(dp,zero,one,n-one) % mod) % mod;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int ans = 0;\\n        vector<int>dp(high+1,-1);\\n        \\n        for(int i = low ; i <= high ; i++)\\n        {\\n            ans = (ans + getcount(dp , zero , one , i) % mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n<---------Tabulation---------->\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        vector<int>dp(high+1 , 0);\\n        dp[0] = 1;\\n        for(int k = 1 ; k <= high ; k++)\\n        {\\n            if(k >= zero) dp[k] += dp[k-zero] % mod;\\n            if(k >= one) dp[k] += dp[k-one] % mod;\\n        }\\n        \\n        long long count = 0;\\n        for(int i = low ; i <= high ; i++)\\n        {\\n            count = (count + dp[i]) % mod;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n<------------Recursive(TLE)-------------->\\n\\nclass Solution {\\npublic:\\n    int getcount(int length , int zero , int one , int n)\\n    {\\n        int count = 0;\\n        \\n        if(length == n)\\n            return 1;\\n        \\n        if(length > n)\\n            return 0;\\n        \\n        else\\n            return getcount(length + one , zero , one , n) + getcount(length + zero , zero ,one , n);\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int ans = 0;\\n        vector<int>dp(high,-1);\\n        \\n        for(int i = low ; i <= high ; i++)\\n        {\\n            ans += getcount(0 , zero , one , i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n<-----Memoisation----->\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int getcount(vector<int>&dp , int zero , int one , int n)\\n    {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = (getcount(dp,zero,one,n-zero) % mod + getcount(dp,zero,one,n-one) % mod) % mod;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int ans = 0;\\n        vector<int>dp(high+1,-1);\\n        \\n        for(int i = low ; i <= high ; i++)\\n        {\\n            ans = (ans + getcount(dp , zero , one , i) % mod) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n<---------Tabulation---------->\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        vector<int>dp(high+1 , 0);\\n        dp[0] = 1;\\n        for(int k = 1 ; k <= high ; k++)\\n        {\\n            if(k >= zero) dp[k] += dp[k-zero] % mod;\\n            if(k >= one) dp[k] += dp[k-one] % mod;\\n        }\\n        \\n        long long count = 0;\\n        for(int i = low ; i <= high ; i++)\\n        {\\n            count = (count + dp[i]) % mod;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813134,
                "title": "easy-solution-from-recursion-to-memoization-3-approaches-python3",
                "content": "# Intuition\\nThe first thought that came in my mind after seeing this problem is **recursion**. We can clearly see that for every step, we have 2 options to append zero at end or append one at end \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 1\\nafter appending the characters at back, We check if the length of the string that we are created is in range of low and high. if yes we add 1 to counter \\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        def recursive(s,ans):\\n            if len(s)>=low and len(s)<=high:\\n                ans+=[s]\\n            if len(s)>high:\\n                return \\n            recursive(s+\"0\"*zero,ans)\\n            recursive(s+\"1\"*one,ans)\\n            return\\n        ans=[]\\n        recursive(\"\",ans)\\n        return len(ans)\\n        \\n```\\n# Approach 2\\nThe question is just a distraction and we are actually not seeing that this question cares only about the length of the string not strings actually so changed the same code in perspective of length\\n\\nThis approach gives TLE\\n# RECURSION\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        ans=[0]\\n        def recursive(s):\\n            if s>high:\\n                return 0\\n            p=recursive(s+zero)+recursive(s+one)\\n            if s>=low and s<=high:\\n                p+=1\\n            return p\\n        return recursive(0)%(10**9+7)\\n        \\n```\\n# Approach 3\\nUsing **MEMOIZATION**, created a dp array of length high+1 and store the count when the string has particular length\\n\\n# MEMOIZATION\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        ans=[0]\\n        mod=10**9+7\\n        def recursive(s):\\n            if s>high:\\n                return 0\\n            if dp[s]!=-1:\\n                return dp[s]\\n            p=recursive(s+zero)+recursive(s+one)\\n            if s>=low and s<=high:\\n                p+=1\\n            dp[s]=p%mod\\n            return dp[s]\\n        dp=[-1]*(high+1)\\n        return recursive(0)%mod\\n        \\n```\\n\\n**PLEASE UPVOTE THIS IF YOU FIND THIS AS USEFUL**\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        def recursive(s,ans):\\n            if len(s)>=low and len(s)<=high:\\n                ans+=[s]\\n            if len(s)>high:\\n                return \\n            recursive(s+\"0\"*zero,ans)\\n            recursive(s+\"1\"*one,ans)\\n            return\\n        ans=[]\\n        recursive(\"\",ans)\\n        return len(ans)\\n        \\n```\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        ans=[0]\\n        def recursive(s):\\n            if s>high:\\n                return 0\\n            p=recursive(s+zero)+recursive(s+one)\\n            if s>=low and s<=high:\\n                p+=1\\n            return p\\n        return recursive(0)%(10**9+7)\\n        \\n```\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        ans=[0]\\n        mod=10**9+7\\n        def recursive(s):\\n            if s>high:\\n                return 0\\n            if dp[s]!=-1:\\n                return dp[s]\\n            p=recursive(s+zero)+recursive(s+one)\\n            if s>=low and s<=high:\\n                p+=1\\n            dp[s]=p%mod\\n            return dp[s]\\n        dp=[-1]*(high+1)\\n        return recursive(0)%mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807239,
                "title": "simple-dp-solution",
                "content": "```\\nint md = 1e9+7;\\n    \\n    int f(int ind, int l, int h, int z, int o, vector<long long>&dp){\\n        if(ind > h) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        long long first = f(ind + z, l, h, z, o, dp) % md;  //zero\\n        long long sec = f(ind + o, l, h, z, o, dp) % md;  //one\\n        dp[ind] = (first+sec + (ind>=l && ind<=h)) % md;\\n        return dp[ind] ;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int z, int o) {\\n        vector<long long>dp(high+1, -1);\\n        return f(0, low, high, z, o, dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint md = 1e9+7;\\n    \\n    int f(int ind, int l, int h, int z, int o, vector<long long>&dp){\\n        if(ind > h) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        long long first = f(ind + z, l, h, z, o, dp) % md;  //zero\\n        long long sec = f(ind + o, l, h, z, o, dp) % md;  //one\\n        dp[ind] = (first+sec + (ind>=l && ind<=h)) % md;\\n        return dp[ind] ;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int z, int o) {\\n        vector<long long>dp(high+1, -1);\\n        return f(0, low, high, z, o, dp); \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518708,
                "title": "recursion-memoization-easy-and-clean-codes-c-striver",
                "content": "# Intuition\\nTrying all possible ways and considering all those in the range [low,high] => DP!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOur answer will include all the strings whose lengths are from low to high. So from the given function, call the recursive function for each length. \\nAs the recursive function is called for the length of the string, we have to make the string from \\'one\\' and \\'zero\\' such that they fit in the string.\\nFor the base case if the length goes less than zero we return a 0 else if we somehow reach the length 0 we return a 1.\\nFor the recursive calls we can either make calls by appending \\'zero\\' or \\'one\\', so if length is greater than or equal to \\'one\\' or \\'zero\\' call the function recursively by reducing the length by that value, finally return the sum of both the ways. \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nRecursion: exponential (TLE)\\nMemoized: O(H)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nRecursion: recursive stack space\\nMemoized: O(H) + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Recursion(TLE) []\\nclass Solution {\\npublic:\\n\\nint m=1e9+7;\\n\\nint sumi(int n, int zero, int one){\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    int a=0,b=0;\\n    if(n>=zero) a=sumi(n-zero,zero,one);\\n    if(n>=one) b=sumi(n-one,zero,one);\\n    return (a+b)%m;\\n}\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans+=sumi(i,zero,one)%m;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Memoization []\\nclass Solution {\\npublic:\\n\\nint m=1e9+7;\\n\\nlong long int sumi(int n, int zero, int one, vector<long long int> &dp){\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n]%m;\\n    long long int a=0,b=0;\\n    if(n>=zero) a=sumi(n-zero,zero,one,dp)%m;\\n    if(n>=one) b=sumi(n-one,zero,one,dp)%m;\\n    return dp[n]=(a+b)%m;\\n}\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        long long int ans=0;\\n        vector<long long int> dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans+=sumi(i,zero,one,dp)%m;\\n        }\\n        return ans%m;\\n    }\\n};\\n```\\n# *Please upvote if this helped!*\\n***Happy coding :)***\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```Recursion(TLE) []\\nclass Solution {\\npublic:\\n\\nint m=1e9+7;\\n\\nint sumi(int n, int zero, int one){\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    int a=0,b=0;\\n    if(n>=zero) a=sumi(n-zero,zero,one);\\n    if(n>=one) b=sumi(n-one,zero,one);\\n    return (a+b)%m;\\n}\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans+=sumi(i,zero,one)%m;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Memoization []\\nclass Solution {\\npublic:\\n\\nint m=1e9+7;\\n\\nlong long int sumi(int n, int zero, int one, vector<long long int> &dp){\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n]%m;\\n    long long int a=0,b=0;\\n    if(n>=zero) a=sumi(n-zero,zero,one,dp)%m;\\n    if(n>=one) b=sumi(n-one,zero,one,dp)%m;\\n    return dp[n]=(a+b)%m;\\n}\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        long long int ans=0;\\n        vector<long long int> dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans+=sumi(i,zero,one,dp)%m;\\n        }\\n        return ans%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518038,
                "title": "c-dp-iterative",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    ll mod=1e9+7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll>dp(high+1,0);\\n        dp[0]=1;\\n        ll ans=0;\\n        for(int i=1;i<=high;i++){\\n            if(i>=zero){\\n                dp[i] = (dp[i]%mod + dp[abs(zero-i)]%mod)%mod; \\n            }\\n            if(i>=one){\\n                dp[i] = (dp[i]%mod + dp[abs(one-i)]%mod)%mod; \\n            }\\n            if(i>=low){\\n                ans = (ans%mod + dp[i]%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a00df86d-f51a-44f0-89a9-f48c64fff706_1683947106.9804983.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    ll mod=1e9+7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll>dp(high+1,0);\\n        dp[0]=1;\\n        ll ans=0;\\n        for(int i=1;i<=high;i++){\\n            if(i>=zero){\\n                dp[i] = (dp[i]%mod + dp[abs(zero-i)]%mod)%mod; \\n            }\\n            if(i>=one){\\n                dp[i] = (dp[i]%mod + dp[abs(one-i)]%mod)%mod; \\n            }\\n            if(i>=low){\\n                ans = (ans%mod + dp[i]%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807849,
                "title": "java-9ms-faster-than-100-use-gcd-on-zero-one-to-shrink-bounds",
                "content": "**Intuition**: I was thinking about this problem and what happens when `zero == one`.  And realized if `zero == one > 1`, we could simplify the problem by dividing the values _and_ the bounds by the common value.  And then, I realized, we can still do this even if `zero` and `one` are unequal but have a common divisor greater than 1.  That is, if `gcd(zero, one) > 1`, we can prevent a lot of calculation by shrinking our bounds, by dividing through by the gcd.  One caveat - we have to be careful at the bounds themselves.  Suppose `low` = 5, `high` = 10 and our gcd is 2.  Our new bounds must be 3 and 5, not 2 and 5.  To see this, imagine both `zero` and `one` are 2.  A string of say `0011` is not valid in the original bounds (too short for `low = 5`).  If we divide through by 2, then we have an equivalent string of `01`.  This should still be invalid.  If we round `low` down after dividing by 2, we get 2, and this string would be valid.  Oops.  This is why we must round `low` up when dividing by the GCD, and round `high` down.\\n\\n**Basic Problem - Unoptimized**: I\\'ll briefly cover how we get to the basic solution (unoptimized).  First, realize that if we try to count solutions, we\\'re going to get TLE.  For example, given low = 1, high = 100000, then there are 4999950000 combinations of how many times we append `zero` 0s and how many times we append `one` 1s.  Then we have to determine how many unique strings can be formed from each combination.  That would take minutes if not hours.  So, is there some recursive way we could do this?  Let `count[k]` be the number of good strings of length k.  Then, we can say that `count[k + zero]` will receive `count[k]` contributions by taking all the unique good strings in `count[k]` and appending `zero` 0s.  And similarly, `count[k + one]` will receive `count[k]` contributions by taking all the unique good strings in `count[k]` and appending `one` 1s.  As long as we loop over k from 0 to high and carry forward (build from small to large) our string counts, we can compute all of the values `count[k]` between `low` and `high`.  Then we add these together and get our answer.  This gives us an O(`high`) time complexity (and space complexity).\\n\\n```\\nclass Solution {\\n\\n    static final int MOD = 1_000_000_007;\\n\\n\\tpublic int countGoodStrings(int low, int high, int zero, int one) {\\n\\t\\tfinal int[] dp = new int[high + 1];\\n\\t\\tdp[zero]++;\\n\\t\\tdp[one]++;\\n\\t\\tfor (int i = 0; i < dp.length; ++i) {\\n\\t\\t\\tfinal int zi = i + zero;\\n\\t\\t\\tif (zi < dp.length) {\\n\\t\\t\\t\\tdp[zi] = (dp[zi] + dp[i]) % MOD;\\n\\t\\t\\t}\\n\\t\\t\\tfinal int oi = i + one;\\n\\t\\t\\tif (oi < dp.length) {\\n\\t\\t\\t\\tdp[oi] = (dp[oi] + dp[i]) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = low; i <= high; ++i) {\\n\\t\\t\\tsum = (sum + dp[i]) % MOD;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\\nNote: This is just how I solved the core problem.  If you prefer a different way to solve the core problem, simply plug that in instead of my code.  The GCD-shrinking optimization (discussed next) should be independent of the core solution.\\n\\n**Optimizing with GCD**: Now, let\\'s factor the core solution method out and call it `countGoodStrings0` (or whatever you prefer).  Our new `countGoodStrings` method will check GCD of `zero` and `one`.  If the GCD is 1, we\\'ll proceed by calling `countGoodStrings0` directly.  If it\\'s greater than 1, we\\'ll recompute `zero`, `one`, and our bounds, and call `countGoodStrings0` with the new arguments.  For GCD, there are a few ways we can do this.  I like the [binary GCD algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm), but you can use whichever GCD algorithm you prefer.\\n\\n**Java Code** O(high) time and space (yes, we optimized to reduce high/low in some cases, but this is a coefficient change; it\\'s still linearly proportional to `high`).  Runtime: 9ms as of November 12, 2022.\\n\\n```\\nclass Solution {\\n\\n    static final int MOD = 1_000_000_007;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        final int gcd = binaryGcd(zero, one);\\n        if (gcd > 1) {\\n            return countGoodStrings0((low + gcd - 1) / gcd, high / gcd, zero / gcd, one / gcd);\\n        }\\n        return countGoodStrings0(low, high, zero, one);\\n    }\\n\\n    private int countGoodStrings0(int low, int high, int zero, int one) {\\n        final int[] dp = new int[high + 1];\\n        dp[zero]++;\\n        dp[one]++;\\n        for (int i = 0; i < dp.length; ++i) {\\n            final int zi = i + zero;\\n            if (zi < dp.length) {\\n                dp[zi] = (dp[zi] + dp[i]) % MOD;\\n            }\\n            final int oi = i + one;\\n            if (oi < dp.length) {\\n                dp[oi] = (dp[oi] + dp[i]) % MOD;\\n            }\\n        }\\n        int sum = 0;\\n        for (int i = low; i <= high; ++i) {\\n            sum = (sum + dp[i]) % MOD;\\n        }\\n        return sum;\\n    }\\n    \\n\\tprivate int binaryGcd(int a, int b) {\\n\\t\\t// https://en.wikipedia.org/wiki/Binary_GCD_algorithm\\n\\t\\tint aa = Math.abs(a);\\n\\t\\tint bb = Math.abs(b);\\n\\t\\tif (aa == 0) {\\n\\t\\t\\treturn bb;\\n\\t\\t} else if (bb == 0) {\\n\\t\\t\\treturn aa;\\n\\t\\t}\\n\\t\\tfinal int i = Integer.numberOfTrailingZeros(aa);\\n\\t\\taa >>= i;\\n\\t\\tfinal int j = Integer.numberOfTrailingZeros(bb);\\n\\t\\tbb >>= j;\\n\\t\\tint k = Math.min(i, j);\\n\\t\\twhile (true) {\\n\\t\\t\\tif (aa > bb) {\\n\\t\\t\\t\\tint temp = aa;\\n\\t\\t\\t\\taa = bb;\\n\\t\\t\\t\\tbb = temp;\\n\\t\\t\\t}\\n\\t\\t\\tbb -= aa;\\n\\t\\t\\tif (bb == 0) {\\n\\t\\t\\t\\treturn (aa << k);\\n\\t\\t\\t}\\n\\t\\t\\tbb >>= Integer.numberOfTrailingZeros(bb);\\n\\t\\t}\\n\\t}\\n\\n}\\n```\\n\\n**Some Ideas for Further Optimization**: We have possibilities to optimize further.  For example, we could keep a running total of `dp[k]` for `low <= k <= high` so we don\\'t have to do a second loop to compute `sum`.  This might save some time.  In general, if we create a faster core solution, we can plug that into `countGoodStrings0` and the whole solution will benefit.  Also, I suppose we could shave off a few microseconds by starting i at 1 instead of 0, since we know that `low`, `zero` and `one` are all at least 1.  And finally, we could try some alternative GCD algorithms (but we only compute the GCD once per test case, so again, it may be microseconds).  If you try any of these optimizations and can make this go faster, **I\\'d love to hear about it in the comments!**  There\\'s something satisfying about fast, efficient code - I\\'d enjoy reading yours.\\n\\n**Standard Plea**: If you found this post useful, interesting, or at least did not feel like your time was wasted, **I\\'d appreciate an upvote**.  And if you didn\\'t like this post, **I would be glad to read your constructive criticism so I can improve my solutions in the future.**\\n\\nThanks for reading, and happy coding!\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    static final int MOD = 1_000_000_007;\\n\\n\\tpublic int countGoodStrings(int low, int high, int zero, int one) {\\n\\t\\tfinal int[] dp = new int[high + 1];\\n\\t\\tdp[zero]++;\\n\\t\\tdp[one]++;\\n\\t\\tfor (int i = 0; i < dp.length; ++i) {\\n\\t\\t\\tfinal int zi = i + zero;\\n\\t\\t\\tif (zi < dp.length) {\\n\\t\\t\\t\\tdp[zi] = (dp[zi] + dp[i]) % MOD;\\n\\t\\t\\t}\\n\\t\\t\\tfinal int oi = i + one;\\n\\t\\t\\tif (oi < dp.length) {\\n\\t\\t\\t\\tdp[oi] = (dp[oi] + dp[i]) % MOD;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = low; i <= high; ++i) {\\n\\t\\t\\tsum = (sum + dp[i]) % MOD;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\n    static final int MOD = 1_000_000_007;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        final int gcd = binaryGcd(zero, one);\\n        if (gcd > 1) {\\n            return countGoodStrings0((low + gcd - 1) / gcd, high / gcd, zero / gcd, one / gcd);\\n        }\\n        return countGoodStrings0(low, high, zero, one);\\n    }\\n\\n    private int countGoodStrings0(int low, int high, int zero, int one) {\\n        final int[] dp = new int[high + 1];\\n        dp[zero]++;\\n        dp[one]++;\\n        for (int i = 0; i < dp.length; ++i) {\\n            final int zi = i + zero;\\n            if (zi < dp.length) {\\n                dp[zi] = (dp[zi] + dp[i]) % MOD;\\n            }\\n            final int oi = i + one;\\n            if (oi < dp.length) {\\n                dp[oi] = (dp[oi] + dp[i]) % MOD;\\n            }\\n        }\\n        int sum = 0;\\n        for (int i = low; i <= high; ++i) {\\n            sum = (sum + dp[i]) % MOD;\\n        }\\n        return sum;\\n    }\\n    \\n\\tprivate int binaryGcd(int a, int b) {\\n\\t\\t// https://en.wikipedia.org/wiki/Binary_GCD_algorithm\\n\\t\\tint aa = Math.abs(a);\\n\\t\\tint bb = Math.abs(b);\\n\\t\\tif (aa == 0) {\\n\\t\\t\\treturn bb;\\n\\t\\t} else if (bb == 0) {\\n\\t\\t\\treturn aa;\\n\\t\\t}\\n\\t\\tfinal int i = Integer.numberOfTrailingZeros(aa);\\n\\t\\taa >>= i;\\n\\t\\tfinal int j = Integer.numberOfTrailingZeros(bb);\\n\\t\\tbb >>= j;\\n\\t\\tint k = Math.min(i, j);\\n\\t\\twhile (true) {\\n\\t\\t\\tif (aa > bb) {\\n\\t\\t\\t\\tint temp = aa;\\n\\t\\t\\t\\taa = bb;\\n\\t\\t\\t\\tbb = temp;\\n\\t\\t\\t}\\n\\t\\t\\tbb -= aa;\\n\\t\\t\\tif (bb == 0) {\\n\\t\\t\\t\\treturn (aa << k);\\n\\t\\t\\t}\\n\\t\\t\\tbb >>= Integer.numberOfTrailingZeros(bb);\\n\\t\\t}\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807174,
                "title": "fibonacci-pattern",
                "content": "We have two choices (either we can append **zero** 0s or **one** 1s at a time) which depends on the number of **zeros** and **ones** that we have been given, based on that we can apply our recursive conditions\\n\\nHere we can have **high** as our recursive base condition , after that we just have to return and the strings won\\'t be valid anymore. While we are in the range of low to high (inclusive) we can add 1 with the results of the further recursive calls because **we are in the valid range and the string uptill here is valid in itself**.\\n\\nBefore **i<low** we just have to return the future answers that we will get after going deep in the recursion.\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        Integer[] dp=new Integer[high+1];\\n        return fun(low,high,zero,one,0,dp);\\n    }\\n    int fun(int l,int h,int z, int o,int i,Integer[] dp){\\n        if(i>h)return 0;\\n        if(dp[i]!=null)return dp[i];\\n        int a=0,b=0;\\n        // if(i+z<=high)\\n            a=fun(l,h,z,o,i+z,dp)%mod;\\n        // if(i+o<=high)\\n            b=fun(l,h,z,o,i+o,dp)%mod;\\n        if(i>=l && i<=h)\\n        return dp[i]=(a+b+1)%mod;\\n        return dp[i]=(a+b)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        Integer[] dp=new Integer[high+1];\\n        return fun(low,high,zero,one,0,dp);\\n    }\\n    int fun(int l,int h,int z, int o,int i,Integer[] dp){\\n        if(i>h)return 0;\\n        if(dp[i]!=null)return dp[i];\\n        int a=0,b=0;\\n        // if(i+z<=high)\\n            a=fun(l,h,z,o,i+z,dp)%mod;\\n        // if(i+o<=high)\\n            b=fun(l,h,z,o,i+o,dp)%mod;\\n        if(i>=l && i<=h)\\n        return dp[i]=(a+b+1)%mod;\\n        return dp[i]=(a+b)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517908,
                "title": "javascript-dp-simple-solution-with-comments",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n    const modulo = 1e9 + 7\\n    let answ = 0\\n\\n    // dp array of lenght high + 1 filled with zeros\\n    // dp[i] denotes number of valid strings of lenght i\\n    const dp = Array(high + 1).fill(0)\\n    \\n    // an empty string \"\" can be constructed only in 1 way, so dp[0] = 1\\n    dp[0] = 1\\n\\n    for (let i = 1; i <= high; i++) {\\n        // for each i, a string of length i can be constructed\\n        // by adding either \"0\" zero time\\n        // or by adding \"1\" one times\\n        // dp[i] = dp[i - zero] + dp[i - one]\\n\\n        if (i - zero >= 0) {\\n            dp[i] = (dp[i] + dp[i - zero]) % modulo\\n        }\\n        if (i - one >= 0) {\\n            dp[i] = (dp[i] + dp[i - one]) % modulo\\n        }\\n\\n        // if i >= low start counting the total number of strings      \\n        if (i >= low) {\\n            answ = (answ + dp[i]) % modulo\\n        }  \\n    }\\n\\n    return answ\\n};\\n```\\n\\nPlease upvote if it was helpful. Thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n    const modulo = 1e9 + 7\\n    let answ = 0\\n\\n    // dp array of lenght high + 1 filled with zeros\\n    // dp[i] denotes number of valid strings of lenght i\\n    const dp = Array(high + 1).fill(0)\\n    \\n    // an empty string \"\" can be constructed only in 1 way, so dp[0] = 1\\n    dp[0] = 1\\n\\n    for (let i = 1; i <= high; i++) {\\n        // for each i, a string of length i can be constructed\\n        // by adding either \"0\" zero time\\n        // or by adding \"1\" one times\\n        // dp[i] = dp[i - zero] + dp[i - one]\\n\\n        if (i - zero >= 0) {\\n            dp[i] = (dp[i] + dp[i - zero]) % modulo\\n        }\\n        if (i - one >= 0) {\\n            dp[i] = (dp[i] + dp[i - one]) % modulo\\n        }\\n\\n        // if i >= low start counting the total number of strings      \\n        if (i >= low) {\\n            answ = (answ + dp[i]) % modulo\\n        }  \\n    }\\n\\n    return answ\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518468,
                "title": "c-recursive-memoization-tabulation-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(high)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(high)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n <!-- ------------Recursive-------------  -->\\n    int mod = 1e9 + 7;\\n     int solve(int zero , int one , int n)\\n     {\\n//if the lenght becomes 0 it means we taken length of i string so we increase our ans by 1 \\n         if(n == 0 )\\n         return 1;\\n// if the lenght of our string go beyond i then return 0 \\n         if( n <  0 )\\n         return 0;\\n// we can take all zero or all one so that\\'s why we decrease (n-zero ) or (n-one)\\n         return  (solve(zero,one,n-zero) % mod + solve(zero,one,one) % mod) % mod;\\n     }\\n    \\n     int countGoodStrings(int low, int high, int zero, int one)\\n     {\\n         int ans = 0;\\n// for loop for fixed length of string from low to high inclusive and we calculate the number of occurence in ans \\n         for(int i =  low ; i <=high ;i++)\\n         {\\n             ans = (ans + solve( zero , one , i )%mod ) %mod;\\n         }\\n         return ans;\\n     }\\n\\n\\n <!-- ----------Memoization----------------- -->\\n    int mod = 1e9 + 7;\\n     int solve(vector<int>&dp , int zero , int one , int n)\\n     {\\n//if the lenght becomes 0 it means we taken length of i string so we increase our ans by 1 \\n         if(n == 0 )\\n         return 1;\\n// if the lenght of our string go beyond i then return 0 \\n         if( n <  0 )\\n         return 0;\\n         if(dp[n] != -1)\\n         return dp[n];\\n// we can take all zero or all one so that\\'s why we decrease (n-zero ) or (n-one)\\n         return  dp[n] =  (solve(dp,zero,one,n-zero) % mod + solve(dp,zero,one,n-one) % mod) % mod;\\n     }\\n    \\n     int countGoodStrings(int low, int high, int zero, int one)\\n     {\\n         int ans = 0;\\n         vector<int>dp(high + 1 , -1 );\\n// for loop for fixed length of string and we calculate the number of occurence in ans \\n         for(int i =  low ; i <=high ;i++)\\n         {\\n             ans = (ans + solve( dp , zero , one , i )%mod ) %mod;\\n         }\\n         return ans;\\n     }\\n\\n\\n<!-- ------------Tabulation--------------- -->\\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int mod = 1e9 + 7;\\n        vector<int>dp(high + 1 , 0);\\n        dp[0] = 1;\\n\\n        for(int i = 1 ;i<= high ;i++ )\\n        {\\n            if( i >= zero )\\n            dp[i] = (dp[i] + dp[i-zero] )%mod;\\n            if( i >= one )\\n            dp[i] = (dp[i] + dp[i-one] )%mod;\\n        }\\n\\n        long long ans = 0 ;\\n        for(int i =  low ; i <=high ;i++)\\n        ans = (ans + dp[i] ) %mod;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n <!-- ------------Recursive-------------  -->\\n    int mod = 1e9 + 7;\\n     int solve(int zero , int one , int n)\\n     {\\n//if the lenght becomes 0 it means we taken length of i string so we increase our ans by 1 \\n         if(n == 0 )\\n         return 1;\\n// if the lenght of our string go beyond i then return 0 \\n         if( n <  0 )\\n         return 0;\\n// we can take all zero or all one so that\\'s why we decrease (n-zero ) or (n-one)\\n         return  (solve(zero,one,n-zero) % mod + solve(zero,one,one) % mod) % mod;\\n     }\\n    \\n     int countGoodStrings(int low, int high, int zero, int one)\\n     {\\n         int ans = 0;\\n// for loop for fixed length of string from low to high inclusive and we calculate the number of occurence in ans \\n         for(int i =  low ; i <=high ;i++)\\n         {\\n             ans = (ans + solve( zero , one , i )%mod ) %mod;\\n         }\\n         return ans;\\n     }\\n\\n\\n <!-- ----------Memoization----------------- -->\\n    int mod = 1e9 + 7;\\n     int solve(vector<int>&dp , int zero , int one , int n)\\n     {\\n//if the lenght becomes 0 it means we taken length of i string so we increase our ans by 1 \\n         if(n == 0 )\\n         return 1;\\n// if the lenght of our string go beyond i then return 0 \\n         if( n <  0 )\\n         return 0;\\n         if(dp[n] != -1)\\n         return dp[n];\\n// we can take all zero or all one so that\\'s why we decrease (n-zero ) or (n-one)\\n         return  dp[n] =  (solve(dp,zero,one,n-zero) % mod + solve(dp,zero,one,n-one) % mod) % mod;\\n     }\\n    \\n     int countGoodStrings(int low, int high, int zero, int one)\\n     {\\n         int ans = 0;\\n         vector<int>dp(high + 1 , -1 );\\n// for loop for fixed length of string and we calculate the number of occurence in ans \\n         for(int i =  low ; i <=high ;i++)\\n         {\\n             ans = (ans + solve( dp , zero , one , i )%mod ) %mod;\\n         }\\n         return ans;\\n     }\\n\\n\\n<!-- ------------Tabulation--------------- -->\\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int mod = 1e9 + 7;\\n        vector<int>dp(high + 1 , 0);\\n        dp[0] = 1;\\n\\n        for(int i = 1 ;i<= high ;i++ )\\n        {\\n            if( i >= zero )\\n            dp[i] = (dp[i] + dp[i-zero] )%mod;\\n            if( i >= one )\\n            dp[i] = (dp[i] + dp[i-one] )%mod;\\n        }\\n\\n        long long ans = 0 ;\\n        for(int i =  low ; i <=high ;i++)\\n        ans = (ans + dp[i] ) %mod;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518020,
                "title": "2-line-python-for-fun",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a curLen is between low and high, it contributes one to the total number of good strings. We assume that dfs(curLen+zero) + dfs(curLen+one) will give us the other good strings we can make by adding more characters.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI originally wrote it normally but decided to make it 2 lines by using @cache for memoization and a ternary statement to check for the base case (curLen > high). This is meant for fun, not for practicality. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(high)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(high)\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        @cache\\n        def dfs(curLen): return (int(low <= curLen and curLen <= high) + dfs(curLen+zero) + dfs(curLen + one)) % (10**9+7) if curLen <= high else 0\\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        @cache\\n        def dfs(curLen): return (int(low <= curLen and curLen <= high) + dfs(curLen+zero) + dfs(curLen + one)) % (10**9+7) if curLen <= high else 0\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517795,
                "title": "java-dp-top-down-recursive-12-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem we need to keep adding `zero` or `one` characters at each step. We need to consider only those combinations that are `>= low` and `<= high`. At any step, we need to calculate how many more combinations are possible that satisfy these conditions and return the count to the previous step. To optimize the problem, we can use memoization to remember how many more combinations are possible if the current step has already built a string of length `i`.\\n\\n# Complexity\\n- Time complexity: $$O(high)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(high)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int mod = 1000000007;\\n  int[] memo;\\n\\n  private int countGoodStrings(int low, int high, int zero, int one, int i) {\\n    if (i > high) return 0;\\n    \\n    if (memo[i] != -1) return memo[i];\\n\\n    memo[i] = i >= low && i <= high ? 1 : 0;\\n\\n    memo[i] = (memo[i] + countGoodStrings(low, high, zero, one, i + zero)) % mod;\\n    memo[i] = (memo[i] + countGoodStrings(low, high, zero, one, i + one)) % mod;\\n\\n    return memo[i];\\n  }\\n\\n  public int countGoodStrings(int low, int high, int zero, int one) {\\n    memo = new int[high + 1];\\n    Arrays.fill(memo, -1);\\n\\n    return countGoodStrings(low, high, zero, one, 0);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n  int mod = 1000000007;\\n  int[] memo;\\n\\n  private int countGoodStrings(int low, int high, int zero, int one, int i) {\\n    if (i > high) return 0;\\n    \\n    if (memo[i] != -1) return memo[i];\\n\\n    memo[i] = i >= low && i <= high ? 1 : 0;\\n\\n    memo[i] = (memo[i] + countGoodStrings(low, high, zero, one, i + zero)) % mod;\\n    memo[i] = (memo[i] + countGoodStrings(low, high, zero, one, i + one)) % mod;\\n\\n    return memo[i];\\n  }\\n\\n  public int countGoodStrings(int low, int high, int zero, int one) {\\n    memo = new int[high + 1];\\n    Arrays.fill(memo, -1);\\n\\n    return countGoodStrings(low, high, zero, one, 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820703,
                "title": "simple-recursion-memoization-c-explained",
                "content": "Let us consider the  **zero** as **\\'x\\'** and number of **one** as **\\'y\\'** for simplicity. \\n\\nThe point of the question is **you can take 0s or 1s always in groups of \\'x\\' and \\'y\\' respectively.**\\nSo , we always have **2 choices to build the string , either take \\'x\\' 0s together or \\'y\\' 1s together.**\\nSuppose we are given a length , say **N** and the task is to count the good substrings,\\n\\n**Case of 0s:**\\n\\t\\tWe can form a string which has **\\'x\\'** 0s , thereby we have formed a string of length **\\'x\\'** . Now we can continue from there to solve for **N-\\'x\\'** length .\\n\\n**Case of 1s:**\\n\\t\\tWe can form a string which has **\\'y\\'** 1s , thereby we have formed a string of length **\\'y\\'** . Now we can continue from there to solve for **N-\\'y\\'** length .\\n\\n*A simple recursion solution to the above would look like this.*\\n```\\nint f(int n,int& x,int& y)\\n{\\n\\tif( n<0 ) return 0;\\n\\tif( n==0 ) return 1;\\n\\n\\tint opt1 = f(n-x,x,y);\\n\\tint opt2 = f(n-y,x,y);\\n\\n\\treturn (opt1+opt2)%1000000007;\\n}\\n```\\nSince this is for any **N** , we can run a loop from **i=low to i=high** to account for *all possible good substring from **low to high***.\\n\\nHere is the complete recursive code !\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int n,int& x,int& y)\\n    {\\n        if( n<0 ) return 0;\\n        if( n==0 ) return 1;\\n        \\n        int opt1 = f(n-x,x,y);\\n        int opt2 = f(n-y,x,y);\\n        \\n        return (opt1+opt2)%1000000007;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n\\t\\n        int ans = 0;\\n        for( int i = low; i <= high; i++)\\n        {\\n            ans = ( f(i,zero,one) + ans )%1000000007;\\n        }\\n        return ans;\\n\\t\\t\\n    }\\n};\\n```\\nThe above solution gives **TLE** for large input\\'s. We observe that there are many overlapping sub-problem\\'s and we can use **DP** to save the states.\\n\\nHere is the memoized solution !\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001];\\n    int f(int n,int&x,int&y)\\n    {\\n        if( n<0 ) return 0;\\n        if( n==0 ) return 1;\\n\\n        if( dp[n]!=-1 ) return dp[n];        \\n        int opt1 = f(n-x,x,y);\\n        int opt2 = f(n-y,x,y);\\n        \\n        return dp[n] = ( opt1 + opt2 ) % 1000000007;\\n    }\\n\\t\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for( int i = low; i <= high; i++)\\n        {\\n            ans = ( ans + f(i,zero,one) )%1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION ! ANY CHANGES , PIN DOWN IN THE COMMENT SECTION**\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint f(int n,int& x,int& y)\\n{\\n\\tif( n<0 ) return 0;\\n\\tif( n==0 ) return 1;\\n\\n\\tint opt1 = f(n-x,x,y);\\n\\tint opt2 = f(n-y,x,y);\\n\\n\\treturn (opt1+opt2)%1000000007;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int n,int& x,int& y)\\n    {\\n        if( n<0 ) return 0;\\n        if( n==0 ) return 1;\\n        \\n        int opt1 = f(n-x,x,y);\\n        int opt2 = f(n-y,x,y);\\n        \\n        return (opt1+opt2)%1000000007;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n\\t\\n        int ans = 0;\\n        for( int i = low; i <= high; i++)\\n        {\\n            ans = ( f(i,zero,one) + ans )%1000000007;\\n        }\\n        return ans;\\n\\t\\t\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001];\\n    int f(int n,int&x,int&y)\\n    {\\n        if( n<0 ) return 0;\\n        if( n==0 ) return 1;\\n\\n        if( dp[n]!=-1 ) return dp[n];        \\n        int opt1 = f(n-x,x,y);\\n        int opt2 = f(n-y,x,y);\\n        \\n        return dp[n] = ( opt1 + opt2 ) % 1000000007;\\n    }\\n\\t\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for( int i = low; i <= high; i++)\\n        {\\n            ans = ( ans + f(i,zero,one) )%1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816599,
                "title": "dp",
                "content": "**C++**\\n```cpp\\nint countGoodStrings(int low, int high, int zero, int one) {\\n    int dp[100001] = {};\\n    function<int(int)> dfs = [&](int i){\\n        if (i > high)\\n            return 0;\\n        if (dp[i] == 0)\\n            dp[i] = (1 + (i >= low ? 1 : 0) + dfs(i + zero) + dfs(i + one)) % 1000000007;\\n        return dp[i] - 1;\\n    };\\n    return dfs(0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countGoodStrings(int low, int high, int zero, int one) {\\n    int dp[100001] = {};\\n    function<int(int)> dfs = [&](int i){\\n        if (i > high)\\n            return 0;\\n        if (dp[i] == 0)\\n            dp[i] = (1 + (i >= low ? 1 : 0) + dfs(i + zero) + dfs(i + one)) % 1000000007;\\n        return dp[i] - 1;\\n    };\\n    return dfs(0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807157,
                "title": "java-solution-using-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        int k=0;\\n        int m=1000000007;\\n        for(int i=low;i<=high;i++)\\n        {\\n            k=(k%m+task(dp,i,zero,one,m)%m)%m;\\n        }\\n        return k;\\n    }\\n    public int task(int dp[], int i, int s, int k, int m)\\n    {\\n        if(i<0)\\n        {\\n            return 0;\\n        }\\n        if(i==0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i]%m;\\n        }\\n        return dp[i]=task(dp,i-s,s,k,m)%m+task(dp,i-k,s,k,m)%m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        int k=0;\\n        int m=1000000007;\\n        for(int i=low;i<=high;i++)\\n        {\\n            k=(k%m+task(dp,i,zero,one,m)%m)%m;\\n        }\\n        return k;\\n    }\\n    public int task(int dp[], int i, int s, int k, int m)\\n    {\\n        if(i<0)\\n        {\\n            return 0;\\n        }\\n        if(i==0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i]%m;\\n        }\\n        return dp[i]=task(dp,i-s,s,k,m)%m+task(dp,i-k,s,k,m)%m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521385,
                "title": "java-simple-dp-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each i lenght of Strings, there are 2 cases:\\n1, end with 1;\\n2, end with 0;\\nDP[i] = dp[i - one] + dp[i - zero];\\n\\ninit, dp[0] = 1, for empty Strings, there are 1 way.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high + 1];\\n        int mn = Math.min(zero, one), res = 0, mod = 1_000_000_000 + 7;\\n        dp[0] = 1;\\n        for (int i = mn; i <= high; i++) {\\n            if (i - zero >= 0) dp[i] = dp[i - zero];\\n            if (i - one >= 0) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high + 1];\\n        int mn = Math.min(zero, one), res = 0, mod = 1_000_000_000 + 7;\\n        dp[0] = 1;\\n        for (int i = mn; i <= high; i++) {\\n            if (i - zero >= 0) dp[i] = dp[i - zero];\\n            if (i - one >= 0) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519419,
                "title": "don-t-be-scared-of-dp-use-it-to-support-your-recursion-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple recursion tree can be constructed , beginners can construct on a notebook. Use dp to justify your tree and cache it.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1,0);\\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i=1;i<=high;i++){\\n            dp[i] = 0;\\n            if(i >= zero) dp[i] = (dp[i] + dp[i-zero])%mod;\\n            if(i >= one) dp[i] = (dp[i] + dp[i-one])%mod;\\n\\n            if(i>=low) ans = (ans + dp[i])%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1,0);\\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i=1;i<=high;i++){\\n            dp[i] = 0;\\n            if(i >= zero) dp[i] = (dp[i] + dp[i-zero])%mod;\\n            if(i >= one) dp[i] = (dp[i] + dp[i-one])%mod;\\n\\n            if(i>=low) ans = (ans + dp[i])%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518719,
                "title": "day-408-rec-memo-dp-4-liner-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition &  Approach\\n##### \\u2022\\tWe need to count the number of good strings of length n that have at most zero 0\\'s and at most one 1\\'s\\n##### \\u2022\\tWe can use dynamic programming to solve this problem\\n##### \\u2022\\tWe can define a state dp[i] to represent the number of good strings of length i that have at most zero 0\\'s and at most one 1\\'s\\n##### \\u2022\\tWe can initialize dp[0] to 1, since there is only one good string of length 0, which is the empty string\\n##### \\u2022\\tWe can then use a loop to compute dp[i] for all i from 1 to high, where high is the maximum length of the string\\n##### \\u2022\\tTo compute dp[i], we can use the recurrence relation dp[i] = dp[i-zero] + dp[i-one], where i-zero and i-one are the indices of the previous states that can be used to form a good string of length i\\n##### \\u2022\\tWe need to make sure that we only count good strings that have at least low characters\\n##### \\u2022\\tWe can use another variable ans to keep track of the total number of good strings that have at least low characters\\n##### \\u2022\\tFinally, we can return ans as the answer to the problem\\n##### \\u2022\\tOverall, the approach is to use dynamic programming to compute the number of good strings of length i that have at most zero 0\\'s and at most one 1\\'s, and then count the number of good strings that have at least low characters\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n```java []\\npublic int countGoodStrings(int low, int high, int zero, int one) {\\n    int dp[] = new int[high+1],ans = 0,mod = 1000000007;\\n    dp[0] = 1;\\n    for(int i=1;i<=high;i++){\\n        dp[i] = ((i-zero>=0 ? dp[i-zero] : 0) + (i-one>=0 ? dp[i-one] : 0))%mod;\\n        if(i>=low) ans = (ans + dp[i])%mod;\\n    } return ans;\\n}  \\n```\\n```c++ []\\nint countGoodStrings(int, int high, int zero, int one) {\\n    vector<int> dp(high+1);\\n    int ans = 0, mod = 1e9+7;\\n    dp[0] = 1;\\n    for(int i=1;i<=high;i++){\\n        dp[i] = ((i-zero>=0 ? dp[i-zero] : 0) + (i-one>=0 ? dp[i-one] : 0))%mod;\\n        if(i>=low) ans = (ans + dp[i])%mod;\\n    } \\n    return ans;\\n}\\n```\\n```python []\\ndef countGoodStrings(low: int, high: int, zero: int, one: int) -> int:\\n    dp = [0] * (high+1)\\n    ans, mod = 0, 10**9+7\\n    dp[0] = 1\\n    for i in range(1, high+1):\\n        dp[i] = ((dp[i-zero] if i-zero>=0 else 0) + (dp[i-one] if i-one>=0 else 0)) % mod\\n        if i >= low:\\n            ans = (ans + dp[i]) % mod\\n    return ans\\n```\\n\\n# Complexity\\n##### \\u2022\\tThe time complexity of this approach is O(high), since we need to compute dp[i] for all i from 1 to high\\n##### \\u2022\\tThe space complexity is also O(high), since we need to store the dp array\\n\\n# concise \\n```python []\\ndef countGoodStrings(self,low, high, zero, one):\\n    mod = 10**9 + 7\\n    dp = [1] + [0] * high\\n    for i in range(1, high+1):\\n        dp[i] = (dp[i-zero] + dp[i-one]) % mod\\n    return sum(dp[low:high+1]) % mod\\n```\\n# memo\\n```java\\npublic int countGoodStrings(int low, int high, int zero, int one) {\\n    int dp[] = new int[high+1],ans=0,mod = (int)1e9+7;\\n    Arrays.fill(dp,-1);\\n    dp[0]=1;\\n    for(int i=low;i<=high;i++){\\n        ans+=rec(i,zero,one,mod,dp);\\n        ans%=mod;\\n    } return ans;\\n}\\nint rec(int ind,int zero,int one,int mod,int dp[]){\\n    if(dp[ind]!=-1) return dp[ind];\\n    int cnt=0;\\n    if(ind>=zero) cnt+=rec(ind-zero,zero,one,mod,dp);\\n    if(ind>=one) cnt+=rec(ind-one,zero,one,mod,dp);\\n    return dp[ind]=(cnt%mod);\\n}\\n```\\n\\n# recursive \\n\\n```java \\nint countGoodStrings(int low, int high, int zero, int one) {\\n    int mod = (int)1e9+7,ans = 0;\\n    for(int i=low;i<=high;i++){\\n        ans += rec(i, zero, one, mod);\\n        ans %= mod;\\n    } return ans;\\n}\\nint rec(int ind, int zero, int one, int mod){\\n    if(ind == 0) return 1;\\n    int cnt = 0;\\n    if(ind >= zero) cnt += rec(ind-zero, zero, one, mod);\\n    if(ind >= one) cnt += rec(ind-one, zero, one, mod);\\n    return cnt % mod;\\n}\\n```\\nNote: TLE for larger inputs\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```java []\\npublic int countGoodStrings(int low, int high, int zero, int one) {\\n    int dp[] = new int[high+1],ans = 0,mod = 1000000007;\\n    dp[0] = 1;\\n    for(int i=1;i<=high;i++){\\n        dp[i] = ((i-zero>=0 ? dp[i-zero] : 0) + (i-one>=0 ? dp[i-one] : 0))%mod;\\n        if(i>=low) ans = (ans + dp[i])%mod;\\n    } return ans;\\n}  \\n```\n```c++ []\\nint countGoodStrings(int, int high, int zero, int one) {\\n    vector<int> dp(high+1);\\n    int ans = 0, mod = 1e9+7;\\n    dp[0] = 1;\\n    for(int i=1;i<=high;i++){\\n        dp[i] = ((i-zero>=0 ? dp[i-zero] : 0) + (i-one>=0 ? dp[i-one] : 0))%mod;\\n        if(i>=low) ans = (ans + dp[i])%mod;\\n    } \\n    return ans;\\n}\\n```\n```python []\\ndef countGoodStrings(low: int, high: int, zero: int, one: int) -> int:\\n    dp = [0] * (high+1)\\n    ans, mod = 0, 10**9+7\\n    dp[0] = 1\\n    for i in range(1, high+1):\\n        dp[i] = ((dp[i-zero] if i-zero>=0 else 0) + (dp[i-one] if i-one>=0 else 0)) % mod\\n        if i >= low:\\n            ans = (ans + dp[i]) % mod\\n    return ans\\n```\n```python []\\ndef countGoodStrings(self,low, high, zero, one):\\n    mod = 10**9 + 7\\n    dp = [1] + [0] * high\\n    for i in range(1, high+1):\\n        dp[i] = (dp[i-zero] + dp[i-one]) % mod\\n    return sum(dp[low:high+1]) % mod\\n```\n```java\\npublic int countGoodStrings(int low, int high, int zero, int one) {\\n    int dp[] = new int[high+1],ans=0,mod = (int)1e9+7;\\n    Arrays.fill(dp,-1);\\n    dp[0]=1;\\n    for(int i=low;i<=high;i++){\\n        ans+=rec(i,zero,one,mod,dp);\\n        ans%=mod;\\n    } return ans;\\n}\\nint rec(int ind,int zero,int one,int mod,int dp[]){\\n    if(dp[ind]!=-1) return dp[ind];\\n    int cnt=0;\\n    if(ind>=zero) cnt+=rec(ind-zero,zero,one,mod,dp);\\n    if(ind>=one) cnt+=rec(ind-one,zero,one,mod,dp);\\n    return dp[ind]=(cnt%mod);\\n}\\n```\n```java \\nint countGoodStrings(int low, int high, int zero, int one) {\\n    int mod = (int)1e9+7,ans = 0;\\n    for(int i=low;i<=high;i++){\\n        ans += rec(i, zero, one, mod);\\n        ans %= mod;\\n    } return ans;\\n}\\nint rec(int ind, int zero, int one, int mod){\\n    if(ind == 0) return 1;\\n    int cnt = 0;\\n    if(ind >= zero) cnt += rec(ind-zero, zero, one, mod);\\n    if(ind >= one) cnt += rec(ind-one, zero, one, mod);\\n    return cnt % mod;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2809573,
                "title": "c-solution-using-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100005];\\n    int mod=1e9+7;\\n    int find(int n,int index,int z,int o)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index]%mod;\\n        }\\n        long long ans1=0;\\n        if(index+z<=n)\\n        ans1=1+find(n,index+z,z,o);\\n        long long ans2=0;\\n        if(index+o<=n)\\n        ans2=1+find(n,index+o,z,o);\\n        return dp[index]=(ans1+ans2)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        long long ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        long long first=find(low-1,0,zero,one);\\n        memset(dp,-1,sizeof(dp));\\n        long long second=find(high,0,zero,one);\\n        return (-first+second+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005];\\n    int mod=1e9+7;\\n    int find(int n,int index,int z,int o)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index]%mod;\\n        }\\n        long long ans1=0;\\n        if(index+z<=n)\\n        ans1=1+find(n,index+z,z,o);\\n        long long ans2=0;\\n        if(index+o<=n)\\n        ans2=1+find(n,index+o,z,o);\\n        return dp[index]=(ans1+ans2)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        long long ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        long long first=find(low-1,0,zero,one);\\n        memset(dp,-1,sizeof(dp));\\n        long long second=find(high,0,zero,one);\\n        return (-first+second+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807218,
                "title": "top-down-dp-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    static long [] dp;\\n    static int mod = (int)(1e9+7);\\n    static int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = new long [(int)(1e6)];\\n        Arrays.fill(dp, -1);\\n        return (int)getResult(low, high, zero, one, 0);\\n    }\\n    static long getResult(int low, int high, int x, int y, int cur){\\n        if(cur > high) return 0;\\n        if(dp[cur] != -1) return dp[cur];\\n        long ans = (cur >= low && cur <= high? 1:0) + getResult(low, high, x, y, cur + x) + getResult(low, high, x, y, cur + y);\\n        return dp[cur] = ans % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static long [] dp;\\n    static int mod = (int)(1e9+7);\\n    static int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = new long [(int)(1e6)];\\n        Arrays.fill(dp, -1);\\n        return (int)getResult(low, high, zero, one, 0);\\n    }\\n    static long getResult(int low, int high, int x, int y, int cur){\\n        if(cur > high) return 0;\\n        if(dp[cur] != -1) return dp[cur];\\n        long ans = (cur >= low && cur <= high? 1:0) + getResult(low, high, x, y, cur + x) + getResult(low, high, x, y, cur + y);\\n        return dp[cur] = ans % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807183,
                "title": "easy-short-efficient-clean-code",
                "content": "Strings, 0s, 1s, none of them matter. What matters:\\n* The length of the string at a given point in time.\\n* How much u add (2 options FIXED!)\\n```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nvi(ll)dp;\\nll func(ll cur, const int&z, const int&o, const int&l, const int&h){\\n    if(cur>h){\\n        return 0; // nothing to proceed for\\n    }\\n    ll&ans=dp[cur];\\n    if(ans==-1){\\n        ans=/* if in range */    (cur>=l)+    /* add 0s */    func(cur+z, z, o, l, h)+    /* add 1s */    func(cur+o, z, o, l, h);\\n    }\\n    return ans%mod;\\n}\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        dp.assign(high+1, -1);\\n        return func(0, zero, one, low, high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\nvi(ll)dp;\\nll func(ll cur, const int&z, const int&o, const int&l, const int&h){\\n    if(cur>h){\\n        return 0; // nothing to proceed for\\n    }\\n    ll&ans=dp[cur];\\n    if(ans==-1){\\n        ans=/* if in range */    (cur>=l)+    /* add 0s */    func(cur+z, z, o, l, h)+    /* add 1s */    func(cur+o, z, o, l, h);\\n    }\\n    return ans%mod;\\n}\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        dp.assign(high+1, -1);\\n        return func(0, zero, one, low, high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520069,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp)\\n    {\\n        if(target==0)return 1;\\n        if(target<0)return 0;\\n        if(dp[target]!=-1)return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp)\\n    {\\n        if(target==0)return 1;\\n        if(target<0)return 0;\\n        if(dp[target]!=-1)return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520056,
                "title": "easy-solution-beginner-friendly-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn each step we can either add \"zero\" 0s or \"one\" 1s.\\nSo, eventually two cases can be formed. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will apply recursion here.\\nRecursion will be 2-D.\\nOne condition is adding zero 0s, and other is adding one 1s.\\n\\nRecursive solution: -\\n```\\nclass Solution {\\npublic:\\n    int solve(int size, int low, int high, int zero, int one)\\n    {\\n        //base cases\\n        if(size>high) return 0; //if current size of string becomes greater than high than this string is not valid, so return 0\\n\\n        if(size == high) return 1; //if current size of string becomes equal to high then we found a valid string, so return 1\\n\\n        //recursive cases\\n        int zRec = solve(size+zero, low, high, zero, one); //adding zero 0s in the string\\n\\n        int oRec = solve(size+one, low, high, zero, one); //adding one 1s in the string\\n\\n        if(size>=low) return 1 + zRec + oRec; //if current size of string is between low and high(low inclusive) then count this string as also a valid string, but there can be more valid string other than this one, so call recursion again\\n\\n        return zRec + oRec;//if current size of string is smaller than low then it\\'s not a valid string but call further recursion for finding valid string\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        return solve(0, low, high, zero, one);\\n    }\\n};\\n``` \\nThis recursive solution will then give you a TLE error.\\nAfter getting a TLE apply DP.\\nOnly size is changing at each step so 1D DP will be used here with size as the parameter.  \\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: --> \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int size, int low, int high, int zero, int one, vector<int>& dp)\\n    {\\n        //base cases\\n        if(size>high) return 0;\\n        if(size == high) return 1;\\n\\n        //dp base case\\n        if(dp[size] != -1) return dp[size];\\n\\n        //recursive cases\\n        int zRec = solve(size+zero, low, high, zero, one, dp);\\n        int oRec = solve(size+one, low, high, zero, one, dp);\\n\\n        if(size>=low) return dp[size] = (1 + zRec + oRec)%1000000007;\\n        return dp[size] = (zRec + oRec)%1000000007;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        vector<int> dp(high, -1);\\n        return solve(0, low, high, zero, one, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int size, int low, int high, int zero, int one)\\n    {\\n        //base cases\\n        if(size>high) return 0; //if current size of string becomes greater than high than this string is not valid, so return 0\\n\\n        if(size == high) return 1; //if current size of string becomes equal to high then we found a valid string, so return 1\\n\\n        //recursive cases\\n        int zRec = solve(size+zero, low, high, zero, one); //adding zero 0s in the string\\n\\n        int oRec = solve(size+one, low, high, zero, one); //adding one 1s in the string\\n\\n        if(size>=low) return 1 + zRec + oRec; //if current size of string is between low and high(low inclusive) then count this string as also a valid string, but there can be more valid string other than this one, so call recursion again\\n\\n        return zRec + oRec;//if current size of string is smaller than low then it\\'s not a valid string but call further recursion for finding valid string\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        return solve(0, low, high, zero, one);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int size, int low, int high, int zero, int one, vector<int>& dp)\\n    {\\n        //base cases\\n        if(size>high) return 0;\\n        if(size == high) return 1;\\n\\n        //dp base case\\n        if(dp[size] != -1) return dp[size];\\n\\n        //recursive cases\\n        int zRec = solve(size+zero, low, high, zero, one, dp);\\n        int oRec = solve(size+one, low, high, zero, one, dp);\\n\\n        if(size>=low) return dp[size] = (1 + zRec + oRec)%1000000007;\\n        return dp[size] = (zRec + oRec)%1000000007;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        vector<int> dp(high, -1);\\n        return solve(0, low, high, zero, one, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519932,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1000000007;\\n    int zeros, ones, dp[100005];\\n    int solve(int id) {\\n        if (dp[id] != -1) return dp[id];\\n        int cnt = 0;\\n        if (id - ones >= 0) cnt += solve(id - ones);\\n        if (id - zeros >= 0) cnt += solve(id - zeros);\\n        dp[id] = cnt % mod;\\n        return dp[id];\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        memset(dp, -1, sizeof dp);\\n        dp[0] = 1;\\n        zeros = zero, ones = one;\\n        int ans = 0;\\n        for (int id = low; id <= high; id++) {\\n            ans += solve(id);\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1000000007;\\n    int zeros, ones, dp[100005];\\n    int solve(int id) {\\n        if (dp[id] != -1) return dp[id];\\n        int cnt = 0;\\n        if (id - ones >= 0) cnt += solve(id - ones);\\n        if (id - zeros >= 0) cnt += solve(id - zeros);\\n        dp[id] = cnt % mod;\\n        return dp[id];\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        memset(dp, -1, sizeof dp);\\n        dp[0] = 1;\\n        zeros = zero, ones = one;\\n        int ans = 0;\\n        for (int id = low; id <= high; id++) {\\n            ans += solve(id);\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519291,
                "title": "very-easy-c-soln-recursion-memoisation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem is just like Climbing stairs, we just need to implement some changes and we are good to go.\\n**PLease upVote if it helps.**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//global variables\\nint Zero=0,One=0;\\nint mod = 1000000007;\\n    //this is just like climbing stairs\\n    int solve(int n,vector<int> &dp){\\n        if(n<0)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n] != -1)\\n            return dp[n];\\n        return dp[n] = (solve(n-Zero,dp)%mod+solve(n-One,dp)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        Zero = zero;\\n        One = one;\\n        int ans = 0;\\n        vector<int> dp(high+1,-1);\\n        for(int i=low; i<=high; i++)\\n        {\\n            int sum = solve(i,dp)%mod;\\n            ans = (ans+sum)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//global variables\\nint Zero=0,One=0;\\nint mod = 1000000007;\\n    //this is just like climbing stairs\\n    int solve(int n,vector<int> &dp){\\n        if(n<0)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n] != -1)\\n            return dp[n];\\n        return dp[n] = (solve(n-Zero,dp)%mod+solve(n-One,dp)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        Zero = zero;\\n        One = one;\\n        int ans = 0;\\n        vector<int> dp(high+1,-1);\\n        for(int i=low; i<=high; i++)\\n        {\\n            int sum = solve(i,dp)%mod;\\n            ans = (ans+sum)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518679,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int zero, int one, int low, int high, int mod, vector<int> &dp) {\\n        if(i > high) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int addZero = 0, addOne = 0;\\n        \\n        if(i + zero >= low && i + zero <= high) {\\n            addZero = 1 + dfs(i + zero, zero, one, low, high, mod, dp);\\n        }\\n        else addZero = dfs(i + zero, zero, one, low, high, mod, dp);\\n\\n        if(i + one >= low && i + one <= high) {\\n            addOne = 1 + dfs(i + one, zero, one, low, high, mod, dp);\\n        }\\n        else addOne = dfs(i + one, zero, one, low, high, mod, dp);\\n           \\n        return dp[i] = (addZero + addOne) % mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        return dfs(0, zero, one, low, high, 1e9 + 7, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int zero, int one, int low, int high, int mod, vector<int> &dp) {\\n        if(i > high) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int addZero = 0, addOne = 0;\\n        \\n        if(i + zero >= low && i + zero <= high) {\\n            addZero = 1 + dfs(i + zero, zero, one, low, high, mod, dp);\\n        }\\n        else addZero = dfs(i + zero, zero, one, low, high, mod, dp);\\n\\n        if(i + one >= low && i + one <= high) {\\n            addOne = 1 + dfs(i + one, zero, one, low, high, mod, dp);\\n        }\\n        else addOne = dfs(i + one, zero, one, low, high, mod, dp);\\n           \\n        return dp[i] = (addZero + addOne) % mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        return dfs(0, zero, one, low, high, 1e9 + 7, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518584,
                "title": "easy-recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod  =1000000007;\\n    int[] dp;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = new int[100001];\\n        Arrays.fill(dp,-1);\\n        return solve(0,low,high,zero,one);\\n    }\\n    public int solve(int i,int low, int high, int zero, int one){\\n        if(i>high){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int count =0;\\n        if(i>=low && i<=high){\\n            count=1;\\n        }\\n        int way1 = solve(i+zero,low,high,zero,one)%mod;\\n        int way2 = solve(i+one,low,high,zero,one)%mod;\\n        count+=way1+way2;\\n        return dp[i]=count%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int mod  =1000000007;\\n    int[] dp;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = new int[100001];\\n        Arrays.fill(dp,-1);\\n        return solve(0,low,high,zero,one);\\n    }\\n    public int solve(int i,int low, int high, int zero, int one){\\n        if(i>high){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int count =0;\\n        if(i>=low && i<=high){\\n            count=1;\\n        }\\n        int way1 = solve(i+zero,low,high,zero,one)%mod;\\n        int way2 = solve(i+one,low,high,zero,one)%mod;\\n        count+=way1+way2;\\n        return dp[i]=count%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518525,
                "title": "most-optimised-c-dp-easy-to-understnad",
                "content": "make a dp array of length (high+1) because we store ans for length i.\\ndp[0] = 1 becase if length i = 5 and zero or one any of them is 5 than dp[i] += dp[5-5];\\nin dp array store ans for every length i. for next turn use.\\n\\n# Complexity\\n- Time complexity:\\nO(high)\\n\\n- Space complexity:\\nO(high)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> v(high+1,0);\\n        v[0] = 1;\\n        int mod = 1e9+7;\\n        int sum = 0;\\n        for(int i = 1; i <= high; i++){\\n            if(i>=zero){\\n                v[i] = (v[i]*1LL+v[i-zero])%mod;\\n            }if(i>=one){\\n                v[i] = (v[i]*1LL+v[i-one])%mod;\\n            }\\n            // cout<<v[i]<<\" \";\\n            if(i>=low && i<=high){\\n                sum = (sum*1LL+v[i])%mod;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> v(high+1,0);\\n        v[0] = 1;\\n        int mod = 1e9+7;\\n        int sum = 0;\\n        for(int i = 1; i <= high; i++){\\n            if(i>=zero){\\n                v[i] = (v[i]*1LL+v[i-zero])%mod;\\n            }if(i>=one){\\n                v[i] = (v[i]*1LL+v[i-one])%mod;\\n            }\\n            // cout<<v[i]<<\" \";\\n            if(i>=low && i<=high){\\n                sum = (sum*1LL+v[i])%mod;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3518509,
                "title": "simple-dp-solution-c-100-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUtilizing the DP approach, for the current length, check how we can add zero 0\\'s and one 1\\'s\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we need to loop over 1 to high\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - aas we use DP array\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int mod = 1000000007;\\n\\n        for (int i = 1; i <= high; i++)\\n        {\\n            if (i - zero >= 0)\\n            {\\n                dp[i] += dp[i - zero];\\n            }\\n\\n            if (i - one >= 0)\\n            {\\n                dp[i] += dp[i - one];\\n            }\\n\\n            dp[i] %= mod;\\n        }\\n\\n        int result = 0;\\n        for (int i = low; i <= high; i++)\\n        {\\n            result = (result + dp[i]) % mod;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int mod = 1000000007;\\n\\n        for (int i = 1; i <= high; i++)\\n        {\\n            if (i - zero >= 0)\\n            {\\n                dp[i] += dp[i - zero];\\n            }\\n\\n            if (i - one >= 0)\\n            {\\n                dp[i] += dp[i - one];\\n            }\\n\\n            dp[i] %= mod;\\n        }\\n\\n        int result = 0;\\n        for (int i = low; i <= high; i++)\\n        {\\n            result = (result + dp[i]) % mod;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807344,
                "title": "dp-memoization-tabulation-c",
                "content": "The string doesn\\'t matter, we just have to maintain the sum which is lenght of the string. \\n\\n**Memoization**\\n```\\nclass Solution {\\nprivate:\\n    int solve (int len, int low, int high, int zero, int one, vector<int> &dp) {\\n        if (len > high) {\\n            return 0;\\n        }\\n        \\n        if (dp[len] != -1) {\\n            return dp[len];\\n        }\\n        \\n        int left = solve (len + zero, low, high, zero, one, dp);\\n        int right = solve (len + one, low, high, zero, one, dp);\\n        \\n        return dp[len] = (left + right + (len >= low)) % int(1e9 + 7);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        return solve(0, low, high, zero, one, dp);\\n    }\\n};\\n```\\n\\n**Tabulation**\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        \\n        for (int i = 0; i <= high; i++) {\\n            dp[i] = 1;\\n        }\\n        \\n        for (int i = high; i >= 0; i--) {\\n            int left = i + zero <= high ? dp[i + zero] : 0;\\n            int right = i + one <= high ? dp[i + one] : 0;\\n            \\n            dp[i] = (left + right + (i >= low)) % int(1e9 + 7);\\n        }\\n                \\n        return dp[0];\\n    }\\n};\\n```\\n\\nUpvote if you found it helpful :)",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve (int len, int low, int high, int zero, int one, vector<int> &dp) {\\n        if (len > high) {\\n            return 0;\\n        }\\n        \\n        if (dp[len] != -1) {\\n            return dp[len];\\n        }\\n        \\n        int left = solve (len + zero, low, high, zero, one, dp);\\n        int right = solve (len + one, low, high, zero, one, dp);\\n        \\n        return dp[len] = (left + right + (len >= low)) % int(1e9 + 7);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        return solve(0, low, high, zero, one, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        \\n        for (int i = 0; i <= high; i++) {\\n            dp[i] = 1;\\n        }\\n        \\n        for (int i = high; i >= 0; i--) {\\n            int left = i + zero <= high ? dp[i + zero] : 0;\\n            int right = i + one <= high ? dp[i + one] : 0;\\n            \\n            dp[i] = (left + right + (i >= low)) % int(1e9 + 7);\\n        }\\n                \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807194,
                "title": "java-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mod = 1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        int ans=0;\\n        Arrays.fill(dp,-1);\\n        for(int i=low;i<=high;i++) {\\n            ans = (ans + helper(i,zero,one,dp))%mod;\\n            System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n    public int helper(int n, int zero, int one, int[] dp){\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        // System.out.println(dp[n]);\\n        return dp[n] = (helper(n-zero,zero,one,dp) + helper(n-one,zero,one,dp))%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mod = 1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        int ans=0;\\n        Arrays.fill(dp,-1);\\n        for(int i=low;i<=high;i++) {\\n            ans = (ans + helper(i,zero,one,dp))%mod;\\n            System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n    public int helper(int n, int zero, int one, int[] dp){\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        // System.out.println(dp[n]);\\n        return dp[n] = (helper(n-zero,zero,one,dp) + helper(n-one,zero,one,dp))%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807144,
                "title": "python-dp-iterative-easy-to-read",
                "content": "\\n\\t\\tdef countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tdp = [0]*(high+1)  # 0...high\\n\\t\\t\\tdp[0] = 1\\n\\t\\t\\tfor i in range(high):\\n\\t\\t\\t\\tif i+zero <= high :\\n\\t\\t\\t\\t\\tdp[i+zero] += dp[i]\\n\\t\\t\\t\\tif i+one <= high :\\n\\t\\t\\t\\t\\tdp[i+one] += dp[i]\\n\\t\\t\\treturn sum(dp[low:high+1])%mod\\n## Another variation\\n\\t\\t\\t\\n\\t\\tdef countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tdp = [0]*(high+1)  # 0...high\\n\\t\\t\\tdp[0] = 1\\n\\t\\t\\tfor i in range(1,high+1):\\n\\t\\t\\t\\tif i-zero >= 0 :\\n\\t\\t\\t\\t\\tdp[i] += dp[i-zero]\\n\\t\\t\\t\\tif i-one >= 0:\\n\\t\\t\\t\\t\\tdp[i] += dp[i-one]\\n\\t\\t\\treturn sum(dp[low:high+1])%mod",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n\\t\\tdef countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tdp = [0]*(high+1)  # 0...high\\n\\t\\t\\tdp[0] = 1\\n\\t\\t\\tfor i in range(high):\\n\\t\\t\\t\\tif i+zero <= high :\\n\\t\\t\\t\\t\\tdp[i+zero] += dp[i]\\n\\t\\t\\t\\tif i+one <= high :\\n\\t\\t\\t\\t\\tdp[i+one] += dp[i]\\n\\t\\t\\treturn sum(dp[low:high+1])%mod\\n## Another variation\\n\\t\\t\\t\\n\\t\\tdef countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tdp = [0]*(high+1)  # 0...high\\n\\t\\t\\tdp[0] = 1\\n\\t\\t\\tfor i in range(1,high+1):\\n\\t\\t\\t\\tif i-zero >= 0 :\\n\\t\\t\\t\\t\\tdp[i] += dp[i-zero]\\n\\t\\t\\t\\tif i-one >= 0:\\n\\t\\t\\t\\t\\tdp[i] += dp[i-one]\\n\\t\\t\\treturn sum(dp[low:high+1])%mod",
                "codeTag": "Python3"
            },
            {
                "id": 3521187,
                "title": "python-shortest-1-liner-recursive-dp-functional-programming",
                "content": "# Approach\\n1. Say there is a function `f`, which returns the number of good strings possible with lengths between `low (l)` and `high (h)`, given that the string is already of length `n`.\\n    i.e `def f(n: int) -> int: ...`\\n\\n2. In ideal case, recursively try both options of appending `zero` number of `0`s or `one` number of `1`s to the string, and `add` the results.\\n\\n\\n3. There can only be 3 possiblities, so function `f` would look:\\n    Note: Add `@cache` to memoize the results.\\n    ```python\\n    @cache\\n    def f(n: int) -> int:\\n        if n > h: return 0\\n        if n < l: return f(n + zero) + f(n + one)\\n        if l <= n <= h: return 1 + f(n + zero) + f(n + one)\\n    ```\\n\\n4. These 3 possibilities can be combined into one statement as:\\n    ```python\\n    @cache\\n    def f(n: int) -> int:\\n        return n <= h and (n >= l) + f(n + zero) + f(n + one)\\n    ```\\n\\n5. To make it fun, the entire 3 line can be reduced to a 1-liner as shown in the final solution below.\\n\\n# Complexity\\n- Time complexity: $$O(h)$$\\n\\n- Space complexity: $$O(h)$$\\n\\nwhere, `h = high`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def countGoodStrings(self, l: int, h: int, zero: int, one: int) -> int:\\n        return (f := cache(lambda n: n <= h and ((n >= l) + f(n + zero) + f(n + one)) % 1_000_000_007))(0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n    @cache\\n    def f(n: int) -> int:\\n        if n > h: return 0\\n        if n < l: return f(n + zero) + f(n + one)\\n        if l <= n <= h: return 1 + f(n + zero) + f(n + one)\\n    ```\n```python\\n    @cache\\n    def f(n: int) -> int:\\n        return n <= h and (n >= l) + f(n + zero) + f(n + one)\\n    ```\n```python\\nclass Solution:\\n    def countGoodStrings(self, l: int, h: int, zero: int, one: int) -> int:\\n        return (f := cache(lambda n: n <= h and ((n >= l) + f(n + zero) + f(n + one)) % 1_000_000_007))(0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520689,
                "title": "c-accepted-o-n-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n         long mod = 1000000007;\\n         long long ans=0;\\n         vector<long long>dp(high+2);\\n         dp[0]=1;\\n         for(int i=1;i<=high+1;i++){\\n            if((i-zero)>=0){\\n             dp[i]+=dp[i-zero];\\n            }\\n            if((i-one)>=0){\\n            dp[i]+=dp[i-one];\\n            }\\n            dp[i]%=mod;\\n         }\\n\\n\\n     \\n         for(int i=low;i<=high;i++){\\n            ans+=dp[i];\\n            ans%=mod;\\n         }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n         long mod = 1000000007;\\n         long long ans=0;\\n         vector<long long>dp(high+2);\\n         dp[0]=1;\\n         for(int i=1;i<=high+1;i++){\\n            if((i-zero)>=0){\\n             dp[i]+=dp[i-zero];\\n            }\\n            if((i-one)>=0){\\n            dp[i]+=dp[i-one];\\n            }\\n            dp[i]%=mod;\\n         }\\n\\n\\n     \\n         for(int i=low;i<=high;i++){\\n            ans+=dp[i];\\n            ans%=mod;\\n         }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519016,
                "title": "python-elegant-short-top-down-dp-memoization",
                "content": "# Complexity\\n\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    MOD = 1_000_000_007\\n\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        @cache\\n        def dp(length: int) -> int:\\n            if length > high:\\n                return 0\\n            return (\\n                    int(low <= length) +\\n                    dp(length + zero) +\\n                    dp(length + one)\\n            ) % self.MOD\\n\\n        return dp(0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    MOD = 1_000_000_007\\n\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        @cache\\n        def dp(length: int) -> int:\\n            if length > high:\\n                return 0\\n            return (\\n                    int(low <= length) +\\n                    dp(length + zero) +\\n                    dp(length + one)\\n            ) % self.MOD\\n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519004,
                "title": "easy-c-solution-recurstive-tle-memoized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// recursion-tle\\n\\n// class Solution {\\n// public:\\n\\n//   int lenGoodString(int len, int zero, int one){\\n//       if(len==0)\\n// return 1;\\n// if(len<0)\\n// return 0;\\n\\n// int sum = lenGoodString (len-one, zero, one) + lenGoodString (len-zero, zero, one);\\n// return sum;\\n//   }\\n\\n//     int countGoodStrings(int low, int high, int zero, int one) {\\n//         int res=0;\\n//         for(int i=low;i<=high;i++)\\n//         {\\n//              res+= lenGoodString(i,zero,one);\\n//         }\\n//     return res ;\\n// }\\n// };\\n\\nclass Solution\\n{\\npublic:\\n    const int MOD = 1000000007;\\n    int dp[1000000];\\n    int lenGoodString(int len, int zero, int one)\\n    {\\n        if (len == 0)\\n            return 1;\\n        if (len < 0)\\n            return 0;\\n\\n        if (dp[len] != -1)\\n            return dp[len];\\n\\n        int sum = (lenGoodString(len - one, zero, one) % MOD + lenGoodString(len - zero, zero, one) % MOD) % MOD;\\n        return dp[len] = sum;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        long long int res = 0;\\n        for (int i = low; i <= high; i++)\\n        {\\n            res += lenGoodString(i, zero, one);\\n        }\\n        return res % MOD;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// recursion-tle\\n\\n// class Solution {\\n// public:\\n\\n//   int lenGoodString(int len, int zero, int one){\\n//       if(len==0)\\n// return 1;\\n// if(len<0)\\n// return 0;\\n\\n// int sum = lenGoodString (len-one, zero, one) + lenGoodString (len-zero, zero, one);\\n// return sum;\\n//   }\\n\\n//     int countGoodStrings(int low, int high, int zero, int one) {\\n//         int res=0;\\n//         for(int i=low;i<=high;i++)\\n//         {\\n//              res+= lenGoodString(i,zero,one);\\n//         }\\n//     return res ;\\n// }\\n// };\\n\\nclass Solution\\n{\\npublic:\\n    const int MOD = 1000000007;\\n    int dp[1000000];\\n    int lenGoodString(int len, int zero, int one)\\n    {\\n        if (len == 0)\\n            return 1;\\n        if (len < 0)\\n            return 0;\\n\\n        if (dp[len] != -1)\\n            return dp[len];\\n\\n        int sum = (lenGoodString(len - one, zero, one) % MOD + lenGoodString(len - zero, zero, one) % MOD) % MOD;\\n        return dp[len] = sum;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        long long int res = 0;\\n        for (int i = low; i <= high; i++)\\n        {\\n            res += lenGoodString(i, zero, one);\\n        }\\n        return res % MOD;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518694,
                "title": "python3-easiest-solution-with-images-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Recursion and Memoization**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- simple and clean approach, **add one keep zero still** and **add zero keeping one still**\\n- we start from 0==Zeroes, 0==ones.\\n- now add one by one 1 and 0.\\n- if combined length is in range of low and high, then again add 1 and 0 and check.\\n- if current length is in range then make sure to add one to answer.\\n- return answer with mod\\n\\n![image.png](https://assets.leetcode.com/users/images/6427cbae-d9d2-4b21-8b4f-76589675e69a_1683961983.6186538.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/13a8f645-9d50-405c-b4ff-0a7e0df89e3c_1683961943.3798113.png)\\n\\n# Complexity\\n- Time complexity: O(High)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*High)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, z: int, o: int) -> int:\\n# we cannot use 2d array as we will reach out of time so use hashtable\\n        dp = dict()\\n        mod = 10**9 + 7\\n        def f(one=0, zero=0):\\n#if legth is not in range return 0, and don\\'t compute further\\n            if one+zero > high: return 0\\n# now if in range then do operations.\\n            elif (one+zero) <= high:\\n# if we already have computed this sub-problem then return directly don\\'t waste time\\n                if zero+one in dp: return dp[zero+one]\\n                else:\\n# if not then keep zero still and add one\\n                    One_Add = f(one + o, zero)\\n# keep one still and add zero\\n                    Zero_Add = f(one, zero + z)\\n# if current string is good then add \\'1\\' in answer for this.\\n                    ADD_IF_GOOD = 1 if (one+zero) >= low else 0\\n# memorize the answer and return it, so next time it is fast to compute\\n                    dp[zero+one] = One_Add + Zero_Add + ADD_IF_GOOD\\n                    return dp[zero+one] % mod # do mod if ans is big\\n        return f()\\n```\\n# Please Upvote and comment below ( \\u0361\\u2688\\u202F\\u035C\\u0296 \\u0361\\u2688)\\uD83D\\uDC49",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, z: int, o: int) -> int:\\n# we cannot use 2d array as we will reach out of time so use hashtable\\n        dp = dict()\\n        mod = 10**9 + 7\\n        def f(one=0, zero=0):\\n#if legth is not in range return 0, and don\\'t compute further\\n            if one+zero > high: return 0\\n# now if in range then do operations.\\n            elif (one+zero) <= high:\\n# if we already have computed this sub-problem then return directly don\\'t waste time\\n                if zero+one in dp: return dp[zero+one]\\n                else:\\n# if not then keep zero still and add one\\n                    One_Add = f(one + o, zero)\\n# keep one still and add zero\\n                    Zero_Add = f(one, zero + z)\\n# if current string is good then add \\'1\\' in answer for this.\\n                    ADD_IF_GOOD = 1 if (one+zero) >= low else 0\\n# memorize the answer and return it, so next time it is fast to compute\\n                    dp[zero+one] = One_Add + Zero_Add + ADD_IF_GOOD\\n                    return dp[zero+one] % mod # do mod if ans is big\\n        return f()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518493,
                "title": "java-solution-for-count-ways-to-build-good-strings-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution builds on the observation that the number of good strings of a specific length depends on the number of good strings of smaller lengths. By iteratively calculating the number of good strings for each length, we can build up the solution for larger lengths.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array dp of size high + 1 to store the number of good strings for each length.\\n2. Set dp[0] to 1 since an empty string is considered a good string.\\n3. Iterate from length 1 to high:\\n- Check if the current length is greater than or equal to the required number of zeros (zero) and add the number of good strings with length end - zero to the current count.\\n- Check if the current length is greater than or equal to the required number of ones (one) and add the number of good strings with length end - one to the current count.\\n- Take the modulo mod of the count to keep the values within the specified range.\\n4. Sum up the number of good strings within the range from low to high and return the result\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(high), as it iterates from 1 to high to calculate the number of good strings for each length.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(high) as well, as it uses an array dp to store the number of good strings for each length.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n          int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int mod = 1000000007;\\n\\n        for (int end = 1; end <= high; ++end) {\\n            if (end >= zero) {\\n                dp[end] += dp[end - zero];\\n                dp[end] %= mod;\\n            }\\n            if (end >= one) {\\n                dp[end] += dp[end - one];\\n                dp[end] %= mod;\\n            }\\n        }\\n\\n        int answer = 0;\\n        for (int i = low; i <= high; ++i) {\\n            answer += dp[i];\\n            answer %= mod;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n          int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int mod = 1000000007;\\n\\n        for (int end = 1; end <= high; ++end) {\\n            if (end >= zero) {\\n                dp[end] += dp[end - zero];\\n                dp[end] %= mod;\\n            }\\n            if (end >= one) {\\n                dp[end] += dp[end - one];\\n                dp[end] %= mod;\\n            }\\n        }\\n\\n        int answer = 0;\\n        for (int i = low; i <= high; ++i) {\\n            answer += dp[i];\\n            answer %= mod;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518235,
                "title": "c-dp-memoized",
                "content": "### Memoization\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        return solve(0, low, high, zero, one, dp);\\n    }\\n\\n    int solve(int size, int low, int high, int zero, int one, vector<int>& dp) {\\n        if(size > high)\\n            return 0;\\n\\n        if(dp[size] != -1)\\n            return dp[size];\\n\\n        int pickZero = solve(size + zero, low, high, zero, one, dp);\\n        int pickOne = solve(size + one, low, high, zero, one, dp);\\n\\n        return dp[size] = ((size >= low) + pickOne + pickZero) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        return solve(0, low, high, zero, one, dp);\\n    }\\n\\n    int solve(int size, int low, int high, int zero, int one, vector<int>& dp) {\\n        if(size > high)\\n            return 0;\\n\\n        if(dp[size] != -1)\\n            return dp[size];\\n\\n        int pickZero = solve(size + zero, low, high, zero, one, dp);\\n        int pickOne = solve(size + one, low, high, zero, one, dp);\\n\\n        return dp[size] = ((size >= low) + pickOne + pickZero) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518014,
                "title": "easy-recursive-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    vector<long long> dp;\\n    long long good(int n, int x0, int x1){\\n        if ( dp[n]!=-1 ) return dp[n];\\n        long long ans;\\n        if (n < x0) {\\n            ans=1;\\n        }\\n        if ( n >= x0){\\n            ans+=good(n-x0, x0, x1);\\n        }\\n        if ( n >= x1){\\n            ans+=good(n-x1, x0, x1);\\n        }\\n        ans%=mod;\\n        dp[n]=ans;\\n        return ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        if (zero > one) swap(zero, one);\\n        dp.assign(high+1, -1);\\n        return (good(high, zero, one)-good(low-1, zero, one)+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    vector<long long> dp;\\n    long long good(int n, int x0, int x1){\\n        if ( dp[n]!=-1 ) return dp[n];\\n        long long ans;\\n        if (n < x0) {\\n            ans=1;\\n        }\\n        if ( n >= x0){\\n            ans+=good(n-x0, x0, x1);\\n        }\\n        if ( n >= x1){\\n            ans+=good(n-x1, x0, x1);\\n        }\\n        ans%=mod;\\n        dp[n]=ans;\\n        return ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        if (zero > one) swap(zero, one);\\n        dp.assign(high+1, -1);\\n        return (good(high, zero, one)-good(low-1, zero, one)+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517849,
                "title": "c-dp-memoization",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ (`n` == `high`)\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    private const int Mod = 1_000_000_000 + 7;\\n\\n    public int CountGoodStrings(int low, int high, int zero, int one)\\n    {\\n        var dp = new int[high + 1];\\n        dp[0] = 1;\\n\\n        var result = 0;\\n\\n        for (var i = 1; i <= high; ++i)\\n        {\\n            if (i >= zero)\\n            {\\n                dp[i] = (dp[i] + dp[i - zero]) % Mod;\\n            }\\n\\n            if (i >= one)\\n            {\\n                dp[i] = (dp[i] + dp[i - one]) % Mod;\\n            }\\n\\n            if (i >= low)\\n            {\\n                result = (result + dp[i]) % Mod;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private const int Mod = 1_000_000_000 + 7;\\n\\n    public int CountGoodStrings(int low, int high, int zero, int one)\\n    {\\n        var dp = new int[high + 1];\\n        dp[0] = 1;\\n\\n        var result = 0;\\n\\n        for (var i = 1; i <= high; ++i)\\n        {\\n            if (i >= zero)\\n            {\\n                dp[i] = (dp[i] + dp[i - zero]) % Mod;\\n            }\\n\\n            if (i >= one)\\n            {\\n                dp[i] = (dp[i] + dp[i - one]) % Mod;\\n            }\\n\\n            if (i >= low)\\n            {\\n                result = (result + dp[i]) % Mod;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517802,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Memoisation\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    long fun(int n,int zero,int one,int low,int high,vector<long>& dp)\\n    {\\n        if(n>high) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        long ans=(fun(n+zero,zero,one,low,high,dp)%mod+fun(n+one,zero,one,low,high,dp)%mod)%mod;\\n        if(n>=low&&n<=high)\\n        {\\n            ans=(ans+1)%mod;\\n        }\\n        return dp[n]=ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long> dp(high+1,-1);\\n        return (int)fun(0,zero,one,low,high,dp);\\n    }\\n};\\n```\\n```\\n//Tabulation\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long> dp(high+zero+one+1,0);\\n        for(int i=high;i>=0;i--)\\n        {\\n            long ans=(dp[i+zero]%mod+dp[i+one]%mod)%mod;\\n            if(i>=low&&i<=high)\\n            {\\n                ans=(ans+1)%mod;\\n            }\\n            dp[i]=ans;\\n        }\\n        return (int)dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Memoisation\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    long fun(int n,int zero,int one,int low,int high,vector<long>& dp)\\n    {\\n        if(n>high) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        long ans=(fun(n+zero,zero,one,low,high,dp)%mod+fun(n+one,zero,one,low,high,dp)%mod)%mod;\\n        if(n>=low&&n<=high)\\n        {\\n            ans=(ans+1)%mod;\\n        }\\n        return dp[n]=ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long> dp(high+1,-1);\\n        return (int)fun(0,zero,one,low,high,dp);\\n    }\\n};\\n```\n```\\n//Tabulation\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long> dp(high+zero+one+1,0);\\n        for(int i=high;i>=0;i--)\\n        {\\n            long ans=(dp[i+zero]%mod+dp[i+one]%mod)%mod;\\n            if(i>=low&&i<=high)\\n            {\\n                ans=(ans+1)%mod;\\n            }\\n            dp[i]=ans;\\n        }\\n        return (int)dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517782,
                "title": "c-easy-implementation",
                "content": "# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define mod 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll> ret(200005);\\n        set<int> s ;\\n        for(int i = 0; i < 10; i++){\\n            s.insert(i);\\n        }\\n        ret[0] = 1;\\n        for(int i = 0; i < 100005; i++){\\n            ret[i + zero] %= mod;\\n            ret[i + zero] += ret[i];\\n            ret[i + one] %= mod;\\n            ret[i + one] += ret[i];\\n        }\\n        ll res = 0;\\n        for(int i = low; i <= high; i++){\\n            res = (res + ret[i]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define mod 1000000007\\n#define ll long long\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll> ret(200005);\\n        set<int> s ;\\n        for(int i = 0; i < 10; i++){\\n            s.insert(i);\\n        }\\n        ret[0] = 1;\\n        for(int i = 0; i < 100005; i++){\\n            ret[i + zero] %= mod;\\n            ret[i + zero] += ret[i];\\n            ret[i + one] %= mod;\\n            ret[i + one] += ret[i];\\n        }\\n        ll res = 0;\\n        for(int i = low; i <= high; i++){\\n            res = (res + ret[i]) % mod;\\n        }\\n        return res;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3512855,
                "title": "ruby-solution-with-memoization-and-explanation-100-100",
                "content": "# Intuition\\nUse memoization to find the possibilities for each length, then sum the lengths from low to high.\\n\\n# Approach\\n1. Create class variables for helper function\\n2. Find the sum of the number of good strings for each length low to high using a helper function\\n    Helper function:\\n    a. Handle base cases\\n    b. Return memoized value if it exists\\n    c. Find the number of possibilities for the two shorter strings, by removing one \"1\"s or zero \"0\"s.  (Note that this still works if one and zero are the same -- the strings are distinct even if the ending is the same.)\\n    d. Add these together, do mod 10**9+7, memoize, and return.  (We want to use modulo here to prevent each value from growing too much.)\\n3. Return the sum mod 10**9+7\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef count_good_strings(low, high, zero, one)\\n    @memo = {}\\n    @zero, @one = zero, one\\n    @mod = 1000000007\\n\\n    total = 0\\n    (low..high).each { |i| total += good_strings(i) }\\n    total % @mod\\nend\\n\\ndef good_strings(i)\\n    return 0 if i < 0\\n    return 1 if i == 0\\n    return @memo[i] if @memo[i]\\n\\n    @memo[i] = (good_strings(i - @zero) + good_strings(i - @one)) % @mod\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef count_good_strings(low, high, zero, one)\\n    @memo = {}\\n    @zero, @one = zero, one\\n    @mod = 1000000007\\n\\n    total = 0\\n    (low..high).each { |i| total += good_strings(i) }\\n    total % @mod\\nend\\n\\ndef good_strings(i)\\n    return 0 if i < 0\\n    return 1 if i == 0\\n    return @memo[i] if @memo[i]\\n\\n    @memo[i] = (good_strings(i - @zero) + good_strings(i - @one)) % @mod\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2837056,
                "title": "start-empty",
                "content": "# Intuition\\nBy calculating backwards from `0` empty string to `high`. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo compute all possible permutations that we can create using the operations we start backwards knowing empty string is possible only `1` way and then adding `one` and `zero` the lenghs.\\nThen we iterat from `low` to `high` to sum all the permutations.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(high)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(high)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, 0);\\n        dp[0] = 1;\\n        \\n        for(int i = 0; i < high; i++) {\\n            if(i + one <= high)\\n                dp[i + one] = (dp[i + one] + dp[i]) % mod;\\n            \\n            if(i + zero <= high)\\n                dp[i + zero] = (dp[i + zero] + dp[i]) % mod;\\n        }        \\n        \\n        int sum = 0;\\n        for(int i = low; i <= high; i++)\\n            sum = (sum + dp[i]) % mod;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, 0);\\n        dp[0] = 1;\\n        \\n        for(int i = 0; i < high; i++) {\\n            if(i + one <= high)\\n                dp[i + one] = (dp[i + one] + dp[i]) % mod;\\n            \\n            if(i + zero <= high)\\n                dp[i + zero] = (dp[i + zero] + dp[i]) % mod;\\n        }        \\n        \\n        int sum = 0;\\n        for(int i = low; i <= high; i++)\\n            sum = (sum + dp[i]) % mod;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807680,
                "title": "java-o-high-dp-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll use DP to solve this problem.\\n- To get **good strings** of length ```n```, we\\'ll check the for **good strings** of length ```n-one``` and ```n-zero```.\\n- ```dp[i] = dp[i-one] + dp[i-zero]``` This formula will help us out to get the solution for required length of good strings.\\n- ```dp[i] = (dp[i-one] + dp[i-zero]) % mod```. ```mod``` modification in the formula is to maintain our solution within constraint bounds.\\n\\n# Complexity\\n- Time complexity: **O(high)** -> *We traverse the array ```high``` number of times to get solution.*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(high)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution... :)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        final int mod = 1000000007;\\n        int[] dp = new int[high+1];\\n        //to handle base case\\n        dp[0] = 1;\\n        for(int i = 1; i < dp.length; i++) {\\n            if(i-one >= 0) dp[i] = (dp[i]+dp[i-one]) % mod;\\n            if(i-zero >= 0) dp[i] = (dp[i]+dp[i-zero]) % mod;\\n        }\\n        int ans = 0;\\n        for(int i = low; i <= high; i++) ans = (ans+dp[i]) % mod;\\n        return ans%mod;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```n```\n```n-one```\n```n-zero```\n```dp[i] = dp[i-one] + dp[i-zero]```\n```dp[i] = (dp[i-one] + dp[i-zero]) % mod```\n```mod```\n```high```\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        final int mod = 1000000007;\\n        int[] dp = new int[high+1];\\n        //to handle base case\\n        dp[0] = 1;\\n        for(int i = 1; i < dp.length; i++) {\\n            if(i-one >= 0) dp[i] = (dp[i]+dp[i-one]) % mod;\\n            if(i-zero >= 0) dp[i] = (dp[i]+dp[i-zero]) % mod;\\n        }\\n        int ans = 0;\\n        for(int i = low; i <= high; i++) ans = (ans+dp[i]) % mod;\\n        return ans%mod;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807356,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n  let answer = 0;\\n  const dp = Array(high + 1).fill(0);\\n  dp[0] = 1;\\n  for(let i = 1; i <= high; i++) {\\n    if(i >= zero) {\\n      dp[i] += dp[i - zero];\\n    }\\n    if( i >= one) {\\n      dp[i] += dp[i - one];\\n    }\\n    dp[i] %= 10**9 + 7;\\n    if(i >= low) {\\n      answer = (answer + dp[i]) % (10**9 + 7);\\n    }\\n\\n  }  \\n  return answer;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n  let answer = 0;\\n  const dp = Array(high + 1).fill(0);\\n  dp[0] = 1;\\n  for(let i = 1; i <= high; i++) {\\n    if(i >= zero) {\\n      dp[i] += dp[i - zero];\\n    }\\n    if( i >= one) {\\n      dp[i] += dp[i - one];\\n    }\\n    dp[i] %= 10**9 + 7;\\n    if(i >= low) {\\n      answer = (answer + dp[i]) % (10**9 + 7);\\n    }\\n\\n  }  \\n  return answer;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807201,
                "title": "dp-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCoin Problem Variant\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,int zero,int one,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n       return dp[n]=(solve(n-zero,zero,one,dp)%mod+solve(n-one,zero,one,dp)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        int ans=0;\\n        vector<int> dp(1e6,-1);\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=(ans%mod+solve(i,zero,one,dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,int zero,int one,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n       return dp[n]=(solve(n-zero,zero,one,dp)%mod+solve(n-one,zero,one,dp)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        int ans=0;\\n        vector<int> dp(1e6,-1);\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=(ans%mod+solve(i,zero,one,dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807162,
                "title": "java-bottom-up-dp",
                "content": "```\\nclass Solution {\\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] counts = new int[high + 1];\\n        counts[zero]++;\\n        counts[one]++;\\n        \\n        for (int i = 0; i < counts.length; i++) {\\n            if (i - zero >= 0) {\\n                counts[i] = (counts[i] + counts[i - zero]) % M;\\n            }\\n            if (i - one >= 0) {\\n                counts[i] = (counts[i] + counts[i - one]) % M;\\n            }\\n        }\\n        \\n        int total = 0;\\n        for (int i = low; i <= high; i++) {\\n            total = (total + counts[i]) % M;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] counts = new int[high + 1];\\n        counts[zero]++;\\n        counts[one]++;\\n        \\n        for (int i = 0; i < counts.length; i++) {\\n            if (i - zero >= 0) {\\n                counts[i] = (counts[i] + counts[i - zero]) % M;\\n            }\\n            if (i - one >= 0) {\\n                counts[i] = (counts[i] + counts[i - one]) % M;\\n            }\\n        }\\n        \\n        int total = 0;\\n        for (int i = low; i <= high; i++) {\\n            total = (total + counts[i]) % M;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807142,
                "title": "ez-python-dp",
                "content": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \"\"\"\\n            . find total number of good strings possible to make using within the string length range [low-high]\\n            \\n            dp(count):\\n                \\n            state:\\n                count: total elements used till now\\n            transition\\n                use o + use 1\\n            exit\\n                count == high\\n            \\n        \"\"\"\\n        \\n        MOD = 1_000_000_007\\n        \\n        @lru_cache(100*100)\\n        def dp(c):\\n            if c == high:\\n                return 1\\n            if c > high:\\n                return 0\\n            \\n            if c >= low:\\n                return 1 + dp(c + zero) + dp(c + one)\\n            else:\\n                return dp(c + zero) + dp(c + one)\\n        \\n        return dp(0) % MOD\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \"\"\"\\n            . find total number of good strings possible to make using within the string length range [low-high]\\n            \\n            dp(count):\\n                \\n            state:\\n                count: total elements used till now\\n            transition\\n                use o + use 1\\n            exit\\n                count == high\\n            \\n        \"\"\"\\n        \\n        MOD = 1_000_000_007\\n        \\n        @lru_cache(100*100)\\n        def dp(c):\\n            if c == high:\\n                return 1\\n            if c > high:\\n                return 0\\n            \\n            if c >= low:\\n                return 1 + dp(c + zero) + dp(c + one)\\n            else:\\n                return dp(c + zero) + dp(c + one)\\n        \\n        return dp(0) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920168,
                "title": "similar-counting-set-beginner-friendly-approach",
                "content": "IDEA:  \\n why not we just calculate size of set of strings from length [min(zero,one]) to limit]\\n limit: max possible length\\n \\n then we can simply subtract   solution[high]-solution[low-1]  \\n {NOTE: (low-1) insted of low bcz low is inclusive to our answer} \\n \\n ```\\n class Solution {\\npublic:\\n    \\n    int z;\\n    int o;\\n    int n;\\n    int m=1e9+7;\\n    \\n    int dp[100001];\\n    int solve(int idx)\\n    {\\n        if(idx==n) return 1;\\n\\t\\t\\n        if(dp[idx]!=-1) return dp[idx]%m;\\n        \\n        int ans=1; // bcz current string is also a valid string so insted of 0 already we have ans=1\\n        \\n        if(idx+z<=n)// if with in limit\\n        ans+=solve(idx+z)%m;\\n        ans%=m;\\n\\t\\t\\n        if(idx+o<=n)\\n        ans+=solve(idx+o)%m;\\n        ans%=m;\\n        \\n        return dp[idx]=ans;\\n        \\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        \\n        //  0 1 10 01 11 00 110 111 100 000 010 011 101 001 =14\\n        n=high;\\n        z=zero;\\n        o=one;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans= solve(0);\\n\\t\\t\\n\\t\\t\\n        n=low-1;// redefine limit\\n        memset(dp,-1,sizeof(dp));\\n        ans-=solve(0);\\n        \\n        return (ans+m)%m;  \\n        \\n    }\\n};\\n \\n \\n \\n ```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    \\n    int z;\\n    int o;\\n    int n;\\n    int m=1e9+7;\\n    \\n    int dp[100001];\\n    int solve(int idx)\\n    {\\n        if(idx==n) return 1;\\n\\t\\t\\n        if(dp[idx]!=-1) return dp[idx]%m;\\n        \\n        int ans=1; // bcz current string is also a valid string so insted of 0 already we have ans=1\\n        \\n        if(idx+z<=n)// if with in limit\\n        ans+=solve(idx+z)%m;\\n        ans%=m;\\n\\t\\t\\n        if(idx+o<=n)\\n        ans+=solve(idx+o)%m;\\n        ans%=m;\\n        \\n        return dp[idx]=ans;\\n        \\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        \\n        //  0 1 10 01 11 00 110 111 100 000 010 011 101 001 =14\\n        n=high;\\n        z=zero;\\n        o=one;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans= solve(0);\\n\\t\\t\\n\\t\\t\\n        n=low-1;// redefine limit\\n        memset(dp,-1,sizeof(dp));\\n        ans-=solve(0);\\n        \\n        return (ans+m)%m;  \\n        \\n    }\\n};\\n \\n \\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3798147,
                "title": "c-dp-memoization-tabulation",
                "content": "# Memoization\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> memo(high + 1, -1);\\n        return dp(low, high, zero, one, 0, memo);\\n    }\\n\\nprivate:\\n    int dp(int& low, int& high, int& zero, int& one, int len, vector<int>& memo) {\\n        int mod = 1e9 + 7;\\n\\n        if (len > high) return 0;\\n        if (memo[len] != -1) return memo[len];\\n\\n        int ways = len >= low ? 1 : 0; \\n        ways += dp(low, high, zero, one, len + zero, memo) + \\n                        dp(low, high, zero, one, len + one, memo);\\n\\n        return memo[len] = ways % mod;\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + max(zero, one), 0);\\n        int mod = 1e9 + 7;\\n\\n        dp[high] = 1;\\n\\n        for (int len = high-1; len >= 0; len--) {\\n            int ways = len >= low ? 1 : 0; \\n            ways += dp[len + zero] + dp[len + one];\\n            dp[len] = ways % mod;\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> memo(high + 1, -1);\\n        return dp(low, high, zero, one, 0, memo);\\n    }\\n\\nprivate:\\n    int dp(int& low, int& high, int& zero, int& one, int len, vector<int>& memo) {\\n        int mod = 1e9 + 7;\\n\\n        if (len > high) return 0;\\n        if (memo[len] != -1) return memo[len];\\n\\n        int ways = len >= low ? 1 : 0; \\n        ways += dp(low, high, zero, one, len + zero, memo) + \\n                        dp(low, high, zero, one, len + one, memo);\\n\\n        return memo[len] = ways % mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + max(zero, one), 0);\\n        int mod = 1e9 + 7;\\n\\n        dp[high] = 1;\\n\\n        for (int len = high-1; len >= 0; len--) {\\n            int ways = len >= low ? 1 : 0; \\n            ways += dp[len + zero] + dp[len + one];\\n            dp[len] = ways % mod;\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743664,
                "title": "easiest-solution-using-memoization-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[100006];\\n    long long solve(int len, int zero, int one, int low , int high){\\n        if(len > high) return 0;\\n        if(dp[len] != -1) return dp[len];\\n\\n        if(len >= low){\\n            return dp[len] = (1 + solve(len+zero,zero,one,low,high) + solve(len+one,zero,one,low,high))%mod;\\n        }\\n\\n        return dp[len] =( solve(len+zero,zero,one,low,high) + solve(len+one,zero,one,low,high))%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = solve(0,zero,one,low,high);\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[100006];\\n    long long solve(int len, int zero, int one, int low , int high){\\n        if(len > high) return 0;\\n        if(dp[len] != -1) return dp[len];\\n\\n        if(len >= low){\\n            return dp[len] = (1 + solve(len+zero,zero,one,low,high) + solve(len+one,zero,one,low,high))%mod;\\n        }\\n\\n        return dp[len] =( solve(len+zero,zero,one,low,high) + solve(len+one,zero,one,low,high))%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = solve(0,zero,one,low,high);\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524455,
                "title": "runtime-100-space-optimised-solution-o-max-zero-one",
                "content": "# Intuition\\nThe recurrence relation that forms is\\n```\\ndp[i] = dp[i - zero] + dp[i - one]\\n```\\nthen we can easily see that actually the most far back we need to go is ```one``` indexes from the current one. Thus, it\\'s wasteful to maintain all the previous entries.\\nWe can use a circular queue to throw away the older entries and keep pushing the newer one.\\n\\n# Complexity\\n- Time complexity:\\n``` O(high) ```\\n- Space complexity:\\n``` O(max(one, zero)) ```\\n\\n# Code\\nApologies for the ugly unidiomatic code, as I didn\\'t write it knowing I would want to publish it \\uD83D\\uDE05\\n```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {\\n        const MOD_VAL: usize = 1000000007;\\n        let smaller = one.min(zero);\\n        let bigger = one.max(zero);\\n        let mut circular_buf = VecDeque::<usize>::with_capacity((bigger + 1) as usize);\\n        \\n        // good_strings(0) should be 1, because technically\\n        // \"\" is a string made up of some 1s and some 0s\\n        // but more importantly, \\n        // dp[i - smaller] when i = smaller will be dp[0]\\n        // similarly dp[i - bigger] when i = bigger will be dp[0]\\n        // and the answer for i = {smaller, bigger} must be 1, not 0.\\n        circular_buf.push_back(1);\\n\\n\\n        // For the rest of them up until min(zero, one), there\\'s definitely no way to make that string.\\n        for _ in 1..smaller {\\n            circular_buf.push_back(0);\\n        }\\n\\n        let mut counter: usize = 0;\\n\\n        // In this range, all the multiples of min(zero, one) can be made, and the rest can\\'t.\\n        \\n        for i in smaller..bigger {\\n            let ans = circular_buf[(i - smaller) as usize];\\n            circular_buf.push_back(ans);\\n            if i >= low {\\n                counter += ans;\\n            }\\n        }\\n\\n        // We didn\\'t pop from the queue until we had max(zero, one) amt of elements, \\n        // because atleast that many elements must be present before proceeding with the general case.\\n        for i in bigger..=high {\\n            // the indexing will be [bigger - {zero, one}]\\n            // because at any given time, the i_th index is really `bigger`\\n            // we insert at the length of the queue, and length is always `bigger`, as we keep popping the last element as soon as length becomes `bigger` + 1.\\n            let ans = (circular_buf[(bigger - zero) as usize]\\n                + circular_buf[(bigger - one) as usize])\\n                % MOD_VAL;\\n            circular_buf.push_back(ans);\\n            circular_buf.pop_front();\\n\\n            if i >= low {\\n                counter = (counter + ans) % MOD_VAL;\\n            }\\n        }\\n\\n        counter as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\ndp[i] = dp[i - zero] + dp[i - one]\\n```\n```one```\n``` O(high) ```\n``` O(max(one, zero)) ```\n```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {\\n        const MOD_VAL: usize = 1000000007;\\n        let smaller = one.min(zero);\\n        let bigger = one.max(zero);\\n        let mut circular_buf = VecDeque::<usize>::with_capacity((bigger + 1) as usize);\\n        \\n        // good_strings(0) should be 1, because technically\\n        // \"\" is a string made up of some 1s and some 0s\\n        // but more importantly, \\n        // dp[i - smaller] when i = smaller will be dp[0]\\n        // similarly dp[i - bigger] when i = bigger will be dp[0]\\n        // and the answer for i = {smaller, bigger} must be 1, not 0.\\n        circular_buf.push_back(1);\\n\\n\\n        // For the rest of them up until min(zero, one), there\\'s definitely no way to make that string.\\n        for _ in 1..smaller {\\n            circular_buf.push_back(0);\\n        }\\n\\n        let mut counter: usize = 0;\\n\\n        // In this range, all the multiples of min(zero, one) can be made, and the rest can\\'t.\\n        \\n        for i in smaller..bigger {\\n            let ans = circular_buf[(i - smaller) as usize];\\n            circular_buf.push_back(ans);\\n            if i >= low {\\n                counter += ans;\\n            }\\n        }\\n\\n        // We didn\\'t pop from the queue until we had max(zero, one) amt of elements, \\n        // because atleast that many elements must be present before proceeding with the general case.\\n        for i in bigger..=high {\\n            // the indexing will be [bigger - {zero, one}]\\n            // because at any given time, the i_th index is really `bigger`\\n            // we insert at the length of the queue, and length is always `bigger`, as we keep popping the last element as soon as length becomes `bigger` + 1.\\n            let ans = (circular_buf[(bigger - zero) as usize]\\n                + circular_buf[(bigger - one) as usize])\\n                % MOD_VAL;\\n            circular_buf.push_back(ans);\\n            circular_buf.pop_front();\\n\\n            if i >= low {\\n                counter = (counter + ans) % MOD_VAL;\\n            }\\n        }\\n\\n        counter as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521266,
                "title": "java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%1000000007)+(f(i,dp,zero,one)%1000000007))%1000000007;\\n        }\\n        return ans;\\n    }\\n    public int f(int ind,int[] dp,int zero,int one){\\n        if(ind==0)\\n            return 1;\\n        if(ind<0)\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int forzero=f(ind-zero,dp,zero,one);\\n        int forone=f(ind-one,dp,zero,one);\\n        return dp[ind]=(forzero+forone)%1000000007;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%1000000007)+(f(i,dp,zero,one)%1000000007))%1000000007;\\n        }\\n        return ans;\\n    }\\n    public int f(int ind,int[] dp,int zero,int one){\\n        if(ind==0)\\n            return 1;\\n        if(ind<0)\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int forzero=f(ind-zero,dp,zero,one);\\n        int forone=f(ind-one,dp,zero,one);\\n        return dp[ind]=(forzero+forone)%1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521163,
                "title": "swift-dp-100-performance",
                "content": "# Complexity\\n- Time complexity: O(high)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(high)\\n\\n# Code\\n```\\nclass Solution {\\n    func countGoodStrings(_ low: Int, _ high: Int, _ zero: Int, _ one: Int) -> Int {\\n        var dp = Array(repeating: 0, count: high + 1)\\n        var mod = 1_000_000_007\\n\\n        dp[0] = 1\\n        for i in 1 ... high {\\n            if i >= zero {\\n                dp[i] += dp[i - zero]\\n            }\\n\\n            if i >= one {\\n                dp[i] += dp[i - one]\\n            }\\n\\n            dp[i] %= mod\\n        }\\n\\n        return dp[low...].reduce(0, {\\n            return ($0 + $1) % mod\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func countGoodStrings(_ low: Int, _ high: Int, _ zero: Int, _ one: Int) -> Int {\\n        var dp = Array(repeating: 0, count: high + 1)\\n        var mod = 1_000_000_007\\n\\n        dp[0] = 1\\n        for i in 1 ... high {\\n            if i >= zero {\\n                dp[i] += dp[i - zero]\\n            }\\n\\n            if i >= one {\\n                dp[i] += dp[i - one]\\n            }\\n\\n            dp[i] %= mod\\n        }\\n\\n        return dp[low...].reduce(0, {\\n            return ($0 + $1) % mod\\n        })\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521067,
                "title": "explained-solution-recursion-tabulation-memiozation",
                "content": "\\ne.g-->\\nzero-2,one-2 low-3,high-3\\nall string start from Either 00 or 11 and continue to append one and zero fursther upto len <= high\\no/p- 0 bcoz no string possible\\n\\n//Recursive\\n```\\nclass Solution {\\npublic:\\n    int solve(int low, int high, int zero, int one,int len){\\n        if(len > high){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(len >= low){\\n            ans++;\\n        }\\n        int ans1 = solve(low,high,zero,one,len+zero);\\n        int ans2 = solve(low,high,zero,one,len+one);\\n        return ans+ans1+ans2;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return solve(low,high,zero,one,0);\\n    }\\n};\\n```\\n//tabulation\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int low, int high, int zero, int one){\\n        vector<int>dp(high+1,0);\\n        dp[0]=1;\\n        for(int i=1;i <= high;i++){\\n            if(i-zero >= 0){\\n                dp[i]+=dp[i-zero] % mod;\\n            }\\n            if(i-one >= 0){\\n                dp[i]+=dp[i-one] % mod;\\n            }\\n        }\\n        long long  ans=0;\\n        for(int i=low;i <= high;i++){\\n            ans+=dp[i]%mod;\\n        }\\n        return ans % mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return solve(low,high,zero,one);\\n    }\\n};\\n```\\n//Memoization\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int low, int high, int zero, int one,int len,vector<int>&dp){\\n        if(len > high){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(dp[len] != -1){\\n            return dp[len];\\n        }\\n        if(len >= low){\\n            ans++;\\n        }\\n        int ans1 = solve(low,high,zero,one,len+zero,dp) % mod;\\n        int ans2 = solve(low,high,zero,one,len+one,dp) % mod;\\n        dp[len] = (ans+ans1+ans2) % mod;\\n        return dp[len] % mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int>dp(high+1,-1);\\n        return solve(low,high,zero,one,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int low, int high, int zero, int one,int len){\\n        if(len > high){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(len >= low){\\n            ans++;\\n        }\\n        int ans1 = solve(low,high,zero,one,len+zero);\\n        int ans2 = solve(low,high,zero,one,len+one);\\n        return ans+ans1+ans2;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return solve(low,high,zero,one,0);\\n    }\\n};\\n```\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int low, int high, int zero, int one){\\n        vector<int>dp(high+1,0);\\n        dp[0]=1;\\n        for(int i=1;i <= high;i++){\\n            if(i-zero >= 0){\\n                dp[i]+=dp[i-zero] % mod;\\n            }\\n            if(i-one >= 0){\\n                dp[i]+=dp[i-one] % mod;\\n            }\\n        }\\n        long long  ans=0;\\n        for(int i=low;i <= high;i++){\\n            ans+=dp[i]%mod;\\n        }\\n        return ans % mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return solve(low,high,zero,one);\\n    }\\n};\\n```\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int low, int high, int zero, int one,int len,vector<int>&dp){\\n        if(len > high){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(dp[len] != -1){\\n            return dp[len];\\n        }\\n        if(len >= low){\\n            ans++;\\n        }\\n        int ans1 = solve(low,high,zero,one,len+zero,dp) % mod;\\n        int ans2 = solve(low,high,zero,one,len+one,dp) % mod;\\n        dp[len] = (ans+ans1+ans2) % mod;\\n        return dp[len] % mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int>dp(high+1,-1);\\n        return solve(low,high,zero,one,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520937,
                "title": "c-dp-memoization-easy-to-understand-similar-to-take-nottake-method",
                "content": "# Complexity\\n- Time complexity:\\no(high)\\n\\n- Space complexity:\\no(high)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\n    int solve(int low, int high, int zero, int one, int cnt, vector<int>& dp) {\\n        if(cnt > high) return 0;\\n\\n        if(dp[cnt] != -1) return dp[cnt];\\n        \\n        int ans = 0;\\n        if(cnt >= low && cnt <= high) ans = 1;\\n        int append_0 = solve(low, high, zero, one, cnt + zero, dp)%mod;\\n        int append_1 = solve(low, high, zero, one, cnt + one, dp)%mod;\\n\\n        return dp[cnt] = (ans + append_0 + append_1)%mod;\\n    } \\n\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1, -1);\\n        return solve(low, high, zero, one, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\n    int solve(int low, int high, int zero, int one, int cnt, vector<int>& dp) {\\n        if(cnt > high) return 0;\\n\\n        if(dp[cnt] != -1) return dp[cnt];\\n        \\n        int ans = 0;\\n        if(cnt >= low && cnt <= high) ans = 1;\\n        int append_0 = solve(low, high, zero, one, cnt + zero, dp)%mod;\\n        int append_1 = solve(low, high, zero, one, cnt + one, dp)%mod;\\n\\n        return dp[cnt] = (ans + append_0 + append_1)%mod;\\n    } \\n\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1, -1);\\n        return solve(low, high, zero, one, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520884,
                "title": "easy-c-simple-explanation-of-a-complex-solution",
                "content": "# Intuition\\nWe will solve the problem using the memorization method. To perform a memorized solution, we need to memorize the results, so we need to allocate memory for dp.\\n\\nNext, we will add one to dp[```zero```] and dp[```one```], since minimal solutions will be located according to these indices.\\n\\nIn the loop, we will add up the previous results starting with the minimum value from ```zero``` and ```one```\\n\\nThe result of addition must be divided modulo in order not to go abroad\\n\\nAs soon as the word size reaches the minimum length, we start counting the result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo begin with, we will create a vector of the size ``high + 1``. \\nPlus 1 because we sum up the previous steps and we will have a result if we go through all the steps.\\n\\nAdd + 1 solution for the index ``zero`` and ``one``. According to this index, we will have a minimum length solution for ``zero`` and ``one``.\\n\\nWe start the cycle with the minimum value of ``zero`` or ``one``. We start this way because from this index we have at least one good row of the type we need.\\n\\nCreating the dpSum field where we will save the result of the sum of dpSum[i - zero] and dpSum[i - one].\\n\\n- dp[i - zero] - number of lines ending with \\'0\\'\\n- dp[i - one] - number of lines ending with \\'1\\'\\n\\nThe amount must be divided modulo in order not to go beyond the boundaries.\\n\\nIf a word is longer than the minimum length , then it suits us and we add the number of good words of this length to the result.\\n\\nThe result must be divided modulo in order not to go beyond the boundaries.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(high)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(high)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int result = 0, mod = 1e9 + 7;\\n        // Creating a vector for counting sums\\n        vector<int> dp(high + 1, 0);\\n        // We add one to the vector by the index zero and one\\n        // In these positions the first word of the minimally used letters is set\\n        dp[zero]++;\\n        dp[one]++;\\n        // We start the cycle with the minimum word length\\n        for (int i = min(zero, one); i <= high; i++) {\\n            // To get dp[i], we add the number of lines ending in 0 and 1\\n            int dpSum = 0;\\n            dpSum += zero <= i ? dp[i - zero] : 0;\\n            dpSum += one <= i ? dp[i - one] : 0;\\n            dp[i] += dpSum % mod;\\n            // If i >= the minimum length of the word, then we begin to add the result\\n            if (i >= low) {\\n                result += dp[i];\\n                result %= mod;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```zero```\n```one```\n```zero```\n```one```\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int result = 0, mod = 1e9 + 7;\\n        // Creating a vector for counting sums\\n        vector<int> dp(high + 1, 0);\\n        // We add one to the vector by the index zero and one\\n        // In these positions the first word of the minimally used letters is set\\n        dp[zero]++;\\n        dp[one]++;\\n        // We start the cycle with the minimum word length\\n        for (int i = min(zero, one); i <= high; i++) {\\n            // To get dp[i], we add the number of lines ending in 0 and 1\\n            int dpSum = 0;\\n            dpSum += zero <= i ? dp[i - zero] : 0;\\n            dpSum += one <= i ? dp[i - one] : 0;\\n            dp[i] += dpSum % mod;\\n            // If i >= the minimum length of the word, then we begin to add the result\\n            if (i >= low) {\\n                result += dp[i];\\n                result %= mod;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520827,
                "title": "java-recursive-memoization-solution",
                "content": "# Complexity\\n- Time complexity: $$O(high)$$\\n\\n- Space complexity: $$O(high)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans = 0;\\n        int[] dp = new int[high + 1];\\n        Arrays.fill(dp, -1);\\n        for(int i = low; i <= high; i++){\\n            // ans = ((ans) % mod + (helper(i, high, low, zero, one)) % mod) % mod;\\n            ans = ((ans) % mod + (helperMem(i, high, low, zero, one, dp)) % mod) % mod;\\n        }\\n        return ans;\\n    }\\n\\n    public int helper(int val, int low, int high, int zero, int one){\\n        if(val == 0) return 1;\\n        if(val < 0) return 0;\\n        int first = helper(val - zero, low, high, zero, one);\\n        int second = helper(val - one, low, high, zero, one);\\n        return (first + second) % mod;\\n    }\\n\\n    public int helperMem(int val, int low, int high, int zero, int one, int[] dp){\\n        if(val == 0) return 1;\\n        if(val < 0) return 0;\\n        if(dp[val] != -1) return dp[val];\\n        int first = helperMem(val - zero, low, high, zero, one, dp);\\n        int second = helperMem(val - one, low, high, zero, one, dp);\\n        return dp[val] = (first + second) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans = 0;\\n        int[] dp = new int[high + 1];\\n        Arrays.fill(dp, -1);\\n        for(int i = low; i <= high; i++){\\n            // ans = ((ans) % mod + (helper(i, high, low, zero, one)) % mod) % mod;\\n            ans = ((ans) % mod + (helperMem(i, high, low, zero, one, dp)) % mod) % mod;\\n        }\\n        return ans;\\n    }\\n\\n    public int helper(int val, int low, int high, int zero, int one){\\n        if(val == 0) return 1;\\n        if(val < 0) return 0;\\n        int first = helper(val - zero, low, high, zero, one);\\n        int second = helper(val - one, low, high, zero, one);\\n        return (first + second) % mod;\\n    }\\n\\n    public int helperMem(int val, int low, int high, int zero, int one, int[] dp){\\n        if(val == 0) return 1;\\n        if(val < 0) return 0;\\n        if(dp[val] != -1) return dp[val];\\n        int first = helperMem(val - zero, low, high, zero, one, dp);\\n        int second = helperMem(val - one, low, high, zero, one, dp);\\n        return dp[val] = (first + second) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520714,
                "title": "memoization-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asked to find the total number of good strings, and when ever we are appending we have two choices i.e add ones or zeroes,\\nSo it gives a intution to draw a recursion tree and to find all possible strings there is no other way other than trying all possible cases in this case.Hence this can be done using recurion. But this can be optimized using memoization to use previously computed results.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd ones and zeroes to the string recursively until the length of the string is greater than high.While doing this whenever the length of the string falls in the specified range add 1 to the answer and zeors,ones to the existing string get more possible solutions.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(high) Since we are traversing from length 0 to high\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(High+High) For DP Array+Recursive Tree\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long Util(int low,int high,int zero,int one,int len,long[] dp){\\n\\n        if(len>high)\\n            return 0;\\n\\n        //Using precomputed results\\n        if(dp[len] != -1)\\n            return dp[len]; \\n\\n        long count = len>=low?1:0;\\n        //Adding zeroes\\n        count+=(Util(low,high,zero,one,len+zero,dp))%(long)(1e9+7);\\n\\n        //Adding Ones\\n        count+=(Util(low,high,zero,one,len+one,dp))%(long)(1e9+7);\\n\\n        //Storing the results in dp array for future use\\n        return dp[len] = count%(long)(1e9+7);\\n\\n    }\\n\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n\\n        long[] dp = new long[high+1];\\n        Arrays.fill(dp,-1);\\n\\n        return (int)Util(low,high,zero,one,0,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long Util(int low,int high,int zero,int one,int len,long[] dp){\\n\\n        if(len>high)\\n            return 0;\\n\\n        //Using precomputed results\\n        if(dp[len] != -1)\\n            return dp[len]; \\n\\n        long count = len>=low?1:0;\\n        //Adding zeroes\\n        count+=(Util(low,high,zero,one,len+zero,dp))%(long)(1e9+7);\\n\\n        //Adding Ones\\n        count+=(Util(low,high,zero,one,len+one,dp))%(long)(1e9+7);\\n\\n        //Storing the results in dp array for future use\\n        return dp[len] = count%(long)(1e9+7);\\n\\n    }\\n\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n\\n        long[] dp = new long[high+1];\\n        Arrays.fill(dp,-1);\\n\\n        return (int)Util(low,high,zero,one,0,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520650,
                "title": "easy-solution-with-dp-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func countGoodStrings(_ low: Int, _ high: Int, _ zero: Int, _ one: Int) -> Int {\\n        var dp = [Int](repeating: 0, count: high+1)\\n        dp[0] = 1\\n        var goodStrings = 0\\n        for i in 1...high {\\n            if i-zero >= 0 {\\n                dp[i] += dp[i-zero]\\n            }\\n            if i-one >= 0 {\\n                dp[i] += dp[i-one]\\n            }\\n            dp[i] %= 1000000007\\n        }\\n        if low == high {\\n            return dp[low]\\n        }\\n        for i in low...high {\\n            goodStrings += dp[i]\\n            goodStrings %= 1000000007\\n        }\\n        return goodStrings\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countGoodStrings(_ low: Int, _ high: Int, _ zero: Int, _ one: Int) -> Int {\\n        var dp = [Int](repeating: 0, count: high+1)\\n        dp[0] = 1\\n        var goodStrings = 0\\n        for i in 1...high {\\n            if i-zero >= 0 {\\n                dp[i] += dp[i-zero]\\n            }\\n            if i-one >= 0 {\\n                dp[i] += dp[i-one]\\n            }\\n            dp[i] %= 1000000007\\n        }\\n        if low == high {\\n            return dp[low]\\n        }\\n        for i in low...high {\\n            goodStrings += dp[i]\\n            goodStrings %= 1000000007\\n        }\\n        return goodStrings\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520640,
                "title": "python3-dp-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        strCount = 0\\n\\n        dp = [0]*(high+1)\\n        dp[0] = 1\\n\\n        greater = max(zero,one)\\n        lesser = min(zero,one)\\n\\n        for i in range(lesser,greater):\\n            dp[i] += dp[i-lesser]%(10**9 + 7)\\n        \\n        for i in range(greater,high+1):\\n            dp[i] += (dp[i-zero]+dp[i-one])%(10**9 + 7)\\n        \\n        return sum(dp[low:high+1])%(10**9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        strCount = 0\\n\\n        dp = [0]*(high+1)\\n        dp[0] = 1\\n\\n        greater = max(zero,one)\\n        lesser = min(zero,one)\\n\\n        for i in range(lesser,greater):\\n            dp[i] += dp[i-lesser]%(10**9 + 7)\\n        \\n        for i in range(greater,high+1):\\n            dp[i] += (dp[i-zero]+dp[i-one])%(10**9 + 7)\\n        \\n        return sum(dp[low:high+1])%(10**9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520514,
                "title": "c-java-python-100-beats-explanation-of-each-step",
                "content": "**CPP**\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int mod=1e9+7;\\n        vector<int>dp(high+1,0);\\n        \\n        //dp[i] indicates all strings of length i;\\n        dp[0]=1;  // always as one null(\"\") string will be present in every case\\n       \\n        \\n        // Iterate over each length `i`.\\n        for(int i=1;i<high+1;i++){\\n          // check if the current string can be made by append zero `0`s or one `1`s.\\n            if(i>=zero){\\n                dp[i]+=dp[i-zero];\\n            }\\n            if(i>=one){\\n                dp[i]+=dp[i-one];\\n            }\\n            dp[i]%=mod;\\n        }\\n        \\n        // Add up the number of strings with each valid length [low ~ high].\\n        int answer=0;\\n        for(int i=low;i<=high;i++){\\n            answer+=dp[i];\\n            answer%=mod;\\n        }\\n        \\n        return answer;     \\n    }\\n};\\n``` \\n\\n**JAVA**\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        // Use dp[i] to record to number of good strings of length i.\\n        int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int mod = 1_000_000_007;\\n        \\n        // Iterate over each length `end`.\\n        for (int end = 1; end <= high; ++end) {\\n            // check if the current string can be made by append zero `0`s or one `1`s.\\n            if (end >= zero) {\\n                dp[end] += dp[end - zero];\\n            }\\n            if (end >= one) {\\n                dp[end] += dp[end - one];\\n            }\\n            dp[end] %= mod;\\n        }\\n        \\n        // Add up the number of strings with each valid length [low ~ high].\\n        int answer = 0;\\n        for (int i = low; i <= high; ++i) {\\n            answer += dp[i];\\n            answer %= mod;\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n\\n**PYTHON**\\n```\\n  class Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        # Use dp[i] to record to number of good strings of length i.\\n        dp = [1] + [0] * (high)\\n        mod = 10 ** 9 + 7\\n        \\n        # Iterate over each length `end`.\\n        for end in range(1, high + 1):\\n            # check if the current string can be made by append zero `0`s or one `1`s.\\n            if end >= zero:\\n                dp[end] += dp[end - zero]\\n            if end >= one:\\n                dp[end] += dp[end - one]\\n            dp[end] %= mod\\n        \\n        # Add up the number of strings with each valid length [low ~ high].\\n        return sum(dp[low : high + 1]) % mod\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int mod=1e9+7;\\n        vector<int>dp(high+1,0);\\n        \\n        //dp[i] indicates all strings of length i;\\n        dp[0]=1;  // always as one null(\"\") string will be present in every case\\n       \\n        \\n        // Iterate over each length `i`.\\n        for(int i=1;i<high+1;i++){\\n          // check if the current string can be made by append zero `0`s or one `1`s.\\n            if(i>=zero){\\n                dp[i]+=dp[i-zero];\\n            }\\n            if(i>=one){\\n                dp[i]+=dp[i-one];\\n            }\\n            dp[i]%=mod;\\n        }\\n        \\n        // Add up the number of strings with each valid length [low ~ high].\\n        int answer=0;\\n        for(int i=low;i<=high;i++){\\n            answer+=dp[i];\\n            answer%=mod;\\n        }\\n        \\n        return answer;     \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        // Use dp[i] to record to number of good strings of length i.\\n        int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int mod = 1_000_000_007;\\n        \\n        // Iterate over each length `end`.\\n        for (int end = 1; end <= high; ++end) {\\n            // check if the current string can be made by append zero `0`s or one `1`s.\\n            if (end >= zero) {\\n                dp[end] += dp[end - zero];\\n            }\\n            if (end >= one) {\\n                dp[end] += dp[end - one];\\n            }\\n            dp[end] %= mod;\\n        }\\n        \\n        // Add up the number of strings with each valid length [low ~ high].\\n        int answer = 0;\\n        for (int i = low; i <= high; ++i) {\\n            answer += dp[i];\\n            answer %= mod;\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\n  class Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        # Use dp[i] to record to number of good strings of length i.\\n        dp = [1] + [0] * (high)\\n        mod = 10 ** 9 + 7\\n        \\n        # Iterate over each length `end`.\\n        for end in range(1, high + 1):\\n            # check if the current string can be made by append zero `0`s or one `1`s.\\n            if end >= zero:\\n                dp[end] += dp[end - zero]\\n            if end >= one:\\n                dp[end] += dp[end - one]\\n            dp[end] %= mod\\n        \\n        # Add up the number of strings with each valid length [low ~ high].\\n        return sum(dp[low : high + 1]) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520513,
                "title": "js-memoization-tc-o-n",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nconst mod = 1e9 + 7;\\nvar getGoodStrings = function(len, low, high, zero, one, dp){\\n        if(len > high){\\n            return 0;\\n        }\\n        if(dp[len] != -1) return dp[len];\\n        let ans = 0;\\n        if(len>=low && len<=high){\\n            ans++;\\n        }\\n        ans += getGoodStrings(len+zero, low, high, zero, one, dp);\\n        ans += getGoodStrings(len+one, low, high, zero, one, dp);\\n\\n        return dp[len] = ans % mod;\\n}\\nvar countGoodStrings = function(low, high, zero, one) {\\n    \\n    let dp = new Array(high+1);\\n    dp.fill(-1);\\n    return getGoodStrings(0, low, high, zero, one, dp);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nconst mod = 1e9 + 7;\\nvar getGoodStrings = function(len, low, high, zero, one, dp){\\n        if(len > high){\\n            return 0;\\n        }\\n        if(dp[len] != -1) return dp[len];\\n        let ans = 0;\\n        if(len>=low && len<=high){\\n            ans++;\\n        }\\n        ans += getGoodStrings(len+zero, low, high, zero, one, dp);\\n        ans += getGoodStrings(len+one, low, high, zero, one, dp);\\n\\n        return dp[len] = ans % mod;\\n}\\nvar countGoodStrings = function(low, high, zero, one) {\\n    \\n    let dp = new Array(high+1);\\n    dp.fill(-1);\\n    return getGoodStrings(0, low, high, zero, one, dp);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520434,
                "title": "c-dp-tabulation-explained",
                "content": "First, I initialized a vector dp of size \"high+1\" to store the intermediate results. I also set dp[0] to 1 to represent the empty string, which is a good string. Then, I iterated from 1 to \"high\" and computed dp[i] as the sum of dp[i-zero] and dp[i-one], if i was greater than or equal to zero and one respectively. This is because, if we add a \\'0\\' to a good string of length i-zero, we get a good string of length i, and if we add a \\'1\\' to a good string of length i-one, we get a good string of length i. Finally, if i was in the range [low, high], I added dp[i] to the result.\\n\\n**Time Complexity:**\\nThe time complexity of this solution is O(high), as we iterate over all integers from 1 to high, and perform a constant amount of work for each integer.\\n\\n**Space Complexity:**\\nThe space complexity of this solution is O(high), as we use a dp vector of size high+1 to store the intermediate results.\\n\\n**Code:**\\n```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1; // 1 string of length 0\\n        int res = 0;\\n        for(int i = 1; i <= high; ++i) {\\n            if(i >= zero)\\n                dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            \\n            if(i >= one)\\n                dp[i] = (dp[i] + dp[i - one]) % mod;\\n            \\n            if(i >= low) // it\\'s in range\\n                res = (res + dp[i]) % mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int mod = 1e9 + 7;\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1; // 1 string of length 0\\n        int res = 0;\\n        for(int i = 1; i <= high; ++i) {\\n            if(i >= zero)\\n                dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            \\n            if(i >= one)\\n                dp[i] = (dp[i] + dp[i - one]) % mod;\\n            \\n            if(i >= low) // it\\'s in range\\n                res = (res + dp[i]) % mod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520008,
                "title": "java-code-using-dp-and-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int mod = 1_00_00_00_00_7;\\n\\n    public int lgs(int dp[],int len,int zero,int one){\\n        if(len==0) return 1;\\n        if(len<0) return 0;\\n        if(dp[len]!=-1) return dp[len];\\n\\n        int s = (lgs(dp,len-zero,zero,one)+lgs(dp,len-one,zero,one))%mod;\\n        dp[len] = s;\\n        return s;\\n\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        int dp[] = new int[high+1];\\n        Arrays.fill(dp,-1);\\n\\n        int ans = 0;\\n\\n        for(int i=low;i<=high;i++){\\n            ans=(ans+lgs(dp,i,zero,one))%mod;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int mod = 1_00_00_00_00_7;\\n\\n    public int lgs(int dp[],int len,int zero,int one){\\n        if(len==0) return 1;\\n        if(len<0) return 0;\\n        if(dp[len]!=-1) return dp[len];\\n\\n        int s = (lgs(dp,len-zero,zero,one)+lgs(dp,len-one,zero,one))%mod;\\n        dp[len] = s;\\n        return s;\\n\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        int dp[] = new int[high+1];\\n        Arrays.fill(dp,-1);\\n\\n        int ans = 0;\\n\\n        for(int i=low;i<=high;i++){\\n            ans=(ans+lgs(dp,i,zero,one))%mod;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519858,
                "title": "python-java-c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemoization -> Tabulation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n- Memoization in Python\\n```\\nclass Solution:\\n    def findWays(self, low, high, zero, one, l, dp):\\n        if l > high: return 0\\n        if dp[l] != -1: return dp[l]\\n\\n        if low <= l <= high:\\n            dp[l] = max(dp[l], (1 + self.findWays(low, high, zero, one, l + zero, dp) + self.findWays(low, high, zero, one, l + one, dp))%(10**9+7))\\n        else:\\n            dp[l] = max(dp[l], (self.findWays(low, high, zero, one, l + zero, dp) + self.findWays(low, high, zero, one, l + one, dp))%(10**9+7)) \\n        return dp[l] % (10**9+7)\\n\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [-1] * (high+1)\\n        return self.findWays(low, high, zero, one, 0, dp)\\n```\\n- Tabulation in Python\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0] * (high+1)\\n        dp[0] = 1\\n        summ =  0\\n        for l in range(min(one, zero), high+1):\\n            if l >= one: dp[l] += dp[l - one]\\n            if l >= zero: dp[l] += dp[l - zero]\\n            dp[l] = dp[l] % (10**9+7)\\n            if l >= low: summ = (summ + dp[l])%(10**9+7)\\n        return summ\\n```\\n- Tabulation in Java\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int [] dp = new int[high+1];\\n        int summ = 0;\\n        int l = one <= zero? one: zero, md = 1000000007;\\n        dp[0] = 1;\\n        for(; l < high+1; l++){\\n            if(l >= one) dp[l] += dp[l-one];\\n            if(l >= zero) dp[l] += dp[l-zero];\\n            dp[l] = dp[l]%md;\\n            if(l >= low) summ = (summ + dp[l]) % md;\\n        }\\n        return summ;\\n    }\\n}\\n```\\n- Tabulation in C++\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1);\\n        int summ = 0, l = one <= zero? one: zero, md = 1e9 + 7;\\n        dp[0] = 1;\\n        for(; l < high+1; l++){\\n            if(l >= one) dp[l] += dp[l-one];\\n            if(l >= zero) dp[l] += dp[l-zero];\\n            dp[l] = dp[l]%md;\\n            if(l >= low) summ = (summ + dp[l]) % md;\\n        }\\n        return summ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findWays(self, low, high, zero, one, l, dp):\\n        if l > high: return 0\\n        if dp[l] != -1: return dp[l]\\n\\n        if low <= l <= high:\\n            dp[l] = max(dp[l], (1 + self.findWays(low, high, zero, one, l + zero, dp) + self.findWays(low, high, zero, one, l + one, dp))%(10**9+7))\\n        else:\\n            dp[l] = max(dp[l], (self.findWays(low, high, zero, one, l + zero, dp) + self.findWays(low, high, zero, one, l + one, dp))%(10**9+7)) \\n        return dp[l] % (10**9+7)\\n\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [-1] * (high+1)\\n        return self.findWays(low, high, zero, one, 0, dp)\\n```\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0] * (high+1)\\n        dp[0] = 1\\n        summ =  0\\n        for l in range(min(one, zero), high+1):\\n            if l >= one: dp[l] += dp[l - one]\\n            if l >= zero: dp[l] += dp[l - zero]\\n            dp[l] = dp[l] % (10**9+7)\\n            if l >= low: summ = (summ + dp[l])%(10**9+7)\\n        return summ\\n```\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int [] dp = new int[high+1];\\n        int summ = 0;\\n        int l = one <= zero? one: zero, md = 1000000007;\\n        dp[0] = 1;\\n        for(; l < high+1; l++){\\n            if(l >= one) dp[l] += dp[l-one];\\n            if(l >= zero) dp[l] += dp[l-zero];\\n            dp[l] = dp[l]%md;\\n            if(l >= low) summ = (summ + dp[l]) % md;\\n        }\\n        return summ;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1);\\n        int summ = 0, l = one <= zero? one: zero, md = 1e9 + 7;\\n        dp[0] = 1;\\n        for(; l < high+1; l++){\\n            if(l >= one) dp[l] += dp[l-one];\\n            if(l >= zero) dp[l] += dp[l-zero];\\n            dp[l] = dp[l]%md;\\n            if(l >= low) summ = (summ + dp[l]) % md;\\n        }\\n        return summ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519818,
                "title": "c-solution-dp-memoization",
                "content": "# Complexity\\n- Time complexity:\\nO(3*high)\\n\\n- Space complexity:\\nO(3*high)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(int low,int high,int zero,int one,int currLen,int endswith,vector<vector<int>>& dp){\\n        if(currLen>high) return 0;\\n        if(dp[currLen][endswith]!=-1) return dp[currLen][endswith];\\n        long long ans = 0;\\n        if(currLen>=low && currLen<=high){\\n            ans++;\\n        }\\n        ans += solve(low,high,zero,one,currLen+zero,0,dp);\\n        ans %= mod;\\n        ans += solve(low,high,zero,one,currLen+one,1,dp);\\n        ans %= mod;\\n        return dp[currLen][endswith] = ans;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<vector<int>> dp(high+1,vector<int>(3,-1));\\n        return solve(low,high,zero,one,0,2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(int low,int high,int zero,int one,int currLen,int endswith,vector<vector<int>>& dp){\\n        if(currLen>high) return 0;\\n        if(dp[currLen][endswith]!=-1) return dp[currLen][endswith];\\n        long long ans = 0;\\n        if(currLen>=low && currLen<=high){\\n            ans++;\\n        }\\n        ans += solve(low,high,zero,one,currLen+zero,0,dp);\\n        ans %= mod;\\n        ans += solve(low,high,zero,one,currLen+one,1,dp);\\n        ans %= mod;\\n        return dp[currLen][endswith] = ans;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<vector<int>> dp(high+1,vector<int>(3,-1));\\n        return solve(low,high,zero,one,0,2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519802,
                "title": "php-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $low\\n     * @param Integer $high\\n     * @param Integer $zero\\n     * @param Integer $one\\n     * @return Integer\\n     */\\n    \\n    function countGoodStrings($low, $high, $zero, $one) {\\n        $n = $high - $low + 1;\\n        $dp = array_fill(0, $high+1, -1);\\n        $solution = 0;\\n        $mod = 1_000_000_007;\\n        $dp[0] = 1;\\n        for ($i=1;$i<=$high;$i++) {\\n            $dp[$i] = (($dp[$i-$zero] ?? 0) + ($dp[$i-$one] ?? 0)) % $mod;\\n            if($i >= $low) {\\n            $solution += $dp[$i];\\n            $solution %= $mod; }\\n        }\\n        //print_r($dp);\\n        return $solution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $low\\n     * @param Integer $high\\n     * @param Integer $zero\\n     * @param Integer $one\\n     * @return Integer\\n     */\\n    \\n    function countGoodStrings($low, $high, $zero, $one) {\\n        $n = $high - $low + 1;\\n        $dp = array_fill(0, $high+1, -1);\\n        $solution = 0;\\n        $mod = 1_000_000_007;\\n        $dp[0] = 1;\\n        for ($i=1;$i<=$high;$i++) {\\n            $dp[$i] = (($dp[$i-$zero] ?? 0) + ($dp[$i-$one] ?? 0)) % $mod;\\n            if($i >= $low) {\\n            $solution += $dp[$i];\\n            $solution %= $mod; }\\n        }\\n        //print_r($dp);\\n        return $solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519801,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp){\\n        if(target==0)\\n            return 1;\\n        if(target<0)\\n            return 0;\\n        if(dp[target]!=-1)\\n            return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp){\\n        if(target==0)\\n            return 1;\\n        if(target<0)\\n            return 0;\\n        if(dp[target]!=-1)\\n            return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519636,
                "title": "c-easy-dp-solution-top-down-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The solution uses dynamic programming to compute the answer. Recursion + Memoisation.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* The function \"strLength\" takes the length of the string, the number of \\'0\\'s allowed, the number of \\'1\\'s allowed, and a vector \"dp\" that stores the previously computed values. It returns the number of good strings of length \"len\".\\n* The function first checks if the length is 0 or negative, in which case it returns 1 or 0, respectively.\\n* Otherwise, it checks if the value has already been computed and stored in the \"dp\" vector. If so, it returns the stored value.\\n* Otherwise, it recursively computes the number of good strings by considering two cases: either the first character is a \\'0\\' or a \\'1\\'. It then adds these two cases modulo \"MOD\" and stores the result in \"dp[len]\" before returning it.\\n* The \"countGoodStrings\" function uses the \"XLength\" function to compute the number of good strings for each length between \"low\" and \"high\", and sums them up to get the final answer. It initializes a vector \"dp\" with -1 values of size \"high+1\" to store the computed values of \"XLength\". The final answer is returned modulo \"MOD\".\\n# Complexity\\n- Time complexity: $$O(high)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(high)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strLength(int len, int zero, int one, vector<int>& dp){\\n        int MOD = 1e9 + 7;\\n        if(len == 0){\\n            return 1;\\n        }\\n        if(len < 0){\\n            return 0;\\n        }\\n\\n        int &result = dp[len];\\n        if(dp[len] != -1){\\n            return result;\\n        }\\n\\n        result = (strLength(len-zero, zero, one, dp) + strLength(len-one,zero,one,dp)) % MOD;\\n        return result;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int MOD = 1e9 + 7;\\n        vector<int> dp;\\n        dp.resize(high+1, -1);\\n\\n        long long ans = 0;\\n        for(int len=low; len<=high; len++){\\n            ans = (ans + strLength(len, zero, one, dp)) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/210991d4-790b-42f3-ac1b-1f84c4fb1a1b_1683980189.2906406.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strLength(int len, int zero, int one, vector<int>& dp){\\n        int MOD = 1e9 + 7;\\n        if(len == 0){\\n            return 1;\\n        }\\n        if(len < 0){\\n            return 0;\\n        }\\n\\n        int &result = dp[len];\\n        if(dp[len] != -1){\\n            return result;\\n        }\\n\\n        result = (strLength(len-zero, zero, one, dp) + strLength(len-one,zero,one,dp)) % MOD;\\n        return result;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int MOD = 1e9 + 7;\\n        vector<int> dp;\\n        dp.resize(high+1, -1);\\n\\n        long long ans = 0;\\n        for(int len=low; len<=high; len++){\\n            ans = (ans + strLength(len, zero, one, dp)) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519611,
                "title": "rust-iterative-dp",
                "content": "\\n```\\nimpl Solution {\\n    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {\\n        let m: i64 = 1_000_000_007;\\n        let mut dp: Vec<i64> = vec![0; high as usize + 1];\\n        dp[0] = 1;\\n\\n        for i in (0..high as usize + 1) {\\n            if i >= zero as usize { dp[i] += dp[i - zero as usize]; }\\n            if i >= one as usize { dp[i] += dp[i - one as usize]; }\\n            dp[i] = dp[i].rem_euclid(m);\\n        }\\n\\n        dp.into_iter().skip(low as usize).fold(0, |acc, e| (acc + e).rem_euclid(m)) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {\\n        let m: i64 = 1_000_000_007;\\n        let mut dp: Vec<i64> = vec![0; high as usize + 1];\\n        dp[0] = 1;\\n\\n        for i in (0..high as usize + 1) {\\n            if i >= zero as usize { dp[i] += dp[i - zero as usize]; }\\n            if i >= one as usize { dp[i] += dp[i - one as usize]; }\\n            dp[i] = dp[i].rem_euclid(m);\\n        }\\n\\n        dp.into_iter().skip(low as usize).fold(0, |acc, e| (acc + e).rem_euclid(m)) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519548,
                "title": "fastest-easiest-beginner-friendly-c-explanation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires counting the number of good strings within a given range. Good strings are those that satisfy certain conditions. We can use dynamic programming to solve this problem efficiently. The intuition behind the solution is to build the count of good strings incrementally, considering the available options at each step. By iterating through the lengths and updating the count based on the number of \\'0\\'s and \\'1\\'s, we can determine the count of good strings up to a certain length. This approach allows us to avoid redundant calculations and obtain the final count within the given range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize a count for each possible length of the string and update it based on the conditions. By considering the available \\'0\\'s and \\'1\\'s, we incrementally build the count of good strings. Using a bottom-up approach, we iterate through the lengths and update the counts accordingly. Finally, we sum up the counts within the desired range to obtain the result. This dynamic programming solution optimizes the calculation process by reusing previously computed counts, leading to an efficient count of good strings within the given range.\\n\\n# Complexity\\n- Time complexity:O(high)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(high)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1);\\n        dp[0]=1;\\n        int mod=1000000007;\\n        for(int i=min(zero,one);i<=high;i++){\\n            if(i>=zero){\\n                dp[i]=(dp[i]+dp[i-zero])%mod;\\n            }\\n            if(i>=one){\\n                dp[i]=(dp[i]+dp[i-one])%mod;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=low;i<=high;i++){\\n            sum=(sum+dp[i])%mod;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high+1);\\n        dp[0]=1;\\n        int mod=1000000007;\\n        for(int i=min(zero,one);i<=high;i++){\\n            if(i>=zero){\\n                dp[i]=(dp[i]+dp[i-zero])%mod;\\n            }\\n            if(i>=one){\\n                dp[i]=(dp[i]+dp[i-one])%mod;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=low;i<=high;i++){\\n            sum=(sum+dp[i])%mod;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519417,
                "title": "2466-count-ways-to-build-good-strings-java",
                "content": "```\\nclass Solution {\\n    int modulo=(int)1e9+7;\\n    public int solve(int len,int [] dp,int zero,int one)\\n    {\\n        if(len<0)\\n            return 0;\\n        if(len==0)\\n            return 1;\\n        if(dp[len]!=-1)\\n            return dp[len];\\n        return  dp[len] =(solve(len-zero,dp,zero,one)%modulo+solve(len-one,dp,zero,one)%modulo)%modulo;\\n    }\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        for(int i=low;i<=high;i++)\\n            ans=(ans+solve(i,dp,zero,one))%modulo;\\n        return ans;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int modulo=(int)1e9+7;\\n    public int solve(int len,int [] dp,int zero,int one)\\n    {\\n        if(len<0)\\n            return 0;\\n        if(len==0)\\n            return 1;\\n        if(dp[len]!=-1)\\n            return dp[len];\\n        return  dp[len] =(solve(len-zero,dp,zero,one)%modulo+solve(len-one,dp,zero,one)%modulo)%modulo;\\n    }\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        for(int i=low;i<=high;i++)\\n            ans=(ans+solve(i,dp,zero,one))%modulo;\\n        return ans;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519085,
                "title": "recursive-memorization-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1,-1);\\n        int sum=0;\\n        for(int i=low;i<=high;i++)\\n            sum=(sum%mod+count(dp,i,zero,one)%mod)%mod;\\n        return sum;\\n    }\\n    int count(vector<int>& dp,int high,int zero,int one)\\n    {\\n        if(high==0)\\n            return 1;\\n        if(high<0)\\n            return 0;\\n        \\n        if(dp[high]!=-1)\\n            return dp[high];\\n        \\n        int p = count(dp,high-zero,zero,one);\\n        int q = count(dp,high-one,zero,one);\\n        \\n        return dp[high] = (p+q)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1,-1);\\n        int sum=0;\\n        for(int i=low;i<=high;i++)\\n            sum=(sum%mod+count(dp,i,zero,one)%mod)%mod;\\n        return sum;\\n    }\\n    int count(vector<int>& dp,int high,int zero,int one)\\n    {\\n        if(high==0)\\n            return 1;\\n        if(high<0)\\n            return 0;\\n        \\n        if(dp[high]!=-1)\\n            return dp[high];\\n        \\n        int p = count(dp,high-zero,zero,one);\\n        int q = count(dp,high-one,zero,one);\\n        \\n        return dp[high] = (p+q)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518922,
                "title": "count-all-possible-combinations-and-take-care-of-the-repeated-values",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    \\n    int solve(int s, int l, int h ,int z , int o,vector<int> &cache)\\n    {\\n        if(s>h) return 0;\\n        if(cache[s]!=-1)\\n            return cache[s];\\n        int res = 0;\\n        if(s<l) res = 0; else res =1;\\n        \\n        res = res%mod + solve(s+z,l,h,z,o,cache)%mod;\\n        res%=mod;\\n        res = res%mod + solve(s+o,l,h,z,o,cache)%mod;\\n        res%=mod;\\n        return cache[s] = res;\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        \\n        vector<int> cache(h+1,-1);\\n        return solve(0,l,h,z,o,cache)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    \\n    int solve(int s, int l, int h ,int z , int o,vector<int> &cache)\\n    {\\n        if(s>h) return 0;\\n        if(cache[s]!=-1)\\n            return cache[s];\\n        int res = 0;\\n        if(s<l) res = 0; else res =1;\\n        \\n        res = res%mod + solve(s+z,l,h,z,o,cache)%mod;\\n        res%=mod;\\n        res = res%mod + solve(s+o,l,h,z,o,cache)%mod;\\n        res%=mod;\\n        return cache[s] = res;\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        \\n        vector<int> cache(h+1,-1);\\n        return solve(0,l,h,z,o,cache)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518920,
                "title": "dp-memoization-recursive-tree-draw-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![1.jpg](https://assets.leetcode.com/users/images/3efe73d0-bad7-460e-a52d-f53367943607_1683965940.573155.jpeg)\\n\\n**For the above example lets simulate the all possible string.**\\n\\n![2222.jpg](https://assets.leetcode.com/users/images/63eebf40-0a05-4e8b-ab59-0adbc4bc0c34_1683966064.2941892.jpeg)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(maximumLengthOfString)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(maximumLengthOfString)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cntOfZero,cntOfOne;\\n    int upper,lower;\\n    int MOD=1e9+7;\\n\\n    int solve(int len, vector<int>&dp){\\n        //base case\\n        if(len>upper){\\n            return 0;\\n        }\\n\\n        // if the result is already calculated\\n        if(dp[len]!=-1){\\n            return dp[len];\\n        }\\n\\n        /*recurrence relation*/\\n        // left subtree for 0.\\n        int left;\\n        if( (len+cntOfZero)>=lower && (len+cntOfZero)<=upper){\\n            left=1+solve(len+cntOfZero,dp);\\n        }\\n        else{\\n            left=solve(len+cntOfZero,dp);\\n        }\\n        // right subtree for 1.\\n        int right;\\n        if( (len+cntOfOne)>=lower && (len+cntOfOne)<=upper){\\n            right=1+solve(len+cntOfOne,dp);\\n        }\\n        else{\\n            right=solve(len+cntOfOne,dp);\\n        }\\n\\n        int ans= (left+right) % MOD;\\n        return dp[len]=ans;\\n    }\\n\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        cntOfZero=zero;\\n        cntOfOne=one;\\n        upper=high;\\n        lower=low;\\n        \\n        vector<int>dp(high+1,-1);\\n        return solve(0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cntOfZero,cntOfOne;\\n    int upper,lower;\\n    int MOD=1e9+7;\\n\\n    int solve(int len, vector<int>&dp){\\n        //base case\\n        if(len>upper){\\n            return 0;\\n        }\\n\\n        // if the result is already calculated\\n        if(dp[len]!=-1){\\n            return dp[len];\\n        }\\n\\n        /*recurrence relation*/\\n        // left subtree for 0.\\n        int left;\\n        if( (len+cntOfZero)>=lower && (len+cntOfZero)<=upper){\\n            left=1+solve(len+cntOfZero,dp);\\n        }\\n        else{\\n            left=solve(len+cntOfZero,dp);\\n        }\\n        // right subtree for 1.\\n        int right;\\n        if( (len+cntOfOne)>=lower && (len+cntOfOne)<=upper){\\n            right=1+solve(len+cntOfOne,dp);\\n        }\\n        else{\\n            right=solve(len+cntOfOne,dp);\\n        }\\n\\n        int ans= (left+right) % MOD;\\n        return dp[len]=ans;\\n    }\\n\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        cntOfZero=zero;\\n        cntOfOne=one;\\n        upper=high;\\n        lower=low;\\n        \\n        vector<int>dp(high+1,-1);\\n        return solve(0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518845,
                "title": "space-optimization-o-max-one-zero",
                "content": "\\n we can optimize space \\nwhile calculating dp[i] , we need values only upto dp[i-max(one , zero)]\\nat any point we only store values of dp[i-1] to dp[i-max(one,zero)] \\nanything behind dp[i-max(one , zero)] is not of use \\nand if it is not used by dp[i] is wont be used by any index > i \\nlet m = max(one , zero)\\nso we can use a dp array of size m\\nand use index i%m to store the current result ie dp[i]\\nto get dp[i-x] we use the value dp [ (i-x+m) % m ] \\n\\t\\n```\\nint countGoodStrings(int low, int high, int zero, int one) {\\n        int m = max(zero , one);\\n        vector<int> dp(m , 0);\\n        dp[0] = 1; \\n        int ans = 0 , mod = 1e9 + 7 ;\\n        for(int i = 1 ; i<= high  ; i++)\\n        {\\n            int op1 = (i-zero >= 0) ? dp[(i-zero + m) % m ] : 0 ;\\n            int op2 = (i-one >= 0) ? dp[(i-one + m) % m] : 0 ;\\n            \\n            int here = (op1 + op2) % mod;\\n            if(i>=low ) ans = (ans +here) % mod;\\n            \\n            dp[i%m] = here;\\n        }\\n        return ans;\\n        \\n        // O(high) time , O(max(zero , one)) space \\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countGoodStrings(int low, int high, int zero, int one) {\\n        int m = max(zero , one);\\n        vector<int> dp(m , 0);\\n        dp[0] = 1; \\n        int ans = 0 , mod = 1e9 + 7 ;\\n        for(int i = 1 ; i<= high  ; i++)\\n        {\\n            int op1 = (i-zero >= 0) ? dp[(i-zero + m) % m ] : 0 ;\\n            int op2 = (i-one >= 0) ? dp[(i-one + m) % m] : 0 ;\\n            \\n            int here = (op1 + op2) % mod;\\n            if(i>=low ) ans = (ans +here) % mod;\\n            \\n            dp[i%m] = here;\\n        }\\n        return ans;\\n        \\n        // O(high) time , O(max(zero , one)) space \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518832,
                "title": "beats-100-c-using-memoization",
                "content": "# Approach\\nCode Summary:\\n- The code is a C++ solution to the problem of counting good strings within a given range of string lengths, with a given number of zeros and ones.\\n- A good string is defined as a string where there are no adjacent identical characters.\\n- The approach taken in this code is a recursive approach using memoization.\\n- The function solve takes in the current length of the string, the number of zeros and ones remaining, the lower and upper bounds for the string length, and a vector to store previously calculated values. The function returns the number of good strings that can be formed with the given parameters.\\n- The function first checks if the current length of the string is greater than the upper bound, in which case it returns 0 since no good string can be formed beyond the given range.\\n- It then checks if the number of good strings with the given parameters has already been calculated and stored in the memoization vector. If yes, it returns the stored value.\\n- The function then calculates the two possible next lengths for the string, one with an added zero and the other with an added one, and adds them to the current length.\\n- It then counts the number of good strings that can be formed with each of these lengths, taking into account the remaining zeros and ones, and the lower and upper bounds for the string length.\\n- It adds the count for each of these lengths and returns the result, which is also stored in the memoization vector for future use.\\n- The countGoodStrings function takes in the lower and upper bounds for the string length, and the number of zeros and ones, and initializes the memoization vector. It then calls the solve function with the initial length of 0 and returns the result.\\n\\n# Complexity\\nTime Complexity:\\n- The time complexity of the code is O(N)\\n- Each value of solve is calculated only once and stored in the memoization vector.\\n- As a result, the time complexity is reduced from an exponential time complexity to a polynomial time complexity.\\n\\nSpace Complexity:\\n- The space complexity of the code is O(N), since the size of the memoization vector is N+1.\\n- The space complexity is linear, since only a single vector is used to store previously calculated values.\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int mod=1e9+7;\\n    int solve(int n,int z,int o,int low,int high,vector<int>&dp)\\n    {\\n        if(n>high) return 0;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        int s1=n+z,s2=n+o;\\n        \\n        int cnt=0;\\n        if(n>=low && n<=high) cnt+=1;\\n\\n        cnt+=(solve(s1,z,o,low,high,dp)%mod+solve(s2,z,o,low,high,dp)%mod)%mod;\\n        return dp[n]=cnt%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int>dp(high+1,-1);\\n        return solve(0,zero,one,low,high,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int mod=1e9+7;\\n    int solve(int n,int z,int o,int low,int high,vector<int>&dp)\\n    {\\n        if(n>high) return 0;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        int s1=n+z,s2=n+o;\\n        \\n        int cnt=0;\\n        if(n>=low && n<=high) cnt+=1;\\n\\n        cnt+=(solve(s1,z,o,low,high,dp)%mod+solve(s2,z,o,low,high,dp)%mod)%mod;\\n        return dp[n]=cnt%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int>dp(high+1,-1);\\n        return solve(0,zero,one,low,high,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518827,
                "title": "recursion-memoization-c-code",
                "content": "\\n\\n# Recursion Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int cLen, int zero, int one, int low, int high){\\n        if(cLen>high) return 0;\\n\\n        int ans = 0;\\n        if(cLen>=low and cLen<=high) ans = 1;\\n        \\n        ans = ans + helper(cLen+zero,zero,one,low,high);\\n        ans = ans + helper(cLen+one, zero,one,low, high);\\n        return ans;\\n\\n        \\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return helper(0,zero,one,low,high);\\n    }\\n};\\n```\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int helper(int cLen, int zero, int one, int low, int high, vector<int> &dp){\\n        if(cLen>high) return 0;\\n        if(dp[cLen]!=-1) return dp[cLen];\\n\\n        int ans = 0;\\n        if(cLen>=low and cLen<=high) ans = 1;\\n        \\n        ans = (ans%mod + helper(cLen+zero,zero,one,low,high,dp)%mod)%mod;\\n        ans = (ans%mod + helper(cLen+one, zero,one,low, high,dp)%mod)%mod;\\n        return dp[cLen] = ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector< int> dp(high+1, -1);\\n        return helper(0,zero,one,low,high,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int cLen, int zero, int one, int low, int high){\\n        if(cLen>high) return 0;\\n\\n        int ans = 0;\\n        if(cLen>=low and cLen<=high) ans = 1;\\n        \\n        ans = ans + helper(cLen+zero,zero,one,low,high);\\n        ans = ans + helper(cLen+one, zero,one,low, high);\\n        return ans;\\n\\n        \\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return helper(0,zero,one,low,high);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int helper(int cLen, int zero, int one, int low, int high, vector<int> &dp){\\n        if(cLen>high) return 0;\\n        if(dp[cLen]!=-1) return dp[cLen];\\n\\n        int ans = 0;\\n        if(cLen>=low and cLen<=high) ans = 1;\\n        \\n        ans = (ans%mod + helper(cLen+zero,zero,one,low,high,dp)%mod)%mod;\\n        ans = (ans%mod + helper(cLen+one, zero,one,low, high,dp)%mod)%mod;\\n        return dp[cLen] = ans;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector< int> dp(high+1, -1);\\n        return helper(0,zero,one,low,high,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518752,
                "title": "easy-dp-iterative-approach-c-easy-to-understand",
                "content": "# Intuition\\nIt look like a question that can be solved with recursion and later optimized using dp memoization.\\n- It can be done using recursion with dfs\\n- I dont know how to use trees so tried iterative approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start with ``` count = 0 ``` and an array with a size high + 1 all initialized with zero like this ``` vector<int> dp(high + 1, 0) ```.\\n2. Now set ``` dp[0] = 1``` to make a starting point.\\n3. Now run a loop from ```1 ```-> ``` high ``` and do two things.\\n4. First check ``` if (k >= zero) ``` and add it into your ```dp``` array.\\n5. Next do the same with ``` if( k >= one) ``` and add it in your ```dp ``` array.\\n6. Finally now run a loop from ```k ``` -> ```high``` and store this in ``` count ``` variable we created in step 1 \\n7. We return ``` count ``` as our ans\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        int count = 0;\\n        vector<int> dp(high + 1, 0);\\n        dp[0] = 1;\\n\\n        for(int k = 1; k <= high; k++) {\\n            if(k >= zero) {\\n                dp[k] += dp[k - zero];\\n                dp[k] = dp[k] % mod;\\n            }\\n\\n            if(k >= one) {\\n                dp[k] += dp[k - one];\\n                dp[k] = dp[k] % mod;\\n            }\\n        }\\n        for(int k = low; k <=high; k++) {\\n            count += dp[k];\\n            count = count % mod;\\n        }\\n        return count;\\n\\n    }\\n};\\n```\\n> Upvote if got it right \\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` count = 0 ```\n``` vector<int> dp(high + 1, 0) ```\n``` dp[0] = 1```\n```1 ```\n``` high ```\n``` if (k >= zero) ```\n```dp```\n``` if( k >= one) ```\n```dp ```\n```k ```\n```high```\n``` count ```\n``` count ```\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        int count = 0;\\n        vector<int> dp(high + 1, 0);\\n        dp[0] = 1;\\n\\n        for(int k = 1; k <= high; k++) {\\n            if(k >= zero) {\\n                dp[k] += dp[k - zero];\\n                dp[k] = dp[k] % mod;\\n            }\\n\\n            if(k >= one) {\\n                dp[k] += dp[k - one];\\n                dp[k] = dp[k] % mod;\\n            }\\n        }\\n        for(int k = low; k <=high; k++) {\\n            count += dp[k];\\n            count = count % mod;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518717,
                "title": "c-recursion-memorization-very-easy-coin-change-approach",
                "content": "Please Upvote :)\\n\\n# Approach\\nThink it as a Coin Change problem where you have to make to total of (i) rupee using (zero) & (one) rupee coin, we count the total number of ways to do so and then add them. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1,-1);\\n        int sum=0;\\n        for(int i=low;i<=high;i++)\\n            sum=(sum%mod+count(dp,i,zero,one)%mod)%mod;\\n        return sum;\\n    }\\n    int count(vector<int>& dp,int high,int zero,int one)\\n    {\\n        if(high==0)\\n            return 1;\\n        if(high<0)\\n            return 0;\\n        \\n        if(dp[high]!=-1)\\n            return dp[high];\\n        \\n        int p = count(dp,high-zero,zero,one);\\n        int q = count(dp,high-one,zero,one);\\n        \\n        return dp[high] = (p+q)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1,-1);\\n        int sum=0;\\n        for(int i=low;i<=high;i++)\\n            sum=(sum%mod+count(dp,i,zero,one)%mod)%mod;\\n        return sum;\\n    }\\n    int count(vector<int>& dp,int high,int zero,int one)\\n    {\\n        if(high==0)\\n            return 1;\\n        if(high<0)\\n            return 0;\\n        \\n        if(dp[high]!=-1)\\n            return dp[high];\\n        \\n        int p = count(dp,high-zero,zero,one);\\n        int q = count(dp,high-one,zero,one);\\n        \\n        return dp[high] = (p+q)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518714,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {\\n        let mut dp = vec![0; high as usize + 1];\\n        dp[0] = 1;\\n        let m = 1_000_000_007;\\n\\n        for end in 1..=high {\\n            if end >= zero{\\n                dp[end as usize] += dp[(end-zero) as usize];\\n            }\\n            if end >= one{\\n                dp[end as usize] += dp[(end-one) as usize];\\n            }\\n            dp[end as usize] %= m;\\n        }\\n        (low..=high).fold(0, |sum, i| (sum + dp[i as usize]) % m)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {\\n        let mut dp = vec![0; high as usize + 1];\\n        dp[0] = 1;\\n        let m = 1_000_000_007;\\n\\n        for end in 1..=high {\\n            if end >= zero{\\n                dp[end as usize] += dp[(end-zero) as usize];\\n            }\\n            if end >= one{\\n                dp[end as usize] += dp[(end-one) as usize];\\n            }\\n            dp[end as usize] %= m;\\n        }\\n        (low..=high).fold(0, |sum, i| (sum + dp[i as usize]) % m)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518668,
                "title": "12-lines-beats-100-java-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high+1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        for(int i=1;i<=high;i++){\\n            dp[i]=((i-zero>=0?dp[i-zero]:0)+(i-one>=0?dp[i-one]:0))%mod;\\n            if(i>=low){\\n                ans = (ans + dp[i])%mod;\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[] = new int[high+1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        int mod = 1000000007;\\n        for(int i=1;i<=high;i++){\\n            dp[i]=((i-zero>=0?dp[i-zero]:0)+(i-one>=0?dp[i-one]:0))%mod;\\n            if(i>=low){\\n                ans = (ans + dp[i])%mod;\\n            }\\n        }\\n        return ans;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518569,
                "title": "c-easy-recursion-memoization-tabulation",
                "content": "# Intuition\\n\\nBoth the choices are necessary i.e append one and append zero . So we need summation of the two for computing our total no of ways of building good string .\\n\\n# Approach\\nWe can start from zero , and try both the choices and add them to our result . And also , at each step we need to check if we haeve broken the rules (index>high) and if we have a good string (index>=low and index<=high) . If we have a good string we dont have to stop , we will just add 1 to our result variable to keep counting no. of good strings.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    \\n    int tab(int low,int high,int zero ,int one){\\n        \\n        vector<int> dp(high+1,0);\\n\\n        for(int i=high;i>=0;i--){\\n            int result = 0;\\n            if(i>=low and i<=high) result+=1;\\n\\n            int appendZero = (i+zero<=high) ? dp[i+zero]%mod : 0;\\n            int appendOne = (i+one<=high) ? dp[i+one]%mod : 0 ;\\n\\n            result += (appendZero+appendOne)%mod;\\n\\n            dp[i]=result%mod;\\n        }\\n\\n        return dp[0];\\n    }\\n    int memo(int i,int low ,int high,int zero,int one , vector<int> &dp){\\n        \\n        if(i>high) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n\\n        int result = 0;\\n        if(i>=low and i<=high) result+=1;\\n\\n        int appendZero = memo(i+zero,low,high,zero,one,dp)%mod;\\n        int appendOne = memo(i+one,low,high,zero,one,dp)%mod;\\n\\n        result += (appendZero+appendOne)%mod;\\n\\n        return dp[i]=result%mod;\\n\\n    }\\n    int recur(int i , int low , int high,int zero,int one){\\n    \\n        if(i>high) return 0;\\n        int result = 0;\\n        if(i>=low and i<=high) result+=1;\\n\\n        int appendZero = recur(i+zero,low,high,zero,one)%mod;\\n        int appendOne = recur(i+one,low,high,zero,one)%mod;\\n\\n        result += (appendZero+appendOne)%mod;\\n\\n        return result%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) { \\n        // return recur(0,low,high,zero,one);\\n\\n        // vector<int> dp(high+1,-1);\\n        // return memo(0,low,high,zero,one,dp);\\n\\n        return tab(low,high,zero,one);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    \\n    int tab(int low,int high,int zero ,int one){\\n        \\n        vector<int> dp(high+1,0);\\n\\n        for(int i=high;i>=0;i--){\\n            int result = 0;\\n            if(i>=low and i<=high) result+=1;\\n\\n            int appendZero = (i+zero<=high) ? dp[i+zero]%mod : 0;\\n            int appendOne = (i+one<=high) ? dp[i+one]%mod : 0 ;\\n\\n            result += (appendZero+appendOne)%mod;\\n\\n            dp[i]=result%mod;\\n        }\\n\\n        return dp[0];\\n    }\\n    int memo(int i,int low ,int high,int zero,int one , vector<int> &dp){\\n        \\n        if(i>high) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n\\n        int result = 0;\\n        if(i>=low and i<=high) result+=1;\\n\\n        int appendZero = memo(i+zero,low,high,zero,one,dp)%mod;\\n        int appendOne = memo(i+one,low,high,zero,one,dp)%mod;\\n\\n        result += (appendZero+appendOne)%mod;\\n\\n        return dp[i]=result%mod;\\n\\n    }\\n    int recur(int i , int low , int high,int zero,int one){\\n    \\n        if(i>high) return 0;\\n        int result = 0;\\n        if(i>=low and i<=high) result+=1;\\n\\n        int appendZero = recur(i+zero,low,high,zero,one)%mod;\\n        int appendOne = recur(i+one,low,high,zero,one)%mod;\\n\\n        result += (appendZero+appendOne)%mod;\\n\\n        return result%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) { \\n        // return recur(0,low,high,zero,one);\\n\\n        // vector<int> dp(high+1,-1);\\n        // return memo(0,low,high,zero,one,dp);\\n\\n        return tab(low,high,zero,one);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518556,
                "title": "easy-and-simple-solution-in-javascript-wow-0-0-this-almost-looks-like-to-editorial-but-in-js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nfunction countGoodStrings(low, high, zero, one) {\\n        // Use dp[i] to record to number of good strings of length i.\\n        let dp = new Array(high + 1).fill(0);\\n        dp[0] = 1;\\n        let mod = 1_000_000_007;\\n        \\n        // Iterate over each length `end`.\\n        for (end = 1; end <= high; ++end) {\\n            // check if the current string can be made by append zero `0`s or one `1`s.\\n            if (end >= zero) {\\n                dp[end] += dp[end - zero];\\n            }\\n            if (end >= one) {\\n                dp[end] += dp[end - one];\\n            }\\n            dp[end] %= mod;\\n        }\\n        \\n        // Add up the number of strings with each valid length [low ~ high].\\n        let answer = 0;\\n        for (i = low; i <= high; ++i) {\\n            answer += dp[i];\\n            answer %= mod;\\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nfunction countGoodStrings(low, high, zero, one) {\\n        // Use dp[i] to record to number of good strings of length i.\\n        let dp = new Array(high + 1).fill(0);\\n        dp[0] = 1;\\n        let mod = 1_000_000_007;\\n        \\n        // Iterate over each length `end`.\\n        for (end = 1; end <= high; ++end) {\\n            // check if the current string can be made by append zero `0`s or one `1`s.\\n            if (end >= zero) {\\n                dp[end] += dp[end - zero];\\n            }\\n            if (end >= one) {\\n                dp[end] += dp[end - one];\\n            }\\n            dp[end] %= mod;\\n        }\\n        \\n        // Add up the number of strings with each valid length [low ~ high].\\n        let answer = 0;\\n        for (i = low; i <= high; ++i) {\\n            answer += dp[i];\\n            answer %= mod;\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518487,
                "title": "best-c-code-o-high",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(high)\\n\\n- Space complexity:\\nO(high)\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int countGoodStrings(int low, int high, int zero, int one) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    int ans = 0;\\n    // dp[i] := # of good strings with length i\\n    vector<int> dp(high + 1);\\n    dp[0] = 1;\\n\\n    for (int i = 1; i <= high; ++i) {\\n      if (i >= zero)\\n        dp[i] = (dp[i] + dp[i - zero]) % kMod;\\n      if (i >= one)\\n        dp[i] = (dp[i] + dp[i - one]) % kMod;\\n      if (i >= low)\\n        ans = (ans + dp[i]) % kMod;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int countGoodStrings(int low, int high, int zero, int one) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    int ans = 0;\\n    // dp[i] := # of good strings with length i\\n    vector<int> dp(high + 1);\\n    dp[0] = 1;\\n\\n    for (int i = 1; i <= high; ++i) {\\n      if (i >= zero)\\n        dp[i] = (dp[i] + dp[i - zero]) % kMod;\\n      if (i >= one)\\n        dp[i] = (dp[i] + dp[i - one]) % kMod;\\n      if (i >= low)\\n        ans = (ans + dp[i]) % kMod;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518454,
                "title": "beats-100-java-c-python3-forward-style-dp-iterative-solution",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\n**Dont forget to upvote if you like the content below. \\uD83D\\uDE43**\\n\\n\\n[TOC]\\n\\n# Problem\\nThe problem involves creating \"good strings\" with a length within the range `[low, high]`. A \"good string\" is defined as a string that does not have more than `zero` consecutive \\'0\\'s and `one` consecutive \\'1\\'s.\\n\\n---\\n\\n# Normal solution (Beats 100% time)\\n\\n## Approach\\nThe approach is based on Dynamic Programming (DP). \\n\\nFirst, a check is made to see if `zero > one`. If this is the case, we call the same function but swap `zero` and `one`. This is due to the fact that the type of characters (0 or 1) is interchangeable, and we want to ensure `zero <= one` for the following steps.\\n\\nA DP array `dp` of size `high + 1` is then initialized, where `dp[i]` means how many \"good strings\" of length `i` we can build, with `dp[0] = 1`, as there is one way to build a string of length zero: an empty string.\\n\\nWe then iterate over `i` from 1 to `high`:\\n\\n- If `i` is greater than or equal to `one`, we set `dp[i]` to `dp[i - zero] + dp[i - one]`. This update signifies the ways of building strings of length `i` by appending a \\'0\\' to strings of `i-zero` lengths and \\'1\\' to strings of `i-one` lengths, while adhering to the maximum consecutive counts.\\n\\n- If `i` is less than `one` but greater than or equal to `zero`, we set `dp[i]` to `dp[i - zero]`. *This little optimisation was made because after some time `i` will always be greater than `zero` and execution will not ever fall into this branch again.*\\n\\n- If `i` is greater than or equal to `low`, we update our answer `ans` by adding `dp[i]`. Strings of length `i` contribute to our final count of good strings.\\n\\nFinally, we return `ans` modulo `MOD`, as the problem asks for the answer modulo `1e9 + 7`.\\n\\n\\n**Note:** according to modular arithmetic, `(a + b) % c = (a % c + b % c) % c`. This property allows us to take the modulus at each step rather than at the end, preventing potential overflow if `a + b` exceeds the limit of the data type.\\n\\n\\n## Complexity\\n- Time complexity: $$O(high)$$ due to the single pass through the `dp` array.\\n- Space complexity: $$O(high)$$ as we use a `dp` array of size `high + 1`.\\n\\n## Code\\n```java []\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        if (zero > one) {\\n            return countGoodStrings(low, high, one, zero);\\n        }\\n        int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            if (i >= one) {\\n                dp[i] = (dp[i - zero] + dp[i - one]) % MOD;\\n            } else if (i >= zero) {\\n                dp[i] = dp[i - zero] % MOD;\\n            }\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        if (zero > one) {\\n            return countGoodStrings(low, high, one, zero);\\n        }\\n        vector<int> dp(high + 1, 0);\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            if (i >= one) {\\n                dp[i] = (dp[i - zero] + dp[i - one]) % MOD;\\n            } else if (i >= zero) {\\n                dp[i] = dp[i - zero] % MOD;\\n            }\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n``` python3 []\\nclass Solution:\\n    MOD = 10**9 + 7\\n\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        if zero > one:\\n            zero, one = one, zero\\n        dp = [0] * (high + 1)\\n        dp[0] = 1\\n        ans = 0\\n        for i in range(1, high + 1):\\n            if i >= one:\\n                dp[i] = (dp[i - zero] + dp[i - one]) % self.MOD\\n            elif i >= zero:\\n                dp[i] = dp[i - zero] % self.MOD\\n            if i >= low:\\n                ans = (ans + dp[i]) % self.MOD\\n        return ans\\n\\n```\\n---\\n# Optimised solution (Beats 100% time and memory)\\n\\n## Approach\\nThe approach is based on optimization through the GCD of `zero` and `one` and reducing space for `dp`.\\n\\nThe function `countGoodStrings` first calculates the GCD of `zero` and `one` using Stein\\'s algorithm. It then calls a helper function `count` with `low`, `high`, `zero`, and `one` divided by the GCD. This scales down the problem space, effectively reducing the time and space complexities.\\n\\nThe helper function `count` follows the same logic as the non-optimized solution, but with `zero` and `one` divided by the GCD, and the `dp` array size is now `one+1` (also divided by the GCD). In addition, the `dp` array is now indexed using the modulus operator to save space.\\n\\n*Instead of keeping track of all `i` from 1 to `high`, this solution only maintains a window of the last `one + 1` results (`dp[i % n]`). This is because for any `i` larger than `one`, the result only depends on the `i - one` and `i - zero` results. This technique significantly reduces the space requirement.*\\n\\n## Complexity\\nLet\\'s denote `GCD` as `g`. \\n\\n- Time complexity: $$O(\\\\log(\\\\min(zero, one))) + O(\\\\frac{high}{g})$$ due to Stein\\'s algorithm and the DP loop.\\n- Space complexity: $$O(\\\\frac{one}{g})$$ as we use a `dp` array of size `one/g + 1`.\\n\\n## Code\\n``` java\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int gcd = gcdBySteinsAlgorithm(zero, one);\\n        return count((low + gcd - 1) / gcd, high / gcd, zero / gcd, one / gcd);\\n    }\\n\\n    private static int count(int low, int high, int zero, int one) {\\n        if (zero > one) {\\n            return count(low, high, one, zero);\\n        }\\n        int n = one + 1;\\n        int[] dp = new int[one + 1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            if (i >= one) {\\n                dp[i % n] = (dp[(i - zero) % n] + dp[(i - one) % n]) % MOD;\\n            } else if (i >= zero) {\\n                dp[i % n] = (dp[(i - zero) % n]) % MOD;\\n            }\\n            if (i >= low) {\\n                ans = (ans + dp[i % n]) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int gcdBySteinsAlgorithm(int n1, int n2) {\\n        if (n1 == 0) {\\n            return n2;\\n        }\\n        if (n2 == 0) {\\n            return n1;\\n        }\\n\\n        int n;\\n        for (n = 0; ((n1 | n2) & 1) == 0; n++) {\\n            n1 >>= 1;\\n            n2 >>= 1;\\n        }\\n\\n        while ((n1 & 1) == 0) {\\n            n1 >>= 1;\\n        }\\n\\n        do {\\n            while ((n2 & 1) == 0) {\\n                n2 >>= 1;\\n            }\\n            if (n1 > n2) {\\n                int temp = n1;\\n                n1 = n2;\\n                n2 = temp;\\n            }\\n            n2 = (n2 - n1);\\n        } while (n2 != 0);\\n\\n        return n1 << n;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```java []\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        if (zero > one) {\\n            return countGoodStrings(low, high, one, zero);\\n        }\\n        int[] dp = new int[high + 1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            if (i >= one) {\\n                dp[i] = (dp[i - zero] + dp[i - one]) % MOD;\\n            } else if (i >= zero) {\\n                dp[i] = dp[i - zero] % MOD;\\n            }\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        if (zero > one) {\\n            return countGoodStrings(low, high, one, zero);\\n        }\\n        vector<int> dp(high + 1, 0);\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            if (i >= one) {\\n                dp[i] = (dp[i - zero] + dp[i - one]) % MOD;\\n            } else if (i >= zero) {\\n                dp[i] = dp[i - zero] % MOD;\\n            }\\n            if (i >= low) {\\n                ans = (ans + dp[i]) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` python3 []\\nclass Solution:\\n    MOD = 10**9 + 7\\n\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        if zero > one:\\n            zero, one = one, zero\\n        dp = [0] * (high + 1)\\n        dp[0] = 1\\n        ans = 0\\n        for i in range(1, high + 1):\\n            if i >= one:\\n                dp[i] = (dp[i - zero] + dp[i - one]) % self.MOD\\n            elif i >= zero:\\n                dp[i] = dp[i - zero] % self.MOD\\n            if i >= low:\\n                ans = (ans + dp[i]) % self.MOD\\n        return ans\\n\\n```\n``` java\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int gcd = gcdBySteinsAlgorithm(zero, one);\\n        return count((low + gcd - 1) / gcd, high / gcd, zero / gcd, one / gcd);\\n    }\\n\\n    private static int count(int low, int high, int zero, int one) {\\n        if (zero > one) {\\n            return count(low, high, one, zero);\\n        }\\n        int n = one + 1;\\n        int[] dp = new int[one + 1];\\n        dp[0] = 1;\\n        int ans = 0;\\n        for (int i = 1; i <= high; i++) {\\n            if (i >= one) {\\n                dp[i % n] = (dp[(i - zero) % n] + dp[(i - one) % n]) % MOD;\\n            } else if (i >= zero) {\\n                dp[i % n] = (dp[(i - zero) % n]) % MOD;\\n            }\\n            if (i >= low) {\\n                ans = (ans + dp[i % n]) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int gcdBySteinsAlgorithm(int n1, int n2) {\\n        if (n1 == 0) {\\n            return n2;\\n        }\\n        if (n2 == 0) {\\n            return n1;\\n        }\\n\\n        int n;\\n        for (n = 0; ((n1 | n2) & 1) == 0; n++) {\\n            n1 >>= 1;\\n            n2 >>= 1;\\n        }\\n\\n        while ((n1 & 1) == 0) {\\n            n1 >>= 1;\\n        }\\n\\n        do {\\n            while ((n2 & 1) == 0) {\\n                n2 >>= 1;\\n            }\\n            if (n1 > n2) {\\n                int temp = n1;\\n                n1 = n2;\\n                n2 = temp;\\n            }\\n            n2 = (n2 - n1);\\n        } while (n2 != 0);\\n\\n        return n1 << n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518426,
                "title": "using-dp-recursion-memoisation",
                "content": "# Intuition\\nUsing DP\\n\\n# Approach\\n Using Recursion -> repeating sub-problem -> memoization (DP)\\n\\n# Complexity\\n- Time complexity:\\n  O(High or Low)\\n\\n- Space complexity:\\nO(High)\\n\\n# Code\\n```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n\\n    // Using Recursion\\n    // memoization\\n    int lenGoodString(int len, vector<int> &dp, int zero, int one){\\n        if(len == 0) return 1;\\n        if(len < 0) return 0;\\n        if(dp[len] != -1) return dp[len];\\n        long long sum = (lenGoodString(len - one, dp, zero, one) + lenGoodString(len - zero, dp, zero, one))%mod;\\n\\n        return dp[len] = sum;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        int ans = 0;\\n        for(int len = low; len <= high; len++){\\n            ans = (ans + lenGoodString(len, dp, zero, one))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n\\n    // Using Recursion\\n    // memoization\\n    int lenGoodString(int len, vector<int> &dp, int zero, int one){\\n        if(len == 0) return 1;\\n        if(len < 0) return 0;\\n        if(dp[len] != -1) return dp[len];\\n        long long sum = (lenGoodString(len - one, dp, zero, one) + lenGoodString(len - zero, dp, zero, one))%mod;\\n\\n        return dp[len] = sum;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1, -1);\\n        int ans = 0;\\n        for(int len = low; len <= high; len++){\\n            ans = (ans + lenGoodString(len, dp, zero, one))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518394,
                "title": "c-dp-memoization-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(high-low)$$\\n\\n- Space complexity:$$O(high+1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int ans(int z, int o, int i, vector<int>&dp){\\n        if(i==0){return 1;}\\n        if(i<0){return 0;}\\n        if(dp[i]!=-1){return dp[i];}\\n        return dp[i]=(ans(z, o, i-z, dp)%M+ans(z, o, i-o, dp)%M)%M;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int cnt=0;\\n        vector<int>dp(high+1, -1);\\n        for(int i=low; i<=high; i++){\\n            cnt=(cnt%M+ans(zero, one, i, dp)%M)%M;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int ans(int z, int o, int i, vector<int>&dp){\\n        if(i==0){return 1;}\\n        if(i<0){return 0;}\\n        if(dp[i]!=-1){return dp[i];}\\n        return dp[i]=(ans(z, o, i-z, dp)%M+ans(z, o, i-o, dp)%M)%M;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int cnt=0;\\n        vector<int>dp(high+1, -1);\\n        for(int i=low; i<=high; i++){\\n            cnt=(cnt%M+ans(zero, one, i, dp)%M)%M;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518319,
                "title": "dynamic-programming-based-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n    MAX = 1000000007\\n    table = [0]*(high+1)\\n    table[zero] += 1\\n    table[one] += 1\\n    start = min(zero, one)\\n\\n    for i in range(start, high+1):\\n      # Fill in table[i]\\n      if i-zero >= 0:\\n        table[i] += table[i-zero] % MAX\\n      if i-one >= 0:\\n        table[i] += table[i-one] % MAX\\n    \\n    total_count = 0\\n    for i in range(low, high+1):\\n      total_count += table[i] % MAX\\n    return total_count % MAX\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n    MAX = 1000000007\\n    table = [0]*(high+1)\\n    table[zero] += 1\\n    table[one] += 1\\n    start = min(zero, one)\\n\\n    for i in range(start, high+1):\\n      # Fill in table[i]\\n      if i-zero >= 0:\\n        table[i] += table[i-zero] % MAX\\n      if i-one >= 0:\\n        table[i] += table[i-one] % MAX\\n    \\n    total_count = 0\\n    for i in range(low, high+1):\\n      total_count += table[i] % MAX\\n    return total_count % MAX\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518304,
                "title": "easy-c-dp-solution",
                "content": "```\\nclass Solution {\\n    \\n    const long M = 1e9+7;\\n    \\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        vector<int> dp(high+1,0);\\n        \\n        for(int i=0;i<=high;i++){\\n            if(i-zero>=0){\\n                dp[i] = (1+dp[i-zero]+dp[i])%(M);\\n            }\\n            if(i-one>=0){\\n                dp[i] = (1+dp[i-one]+dp[i])%(M);\\n            }\\n        }\\n        \\n        // for(int i=0;i<=high;i++){\\n        //     cout<<dp[i]<<\" \";\\n        // }\\n        \\n        return (dp[high]-dp[low-1]+M)%(M);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    const long M = 1e9+7;\\n    \\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        vector<int> dp(high+1,0);\\n        \\n        for(int i=0;i<=high;i++){\\n            if(i-zero>=0){\\n                dp[i] = (1+dp[i-zero]+dp[i])%(M);\\n            }\\n            if(i-one>=0){\\n                dp[i] = (1+dp[i-one]+dp[i])%(M);\\n            }\\n        }\\n        \\n        // for(int i=0;i<=high;i++){\\n        //     cout<<dp[i]<<\" \";\\n        // }\\n        \\n        return (dp[high]-dp[low-1]+M)%(M);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3518300,
                "title": "dp-ladder-variant-c-jump-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you see clearly it then it is like variant of Ladder problem in which number of ways we can reach at particular step depends on previous k steps. While in this question, to reach at high we can\\'t go thro from previous one steps since size of zero and one may be more than 1. So while writing bottom-up DP for each i we will subtract size of zero and one bcoz only from those location we can reach i.  \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int m=1000000007;\\n        vector<int>dp(high+1,0);\\n        dp[zero]=1;\\n        dp[one]+=1;\\n        int temp;\\n        int mini=min(zero,one);\\n        for(int i=mini+1;i<=high;i++){\\n            temp=i-zero;\\n            if(temp>0)\\n                dp[i]=(dp[i]+dp[temp])%m;;\\n            temp=i-one;\\n            if(temp>0)\\n                dp[i]=(dp[i]+dp[temp])%m;\\n        }\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans=(ans+dp[i])%m;\\n        }\\n            //cout <<x<<\",\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int m=1000000007;\\n        vector<int>dp(high+1,0);\\n        dp[zero]=1;\\n        dp[one]+=1;\\n        int temp;\\n        int mini=min(zero,one);\\n        for(int i=mini+1;i<=high;i++){\\n            temp=i-zero;\\n            if(temp>0)\\n                dp[i]=(dp[i]+dp[temp])%m;;\\n            temp=i-one;\\n            if(temp>0)\\n                dp[i]=(dp[i]+dp[temp])%m;\\n        }\\n        int ans=0;\\n        for(int i=low;i<=high;i++){\\n            ans=(ans+dp[i])%m;\\n        }\\n            //cout <<x<<\",\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3518280,
                "title": "brute-force-recursive-to-understand-all-calls-and-how-it-work-dp-solution-on-same-approach",
                "content": "**14/36 tle **\\n```\\n\\n```class Solution {\\nprivate:\\n    int solve(set<string>&st,string s,int low,int high,int zero,int one,string sz,string so,vector<int>&dp){\\n        if(s.size()>high)return 0;\\n        if(s.size()>=low&&s.size()<=high){\\n            if(st.find(s)==st.end()){\\n                st.insert(s);\\n              if(s.size()+zero>high&&s.size()+one>high)\\n                  return 1;\\n            }\\n           if(s.size()+zero>high&&s.size()+one>high)\\n               return 0;\\n        }\\n       int pickone=0,pickzero=0;\\n       if(s.size()+one<=high)\\n       pickone=solve(st,s+so,low,high,zero,one,sz,so,dp);\\n       if(s.size()+zero<=high)\\n       pickzero=solve(st,s+sz,low,high,zero,one,sz,so,dp);\\n       return pickone+pickzero;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        set<string>st;\\n        string s;\\n        string so,sz;\\n        for(int i=0;i<zero;i++)sz.push_back(\\'0\\');\\n        for(int i=0;i<one;i++)so.push_back(\\'1\\');\\n        vector<int>dp(high+1,-1);\\n         solve(st,s,low,high,zero,one,sz,so,dp);\\n       return st.size();\\n    }\\n};\\n\\n```\\n\\n```\\n**all clear()**\\n int mod=1e9+7;\\n    long long optimize(vector<long long>&dp,int low,int high,int length,int zero,int one){\\n        if(length>=high)return 0;\\n        if(dp[length]!=-1)return dp[length];\\n        long long pickzero=optimize(dp,low,high,length+zero,zero,one)%mod; \\n        if(length+zero>=low&&length+zero<=high)++pickzero;\\n        long long pickone=optimize(dp,low,high,length+one,zero,one)%mod;\\n        if(length+one>=low&&length+one<=high)++pickone;\\n        return dp[length]=(pickone+pickzero)%mod;\\n    }\\n\\t int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long>dp(high+1,-1);\\n        return int(optimize(dp,low,high,0,zero,one));\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\n```\n```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518239,
                "title": "100-java-o-n-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse array to store data ,such that **nth** index contain number of way to make string smaller than length **n**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we make array of length high+1\\n2. then iterate over array and think like that you have two option either chose 0 or 1 then if you chose 0 then arr[i]+=arr[i-zero] same for one\\n3. then add all ith index value from low to high in each time take mod of (int)(1e9+7) == 1000000007\\n4. return the sum\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] ans=new int[high+1];\\n        ans[0]=1;\\n        for(int i=1;i<=(one>zero?one:zero);i++){\\n            if((i-zero)>=0){\\n                ans[i]+=ans[i-zero];\\n            }\\n            if((i-one)>=0){\\n                ans[i]=(ans[i]+ans[i-one])%(int)(1e9+7);\\n            }\\n        }\\n        for(int i=(one>zero?one:zero)+1;i<=low;i++){\\n            ans[i]=(ans[i-zero]+ans[i-one])%(int)(1e9+7);\\n        } \\n        int sum=ans[low];\\n        for(int i=low+1;i<ans.length;i++){\\n            ans[i]=(ans[i-zero]+ans[i-one])%(int)(1e9+7);\\n            sum=(sum+ans[i])%(int)(1e9+7);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] ans=new int[high+1];\\n        ans[0]=1;\\n        for(int i=1;i<=(one>zero?one:zero);i++){\\n            if((i-zero)>=0){\\n                ans[i]+=ans[i-zero];\\n            }\\n            if((i-one)>=0){\\n                ans[i]=(ans[i]+ans[i-one])%(int)(1e9+7);\\n            }\\n        }\\n        for(int i=(one>zero?one:zero)+1;i<=low;i++){\\n            ans[i]=(ans[i-zero]+ans[i-one])%(int)(1e9+7);\\n        } \\n        int sum=ans[low];\\n        for(int i=low+1;i<ans.length;i++){\\n            ans[i]=(ans[i-zero]+ans[i-one])%(int)(1e9+7);\\n            sum=(sum+ans[i])%(int)(1e9+7);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518232,
                "title": "c-best-solution-recursion-memorization-tabulation-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n\\n    // recursive method\\n    ll solve(int low, int high, int zero, int one, int index)    {\\n        if(index >= high+1) return 0;\\n        ll cnt = 0;\\n        if(index >= low && index <= high)   cnt++;\\n        cnt += solve(low, high, zero, one, index+zero)%mod;\\n        cnt += solve(low, high, zero, one, index+one)%mod;\\n        return cnt%mod;\\n    }\\n\\n    // recursion + Memorization (DP)\\n    ll solveMem(int low, int high, int zero, int one, int index, vi& dp)    {\\n        if(index >= high+1) return 0;\\n        if(dp[index] != -1) return dp[index];\\n        ll cnt = 0;\\n        if(index >= low && index <= high)   cnt++;\\n        cnt += solveMem(low, high, zero, one, index+zero, dp)%mod;\\n        cnt += solveMem(low, high, zero, one, index+one, dp)%mod;\\n        return dp[index] = cnt%mod;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        // return solve(low, high, zero, one, 0);\\n\\n        vi dp(high+1, -1);\\n        return solveMem(low, high, zero, one, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n\\n    // recursive method\\n    ll solve(int low, int high, int zero, int one, int index)    {\\n        if(index >= high+1) return 0;\\n        ll cnt = 0;\\n        if(index >= low && index <= high)   cnt++;\\n        cnt += solve(low, high, zero, one, index+zero)%mod;\\n        cnt += solve(low, high, zero, one, index+one)%mod;\\n        return cnt%mod;\\n    }\\n\\n    // recursion + Memorization (DP)\\n    ll solveMem(int low, int high, int zero, int one, int index, vi& dp)    {\\n        if(index >= high+1) return 0;\\n        if(dp[index] != -1) return dp[index];\\n        ll cnt = 0;\\n        if(index >= low && index <= high)   cnt++;\\n        cnt += solveMem(low, high, zero, one, index+zero, dp)%mod;\\n        cnt += solveMem(low, high, zero, one, index+one, dp)%mod;\\n        return dp[index] = cnt%mod;\\n    }\\n\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        // return solve(low, high, zero, one, 0);\\n\\n        vi dp(high+1, -1);\\n        return solveMem(low, high, zero, one, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518204,
                "title": "go-recursive-dp",
                "content": "# Intuition\\nDP problem.\\n\\n# Approach\\nProcess all posible answer.\\nThe next posible answer is \\n- current length (**temp**) + length of **ZERO** OR\\n- current length (**temp**) + length of **ONE**\\n\\nAnother Condition that we need to pay attention is\\n- if current length (**temp**) is in between **LOW** and **HIGH** then we need to add 1 to the answer + all next posible answer.\\n- else find next posible answer\\n\\nstop condition for the recursive \\n- is temp length is more than high\\n\\nAlso dont forget to modulo the answer\\n\\n\\n# Code\\n\\n```\\nconst(\\n    mod = 1000000007\\n)\\nfunc countGoodStrings(low int, high int, zero int, one int) int {\\n    memo := make(map[int]int)\\n    result := helper(low,high,zero, one, 0, memo)\\n    return result\\n}\\n\\nfunc helper(low int, high int, zero int, one int, temp int, memo map[int]int)int{\\n    if temp > high {\\n        return 0\\n    }\\n    if _, ok := memo[temp]; ok {\\n        return memo[temp]\\n    }\\n    if temp >= low && temp <= high{\\n        memo[temp] = (helper(low, high, zero, one, temp + zero, memo) + helper(low, high, zero, one, temp + one, memo)  + 1) % mod\\n        return memo[temp]\\n    }\\n    memo[temp] = (helper(low, high, zero, one, temp + zero, memo) + helper(low, high, zero, one, temp + one, memo))% mod\\n\\n    return memo[temp]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst(\\n    mod = 1000000007\\n)\\nfunc countGoodStrings(low int, high int, zero int, one int) int {\\n    memo := make(map[int]int)\\n    result := helper(low,high,zero, one, 0, memo)\\n    return result\\n}\\n\\nfunc helper(low int, high int, zero int, one int, temp int, memo map[int]int)int{\\n    if temp > high {\\n        return 0\\n    }\\n    if _, ok := memo[temp]; ok {\\n        return memo[temp]\\n    }\\n    if temp >= low && temp <= high{\\n        memo[temp] = (helper(low, high, zero, one, temp + zero, memo) + helper(low, high, zero, one, temp + one, memo)  + 1) % mod\\n        return memo[temp]\\n    }\\n    memo[temp] = (helper(low, high, zero, one, temp + zero, memo) + helper(low, high, zero, one, temp + one, memo))% mod\\n\\n    return memo[temp]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518198,
                "title": "python-3-liner-easy-approach-dry-run-it",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp, mod = Counter({0: 1}), 10 ** 9 + 7\\n        for i in range(1, high + 1): dp[i] = (dp[i - zero] + dp[i - one]) % mod\\n        return sum(dp[i] for i in range(low, high + 1)) % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp, mod = Counter({0: 1}), 10 ** 9 + 7\\n        for i in range(1, high + 1): dp[i] = (dp[i - zero] + dp[i - one]) % mod\\n        return sum(dp[i] for i in range(low, high + 1)) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518101,
                "title": "java-runtime-22-ms-beats-26-55-memory-64-5-mb-beats-8-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tint mod = 1000000000+7;\\n\\tpublic int countGoodStrings(int low, int high, int zero, int one) {\\n\\t\\tInteger[] dp = new Integer[high+1];\\n\\t   return dfs(high,low,zero,one,0,dp);\\n\\t}\\n\\n\\tint dfs(int h, int l, int z, int o, int str, Integer[] dp){\\n\\t   if(str>h)return 0;\\n\\t\\tif(dp[str]!=null)return dp[str];\\n\\t   int take=0, dont=0,ans=0;\\n\\n\\t\\tif(str>=l && str<=h)ans++;\\n\\n\\t\\ttake = dfs(h,l,z,o,str+o,dp);\\n\\t\\tdont = dfs(h,l,z,o,str+z,dp);\\n\\n\\t\\treturn dp[str]=(ans+take+dont)%mod;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tint mod = 1000000000+7;\\n\\tpublic int countGoodStrings(int low, int high, int zero, int one) {\\n\\t\\tInteger[] dp = new Integer[high+1];\\n\\t   return dfs(high,low,zero,one,0,dp);\\n\\t}\\n\\n\\tint dfs(int h, int l, int z, int o, int str, Integer[] dp){\\n\\t   if(str>h)return 0;\\n\\t\\tif(dp[str]!=null)return dp[str];\\n\\t   int take=0, dont=0,ans=0;\\n\\n\\t\\tif(str>=l && str<=h)ans++;\\n\\n\\t\\ttake = dfs(h,l,z,o,str+o,dp);\\n\\t\\tdont = dfs(h,l,z,o,str+z,dp);\\n\\n\\t\\treturn dp[str]=(ans+take+dont)%mod;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518065,
                "title": "dp-memoized-code",
                "content": "# **Please Upvote if it help \\uD83D\\uDE07**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long solve(int length,int high,int low,int zero,int one,vector<long long>& dp){\\n        if(length>=high)\\n            return 0;\\n\\n        if(dp[length]!=-1)\\n            return dp[length];\\n        \\n        long long a= solve(length+zero,high,low,zero,one,dp);\\n\\n         if(zero+length>=low and zero+length<=high)\\n            a++;\\n        \\n        long long b= solve(length+one,high,low,zero,one,dp);\\n\\n         if(one+length>=low and one+length<=high)\\n            b++;\\n        \\n        return dp[length]=(a+b)%mod;\\n        \\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long> dp(1e5+1,-1);\\n        return int(solve(0,high,low,zero,one,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long solve(int length,int high,int low,int zero,int one,vector<long long>& dp){\\n        if(length>=high)\\n            return 0;\\n\\n        if(dp[length]!=-1)\\n            return dp[length];\\n        \\n        long long a= solve(length+zero,high,low,zero,one,dp);\\n\\n         if(zero+length>=low and zero+length<=high)\\n            a++;\\n        \\n        long long b= solve(length+one,high,low,zero,one,dp);\\n\\n         if(one+length>=low and one+length<=high)\\n            b++;\\n        \\n        return dp[length]=(a+b)%mod;\\n        \\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long> dp(1e5+1,-1);\\n        return int(solve(0,high,low,zero,one,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518061,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD=(int)Math.pow(10,9)+7;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        return f(0,low,high,zero,one,dp);\\n    }\\n    public int f(int ind,int low,int high,int zero, int one,int dp[])\\n    {\\n        if(ind>high) return 0;\\n        if(dp[ind]!= -1) return dp[ind];\\n        int count = 0;\\n        if(ind>=low && ind<=high) count=(count+1)%MOD;\\n        count=(count + f(ind+zero,low,high,zero,one,dp))%MOD;\\n        count=(count + f(ind+one,low,high,zero,one,dp))%MOD;\\n        return dp[ind]=count%MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int MOD=(int)Math.pow(10,9)+7;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int dp[]=new int[high+1];\\n        Arrays.fill(dp,-1);\\n        return f(0,low,high,zero,one,dp);\\n    }\\n    public int f(int ind,int low,int high,int zero, int one,int dp[])\\n    {\\n        if(ind>high) return 0;\\n        if(dp[ind]!= -1) return dp[ind];\\n        int count = 0;\\n        if(ind>=low && ind<=high) count=(count+1)%MOD;\\n        count=(count + f(ind+zero,low,high,zero,one,dp))%MOD;\\n        count=(count + f(ind+one,low,high,zero,one,dp))%MOD;\\n        return dp[ind]=count%MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517807,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nComputing the number of strings is similar to computing Fibonacci numbers.\\nThe number of strings of length n is equal to the number of strings of length n-zero plus the number of strings of length n-one, depending on what sequence they end in.\\n\\nTo start off the sequence, we assume that the number of strings of length 0 is 1, meaning we start from the empty string. Obviously, the number of strings with negative length is 0.\\n\\n# Complexity\\n- Time complexity: $O(high)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(high)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:  \\n        p=10**9+7    \\n        table=[1]*(high+1)\\n        for i in range(1, high+1):\\n            table[i]=((table[i-zero] if i>=zero else 0)+(table[i-one] if i>=one else 0))%p\\n        return sum(table[i] for i in range(low, high+1))%p\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:  \\n        p=10**9+7    \\n        table=[1]*(high+1)\\n        for i in range(1, high+1):\\n            table[i]=((table[i-zero] if i>=zero else 0)+(table[i-one] if i>=one else 0))%p\\n        return sum(table[i] for i in range(low, high+1))%p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517772,
                "title": "simple-dart-solution",
                "content": "\\n\\n# Approach\\nIf i is greater than or equal to zero, the code adds dp[i-zero] to dp[i], since we can append zero characters to the end of any good string of length i-zero to get a good string of length i.\\n\\nIf i is greater than or equal to one, the code adds dp[i-one] to dp[i], since we can append one character to the end of any good string of length i-one to get a good string of length i.\\n\\nAfter computing dp, the code then computes the number of good strings in the range [low, high] by summing up the values of dp[i] for i in the range [low, high].\\n# Complexity\\n- Time complexity:\\nO(high)\\n\\n# Code\\n```\\nclass Solution {\\n  int countGoodStrings(int low, int high, int zero, int one) {\\n    List<int> dp = List.filled(high + 1, 0);\\n    int res = 0, mod = 1000000007;\\n    dp[0] = 1;\\n    for (int i = 1; i <= high; ++i) {\\n      if (i >= zero) {\\n        dp[i] = (dp[i] + dp[i - zero]) % mod;\\n      }\\n      if (i >= one) {\\n        dp[i] = (dp[i] + dp[i - one]) % mod;\\n      }\\n      if (i >= low) {\\n        res = (res + dp[i]) % mod;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countGoodStrings(int low, int high, int zero, int one) {\\n    List<int> dp = List.filled(high + 1, 0);\\n    int res = 0, mod = 1000000007;\\n    dp[0] = 1;\\n    for (int i = 1; i <= high; ++i) {\\n      if (i >= zero) {\\n        dp[i] = (dp[i] + dp[i - zero]) % mod;\\n      }\\n      if (i >= one) {\\n        dp[i] = (dp[i] + dp[i - one]) % mod;\\n      }\\n      if (i >= low) {\\n        res = (res + dp[i]) % mod;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517760,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        mod=10**9+7\\n        dp=[1]\\n        total=0\\n\\n        for i in range(1,high+1):\\n            dp.append(0)\\n\\n            if i-zero>=0:\\n                dp[i]+=dp[i-zero]\\n\\n            if i-one>=0:\\n                dp[i]+=dp[i-one]\\n\\n            dp[i]%=mod\\n\\n            if low<=i<=high:\\n                total+=dp[i]\\n                total%=mod\\n\\n        return total%mod                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        mod=10**9+7\\n        dp=[1]\\n        total=0\\n\\n        for i in range(1,high+1):\\n            dp.append(0)\\n\\n            if i-zero>=0:\\n                dp[i]+=dp[i-zero]\\n\\n            if i-one>=0:\\n                dp[i]+=dp[i-one]\\n\\n            dp[i]%=mod\\n\\n            if low<=i<=high:\\n                total+=dp[i]\\n                total%=mod\\n\\n        return total%mod                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447457,
                "title": "simplest-recursive-memo-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int solve(int low, int high, int zero, int one,int l,vector<int>&dp){\\n        if(l>high)return 0;\\n        if(dp[l]!=-1)return dp[l];\\n        int ans=0;\\n        if(l>=low && l<=high)ans=1;\\n        ans=(ans%M+solve(low,high,zero,one,l+zero,dp)%M)%M;\\n        ans=(ans%M+solve(low,high,zero,one,l+one,dp)%M)%M;\\n        return dp[l]=ans%M;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int>dp(2*high+1,-1);\\n        return solve(low,high,zero,one,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1000000007;\\n    int solve(int low, int high, int zero, int one,int l,vector<int>&dp){\\n        if(l>high)return 0;\\n        if(dp[l]!=-1)return dp[l];\\n        int ans=0;\\n        if(l>=low && l<=high)ans=1;\\n        ans=(ans%M+solve(low,high,zero,one,l+zero,dp)%M)%M;\\n        ans=(ans%M+solve(low,high,zero,one,l+one,dp)%M)%M;\\n        return dp[l]=ans%M;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int>dp(2*high+1,-1);\\n        return solve(low,high,zero,one,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311186,
                "title": "c",
                "content": "```\\nint countGoodStrings(int low, int high, int zero, int one){\\n    int M = 1e9 + 7 ;\\n    int* dp = calloc(high+1, sizeof(int)) ;\\n    long long ret = 0 ;\\n    dp[0] = 1 ;\\n    for(int i = 1; i <= high; i++){\\n        if(i >= one)\\n            dp[i] = (dp[i] + dp[i-one])%M ;\\n        if(i >= zero)\\n            dp[i] = (dp[i] + dp[i-zero])%M ;\\n        if(i >= low)\\n            ret = (ret + dp[i]) % M ;\\n    }\\n    return ret ;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint countGoodStrings(int low, int high, int zero, int one){\\n    int M = 1e9 + 7 ;\\n    int* dp = calloc(high+1, sizeof(int)) ;\\n    long long ret = 0 ;\\n    dp[0] = 1 ;\\n    for(int i = 1; i <= high; i++){\\n        if(i >= one)\\n            dp[i] = (dp[i] + dp[i-one])%M ;\\n        if(i >= zero)\\n            dp[i] = (dp[i] + dp[i-zero])%M ;\\n        if(i >= low)\\n            ret = (ret + dp[i]) % M ;\\n    }\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2938850,
                "title": "c-simple-dfs-solution-memorization",
                "content": "# Code\\n```\\nclass Solution {\\n    int mod = 1e9+7;\\n    vector<int> dp;\\n    long ans = 0;\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = vector(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n           ans= (ans+dfs(high,zero,one,i))%mod;\\n        }\\n        return ans;\\n    }\\n\\n    long dfs(int high,int zero,int one,int size){\\n        if(size<0) return 0;\\n        if(size==0) return 1;\\n        if(dp[size]!=-1) return dp[size];\\n        int x = dfs(high,zero,one,size-zero);\\n        int y = dfs(high,zero,one,size-one);\\n        return  dp[size] = (x+y)%mod;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\n    vector<int> dp;\\n    long ans = 0;\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = vector(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n           ans= (ans+dfs(high,zero,one,i))%mod;\\n        }\\n        return ans;\\n    }\\n\\n    long dfs(int high,int zero,int one,int size){\\n        if(size<0) return 0;\\n        if(size==0) return 1;\\n        if(dp[size]!=-1) return dp[size];\\n        int x = dfs(high,zero,one,size-zero);\\n        int y = dfs(high,zero,one,size-one);\\n        return  dp[size] = (x+y)%mod;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837805,
                "title": "same-as-377-combination-sum-iv",
                "content": "Since this is an ordered dp problem, it is kind of different to Coin Change II. In fact, this problem is identical to Combination Sum IV. \\n```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\npublic:\\n    // similar to https://leetcode.com/problems/combination-sum-iv/\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1;\\n        for(int i=1; i<=high; i++){\\n            if(i>=zero) dp[i] = (dp[i] + dp[i-zero]) % mod;\\n            if(i>=one) dp[i] = (dp[i] + dp[i-one]) % mod;\\n        }\\n        int ans = 0;\\n        for(int i=low; i<=high; i++)\\n            ans = (ans + dp[i]) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\npublic:\\n    // similar to https://leetcode.com/problems/combination-sum-iv/\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<int> dp(high + 1);\\n        dp[0] = 1;\\n        for(int i=1; i<=high; i++){\\n            if(i>=zero) dp[i] = (dp[i] + dp[i-zero]) % mod;\\n            if(i>=one) dp[i] = (dp[i] + dp[i-one]) % mod;\\n        }\\n        int ans = 0;\\n        for(int i=low; i<=high; i++)\\n            ans = (ans + dp[i]) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823429,
                "title": "java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        long []dp = new long[high+1];\\n        dp[0]=1;\\n        long ans = 0;\\n        for(int i=1;i<=high;i++){\\n            \\n            dp[i] = ((i-zero >=0 ? dp[i-zero] : 0) + (i-one >=0 ? dp[i-one]: 0))%(1000000007);\\n            if(i>=low){\\n                ans = (ans + dp[i])%(1000000007);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        \\n        long []dp = new long[high+1];\\n        dp[0]=1;\\n        long ans = 0;\\n        for(int i=1;i<=high;i++){\\n            \\n            dp[i] = ((i-zero >=0 ? dp[i-zero] : 0) + (i-one >=0 ? dp[i-one]: 0))%(1000000007);\\n            if(i>=low){\\n                ans = (ans + dp[i])%(1000000007);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812655,
                "title": "javascript-solution-with-dp",
                "content": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n    let res = 0;\\n    let dp = new Array(high+1).fill(0);\\n    dp[0] = 1;\\n\\n    for(let i=1; i<=high; i++){\\n        if(i-zero >= 0){\\n            dp[i] = (dp[i] + dp[i-zero]) % 1000000007;\\n        }\\n        if(i-one >= 0){\\n            dp[i] = (dp[i] + dp[i-one]) % 1000000007;\\n        }\\n    }\\n\\n    for(let i=low; i<=high; i++){\\n        res += dp[i] % 1000000007;\\n    }\\n\\n    res = res % 1000000007;\\n\\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @param {number} zero\\n * @param {number} one\\n * @return {number}\\n */\\nvar countGoodStrings = function(low, high, zero, one) {\\n    let res = 0;\\n    let dp = new Array(high+1).fill(0);\\n    dp[0] = 1;\\n\\n    for(let i=1; i<=high; i++){\\n        if(i-zero >= 0){\\n            dp[i] = (dp[i] + dp[i-zero]) % 1000000007;\\n        }\\n        if(i-one >= 0){\\n            dp[i] = (dp[i] + dp[i-one]) % 1000000007;\\n        }\\n    }\\n\\n    for(let i=low; i<=high; i++){\\n        res += dp[i] % 1000000007;\\n    }\\n\\n    res = res % 1000000007;\\n\\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812003,
                "title": "fastest-python-solution-using-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, a: int, b: int) -> int:\\n        ct=0\\n        lst=[-1]*(high+1)\\n        def sol(a,b,lst,i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            if lst[i]!=-1:\\n                return lst[i]\\n            lst[i]=sol(a,b,lst,i-a)+sol(a,b,lst,i-b)\\n            return lst[i]\\n        for i in range(low,high+1):\\n            ct+=sol(a,b,lst,i)\\n        return ct%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, a: int, b: int) -> int:\\n        ct=0\\n        lst=[-1]*(high+1)\\n        def sol(a,b,lst,i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            if lst[i]!=-1:\\n                return lst[i]\\n            lst[i]=sol(a,b,lst,i-a)+sol(a,b,lst,i-b)\\n            return lst[i]\\n        for i in range(low,high+1):\\n            ct+=sol(a,b,lst,i)\\n        return ct%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811676,
                "title": "c-dp-solution-fast-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int zero,int one, vector<long long>&dp)\\n    {\\n        if(i==0)\\n            return 1;\\n        if(i<0) \\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=(recur(i-zero,zero,one,dp)%1000000007 + recur(i-one,zero,one,dp)%1000000007)%1000000007;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long>dp(high+1,-1);\\n        long long ans=0;\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=(ans%1000000007 + recur(i,zero,one,dp)%1000000007)%1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int zero,int one, vector<long long>&dp)\\n    {\\n        if(i==0)\\n            return 1;\\n        if(i<0) \\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=(recur(i-zero,zero,one,dp)%1000000007 + recur(i-one,zero,one,dp)%1000000007)%1000000007;\\n    }\\n    \\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<long long>dp(high+1,-1);\\n        long long ans=0;\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=(ans%1000000007 + recur(i,zero,one,dp)%1000000007)%1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811117,
                "title": "dp-memoization-java-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[] dp;\\n    int MOD = 1000000007;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = new Integer[high +1];\\n        int ans =0;\\n        for(int i=low; i<= high; i++){\\n            ans =(ans + helper(i, zero, one)) % MOD;\\n        }\\n        return ans;\\n    }\\n\\n    private int helper(int n, int zero, int one){\\n        if(n <0){\\n            return 0;\\n        }\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(dp[n] != null){\\n            return dp[n];\\n        }\\n        int takeZero = helper(n-zero, zero, one) % MOD;\\n        int takeOne = helper(n-one, zero, one) % MOD;\\n\\n        return dp[n] = (takeZero + takeOne) % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] dp;\\n    int MOD = 1000000007;\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = new Integer[high +1];\\n        int ans =0;\\n        for(int i=low; i<= high; i++){\\n            ans =(ans + helper(i, zero, one)) % MOD;\\n        }\\n        return ans;\\n    }\\n\\n    private int helper(int n, int zero, int one){\\n        if(n <0){\\n            return 0;\\n        }\\n        if(n == 0){\\n            return 1;\\n        }\\n        if(dp[n] != null){\\n            return dp[n];\\n        }\\n        int takeZero = helper(n-zero, zero, one) % MOD;\\n        int takeOne = helper(n-one, zero, one) % MOD;\\n\\n        return dp[n] = (takeZero + takeOne) % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810174,
                "title": "refer-it-as-a-coin-change-problem-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s almost similar as a coin change problem where we have unlimited supply of two coins with value {zero and one} and with these two coins we have to find the target between length low and high .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1 : We\\'ll iterate a loop from low to high so that we make sure our string is a good string if the target is found.\\nStep 2: We\\'ll call a reccurence function where we\\'ll just decrease our target by value zero or one and add both of them to get the result.\\n\\n# Complexity\\n- Time complexity: O(high)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(high)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp){\\n        if(target==0)return 1;//Its a good string \\n        if(target<0)return 0;//Its not a goood string \\n        if(dp[target]!=-1)return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1e9+7;\\n    int solve(int target,int one ,int zero,vector<int>&dp){\\n        if(target==0)return 1;//Its a good string \\n        if(target<0)return 0;//Its not a goood string \\n        if(dp[target]!=-1)return dp[target];\\n        long long sum;\\n        sum=solve(target-one,one,zero,dp)+solve(target-zero,one,zero,dp);\\n        return dp[target]=sum%mod;\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        int ans=0;\\n        vector<int>dp(high+1,-1);\\n        for(int i=low;i<=high;i++){\\n            ans=((ans%mod)+solve(i,one,zero,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810007,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp=[0]*(high+1)\\n        dp[0]=1\\n        for i in range(1,high+1):\\n            dp[i]=dp[i-one]+dp[i-zero]\\n        return sum(dp[i] for i in range(low,high+1))%((10**9)+7)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp=[0]*(high+1)\\n        dp[0]=1\\n        for i in range(1,high+1):\\n            dp[i]=dp[i-one]+dp[i-zero]\\n        return sum(dp[i] for i in range(low,high+1))%((10**9)+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808752,
                "title": "c-most-easy-dp-solution-be-careful-while-using-mod",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n   ll f(ll n,int z,int o,vector<ll> &dp)\\n    {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return dp[n]=(f(n-z,z,o,dp)%mod+f(n-o,z,o,dp)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll> dp(1e5+1,-1);\\n        ll ans=0;\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=(ans%mod+f(i,zero,one,dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll mod=1e9+7;\\n   ll f(ll n,int z,int o,vector<ll> &dp)\\n    {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        return dp[n]=(f(n-z,z,o,dp)%mod+f(n-o,z,o,dp)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        vector<ll> dp(1e5+1,-1);\\n        ll ans=0;\\n        for(int i=low;i<=high;i++)\\n        {\\n            ans=(ans%mod+f(i,zero,one,dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808241,
                "title": "python-dp-tabulation-approach",
                "content": "# Intuition\\nSince the solution at each step depends on the result obtained at the previous step DP tabulation seems to be the reasonable approach to use.\\n\\n# Approach\\nLet\\'s create an array `dp` of size `(high+1)`. Each element `dp[i]` of this array will store the number of strings of size `i` that can be formed according to the problem\\'s rules.\\n\\nWe start with an empty string, so `dp[0] = 1`. If we append `\\'0\\'` char `zero` times the length of this new string will be `zero`, so we can set `dp[0 + zero] += dp[0]`. Using the same approach we can construct new string from an empty string using `one` chars of `1`: `dp[0 + one] += dp[0]`. Then we can move to index `1` and repeat the process for zeroes and ones, and so on.\\n\\nFor index `i`:\\n- `dp[i+zero] += dp[i] % MOD`\\n- `dp[i+one] += dp[i] % MOD`\\n- \\nwhere `MOD` is 10<sup>9</sup> + 7.\\n\\nThe answer can be calculated as `sum(dp[low:high+1]) % MOD`.\\n\\nTo avoid checking if `i + zero` and `i + one` is less than `len(dp)` at each iteration, we can calculate the last index that shall be processed as `limit = high + 1 - min(zero, one)` and `dp` size as `limit + max(zero, one)`\\n\\n# Complexity\\n- Time complexity: O(high)\\n- Space complexity: O(high)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        MOD = 1_000_000_007\\n        limit = high + 1 - min(zero, one)   # last dp array index to be processed\\n        dp_size = limit + max(zero, one)    # dp array size\\n\\n        dp: List[int] = [0] * dp_size\\n        dp[0] = 1    \\n\\n        for i in range(limit):\\n            if dp[i]:\\n                dp[i+zero] += dp[i] % MOD\\n                dp[i+one] += dp[i] % MOD\\n\\n        return sum(dp[low:high+1]) % MOD\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        \\n        MOD = 1_000_000_007\\n        limit = high + 1 - min(zero, one)   # last dp array index to be processed\\n        dp_size = limit + max(zero, one)    # dp array size\\n\\n        dp: List[int] = [0] * dp_size\\n        dp[0] = 1    \\n\\n        for i in range(limit):\\n            if dp[i]:\\n                dp[i+zero] += dp[i] % MOD\\n                dp[i+one] += dp[i] % MOD\\n\\n        return sum(dp[low:high+1]) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807754,
                "title": "c-easy-7-lines-dp-approach",
                "content": "**If it helps, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        int mod = 1e9+7;     \\n        vector<int> dp(high + max(zero, one)+1, 0);  //dp[i] = count of good strings when size of string = i\\n        \\n        for(int i=high; i>=0; i--)                   //base case: size>high , no good string\\n        {\\n            dp[i] = (dp[i+zero] + dp[i+one])%mod;    //because size of string increases if we add 0 zero times or 1 one times, here we need to work only with size of string\\n            \\n            if(low <= i and i <= high)               //found one good string, increment cnt by 1\\n                dp[i] = (dp[i] + 1)%mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) \\n    {\\n        int mod = 1e9+7;     \\n        vector<int> dp(high + max(zero, one)+1, 0);  //dp[i] = count of good strings when size of string = i\\n        \\n        for(int i=high; i>=0; i--)                   //base case: size>high , no good string\\n        {\\n            dp[i] = (dp[i+zero] + dp[i+one])%mod;    //because size of string increases if we add 0 zero times or 1 one times, here we need to work only with size of string\\n            \\n            if(low <= i and i <= high)               //found one good string, increment cnt by 1\\n                dp[i] = (dp[i] + 1)%mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807274,
                "title": "simple-python3-solution",
                "content": "# Intuition\\n Simple modification to climbing stairs Problem. I highly recommend to solve that problem and come here.\\n\\n# Approach\\n We just have to add a range factor to climbing stairs problem. Where we not only have to return the number of ways to reach the final step. But here we have to add the all the ways to reach in between the range from low and high given in the problem. \\n\\n# Complexity\\n- Time complexity:\\n    O(high)\\n\\n- Space complexity:\\n    O(high)\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0]*(high+1)\\n        dp[zero] += 1\\n        dp[one] += 1\\n        mod = (10**9)+7\\n        for i in range(min(zero,one)+1,high+1):\\n            if i-zero>=0:\\n                dp[i]+=dp[i-zero]\\n            if i-one>=0:\\n                dp[i]+=dp[i-one]\\n        s = 0\\n        for i in range(low,high+1):\\n            s+=dp[i]\\n        return s%mod\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0]*(high+1)\\n        dp[zero] += 1\\n        dp[one] += 1\\n        mod = (10**9)+7\\n        for i in range(min(zero,one)+1,high+1):\\n            if i-zero>=0:\\n                dp[i]+=dp[i-zero]\\n            if i-one>=0:\\n                dp[i]+=dp[i-one]\\n        s = 0\\n        for i in range(low,high+1):\\n            s+=dp[i]\\n        return s%mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807251,
                "title": "easy-understanding-java-c-dp-solution-o-n",
                "content": "# ***// Upvote bhi kr do yar ab***\\nclass Solution {\\npublic:\\n\\n    long long mod  = 1000000007;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n       \\n\\t   vector<long long>arr(200005);\\n        long long res = 0;\\n        arr[0] = 1;\\n        for(int i = 0; i < 100005; i++){\\n            arr[i + zero]= arr[i + zero]%mod;\\n            arr[i + zero] += arr[i];\\n            arr[i + one]=arr[i + one]%mod;\\n           arr[i + one] += arr[i];\\n        }\\n        for(int i = low; i <= high; i++){\\n            res = (res + arr[i])%mod;\\n        }\\n        return res;\\n    }\\n# };**",
                "solutionTags": [
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long mod  = 1000000007;\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n       \\n\\t   vector<long long>arr(200005);\\n        long long res = 0;\\n        arr[0] = 1;\\n        for(int i = 0; i < 100005; i++){\\n            arr[i + zero]= arr[i + zero]%mod;\\n            arr[i + zero] += arr[i];\\n            arr[i + one]=arr[i + one]%mod;\\n           arr[i + one] += arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2807220,
                "title": "c-dp",
                "content": "```\\n    public int CountGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int mod = 1_000_000_007;\\n        int[] dp = new int[high + low + 1];\\n        dp[0] = 1;\\n        for (int i = 0; i <= high; i++)\\n        {\\n            dp[i + zero] = (dp[i + zero] + dp[i]) % mod;\\n            dp[i + one] = (dp[i + one] + dp[i]) % mod;\\n        }\\n\\n        int result = 0;\\n        for (int i = low; i <= high; i++)\\n        {\\n            result = (result + dp[i]) % mod;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int CountGoodStrings(int low, int high, int zero, int one)\\n    {\\n        int mod = 1_000_000_007;\\n        int[] dp = new int[high + low + 1];\\n        dp[0] = 1;\\n        for (int i = 0; i <= high; i++)\\n        {\\n            dp[i + zero] = (dp[i + zero] + dp[i]) % mod;\\n            dp[i + one] = (dp[i + one] + dp[i]) % mod;\\n        }\\n\\n        int result = 0;\\n        for (int i = low; i <= high; i++)\\n        {\\n            result = (result + dp[i]) % mod;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807214,
                "title": "java-dp-solution-tabulation-with-comments-line-by-line",
                "content": "```\\nclass Solution {\\n    long M = 1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        \\n        // as there is one way of making string of size 0 by taking nothing\\n        dp[0] = 1;\\n        for(int i=0;i<=high;i++)\\n        {\\n            // at each index we will calculate if adding numer of zeroes to it will make any any string less than high\\n            if(i+zero<=high)\\n            {\\n                dp[i+zero] += dp[i];\\n                dp[i+zero]  = (int)(dp[i+zero] % M);\\n            }\\n             // at each index we will calculate if adding numer of ones to it will make any string less than high \\n            if(i+one<=high)\\n            {\\n                dp[i+one] += dp[i];\\n                dp[i+one]  = (int)(dp[i+one] % M);\\n            }\\n        }\\n        \\n\\n        // calculate all strings that lie within range\\n        if(high!=low)\\n        {\\n            int ans = 0;\\n            for(int i=low;i<=high;i++){\\n                ans  = (int)((ans + dp[i])%M);\\n            }  \\n            return ans;\\n        }         \\n        else\\n        {\\n            return dp[high];\\n        }\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long M = 1000000007;\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        \\n        // as there is one way of making string of size 0 by taking nothing\\n        dp[0] = 1;\\n        for(int i=0;i<=high;i++)\\n        {\\n            // at each index we will calculate if adding numer of zeroes to it will make any any string less than high\\n            if(i+zero<=high)\\n            {\\n                dp[i+zero] += dp[i];\\n                dp[i+zero]  = (int)(dp[i+zero] % M);\\n            }\\n             // at each index we will calculate if adding numer of ones to it will make any string less than high \\n            if(i+one<=high)\\n            {\\n                dp[i+one] += dp[i];\\n                dp[i+one]  = (int)(dp[i+one] % M);\\n            }\\n        }\\n        \\n\\n        // calculate all strings that lie within range\\n        if(high!=low)\\n        {\\n            int ans = 0;\\n            for(int i=low;i<=high;i++){\\n                ans  = (int)((ans + dp[i])%M);\\n            }  \\n            return ans;\\n        }         \\n        else\\n        {\\n            return dp[high];\\n        }\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807156,
                "title": "python-simple-iterative-dp",
                "content": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        mod = 10**9 + 7\\n        dp = [1] + [0] * high\\n        result = 0\\n        for i in range(high + 1):\\n            if i + zero <= high:\\n                dp[i + zero] = (dp[i + zero] + dp[i]) % mod\\n            if i + one <= high:\\n                dp[i + one] = (dp[i + one] + dp[i]) % mod\\n            if low <= i <= high:\\n                result = (result + dp[i]) % mod\\n        return result % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        mod = 10**9 + 7\\n        dp = [1] + [0] * high\\n        result = 0\\n        for i in range(high + 1):\\n            if i + zero <= high:\\n                dp[i + zero] = (dp[i + zero] + dp[i]) % mod\\n            if i + one <= high:\\n                dp[i + one] = (dp[i + one] + dp[i]) % mod\\n            if low <= i <= high:\\n                result = (result + dp[i]) % mod\\n        return result % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807153,
                "title": "linear-dp-coin-change-problem",
                "content": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        res = 0\\n        M = 10 ** 9 + 7\\n        dp = [0] * (high + 1)\\n        dp[0] = 1\\n        res = 0\\n        for i in range(high + 1):\\n            if i >= zero:\\n                dp[i] += dp[i - zero]\\n                dp[i] %= M\\n            if i >= one:\\n                dp[i] += dp[i - one]\\n                dp[i] %= M\\n            if low <= i <= high:\\n                res = (res + dp[i]) % M\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        res = 0\\n        M = 10 ** 9 + 7\\n        dp = [0] * (high + 1)\\n        dp[0] = 1\\n        res = 0\\n        for i in range(high + 1):\\n            if i >= zero:\\n                dp[i] += dp[i - zero]\\n                dp[i] %= M\\n            if i >= one:\\n                dp[i] += dp[i - one]\\n                dp[i] %= M\\n            if low <= i <= high:\\n                res = (res + dp[i]) % M\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807151,
                "title": "python-7-line-dp-solution-coin-change",
                "content": "```\\ndef countGoodStrings(self, x: int, y: int, z: int, o: int) -> int:\\n\\tdp, mod = [1]+[0]*y, 10**9+7\\n\\tfor i in range(1, y+1):\\n\\t\\tif i-z>=0:\\n\\t\\t\\tdp[i] = (dp[i]+dp[i-z])%mod\\n\\t\\tif i-o>=0:\\n\\t\\t\\tdp[i] = (dp[i]+dp[i-o])%mod\\n\\treturn sum(dp[x:])%mod\\n```",
                "solutionTags": [],
                "code": "```\\ndef countGoodStrings(self, x: int, y: int, z: int, o: int) -> int:\\n\\tdp, mod = [1]+[0]*y, 10**9+7\\n\\tfor i in range(1, y+1):\\n\\t\\tif i-z>=0:\\n\\t\\t\\tdp[i] = (dp[i]+dp[i-z])%mod\\n\\t\\tif i-o>=0:\\n\\t\\t\\tdp[i] = (dp[i]+dp[i-o])%mod\\n\\treturn sum(dp[x:])%mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2807146,
                "title": "simple-memo-1d-dp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int n, int zero, int one){\\n        if(n <= 0)return n == 0;\\n        if(dp[n]!=-1)return dp[n];\\n        return dp[n] = (helper(n-zero,zero,one)%mod + helper(n-one,zero,one)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one,int ans = 0) {\\n        dp = vector<int>(high + 1,-1);\\n        for(int i=low;i<=high;i++)ans = (ans + helper(i,zero,one))%mod;\\n        return ans;\\n    }\\nprivate:\\n    const int mod = 1e9+7;\\n    vector<int> dp;\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n int countGoodStrings(int low, int high, int zero, int one,int res = 0) {\\n        dp = vector<int>(high + 1);\\n        dp[0] = 1;\\n        for (int i = 1; i <= high; ++i) {\\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\nprivate:\\n    const int mod = 1e9+7;\\n    vector<int> dp;\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int n, int zero, int one){\\n        if(n <= 0)return n == 0;\\n        if(dp[n]!=-1)return dp[n];\\n        return dp[n] = (helper(n-zero,zero,one)%mod + helper(n-one,zero,one)%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one,int ans = 0) {\\n        dp = vector<int>(high + 1,-1);\\n        for(int i=low;i<=high;i++)ans = (ans + helper(i,zero,one))%mod;\\n        return ans;\\n    }\\nprivate:\\n    const int mod = 1e9+7;\\n    vector<int> dp;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n int countGoodStrings(int low, int high, int zero, int one,int res = 0) {\\n        dp = vector<int>(high + 1);\\n        dp[0] = 1;\\n        for (int i = 1; i <= high; ++i) {\\n            if (i >= zero) dp[i] = (dp[i] + dp[i - zero]) % mod;\\n            if (i >= one) dp[i] = (dp[i] + dp[i - one]) % mod;\\n            if (i >= low) res = (res + dp[i]) % mod;\\n        }\\n        return res;\\n    }\\nprivate:\\n    const int mod = 1e9+7;\\n    vector<int> dp;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086748,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long>dp;\\n    int mod = 1000000007;\\n    long solve(int i,int zero,int one){\\n        if(i == 0)\\n            return 0;\\n        if(i < 0)\\n            return -1;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        int takeZero = (1 + solve(i-zero,zero,one))%mod;\\n        int takeOne = (1 + solve(i - one,zero,one))%mod;\\n        return dp[i] = (takeZero + takeOne)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = vector<long>(high+1,-1);\\n        int h = solve(high,zero,one);\\n        int l = 0;\\n        if(low > 0)\\n            l = solve(low-1,zero,one);\\n        return (h-l+mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long>dp;\\n    int mod = 1000000007;\\n    long solve(int i,int zero,int one){\\n        if(i == 0)\\n            return 0;\\n        if(i < 0)\\n            return -1;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        int takeZero = (1 + solve(i-zero,zero,one))%mod;\\n        int takeOne = (1 + solve(i - one,zero,one))%mod;\\n        return dp[i] = (takeZero + takeOne)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        dp = vector<long>(high+1,-1);\\n        int h = solve(high,zero,one);\\n        int l = 0;\\n        if(low > 0)\\n            l = solve(low-1,zero,one);\\n        return (h-l+mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084120,
                "title": "linear-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = {0:1}\\n        mod = 10**9 + 7\\n\\n        for i in range(1,high+1):\\n            dp[i] = (dp.get(i-one,0) + dp.get(i-zero,0)) % mod\\n        return sum([dp[i] for i in range(low,high+1)]) % mod\\n\\n# time/space complexity -> O(N)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = {0:1}\\n        mod = 10**9 + 7\\n\\n        for i in range(1,high+1):\\n            dp[i] = (dp.get(i-one,0) + dp.get(i-zero,0)) % mod\\n        return sum([dp[i] for i in range(low,high+1)]) % mod\\n\\n# time/space complexity -> O(N)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082279,
                "title": "python-bottom-up-tabulation-10-lines",
                "content": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0] * (high+1)\\n        dp[0] = 1\\n        for i in range(1, high+1):\\n            if i - zero >= 0:\\n                dp[i] += dp[i-zero]\\n            if i - one >= 0:\\n                dp[i] += dp[i-one]\\n        return sum(dp[low:high+1]) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0] * (high+1)\\n        dp[0] = 1\\n        for i in range(1, high+1):\\n            if i - zero >= 0:\\n                dp[i] += dp[i-zero]\\n            if i - one >= 0:\\n                dp[i] += dp[i-one]\\n        return sum(dp[low:high+1]) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074486,
                "title": "c-interesting-way-for-dp-solutions-which-state-defining-variable-is-more-efficient",
                "content": "# Code\\n```\\nconst int MOD = pow(10, 9) + 7;\\nclass Solution {\\npublic:\\n    int arr[100005];\\n    long long recur(int low, int high, int zero, int one, int size){\\n      if(size > high) return 0; // Base Case\\n      if(arr[size] != -1) return arr[size];\\n      long long ans = recur(low, high, zero, one, size + zero)%MOD + recur(low, high, zero, one, size + one)%MOD;\\n      if(size >= low) ans = (ans + 1)%MOD;\\n      return arr[size] = ans%MOD;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        memset(arr, -1, sizeof(arr));\\n        return recur(low, high, zero, one, 0);\\n    }\\n};\\n\\n// Main Observation was that how can we uniquely identify the state of a call, size is perfect for that and it also makes\\n// the problem a single loop to 10^5 in worst case. Size is good because it doesn\\'t matter how you have formed the current\\n// string, since you are calling both ones and zeros from the current string so it would result in same number everytime (Current string doesn\\'t matter)\\n// Additionally, if low and high were same this problem can be solved in O(1) time, think about in sense of recur trees....\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nconst int MOD = pow(10, 9) + 7;\\nclass Solution {\\npublic:\\n    int arr[100005];\\n    long long recur(int low, int high, int zero, int one, int size){\\n      if(size > high) return 0; // Base Case\\n      if(arr[size] != -1) return arr[size];\\n      long long ans = recur(low, high, zero, one, size + zero)%MOD + recur(low, high, zero, one, size + one)%MOD;\\n      if(size >= low) ans = (ans + 1)%MOD;\\n      return arr[size] = ans%MOD;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        memset(arr, -1, sizeof(arr));\\n        return recur(low, high, zero, one, 0);\\n    }\\n};\\n\\n// Main Observation was that how can we uniquely identify the state of a call, size is perfect for that and it also makes\\n// the problem a single loop to 10^5 in worst case. Size is good because it doesn\\'t matter how you have formed the current\\n// string, since you are calling both ones and zeros from the current string so it would result in same number everytime (Current string doesn\\'t matter)\\n// Additionally, if low and high were same this problem can be solved in O(1) time, think about in sense of recur trees....\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066221,
                "title": "python-1-d-dp-array-solution-easy-to-understand",
                "content": "To understand this first try using strings (this solution will go over the time limit but its good for understanding) \\n\\nWe create an array of strings, where the index is the length. Starting with \"\" we can build each following string using the two steps of adding \\'0\\' *zero* times and \\'1\\' *one* times. \\n\\nLet zero = 1 and one = 1, then it around dp array would look like:\\n\\n| 0         | 1     | 2 | 3 |\\n|--------------|-----------|------------ |------------|\\n| (\"\") | (1,0)      | (00,01,10,11)        | (000,001, ... ,111)       |\\n\\nNotice how each string can be built by applying the rules to the strings from the previous index? Also notice that the index is always the size of the string? Here is it in code:\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [set() for _ in range(high+1)]\\n        dp[0].add(\"\")\\n        count = 0 \\n        for i in range(len(dp)):\\n\\t\\t\\tfor s in dp[i]:\\n\\t\\t\\t\\tif i+zero < len(dp):\\n\\t\\t\\t\\t\\tdp[i+zero].add(s+(\\'0\\' * zero))\\n\\t\\t\\t\\tif i+one < len(dp):\\n\\t\\t\\t\\t\\tdp[i+one].add(s+(\\'1\\' * one))\\n\\t\\t\\tif i >= low and i<= high: \\n\\t\\t\\t\\tcount += len(dp[i])\\n        return count % ((10**9) + 7)\\n```\\n\\n\\nYou should notice we are doing a lot of uncessary work, first because the number of 1s and 0s we add is fixed, it means each \"new string\" can only produce 2 more \"new strings\". \\n\\nFor example:\\n* \"\" can only produce 1 and 0\\n* 1,0 can only produce 00,01,10,11 and so on. \\n\\nIn the case of zero = 1 and one = 1 it will both be in the next index, but these \"new strings\" can be any length and thus in any index (depending on the zero and one variables). \\n\\nSo finally, we can just add the current strings to the next length index to represent a unique string being created and then also keep a running count of the number of unique strings produced. Important to note: that running count will only go up if the length (or index in our case) is between low and high.  \\n\\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0 for _ in range(high+1)]\\n        dp[0] = 1\\n        count = 0 \\n        for i in range(len(dp)):\\n            if i+zero < len(dp):\\n                dp[i+zero] += (dp[i])\\n            if i+one < len(dp):\\n                dp[i+one] += (dp[i])\\n            if i >= low and i<= high: \\n                count += dp[i]\\n        return count % ((10**9) + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [set() for _ in range(high+1)]\\n        dp[0].add(\"\")\\n        count = 0 \\n        for i in range(len(dp)):\\n\\t\\t\\tfor s in dp[i]:\\n\\t\\t\\t\\tif i+zero < len(dp):\\n\\t\\t\\t\\t\\tdp[i+zero].add(s+(\\'0\\' * zero))\\n\\t\\t\\t\\tif i+one < len(dp):\\n\\t\\t\\t\\t\\tdp[i+one].add(s+(\\'1\\' * one))\\n\\t\\t\\tif i >= low and i<= high: \\n\\t\\t\\t\\tcount += len(dp[i])\\n        return count % ((10**9) + 7)\\n```\n```\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        dp = [0 for _ in range(high+1)]\\n        dp[0] = 1\\n        count = 0 \\n        for i in range(len(dp)):\\n            if i+zero < len(dp):\\n                dp[i+zero] += (dp[i])\\n            if i+one < len(dp):\\n                dp[i+one] += (dp[i])\\n            if i >= low and i<= high: \\n                count += dp[i]\\n        return count % ((10**9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055285,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        int mod = 1000000007;   \\n        for ( int size = high; size >= 0; size--){\\n            int ans1 = 0; int ans2 = 0; int ans3 = 0;\\n            if (size >= low) dp[size] += 1;\\n            if (size + zero <= high) dp[size] = (dp[size] + dp[size+zero]) % mod;\\n            if (size + one <= high) dp[size] = (dp[size] + dp[size+one]) % mod;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int[] dp = new int[high+1];\\n        int mod = 1000000007;   \\n        for ( int size = high; size >= 0; size--){\\n            int ans1 = 0; int ans2 = 0; int ans3 = 0;\\n            if (size >= low) dp[size] += 1;\\n            if (size + zero <= high) dp[size] = (dp[size] + dp[size+zero]) % mod;\\n            if (size + one <= high) dp[size] = (dp[size] + dp[size+one]) % mod;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892071,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891568,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891570,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1681133,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891742,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891725,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891585,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891664,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891680,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1892632,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1892071,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891568,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891570,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1681133,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891742,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891725,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891585,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891664,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1891680,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1892632,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nFirst, let's change the variable names to avoid confusion:\n```\nzero -> numZeros\none -> numOnes\n```\nWe start with an empty string, and at each step we have two choices:\n- Append the character `'0'` `numZeros` times. In other words, append string `\"000...numZeros times\"` to the current string.\n- Append the character `'1'` `numOnes` times. In other words, append string `\"111...numOnes times\"` to the current string.\n\nYou might think that at each step we have two choices, but actually we have three. Can you think of the third one?\n\n# Hint 2\nSince the operations can be done any number of times, we might decide to just stop adding 0s or 1s and call current string to be final to check for good or not. For example, `low = 1, high = 10` and we made a string `\"0011100\"` until now. We can add 0s or 1s but we can also stop adding anything at all because this is also a good string.\nAlthough, we should only consider the third choice when current string's length is at least equal to `low`.\n\n# Hint 3\nSuppose we made a string of length `len` until now, and want to calculate number of good strings by either not adding or adding 0s or 1s. Let's denote this by `f(len)`. Main function asks us for `f(0)`.\n\n# Hint 4\nNow, we have three choices\n1. Add `numZeros 0s`, making length `len + numZeros` and calculate number of good strings, calling `f(len + numZeros)`.\n2. Add `numOnes 1s`, making length `len + numOnes` and calculate number of good strings, calling `f(len + numOnes)`.\n3. Don't add anything, and call it the final string. Check if current `len` is in good range. If yes, add 1 to answer as this is also a good string.\n\nAs we want to count all the strings, add them.\n```\nif low <= len <= high:\n    f(len) = f(len + numZeros) + f(len + numOnes) + 1\nelse:\n    f(len) = f(len + numZeros) + f(len + numOnes)\n```\nThis can also be written compactly as\n```\nf(len) = f(len + numZeros) + f(len + numOnes) + int(low <= len <= high)\n```\nBase case can be when `len > high` as now adding or not adding will never make a good string.\n\nNow build Recursive -> Memoization -> Iterative.\nUpvote if helps!"
                    },
                    {
                        "username": "meow_power",
                        "content": "<b>Best of luck for today's biweekly contest guys :)</b>"
                    },
                    {
                        "username": "motralk",
                        "content": "ay yo thanks nya nya, same to u"
                    },
                    {
                        "username": "khe1154",
                        "content": "what does it mean to append character 0 zero times? should we append it or not?"
                    },
                    {
                        "username": "Anniebme",
                        "content": "Question should be updated to not use terrible variable names.  (int low, int high, int zero, int one)  should be (int minLength, int MaxLength, int Numzeros, int NumOnes) {"
                    },
                    {
                        "username": "GD18",
                        "content": "\"zero \" and \"one\" are variables here, appending \\'0\\' zero times means, appending the character \\'0\\', times the value of the var zero, ie, if the value of zero == 3, that means we have to append 0 three times in a single operation, ex:- on an empty string = \"\" , we will append \"000\" when we have to append 0, as the val of zero ==3."
                    },
                    {
                        "username": "khe1154",
                        "content": "got it, thanks for the replies. they should rename `zero` and `one` to `noOfZeroes` and `noOfOnes`"
                    },
                    {
                        "username": "07ShreyanshLohiya",
                        "content": "it means if you are forming the string then if you want to append \\'0\\' then append it zero times. Therefore length increases by len = len + zero ."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "this will never be the case , as value of zero here is always >= 1"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "zero variable has a value we should append that value number of  times"
                    },
                    {
                        "username": "bharath_reddy_v",
                        "content": "Here,zero is a variable so the thing is you can append integer 0 to the string \"zero\" number of times"
                    },
                    {
                        "username": "raaayyyaaaan",
                        "content": "zero as in the variable zero, and 1 <= zero always"
                    },
                    {
                        "username": "YogiV07",
                        "content": "Try solving this before attempting  -\\n\\n[Climbing-Stairs](https://leetcode.com/problems/climbing-stairs/)"
                    },
                    {
                        "username": "BretzelLudique",
                        "content": "you teach a man to fish stairs"
                    },
                    {
                        "username": "Hautar",
                        "content": "Thx a lot, Very good hint"
                    },
                    {
                        "username": "shantanumapari17",
                        "content": "yes got it!!"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "LeetCode is bombing us with DP questions!!! \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "btw it\\'s good to practice dp more. "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "A brief of question description.\\n\\nYou\\'re to count the number of good strings that you can form.\\nA good string will have length between ```low``` and ```high```\\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```\\'s and ```1```\\'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\\n\\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step. Also since the answer can be very large, mod it by ```10^9+7```\\n\\nUpvote if you like :)"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@AndrewEastwood](/AndrewEastwood) nope, you can add 1 zero or 1 one at each step. So at the beginning, you have the option to add a zero or one. second and third step are also the same. So, you will end up with 2^3 possible combination"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "But does it mean that the example is wrong?\\n>>>>>\\nInput: low = 3, high = 3, zero = 1, one = 1\\nOutput: 8\\nExplanation: \\nOne possible valid good string is \"011\". \\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \\nAll binary strings from \"000\" to \"111\" are good strings in this example."
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "POV: You thought the problem was easy, got a TLE error and now are looking for hints in the comment section."
                    },
                    {
                        "username": "SeineAle",
                        "content": "[@Wizzy2k01](/Wizzy2k01) \\nIsn\\'t it DP brother ?"
                    },
                    {
                        "username": "Wizzy2k01",
                        "content": "same here.. only 14 test case passed\\nTLE"
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be one and zero in this problem, here very simple version."
                    },
                    {
                        "username": "kylestanfield",
                        "content": "Hint: coin counting"
                    },
                    {
                        "username": "akhilg11",
                        "content": "Can anyone explain me the problem statement , it seems kinda confusing to me."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "You're to count the number of good strings that you can form.\nA good string will have length between ```low``` and ```high```\nAt any step you can either append a ```0``` or a ```1```. The number of ```0```'s and ```1```'s that you can append are given by the input variables ```zero``` and ```one``` respectively.\n\nSo if ```zero = 1``` and ```one = 2``` you can add only <i>one</i> ```0```s or <i>two</i> ```1```s at each step."
                    },
                    {
                        "username": "anwendeng",
                        "content": "My first try got a negative answer for this test case!\\n200\\n200\\n10\\n1"
                    },
                    {
                        "username": "akshaymagadum77",
                        "content": "I got TLE for same TC"
                    },
                    {
                        "username": "ccle9975",
                        "content": "[@anwendeng](/anwendeng) yippie!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Finally it\\'s done https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518014/easy-recursive-c-solution/"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "Am I really getting good or the question was quite easy ? Solved it in 1st attempt"
                    },
                    {
                        "username": "alisink",
                        "content": "ques was easy"
                    }
                ]
            },
            {
                "id": 1892105,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1891861,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1891832,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1891807,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1891796,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1891749,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1891747,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1891679,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1714147,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1912038,
                "content": [
                    {
                        "username": "2020pcecsnitu137",
                        "content": "so much DP\\uD83E\\uDD2F"
                    },
                    {
                        "username": "EricRaw",
                        "content": "What is wrong with my code?\n ```\nclass Solution {\n    int answer = 0;\n    int MOD = 1_000_000_007;\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        if (zero == low && zero == high && one == 1 || one == high && one == low && zero == 1) {\n            return 2;\n        }\n        int dp[] = new int[high + low + zero];\n        Arrays.fill(dp, -1);\n        recursive(low, high, zero, one, 0, dp);\n        return answer;\n    }\n    int recursive(int low, int high, int zero, int one, int i,int[] dp) {\n        if (i >= low && i <= high) {\n            answer = (answer + 1) % MOD;\n        }\n        if (i > high) return 0;\n        if (i == high) return 1;\n        if (dp[i] != -1) {\n            answer = (answer + dp[i]) % MOD;\n            return dp[i];\n        }\n        int temp1 = recursive(low, high, zero, one, i + zero, dp);\n        int temp2 = recursive(low, high, zero, one, i + one, dp);\n        return dp[i] = (temp1 + temp2) % MOD;\n    }\n}\n```\nwhen the test case is\nlow = 1\nhigh = 10000\nzero = 1\none = 1\nthe answer become weird"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@TatianaVol]Thanks, i forget to add 1 to the dp and only add it into answer. I got it working now(/TatianaVol) "
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Costan] yeah, the allocated dimension should be \\n```\\nint dp[] = new int[high]\\n```\\ni don\\'t even know why i use high + zero + one.Thanks for pointing that out \\n(/Costan)"
                    },
                    {
                        "username": "Costan",
                        "content": "can u explain the allocated dimension given to the dp array? how did u choose it? From the code it seems that the \\'i\\' it will never reach high as value(when it does the recursive method did not look into dp array but return 1)."
                    },
                    {
                        "username": "TatianaVol",
                        "content": "`dp[i] = (temp1 + temp2) % MOD`\nchange on\n`dp[i] = ((i >= low ? 1 : 0) + temp1 + temp2) % MOD`"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "in the second example why 01 and 10 not a good string?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because in the second example, we append the 1 'two' times in one turn which 01 and 10 is not possible, it will become 011 and 110"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "Make sure u did climbing stairs before doing this.."
                    },
                    {
                        "username": "_drigger",
                        "content": "think this as ladder problem in which to reach at particular step it depends on previous steps and those steps will be `one` and `zero` in this problem."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "Description is really confusing because of the variable names.\\nA better description would use the names.\\n`low` -> `minLength`\\n`high` -> `maxLength`\\n`zero` -> `numZeros`\\n`one` -> `numOnes`"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "After going directly to answers for the the whole week, I have a delusion that I can solve DP now."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "DP days are here guys "
                    },
                    {
                        "username": "sunny-1651",
                        "content": "```\\nclass Solution {\\n    void f(string s, int low, int high, string x, string y, int& count){\\n        if (s.size() >= low && s.size() <= high) {\\n            count++;\\n        }\\n        if (s.size() >= high) return;\\n        f(s+x, low, high, x, y, count);\\n        f(s+y, low, high, x, y, count);\\n    }\\npublic:\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        return 1;\\n        string x = \"\", y = \"\";\\n        for (int i = 0; i<zero; i++) x += \\'0\\';\\n        for (int i = 0; i < one; i++) y += \\'1\\';\\n        int ans = 0;\\n        string temp = \"\";\\n        f(temp, low, high, x, y, ans);\\n        return ans;\\n    }\\n};\\n```\\nThis is my solution but it is giving tle on input 200 . Can someone help me optimize it"
                    },
                    {
                        "username": "sharkzz",
                        "content": "you can try vary  integer value as index which will be easy to optimize using memoization as you have only two choices either u take 0 zero time so index updated to (ind+zero) or 1 one time (ind+zero) and if index equals to the desired size return 1 else if greater than the given size return zero ...\n\nyou can  refer this:-\n\n    int soln(int c0, int c1 ,int i,int high,vector<int>&dp)\n    {\n       \n        if(i>high)return 0;\n        if(i==high)\n        {\n            return 1;\n        }\n        if(dp[i]!=-1)return dp[i]; \n        int c_1=soln(c0,c1,i+c0,high,dp);\n        \n\n        int c2=soln(c0,c1,i+c1,high,dp);\n\n        return dp[i]=(c_1+c2);\n    }\n\n  "
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "You could start by not actually creating the string. Your f function would look like this:\\n`f(int lenString, int low, int high, int zero, int one, int& count)`\\n\\nThis won\\'t be enough, but you will notice that **we don\\'t need to know what are our possibilities, just how many we have**."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was taking mod as 1e9 and not 1e9 + 7 , and was thinking why my answer is coming wrong in large inputs \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1903355,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1899589,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1893914,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892940,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892930,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892897,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892886,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892869,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892842,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892772,
                "content": [
                    {
                        "username": "Arpit_Patel_07",
                        "content": "@harshsinghcs hey buddy...!!! how are you..?"
                    },
                    {
                        "username": "conquestace",
                        "content": "Can this problem not just be solved with combinatorics? "
                    },
                    {
                        "username": "user8913Kd",
                        "content": "Can anyone please explain what i am doing wrong here, the result return true for small low and high test cases, but false for big one.\\nWhat I tried to do is counting the number of zeros and ones possibility and make combination out of it\\nclass Solution:\\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\\n        count = 0\\n        for i in range (low, high+1):\\n            zeroCount = i//zero\\n            for j in range (0, zeroCount+1):\\n                oneCount = i//one\\n                for k in range (0, oneCount+1):\\n                    if (j*zero+k*one==i):\\n                        n=j+k\\n                        count+=math.factorial(n)/((math.factorial(j)*math.factorial(k)))\\n        return int(count%(math.pow(10,9)+7))"
                    },
                    {
                        "username": "danielmascena",
                        "content": "crushed by the testcase:\\n200\\n200\\n10\\n1\\nI try to come out with a solution starting from the low but that didn\\'t work well. I know that I need to avoid repetition using memoization but how I can improve my code to pass this testcase?\\n\\n`\\nvar countGoodStrings = function(low, high, zero, one) {\\n\\n    var counter = 0\\n\\n    function dp(target = \\'\\', size = 0) {\\n        if (size > high) return;\\n        if (size >= low) {\\n            counter++\\n        }\\n        if (size + zero <= high)\\n            dp(target + \\'0\\'.repeat(zero), size + zero)\\n        if (size + one <= high)\\n            dp(target + \\'1\\'.repeat(one), size + one)\\n    }\\n    dp()\\n    return counter\\n}; `"
                    },
                    {
                        "username": "Rowansdabomb",
                        "content": "Very poor variable naming. \"You can append 0 `zero` times\". Took me almost as long to figure out what they meant as it did to solve the problem."
                    },
                    {
                        "username": "s29962590",
                        "content": "  Can someone help me in memoization ??\\n``` \\nclass Solution {\\npublic:\\nint ans=0;\\nstring sz=\"\",so=\"\";\\n    void func(string s,int l,int h)\\n    {\\n        if(s.size()>h)\\n            return ;\\n        if(s.size()>=l && s.size()<=h)\\n        {\\n            ans++;\\n           // return ;\\n        }\\n        func(s+sz,l,h);\\n        func(s+so,l,h);\\n    }\\n    int countGoodStrings(int l, int h, int z, int o) {\\n        string str=\"\";\\n        \\n        for(int i=0;i<z;i++)\\n            sz+=\\'0\\';\\n        for(int i=0;i<o;i++)\\n            so+=\\'1\\';    \\n        func(str,l,h);\\n        return ans;        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot get the example #1. given zeroTimes = 1 and oneTimes = 1\\nhow did they get \"011\". There are two `1`. How do we get two ones when we do have just one?"
                    },
                    {
                        "username": "ShivamRawatlow",
                        "content": "Can anybody tell me how can I memoize this code? Without changing void to int in the recurse function : \n\n`class Solution {\n    int count = 0;\n    int high;\n    int low;\n    String zeroString = \"\";\n    String oneString = \"\"; \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        this.high = high;\n        this.low = low; \n\n        for(int i = 0; i<zero; i++){\n            zeroString += \"0\";\n        }\n        for(int i = 0; i<one; i++){\n            oneString += \"1\";\n        }\n\n        recurse(\"\");\n\n        return count % 1000000007;\n    }\n\n    public void recurse(String s){\n        if(s.length() >= low && s.length() <= high){\n            count++;\n            count = count % 1000000007;\n        }\n        \n        if(s.length() > high){\n            return;\n        }\n\n        String addZero = s + zeroString;\n        recurse(addZero);\n        \n        String addOne = s + oneString;\n        recurse(addOne);\n    }\n}`"
                    },
                    {
                        "username": "user0293ih",
                        "content": "Below code is failing at test 35, i dunno why ? plz help here.\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    unordered_map<int,long long int> mp;\\n    long long int solve(int x,int &zero,int &one)\\n    {\\n        if(x==0) return mp[x]=1;\\n        if(x<0) return mp[x]=0;\\n        long long int ans1=0,ans2=0;\\n        \\n        if(mp.find(x-zero)!=mp.end()) ans1=mp[x-zero];\\n        else ans1=solve(x-zero,zero,one)%mod;\\n        if(mp.find(x-one)!=mp.end()) ans2=mp[x-one];\\n        else ans2=solve(x-one,zero,one)%mod;\\n\\n        return mp[x]=(ans1%mod + ans2%mod)%mod;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        mp.clear();\\n        int ans=0;\\n        \\n        solve(high,zero,one);\\n        for(int i=low;i<=high;i++) \\n        {\\n            ans = (ans%mod+mp[i]%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "` `\nclass Solution:\n    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recur(length):\n            print(length)\n            if low <= length <= high:\n                return 1\n            if length > high:\n                return 0\n            add0 = recur(length + zero)\n            add1 = recur(length + one)\n            return add1 + add0\n        return recur(0). \n``\ncan anyone tell me why this gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1892305,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892262,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892246,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892145,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892139,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892122,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892093,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892069,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892062,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1892046,
                "content": [
                    {
                        "username": "SrBigoton",
                        "content": "Isn\\'t the first example wrong? As I can have only 1 \\'one\\' and 1 \\'zero\\', and there are no combinations for a string of 3 characters that meet that conditions at the same time? Why is \\'111\\' a valid solution?"
                    },
                    {
                        "username": "SenpaiJody",
                        "content": "The problem states:\\n------\\n...and then at each step perform either of the following:\\n\\n - Append the character \\'0\\' zero times.\\n - Append the character \\'1\\' one times.\\n\\n*This can be performed any number of times.*\\n------\\n\\nyou can do the process of adding however many times you want; it\\'s just that when you choose to add a 1, you have to add it \\'one\\' number of times at once; or if you choose to add a 0, you have to add it \\'zero\\' number of times.\\n\\n\\'111\\' is a valid solution because it consists of adding one \\'1\\' 3 separate times\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Managed to solve it with 1 attempt :)**"
                    },
                    {
                        "username": "GD18",
                        "content": "DP/Memoization week, even the JS challenge question today was Memoize lmao"
                    },
                    {
                        "username": "Rajput2003",
                        "content": "I an getting the memory Limit Exceeded error how to solve this error i am using memorization approach for this problem???"
                    },
                    {
                        "username": "dynamo214",
                        "content": "are you passing memoization array by ref or value? can you share your code once"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "crying in corner \\uD83D\\uDE23"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can someone point my error? And explain the improvement?\\n\\nclass Solution {\\n\\n    public static void check(int length , int zero , int one , int count){\\n        if(length == 0){\\n            count = count + 1;\\n        }\\n        if(length < 0){\\n            return;\\n        }\\n        check(length - zero , zero , one , count);\\n        check(length - one , zero , one , count );\\n    }\\n\\n    public int countGoodStrings(int low, int high, int zero, int one) {\\n        int count = 0;\\n        int length = low;\\n\\n        while(length <= high){\\n            check(length , zero , one , count);\\n            length++;\\n        }\\n\\n        System.out.println(count);\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@EricRaw](/EricRaw) Also without memoization it will result into TLE"
                    },
                    {
                        "username": "EricRaw",
                        "content": "In Java, all primitive types (int, double, boolean, etc.) are passed by value. So in your code, the count variable is passed by value to the check. the check function does not change the original count. \n\nyou can set the count as global variable so you can update the count in your check function\n\n```\nclass Solution {\n    int count = 0;\n    public void check(int length , int zero , int one){\n        if(length == 0){\n            count = count + 1;\n        }\n        if(length < 0){\n            return;\n        }\n        check(length - zero , zero , one);\n        check(length - one , zero , one);\n    }\n\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        int length = low;\n\n        while(length <= high){\n            check(length , zero , one);\n            length++;\n        }\n\n        return count;\n    }\n}\n```\n\nand don't forget to use modulo 10^9 + 7 because it will lead to integer overflow and use memoization."
                    },
                    {
                        "username": "kevinyou77",
                        "content": "Don\\u2019t forget to mod the return value by (10 ** 9) + 7. Didn\\u2019t do that in my memoization solution and got TLE"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Was confused for so long... you add \\'0\\' `zero` times, as in the parameter `zero`, not literally add it 0 times"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "I\\'m glad that I was able to solve today\\'s question correctly on my first attempt =)"
                    },
                    {
                        "username": "lostintime",
                        "content": "if you can\\'t be bothered to word the question correctly, i can\\'t be bothered to answer it"
                    }
                ]
            },
            {
                "id": 1891986,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891960,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891944,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891935,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891880,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891851,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891754,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891753,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891751,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            },
            {
                "id": 1891730,
                "content": [
                    {
                        "username": "Mehul_773",
                        "content": "How can I convert the given code into a memorized solution\\nI got TLE\\n\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void ans(int low, int high, int zero, int one,string& s)\\n    {\\n        if(low==high)\\n        {\\n              if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        }\\n        if(s.length()==low)\\n        {\\n            count++;\\n        }\\n        if(s.length()==high)\\n        {\\n            count++;\\n            return;\\n        }\\n        if(s.length()>high)\\n        {\\n            return;\\n        }\\n        string zeroS = s;\\n        string oneS = s;\\n        for(int i=0;i<zero;i++)\\n        {\\n            zeroS+=\"0\";\\n        }\\n        for(int i=0;i<one;i++)\\n        {\\n            oneS+=\"1\";\\n        }\\n        ans(low,high,zero,one,zeroS);\\n        ans(low,high,zero,one,oneS);\\n        return;\\n    }\\n    int countGoodStrings(int low, int high, int zero, int one) {\\n        string s = \"\";\\n        ans(low,high,zero,one,s);\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "Mehul_773",
                        "content": "[@judgementdey](/judgementdey)  okay Thanks "
                    },
                    {
                        "username": "judgementdey",
                        "content": "You don\\'t need to actually create all combinations of the string. That is most likely causing the TLE. You only need to track the length of the different combinations of the strings."
                    },
                    {
                        "username": "raiabhinavprakash",
                        "content": "This is my code which is giving TLE. Can someone modify it to memoization.\n````\nvoid f(int low, int high, string s, string sz, string so, set<string>&st)\n    {\n        if(s.size()>high) return;\n        if(s.size() >= low && s.size() <= high)\n        {\n            st.insert(s);\n        }\n        f(low, high, s+sz, sz, so, st);\n        f(low, high, s+so, sz, so, st);\n    }\n\n    int countGoodStrings(int low, int high, int zero, int one) {\n        string s = \"\", sz = \"\", so = \"\";;\n        while(zero--)\n        {\n            sz += '0';\n        }\n        while(one--)\n        {\n            so += '1';\n        }\n        set<string>st;\n        f(low, high, s, sz, so, st);\n        return st.size();\n    }\n````"
                    },
                    {
                        "username": "judgementdey",
                        "content": "The first issue you need to fix is that actually creating all combinations of the string is not required. That will most certainly cause a TLE. You only need to track the lengths of all different combinations of the string, not the actual string itself."
                    },
                    {
                        "username": "vijay97",
                        "content": "https://leetcode.com/submissions/detail/949381614/\\n\\none Pass Solution \\nauthor : jvelmurugan274 "
                    },
                    {
                        "username": "piyushaggarwal20903",
                        "content": "this code is giving TLE \nwhat is wrong with it??\n\nclass Solution {\n    int dp[];\n\tint mod = 1_000_000_007;\n    private int f(int i, int[] dp2, int zero, int one) {\n\t\tif(i<0) return 0;\n\t\tif(i==0) return 1;\n\t\tif(dp[i]!=0) return dp[i];\n\t\telse {\n\t\t\tdp[i]=f(i-zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n\t\t}\n\t\treturn dp[i];\n\t}\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high+1];\n\t\tint count = 0;\n\t\tfor(int i=low;i<=high;i++) {\n\t\t\tint val = f(i,dp,zero,one);\n\t\t\tcount=(count+val)%mod;\n\t\t}\n\t\treturn count;\n    }\n}"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Got the same issue in first attempt, then figured out that if the memoization array is initialized to 0 and if some valid memoization value is 0 i.e dp[8] = 0 , still it will calculate again\nSo solution would be initialize dp array with -1 and check if its not -1 then return its value"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The reason your code was getting TLE was because there are cases where the answer is zero. In those cases, your code will keep calling the recursive function forever because the dp array will always contain zeros, leading to an infinite loop. \n```\n if(dp[i]!=0) return dp[i];\n else {\n    dp[i]=f(i, zero,dp,zero,one)%mod+f(i-one,dp,zero,one)%mod;\n}\n```\nto avoid this situation you should fill all the dp array with -1"
                    },
                    {
                        "username": "dz_adman",
                        "content": "Once I got correct understanding of the problem statement, it wasn't that difficult to solve it.\n\nif ```zero = 2``` and ```one = 3```, then we have two strings:\n```s0``` = ```\"00\"``` and ```s1``` = ```\"111\"```\nNow, we need to form good strings with the length in range [```low```, ```high```] both inclusive.\n> A 'good string' is a string which is made as a combination of ```s0``` and ```s1```\n\nI hope it helps."
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It\\'s easy if you know DP"
                    },
                    {
                        "username": "vnk01",
                        "content": "For those who\\'re confused with the question, here I ask both Bard and chatGPT to summarize it:\\n\\nBard:\\n `Given the number of 0s and 1s that can be appended to a string, as well as the minimum and maximum length of the string, find the number of different good strings that can be constructed. A good string is a string that has a length between the minimum and maximum length, and is constructed by appending 0s and 1s to an empty string.`\\n\\nChatGPT:\\n `The task is to create a program that counts the number of possible good strings that can be constructed from the given integers zero, one, low, and high, following certain rules.`\\n\\nOk...they\\'re equally confusing \\uD83D\\uDE35"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "ChatGPT\\'s answer is weird. It is not explaining anything.\\n"
                    },
                    {
                        "username": "colewinfield",
                        "content": "For anyone struggling with TLE using 1D dynamic programming, like I was, try putting the modulo arithmetic within the recurrence relation rather than doing final answer % (10^9 + 7). \n\nAs in, instead of \"return dp(0) % (10^9 + 7)\", do it within the for loop or the recursive function, like \"dp[i] = ... % (10^9 + 7)."
                    },
                    {
                        "username": "Harsheys",
                        "content": "Really liking the DP problems! @Leetcode pls post such interesting DP problems more!!.   \\n\\nHint for folks:\\nTry thinking this way how many strings can you form that has length i and ends in \\'0\\' and has length i and ends in \\'1\\'. \\n\\nFor eg zero=1,one =1,\\nTotal strings of length 1 ending in 0 or 1: \"0\", \"1\"\\nTotal strings of length 2 ending in 0 or 1: \"00\",\"01\",\"11\",\"10\"\\nwhich is nothing but total strings of length(2-zero) ending in \\'0\\'  and total strings of length(2-one) ending in \\'1\\'.\\n\\nCan u see subproblems now? Think it."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Problem statement explained: you can do infinite number of operations, where each operation you can 1) append the character '0' `zero` times, or 2) append the character '1' `one` times, so that the final \"good\" string has a length between `low` and `high`. Hope this helps :)"
                    }
                ]
            }
        ]
    }
]