[
    {
        "title": "Number of Submatrices That Sum to Target",
        "question_content": "Given a matrix&nbsp;and a target, return the number of non-empty submatrices that sum to target.\nA submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.\nTwo submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate&nbsp;that is different: for example, if x1 != x1'.\n&nbsp;\nExample 1:\n\nInput: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\nOutput: 4\nExplanation: The four 1x1 submatrices that only contain 0.\n\nExample 2:\n\nInput: matrix = [[1,-1],[-1,1]], target = 0\nOutput: 5\nExplanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.\n\nExample 3:\n\nInput: matrix = [[904]], target = 0\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= matrix.length <= 100\n\t1 <= matrix[0].length <= 100\n\t-1000 <= matrix[i] <= 1000\n\t-10^8 <= target <= 10^8",
        "solutions": [
            {
                "id": 303750,
                "title": "java-c-python-find-the-subarray-with-target-sum",
                "content": "# Intuition\\nPreaquis: [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)\\nFind the Subarray with Target Sum in linear time.\\n<br>\\n\\n# Explanation\\nFor each row, calculate the prefix sum.\\nFor each pair of columns,\\ncalculate the accumulated sum of rows.\\nNow this problem is same to, \"Find the Subarray with Target Sum\".\\n<br>\\n\\n# Complexity\\nTime `O(mnn)`\\nSpace `O(m)`\\n<br>\\n\\n**Java**\\n```java\\n    public int numSubmatrixSumTarget(int[][] A, int target) {\\n        int res = 0, m = A.length, n = A[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter.clear();\\n                counter.put(0, 1);\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.getOrDefault(cur - target, 0);\\n                    counter.put(cur, counter.getOrDefault(cur, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numSubmatrixSumTarget(self, A, target):\\n        m, n = len(A), len(A[0])\\n        for row in A:\\n            for i in xrange(n - 1):\\n                row[i + 1] += row[i]\\n        res = 0\\n        for i in xrange(n):\\n            for j in xrange(i, n):\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n                for k in xrange(m):\\n                    cur += A[k][j] - (A[k][i - 1] if i > 0 else 0)\\n                    res += c[cur - target]\\n                    c[cur] += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numSubmatrixSumTarget(int[][] A, int target) {\\n        int res = 0, m = A.length, n = A[0].length;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter.clear();\\n                counter.put(0, 1);\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.getOrDefault(cur - target, 0);\\n                    counter.put(cur, counter.getOrDefault(cur, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];\\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def numSubmatrixSumTarget(self, A, target):\\n        m, n = len(A), len(A[0])\\n        for row in A:\\n            for i in xrange(n - 1):\\n                row[i + 1] += row[i]\\n        res = 0\\n        for i in xrange(n):\\n            for j in xrange(i, n):\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n                for k in xrange(m):\\n                    cur += A[k][j] - (A[k][i - 1] if i > 0 else 0)\\n                    res += c[cur - target]\\n                    c[cur] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 303773,
                "title": "c-o-n-3-simple-1d-subarray-target-sum-applied-to-2d-array",
                "content": "**Explaination:**\\nCheck out how to solve for 1D array `560. Subarray Sum Equals K` in O(n) time.\\n\\nThe solution for 1D array uses running prefix sum.\\n* We know that to get sum of a subarray `[j,i]` we can calculate using `SUM[0,i] - SUM [0,j-1]`.\\n* If this calculation = target then we have a subarray who\\'s sum equals target and ends at `i`.\\n* Hence at any point `i` we need to find number of occurence of `runningSum - target` since `x + target = runningSum`.\\n* We start moving from 1st element to the last and keep adding the value to running sum.\\n* We also keep a hash map maintaining number of such sums occured.\\n* Thus at any point `i` we have sums from [0,i) stored in hashmap where `i` ranges from `0` to `i` excluding `i`. eg: at `i=3`, we have `SUM[0,0`] , `SUM[0,1]` and `SUM[0,2]`.\\n* At each index `i` we can then query the hashmap to find out number of occurences of `runningSum-target` to get number of subarrays ending at `i`.\\n\\nNow since we know how to find number of subarrays who\\'s sum equals target for 1D array.\\nWe can convert a 2D matrix of values to 1D matrix whose values equal to that of 2D. Such that they have combination of all rows and apply the same technique.\\neg: [[1,2,3,4,5],[2,6,7,8,9]]\\n\\nWe can break this down to 1 2x5 matrix and 2 1x5 matrix\\nThus the 1D value matrices are:\\n* We start row wise\\n* 1st 1x5 matrix is matrix[0] itself [1,2,3,4,5].\\n* We then add second row to previous 1D matrix and get [3,8,10,12,14].\\n* We then move on to make matrices with 2nd row of the original matrix as their first row.\\n* Since 2nd row is the last we end up with last 1D matrix of [2,6,7,8,9].\\n\\nWe use the same technique for each 1D matrix created in above steps and keep adding the result for these individual 1D arrays and return that as the result in the end.\\n\\nIf you notice in the case of 1D array you get results for subarrays of all lengths starting from any point.\\nso you are checking rectangles of 1x1, 1x2, 1x3 ..... upto length.\\nWhen you apply this to a 2D->1D array at each `i` you are checking rectangles of all sizes starting from `i`.\\nwhich looks like ( (1x1, 1x2 ...upto length of row then 2x1, 2x2 ...upto length of a row) .... upto length of columns) for each row in original matrix as their 1st row, hence the result includes all combinations of submatrices.\\n\\n**Note:** You can make this a little bit faster by sacrificing space and precalculating all prefix sums in the 2D matrix and storing them as in `304. Range Sum Query 2D - Immutable` so that we have a constant lookup for calculating sums, this way we avoid recalculating sums of overlapping rows.\\n\\n**Solution:**\\n```c++\\nclass Solution {\\npublic:\\n    int result=0,target;\\n    unordered_map<int,int> map;\\n    void get_result(vector<int>& nums)                          //Get number of subarrays that sum to target.\\n    {\\n        int sum=0;\\n        map.clear();\\n        map[0]++;\\n        for(int &i:nums)\\n        {\\n            sum+=i;\\n            result+=map[sum-target];       //get number of subarrays who\\'s sum equals target and end at i and add result to global result.\\n            map[sum]++;                    //Add the occurence of running sum to map.\\n        }\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) \\n    {\\n        this->target=target;\\n        vector<int> row(matrix[0].size());\\n        for(int i=0;i<matrix.size();i++)                    //Convert 2D array to 1D by row.\\n        {\\n            fill(row.begin(),row.end(),0);                  //Clear vector to start the row with i as starting row.\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int x=0;x<matrix[0].size();x++)         //Add next row\\n                    row[x]+=matrix[j][x];\\n                get_result(row);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int result=0,target;\\n    unordered_map<int,int> map;\\n    void get_result(vector<int>& nums)                          //Get number of subarrays that sum to target.\\n    {\\n        int sum=0;\\n        map.clear();\\n        map[0]++;\\n        for(int &i:nums)\\n        {\\n            sum+=i;\\n            result+=map[sum-target];       //get number of subarrays who\\'s sum equals target and end at i and add result to global result.\\n            map[sum]++;                    //Add the occurence of running sum to map.\\n        }\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) \\n    {\\n        this->target=target;\\n        vector<int> row(matrix[0].size());\\n        for(int i=0;i<matrix.size();i++)                    //Convert 2D array to 1D by row.\\n        {\\n            fill(row.begin(),row.end(),0);                  //Clear vector to start the row with i as starting row.\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int x=0;x<matrix[0].size();x++)         //Add next row\\n                    row[x]+=matrix[j][x];\\n                get_result(row);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803353,
                "title": "java-solution-with-detailed-explanation",
                "content": "## Before this problem\\n>https://leetcode.com/problems/subarray-sum-equals-k/\\n>https://leetcode.com/problems/subarray-sum-equals-k/discuss/803317/Java-Solution-with-Detailed-Explanation\\n## Thinkings\\n\\n1.  For a matrix, what is the prefix sum ?\\n\\n\\t   sum[x] [y] is the sum of submatrix \\n\\n\\t   (The upper left corner is matrix[0] [0], the lower right corner is matrix[x] [y])\\n\\n\\t  ![image](https://assets.leetcode.com/users/images/da24efb3-690d-487a-b40f-8afb366907b8_1597987444.885463.png)\\n\\n\\n2. How to calculate the sum of all submatrices ***whose upper left corners are matrix[0] [0]*** \\uFF1F\\n\\n   Step 1. Calculate the prefix sum of each line.\\n\\n\\t  ![image](https://assets.leetcode.com/users/images/04f9a388-d83a-499c-b7bf-2423a0e4833e_1597987466.6122327.png)\\n\\n\\n   ```java\\n   // Like the one-dimensional prefix sum, \\n   // in order to prevent index out of range and facilitate calculations,\\n   // we add an extra column with all 0s at the forefront.\\n   int line = matrix.length;\\n   int column = matrix[0].length + 1;\\n   int[][] sum = new int[line][column]; // Initialization default is all 0\\n           \\n   for (int l = 0; l < sum.length; l++){\\n     // start from the second column\\n     for (int c = 1; c < sum[0].length; c++){\\n       sum[l][c] = sum[l][c - 1] + matrix[l][c - 1]; // \"c - 1\",because of an extra column.\\n     }\\n   }\\n   ```\\n\\n\\t  ![image](https://assets.leetcode.com/users/images/36d2c68a-1682-4e79-9eb2-84f12b4d0677_1597987495.016029.png)\\n\\n\\n   Step 2. Using the prefix sum of each line to calculate the sum of submatrix.\\n\\n   ![image](https://assets.leetcode.com/users/images/bdd7351c-95df-4c5d-be1a-eed32d7c9057_1597987518.405201.png)\\n\\n\\n   ```java\\xA0\\n   sum[1][2] = sum[1][2] + sum[0][2]; // green + orange\\n   ```\\n\\n   ```java\\n   sum[2][2] = sum[2][2] + sum[1][2] + sum[0][2]; // blue + green + orange\\n   ```\\n\\n   So, to caculate any sum of submatrices ***whose upper left corner are matrix[0] [0].***\\n\\n   ```java\\n   int sumOfSubMatrix = 0;\\n   \\n   for(int l = 0; l < line; l++){\\n   \\tsumOfSubMatrix += sum[l][column]; // one of submatrices\\n   }\\n   ```\\n\\n\\n\\n3. How to find all submatrices ?\\n\\n   1. Any submatrix needs any two rows and any two columns to form, that is to say, four variables and four nested loops are required.\\n\\n      ```java\\n      // Use double nested \"for\" loop to select any two columns\\n      for (int start = 0; start < column; start++){\\n                  for (int end = start + 1; end < column; end++ ){\\n                    \\t// ...\\n                    \\t// Then Use double nested \"for\" loop to select any two lines\\n                  \\t}\\n                  }\\n      ```\\n\\n   2. Convert 2D to 1D\\n\\n      Step 1 : Use the ***prefix sum of each row*** to calculate the matrix sum between the \"start\" column and \"end\" column.\\n\\n      ![image](https://assets.leetcode.com/users/images/14f2cef5-3e35-4d80-abfa-184c6c58b3a0_1597986571.6869073.png)\\n\\n\\n      Step 2 : Rotate it 90 degrees to the left, ***it can be regarded as a one-dimensional array.***\\n\\n\\t\\t ![image](https://assets.leetcode.com/users/images/5c6c40f3-55ab-4af5-b090-f0b32c018c9e_1597986584.019118.png)\\n\\n\\n      Then the problem is transformed into how many sub-arrays whose sum == target ?\\n\\n      ***It\\'s the same with >https://leetcode.com/problems/subarray-sum-equals-k/***\\n\\n      Step 3 : In the same way, we can use hashmap to optimize the double nested loop for any two lines, and only need one loop\\n\\n      ```java\\n      int sumOfSubMatrix = 0;\\n      Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n      map.put(0, 1);\\n      \\n      for(int l = 0; l < line; l++){\\n        // prefix sum\\n      \\tsumOfSubMatrix += sum[l][end] - sum[l][start];\\n        \\n      \\tif (map.containsKey(sumOfSubMatrix - target))\\n      \\t\\tcount += map.get(sumOfSubMatrix - target);\\n        \\n      \\tmap.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n      ```\\n\\n      \\n\\n      \\n\\n## Code\\n\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int count = 0;\\n        int line = matrix.length;\\n        int column = matrix[0].length + 1;\\n        int[][] sum = new int[line][column];\\n        \\n        for (int i = 0; i < sum.length; i++){\\n            for (int j = 1; j < sum[0].length; j++){\\n                sum[i][j] = sum[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        \\n        for (int start = 0; start < column; start++){\\n            for (int end = start + 1; end < column; end++ ){\\n                \\n                int sumOfSubMatrix = 0;\\n                Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n                map.put(0, 1);\\n                for(int l = 0; l < line; l++){\\n                    sumOfSubMatrix += sum[l][end] - sum[l][start];\\n                    if (map.containsKey(sumOfSubMatrix - target))\\n                        count += map.get(sumOfSubMatrix - target);\\n                    map.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```\\n\\n\\n\\n## Update\\nFor the commet from jun.\\n1. What\\'s the meaning of this sentence ?\\n+ \"Any submatrix needs any two rows and any two columns to form, that is to say, four variables and four nested loops are required.\" \\n\\n\\teg. |0| is the submatrix I want to find, whose index is [0][0]\\n\\tIn the \"sum\", the column 1 corresponds to column 0 in \"matrix\".  SO we bound the area like this\\n![image](https://assets.leetcode.com/users/images/3637adc2-9111-4232-8ce2-0195bf164e03_1618829866.7781012.png)\\n\\nSince we have done prefix sum for every line, we need to do sum[line][end_column] - sum[line][start_column], and in this case elements in start_column is all 0, when we subtract sum[line][0], It actually did nothing.\\n\\nAlso, since \"end_cloumn\" starts from \"end_cloumn = start_column + 1\", it is impossible to treat the first column of \"sum\" as part of our result.\\n![image](https://assets.leetcode.com/users/images/bef01364-0496-400b-867e-c664f40b084d_1618830124.2679777.png)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```java\\n   // Like the one-dimensional prefix sum, \\n   // in order to prevent index out of range and facilitate calculations,\\n   // we add an extra column with all 0s at the forefront.\\n   int line = matrix.length;\\n   int column = matrix[0].length + 1;\\n   int[][] sum = new int[line][column]; // Initialization default is all 0\\n           \\n   for (int l = 0; l < sum.length; l++){\\n     // start from the second column\\n     for (int c = 1; c < sum[0].length; c++){\\n       sum[l][c] = sum[l][c - 1] + matrix[l][c - 1]; // \"c - 1\",because of an extra column.\\n     }\\n   }\\n   ```\n```java\\xA0\\n   sum[1][2] = sum[1][2] + sum[0][2]; // green + orange\\n   ```\n```java\\n   sum[2][2] = sum[2][2] + sum[1][2] + sum[0][2]; // blue + green + orange\\n   ```\n```java\\n   int sumOfSubMatrix = 0;\\n   \\n   for(int l = 0; l < line; l++){\\n   \\tsumOfSubMatrix += sum[l][column]; // one of submatrices\\n   }\\n   ```\n```java\\n      // Use double nested \"for\" loop to select any two columns\\n      for (int start = 0; start < column; start++){\\n                  for (int end = start + 1; end < column; end++ ){\\n                    \\t// ...\\n                    \\t// Then Use double nested \"for\" loop to select any two lines\\n                  \\t}\\n                  }\\n      ```\n```java\\n      int sumOfSubMatrix = 0;\\n      Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n      map.put(0, 1);\\n      \\n      for(int l = 0; l < line; l++){\\n        // prefix sum\\n      \\tsumOfSubMatrix += sum[l][end] - sum[l][start];\\n        \\n      \\tif (map.containsKey(sumOfSubMatrix - target))\\n      \\t\\tcount += map.get(sumOfSubMatrix - target);\\n        \\n      \\tmap.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n      ```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int count = 0;\\n        int line = matrix.length;\\n        int column = matrix[0].length + 1;\\n        int[][] sum = new int[line][column];\\n        \\n        for (int i = 0; i < sum.length; i++){\\n            for (int j = 1; j < sum[0].length; j++){\\n                sum[i][j] = sum[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        \\n        for (int start = 0; start < column; start++){\\n            for (int end = start + 1; end < column; end++ ){\\n                \\n                int sumOfSubMatrix = 0;\\n                Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n                map.put(0, 1);\\n                for(int l = 0; l < line; l++){\\n                    sumOfSubMatrix += sum[l][end] - sum[l][start];\\n                    if (map.containsKey(sumOfSubMatrix - target))\\n                        count += map.get(sumOfSubMatrix - target);\\n                    map.put(sumOfSubMatrix, map.getOrDefault(sumOfSubMatrix, 0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162927,
                "title": "optimization-from-brute-force-to-optimized-solution-w-easy-explanation",
                "content": "There are a few solution mentioned by others but most have directly given the most optimal solution. Here, I will try to start from the brute-force approach and try to explain the various optimizations that can be done to finally arrive at the optimal solution.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force Approach) [Rejected]***\\n\\nLet\\'s start with the most basic approach to this problem. Take all the submatrices possible for the given matrix and check if their sum is equal to `target`.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\\n\\n***Time Complexity :*** **`O((M*N)^3)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Compute prefix sum for each Row or Column)***\\n\\nWe can optimize the above approach by reducing the time complexity of the `SUM` function in the above solution. We know that in a given array, the sum of range [i,j] can be calculated by `prefixSum[j] - prefixSum[i - 1]`. We can use this to optimize the solution.\\n\\nAfter computing prefix sum for each row of matrix (*you can do it for column as well*), we can get the sum of a given range in O(1) time. Thus, for any submatrix of the main matrix, we just need to iterate over all its rows and we can get sum of given range (`[colStart, colEnd]`) in O(1) time.\\n\\n1. We just start from row 0, calculate the sum for that row for the range `[colStart, colEnd]`.\\n2. Extend the sum by perform step-1 for row 1, row 2, ... and so on till last row.\\n3. Repeat this process for every `[colStart, colEnd]` combination.\\n\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O((M*N)^2)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**, since we are modifying the given matrix itself. If we use a new prefix sum matrix, the space complexity would be `O(M*N)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Further Optimization in Solution - II)***\\n\\nWe can further optimize the solution by using hashmap. The optimization done here is similar to the one in solution of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/solution/).\\n\\nBasically, we will be maintaining a running submatrix sum starting from row 0 till m, for a given `[colStart, colEnd]` range. Each sum value and number of its occurence will be stored in hashmap. If there\\'s a submatrix which was found such that `cursum` at that time was equal to present sum (`cursum`) - target, then we are sure that there were occurences of submatrices which had sum equal to `target` and the count is given by `mp[cursum - target]`.\\n\\nIf the explanation didn\\'t make the approach clear, I really suggest you to try the *560. Subarray Sum Equals K* problem and read the hashmap solution. It took me some time reading that before I was able to clearly understand this solution.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O(N*N*M)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(N)`**\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298642,
                "title": "fully-explained-intuition-4-solutions-must-read-with-image",
                "content": "Note: that\\'s a long read, but I explained the whole thinking process. It\\'s going to be worth it if you want to learn and not to memorize solutions :)\\n\\nIf you found it helpful, please upvote <3\\n\\n<hr />\\n\\n\\nLet\\'s start with the basics\\n\\nFirst, how do we generate the coordinates for all the submatrices? we need all distinct (x1,y1), (x2,y2) pairs\\n\\nSo it will be something like this:\\n\\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        print(f\"({x1}, {y1}), ({x2, y2})\")\\n```\\n\\n\\nAnd a brute force would be to count the sum between all pairs of coordinates\\n\\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # We could sum the distance between the coordinates\\n                        total = 0\\n                        for r in range(y1, y2+1):\\n                            for c in range(x1, x2+1):\\n                                total += matrix[r][c]\\n                \\n                        if total == target:\\n                            ans += 1\\n        return ans\\n```\\n\\n\\nObviously that\\'s too bad of a solution with `n^3*m^3`\\n\\n# Improvement\\n\\nIn the last example, we had to iterate from (x1,y1) to (x2,y2) to find the sum.\\n\\nWe can reduce the time complexity for finding the sum to `O(1)` instead of `O(m*n)`, but how?\\n\\nBy using `prefix sums` (or prefix matrices one may say), extending the idea of a prefix sum array\\n\\nLet\\'s look at the image below:\\n\\n\\n**UPDATE**: **the value 8 is calculated as `7+6+(-3)-2`. The image has a mistake in it.. Sorry \\nAll other calculations are fine**\\n**Also the usage of DP in the image is for convenience, it\\'s not a dynamic programming question.**\\n\\n![image](https://assets.leetcode.com/users/images/5de8eaf9-89e4-4dd9-afde-6317934c0aeb_1658129118.454311.png)\\n\\nEvery coordinate (x,y) is the matrix sum between origin `(0,0) and (x,y)`\\n\\nWe can calculate the sum by taking the sum of the matrix above `matrix_sum[row-1][col]`, adding the sum of the matrix behind `matrix_sum[row][col-1]` and removing the intersection, because there is a part that is added twice `matrix_sum[row-1][col-1]`\\n\\nThen to calculate the sum of some `submatrix (x1,y1), (x2,y2)` we need to add the sum of the matrix that ends at the bottom coordinates, and remove the parts which are unused (again there is an intersection, hence we need to add the intersection because it\\'s removed twice)\\n\\n![image](https://assets.leetcode.com/users/images/4dbde7d6-b63f-428c-a8bd-467c5f97b330_1658129404.9013832.png)\\n\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # calculate sum in O(1)\\n                        submatrix_total = matrix_sums[y2][x2] \\\\\\n                        - (matrix_sums[y2][x1-1] if x1-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y1-1][x2] if y1-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y1-1][x1-1] if y1-1 >= 0 and x1-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\\n\\n# Do we really need 2 separate iterations?\\nWe can inverse the order of iterations, to build the prefix matrix and calculate in one go\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                # Calculate matrix_sums\\n                # first cell\\n                if y1 == 0 and x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif y1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1][x1-1]\\n                elif x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1-1][x1]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] \\\\\\n                    + (matrix_sums[y1][x1-1]) \\\\\\n                    + (matrix_sums[y1-1][x1]) \\\\\\n                    - (matrix_sums[y1-1][x1-1])\\n                \\n                for y2 in range(y1 + 1):\\n                    for x2 in range(x1 + 1):\\n                        submatrix_total = matrix_sums[y1][x1] \\\\\\n                        - (matrix_sums[y1][x2-1] if x2-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y2-1][x1] if y2-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y2-1][x2-1] if y2-1 >= 0 and x2-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\\n\\n\\n# But wait...\\nWe can optimize even more!\\n\\nWe have time complexity of `m^2*n^2` but do we really need the `n^2` ?\\n\\nInstead, it\\'s enough to simply \"fix\" the vertical coordinates y1, y2 and let x iterate\\n\\nThis way, we can reduce the problem into **subarray sum equal to target** (1D problem)\\n\\nFinal complexity: `O(m^2*n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                # Reduce the problem to subarray sum of target\\n                subarray_sums = defaultdict(int)\\n                subarray_sums[0] = 1\\n                \\n                for x in range(n):\\n                    matrix_sum = matrix_sums[y2][x]\\n                    \\n                    # Remove to matrix sum above y1\\n                    if y1 > 0:\\n                        matrix_sum -= matrix_sums[y1-1][x]\\n                        \\n                    if matrix_sum - target in subarray_sums:\\n                        ans += subarray_sums[matrix_sum - target]\\n                    \\n                    subarray_sums[matrix_sum] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        print(f\"({x1}, {y1}), ({x2, y2})\")\\n```\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # We could sum the distance between the coordinates\\n                        total = 0\\n                        for r in range(y1, y2+1):\\n                            for c in range(x1, x2+1):\\n                                total += matrix[r][c]\\n                \\n                        if total == target:\\n                            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                for y2 in range(y1, m):\\n                    for x2 in range(x1, n):\\n                        # calculate sum in O(1)\\n                        submatrix_total = matrix_sums[y2][x2] \\\\\\n                        - (matrix_sums[y2][x1-1] if x1-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y1-1][x2] if y1-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y1-1][x1-1] if y1-1 >= 0 and x1-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        ans = 0\\n        # Generate all submatrices\\n        for y1 in range(m):\\n            for x1 in range(n):\\n                # Calculate matrix_sums\\n                # first cell\\n                if y1 == 0 and x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif y1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1][x1-1]\\n                elif x1 == 0:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] + matrix_sums[y1-1][x1]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[y1][x1] = matrix[y1][x1] \\\\\\n                    + (matrix_sums[y1][x1-1]) \\\\\\n                    + (matrix_sums[y1-1][x1]) \\\\\\n                    - (matrix_sums[y1-1][x1-1])\\n                \\n                for y2 in range(y1 + 1):\\n                    for x2 in range(x1 + 1):\\n                        submatrix_total = matrix_sums[y1][x1] \\\\\\n                        - (matrix_sums[y1][x2-1] if x2-1 >= 0 else 0) \\\\\\n                        - (matrix_sums[y2-1][x1] if y2-1 >= 0 else 0) \\\\\\n                        + (matrix_sums[y2-1][x2-1] if y2-1 >= 0 and x2-1 >= 0 else 0)\\n                        \\n                        if submatrix_total == target:\\n                            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        matrix_sums = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        # Calculate all the submatrices sum with the transition formula we found\\n        for row in range(m):\\n            for col in range(n):\\n                # first cell\\n                if row == 0 and col == 0:\\n                    matrix_sums[row][col] = matrix[row][col]\\n                # Rows and columns are like prefix sums, without intersection\\n                elif row == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row][col-1]\\n                elif col == 0:\\n                    matrix_sums[row][col] = matrix[row][col] + matrix_sums[row-1][col]\\n                \\n                # current sum is the sum of the matrix above, to the left and subtract the intersection\\n                else:\\n                    matrix_sums[row][col] = matrix[row][col] \\\\\\n                    + (matrix_sums[row][col-1]) \\\\\\n                    + (matrix_sums[row-1][col]) \\\\\\n                    - (matrix_sums[row-1][col-1])\\n\\n                \\n        ans = 0\\n        for y1 in range(m):\\n            for y2 in range(y1, m):\\n                # Reduce the problem to subarray sum of target\\n                subarray_sums = defaultdict(int)\\n                subarray_sums[0] = 1\\n                \\n                for x in range(n):\\n                    matrix_sum = matrix_sums[y2][x]\\n                    \\n                    # Remove to matrix sum above y1\\n                    if y1 > 0:\\n                        matrix_sum -= matrix_sums[y1-1][x]\\n                        \\n                    if matrix_sum - target in subarray_sums:\\n                        ans += subarray_sums[matrix_sum - target]\\n                    \\n                    subarray_sums[matrix_sum] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344440,
                "title": "simple-python-dp-solution",
                "content": "Please see and vote for my solution for these similar problems.\\n[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/discuss/344431/Simple-Python-DP-solution)\\n[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/344436/Simple-Python-DP-solution)\\n[325. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/discuss/344432/Simple-Python-DP-solution)\\n[1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/344440/Simple-Python-DP-solution)\\n[363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/445540/Python-bisect-solution-(960ms-beat-71.25))\\n\\nFor each row, calculate the prefix sum. For each pair of columns, calculate the sum of rows. \\nNow this problem is changed to problem 560 Subarray Sum Equals K.\\n```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = 0\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                preSums = {0: 1}\\n                s = 0\\n                for x in range(m):\\n                    s += matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0)\\n                    res += preSums.get(s - target, 0)\\n                    preSums[s] = preSums.get(s, 0) + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        for x in range(m):\\n            for y in range(n - 1):\\n                matrix[x][y+1] += matrix[x][y]\\n        res = 0\\n        for y1 in range(n):\\n            for y2 in range(y1, n):\\n                preSums = {0: 1}\\n                s = 0\\n                for x in range(m):\\n                    s += matrix[x][y2] - (matrix[x][y1-1] if y1 > 0 else 0)\\n                    res += preSums.get(s - target, 0)\\n                    preSums[s] = preSums.get(s, 0) + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 303767,
                "title": "java-reduce-to-1d-array",
                "content": "Similar to [\"Max Sum of Rectangle No Larger Than K\"](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/), reduce 2D array to 1D, and find the sub-array sum targeting k.\\n\\n```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] array = new int[m];\\n        int result = 0;\\n        for(int i = 0; i < n; i++) { //i is the starting column\\n            Arrays.fill(array, 0);\\n            for(int j = i; j < n; j++) { //j is the ending column\\n                for(int k = 0; k < m; k++) {\\n                    array[k] += matrix[k][j];\\n                }\\n                result += subarraySum(array, target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int subarraySum(int[] nums, int k) {\\n        int sum = 0, result = 0;\\n        Map<Integer, Integer> preSum = new HashMap<>();\\n        preSum.put(0, 1);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (preSum.containsKey(sum - k)) {\\n                result += preSum.get(sum - k);\\n            }\\n            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] array = new int[m];\\n        int result = 0;\\n        for(int i = 0; i < n; i++) { //i is the starting column\\n            Arrays.fill(array, 0);\\n            for(int j = i; j < n; j++) { //j is the ending column\\n                for(int k = 0; k < m; k++) {\\n                    array[k] += matrix[k][j];\\n                }\\n                result += subarraySum(array, target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int subarraySum(int[] nums, int k) {\\n        int sum = 0, result = 0;\\n        Map<Integer, Integer> preSum = new HashMap<>();\\n        preSum.put(0, 1);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (preSum.containsKey(sum - k)) {\\n                result += preSum.get(sum - k);\\n            }\\n            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162748,
                "title": "c-easy-solution-with-explanation",
                "content": "**Intution :**\\n* We need to apply same logic which we used in : **[Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)**. If you have not done this pls check it out first .\\n* Calculate prefix sum for each row.\\n* Calculate  sum for each column and check if **sum - target** is there in the DS or not .If it is there then add the count. (DS is data structure , in this question we will use **`unordered_map<int,int> counter`**)\\n\\t\\t** Why sum - target ? Because if sum - target is there in the DS it means that there is a subset whose sum == target.\\n\\t\\tExample :   target = 4 \\n\\t\\t***1***  *1  1*  1 \\n\\t\\t***1***  *1  1*  1 \\n\\t\\tsum of bold = 2 , sum of bold + Italic = 6 ,,, 6 - 4 = **2** , it means the italic sub matrix sum = target.\\n\\n\\n**Example** : 4 * 4 matrix , target = 4,\\n```\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n```\\n**1. Calculate prefix sum for each row ;**\\n\\n```\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n```\\n\\n**2. For every possible range between two columns, accumulate the prefix sum of submartrixes that can be formed between these two columns by adding up the sum of values between these two columns for every row.**\\n\\nFor first column  :\\n![image](https://assets.leetcode.com/users/images/01ff2db8-d070-445b-b67a-d074f1d454ab_1618661347.535767.png)\\n\\n\\n```\\nSum = 1 + 1 + 1 + 1 =4\\nsum - target =  0 , which is there in map so count will be increased by 1.\\n```\\n\\nFor second column  :\\n![image](https://assets.leetcode.com/users/images/c4b0a598-85e5-40cd-8c32-7eeb643bec5b_1618661383.5533128.png)\\n\\n\\nHere   when row = 1 ,  2 - target is not there in the DS so we will add  2 into DS with count 1,  **sum = 2**     `DS : {{0 , 1 } , {2 , 1}`\\nwhen row = 2  , **sum = 4** 4 - target is there so increase count. `DS : {{0 , 1 } , {2 , 1} , { 4 ,1}`\\nwhen row = 3  , **sum = 6** 6 - target = 2, which is there in DS so increase count.`DS : {{0 , 1 } , {2 , 1} , { 4 ,1} ,{6,1}`\\nwhen row = 4 , **sum = 8** 8 - target = 4 , which is there in DS so increase count. `DS : {{0 , 1 } , {2 , 1} , { 4 ,1} ,{6,1}, {8,1}`\\n\\n**In this way for each column we will get number of sub matrixes whose sum is equals to target. Like wise we will do this for all the columns . Now the problem is in this way we are missing some  sub matrixes**\\n![image](https://assets.leetcode.com/users/images/bc2d358c-f1ad-463d-9f10-87e0e0c1fb9c_1618662144.7394516.png)\\n\\nAs you can see in the image for column 2 we have considered 3 sub matrixes :\\n1. Yellow 1\\'s\\n2. boxes with color inside it.\\n3. Red border color boxes. so **what we missed ?????**\\n![image](https://assets.leetcode.com/users/images/a010166e-ffcd-4ad9-95b4-77240850a0f4_1618662409.24798.png)\\n**We missed the 1\\'s in green box. So to count those sub matrixes  we need to subtract  previous column sum. For this third loop is there which checks if column start is greater than 0  then subtract the sum of previous column and sum.**\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n***Time Complexity   :  O(row * column^2)\\nSpace Complexity :O(N)***\\n\\n**Update 18/04/2021 :**\\n\\nIncase anyone else is having same doubt : \\n![image](https://assets.leetcode.com/users/images/11c39b8e-da66-438b-8d50-bb8ac7f23b00_1618745215.816512.png)\\n\\n**Hello,\\n\\tFeel free to comment for doubts . I will love to clear them . If something is wrong please let me know in comment section.\\nThanks !! Happy Coding.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n```\n```\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n1 2 3 4\\n```\n```\\nSum = 1 + 1 + 1 + 1 =4\\nsum - target =  0 , which is there in map so count will be increased by 1.\\n```\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162767,
                "title": "js-python-java-c-short-prefix-sum-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is essentially a **2-dimensional** version of [**#560. Subarray Sum Equals K (S.S.E.K)**](https://leetcode.com/problems/subarray-sum-equals-k/description/). By using a **prefix sum** on each row or each column, we can compress this problem down to either **N^2** iterations of the **O(M)** SSEK, or **M^2** iterations of the **O(N)** SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a **result map** (**res**) to store the different values found as we iterate through the array while keeping a running sum (**csum**). Just as in the case with a prefix sum array, the sum of a subarray between **i** and **j** is equal to the sum of the subarray from **0** to **j** minus the sum of the subarray from **0** to **i-1**.\\n\\nRather than iteratively checking if **sum[0,j] - sum[0,i-1] = T** for every pair of **i, j** values, we can flip it around to **sum[0,j] - T = sum[0,i-1]** and since every earlier sum value has been stored in **res**, we can simply perform a lookup on **sum[0,j] - T** to see if there are any matches.\\n\\nWhen extrapolating this solution to our **2-dimensional** matrix (**M**), we will need to first prefix sum the rows or columns, (which we can do **in-place** to avoid extra space, as we will not need the original values again). Then we should iterate through **M** again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a **1-dimensional** array and apply the SSEK algorithm.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython, oddly, has _much_ better performance with the use of a simple **dict** instead of a **defaultdict** for **res** (Thanks, [@slcheungcasado](https://leetcode.com/slcheungcasado)!)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **232ms / 44.8MB** (beats 100% / 81%).\\n```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **552ms / 15.0MB** (beats 100% / 85%).\\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **81ms / 39.3MB** (beats 96% / 95%).\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **484ms / 95.3MB** (beats 96% / 76%).\\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162611,
                "title": "python-cumulative-sum-dp-explained",
                "content": "Let us define by `dp[i, j, k]` sum of numbers in the rectangle `i <= x < j` and `0 <= y < m`. Why it is enough to evaluate only values on these matrices? Because then we can use **2Sum** problem: any sum of elements in submatrix with coordinates `a <= x < b` and `c <= y < d` can be evaluated as difference between sum of `a <= x < b, 0 <= y < d` and sum of `a <= x < b, 0 <= y < c`. So, let us fix `a` and `b`, and say we have sums `S1, S2, ... Sm`.  Then we want to find how many differences between these values give us our `target`. The idea is to calculate cumulative sums and keep counter of values, and then check how many we have (we can not use sliding window, because we can have negative values), see problem **560**. Subarray Sum Equals K for more details.\\n\\nSo, we have in total two stages of our algorithm:\\n1. Precompute all sums in rectangles of the type `i <= x < j` and `0 <= y < m`.\\n2. For each `n*(n-1)/2` problems with fixed `i` and `j`, solve sumproblem in `O(m)` time.\\n\\n#### Complexity\\nTime complexity is `O(n^2m)`, we need it for both stages. Space complexity is the same.\\n\\n#### Code\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m, n = len(matrix), len(matrix[0])\\n        dp, ans = {}, 0\\n        for k in range(m):\\n            t = [0] + list(accumulate(matrix[k]))\\n            for i, j in combinations(range(n+1), 2):\\n                dp[i, j, k] = dp.get((i,j,k-1), 0) + t[j] - t[i]\\n        \\n        for i, j in combinations(range(n+1), 2):\\n            T = Counter([0])\\n            for k in range(m):\\n                ans += T[dp[i, j, k] - target]\\n                T[dp[i, j, k]] += 1\\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m, n = len(matrix), len(matrix[0])\\n        dp, ans = {}, 0\\n        for k in range(m):\\n            t = [0] + list(accumulate(matrix[k]))\\n            for i, j in combinations(range(n+1), 2):\\n                dp[i, j, k] = dp.get((i,j,k-1), 0) + t[j] - t[i]\\n        \\n        for i, j in combinations(range(n+1), 2):\\n            T = Counter([0])\\n            for k in range(m):\\n                ans += T[dp[i, j, k] - target]\\n                T[dp[i, j, k]] += 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297590,
                "title": "java-easy-to-understand-heavily-commented-detailed-explanation-with-pictures",
                "content": "Region(Answer)\\n![image](https://assets.leetcode.com/users/images/d00849a5-cb20-4edc-aead-5a6a459a9d13_1658113975.539614.png)\\nSo we first need the sum from each of the following regions:\\n1. Region(A)\\n\\t![image](https://assets.leetcode.com/users/images/ec4d1b9e-b2fb-414f-a710-6edab00ee3b7_1658113980.4055543.png)\\n2. Region(B)\\n\\t![image](https://assets.leetcode.com/users/images/e9c0952f-4c70-4d2c-b051-3ce1ada0d650_1658113989.4605181.png)\\n3. Region(C)\\n   ![image](https://assets.leetcode.com/users/images/add5a19c-d4df-494a-8f1a-003700980546_1658113998.129529.png)\\n4. Region(D)\\n   ![image](https://assets.leetcode.com/users/images/3ce884fc-fb99-4907-a1aa-3a341394a064_1658114008.1346068.png)\\nRegion(Answer) = Region(A) - Region(B) - Region(C) + Region(D)\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n\\t\\t// aux[i][j] is the sum of sub-matrix which start at [0][0] and end in [i][j]\\n        int[][] aux = new int[m + 1][n + 1]; // padding on top and left\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\t// draw a picture, you will understand it easily~\\n                aux[i][j] = matrix[i - 1][j - 1] + aux[i - 1][j] + aux[i][j - 1] - aux[i - 1][j - 1]; \\n            }\\n        }\\n        \\n        int res = 0;\\n\\t\\t// try each sub-matrix\\n        for (int x1 = 1; x1 < m + 1; x1++) {\\n            for (int y1 = 1; y1 < n + 1; y1++) {\\n                for (int x2 = x1; x2 < m + 1; x2++) {\\n                    for (int y2 = y1; y2 < n + 1; y2++) {\\n                        if (target == aux[x2][y2] - aux[x2][y1 - 1] - aux[x1 - 1][y2] + aux[x1 - 1][y1 - 1])\\n                            res++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nPlease vote if it helps\\uD83D\\uDE06~",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n\\t\\t// aux[i][j] is the sum of sub-matrix which start at [0][0] and end in [i][j]\\n        int[][] aux = new int[m + 1][n + 1]; // padding on top and left\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n\\t\\t\\t\\t// draw a picture, you will understand it easily~\\n                aux[i][j] = matrix[i - 1][j - 1] + aux[i - 1][j] + aux[i][j - 1] - aux[i - 1][j - 1]; \\n            }\\n        }\\n        \\n        int res = 0;\\n\\t\\t// try each sub-matrix\\n        for (int x1 = 1; x1 < m + 1; x1++) {\\n            for (int y1 = 1; y1 < n + 1; y1++) {\\n                for (int x2 = x1; x2 < m + 1; x2++) {\\n                    for (int y2 = y1; y2 < n + 1; y2++) {\\n                        if (target == aux[x2][y2] - aux[x2][y1 - 1] - aux[x1 - 1][y2] + aux[x1 - 1][y1 - 1])\\n                            res++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521463,
                "title": "java-n-4-and-n-3-solutions",
                "content": "**Solution 1: N^4 ~ 4500ms**\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] sum = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int u = i + 1; u <= m; u++) {\\n                    for (int v = j + 1; v <= n; v++) {\\n                        int _sum = sum[u][v] - sum[i][v] - sum[u][j] + sum[i][j];\\n                        if (_sum == target) {\\n                            ans++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O((m*n)^2)`\\n- Space: `O(m*n)`\\n\\n**Solution 2 - N^3 ~ 1000ms**\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                HashMap<Integer, Integer> map = new HashMap<>();\\n                map.put(0, 1);\\n                int right = 0;\\n                for (int k = 0; k < m; k++) {\\n                    right += matrix[k][j] - (i == 0 ? 0 : matrix[k][i - 1]);\\n                    int left = right - target;\\n                    ans += map.getOrDefault(left, 0);\\n                    map.put(right, map.getOrDefault(right, 0) + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n*n*m)`\\n- Space: `O(m)` for map",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] sum = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int u = i + 1; u <= m; u++) {\\n                    for (int v = j + 1; v <= n; v++) {\\n                        int _sum = sum[u][v] - sum[i][v] - sum[u][j] + sum[i][j];\\n                        if (_sum == target) {\\n                            ans++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                matrix[i][j] += matrix[i][j - 1];\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                HashMap<Integer, Integer> map = new HashMap<>();\\n                map.put(0, 1);\\n                int right = 0;\\n                for (int k = 0; k < m; k++) {\\n                    right += matrix[k][j] - (i == 0 ? 0 : matrix[k][i - 1]);\\n                    int left = right - target;\\n                    ans += map.getOrDefault(left, 0);\\n                    map.put(right, map.getOrDefault(right, 0) + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162768,
                "title": "number-of-submatrices-that-sum-to-target-js-python-java-c-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is essentially a **2-dimensional** version of [**#560. Subarray Sum Equals K (S.S.E.K)**](https://leetcode.com/problems/subarray-sum-equals-k/description/). By using a **prefix sum** on each row or each column, we can compress this problem down to either **N^2** iterations of the **O(M)** SSEK, or **M^2** iterations of the **O(N)** SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a **result map** (**res**) to store the different values found as we iterate through the array while keeping a running sum (**csum**). Just as in the case with a prefix sum array, the sum of a subarray between **i** and **j** is equal to the sum of the subarray from **0** to **j** minus the sum of the subarray from **0** to **i-1**.\\n\\nRather than iteratively checking if **sum[0,j] - sum[0,i-1] = T** for every pair of **i, j** values, we can flip it around to **sum[0,j] - T = sum[0,i-1]** and since every earlier sum value has been stored in **res**, we can simply perform a lookup on **sum[0,j] - T** to see if there are any matches.\\n\\nWhen extrapolating this solution to our **2-dimensional** matrix (**M**), we will need to first prefix sum the rows or columns, (which we can do **in-place** to avoid extra space, as we will not need the original values again). Then we should iterate through **M** again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a **1-dimensional** array and apply the SSEK algorithm.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython, oddly, has _much_ better performance with the use of a simple **dict** instead of a **defaultdict** for **res** (Thanks, [@slcheungcasado](https://leetcode.com/slcheungcasado)!)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **232ms / 44.8MB** (beats 100% / 81%).\\n```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **552ms / 15.0MB** (beats 100% / 85%).\\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **81ms / 39.3MB** (beats 96% / 95%).\\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **484ms / 95.3MB** (beats 96% / 76%).\\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar numSubmatrixSumTarget = function(M, T) {\\n    let xlen = M[0].length, ylen = M.length,\\n        ans = 0, res = new Map(), csum\\n    for (let i = 0, r = M[0]; i < ylen; r = M[++i]) \\n        for (let j = 1; j < xlen; j++)\\n            r[j] += r[j-1]\\n    for (let j = 0; j < xlen; j++)\\n        for (let k = j; k < xlen; k++) {\\n            res.clear(), res.set(0,1), csum = 0\\n            for (let i = 0; i < ylen; i++) {\\n                csum += M[i][k] - (j ? M[i][j-1] : 0)\\n                ans += (res.get(csum - T) || 0)\\n                res.set(csum, (res.get(csum) || 0) + 1)\\n            }\\n        }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\n```java\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int T) {\\n        int xlen = M[0].size(), ylen = M.size(), ans = 0;\\n        unordered_map<int, int> res;\\n        for (int i = 0; i < ylen; i++)\\n            for (int j = 1; j < xlen; j++)\\n                M[i][j] += M[i][j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res[0] = 1;\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j ? M[i][j-1] : 0);\\n                    ans += res.find(csum - T) != res.end() ? res[csum - T] : 0;\\n                    res[csum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297511,
                "title": "java-easy-solution-with-explanation-hashmap",
                "content": "Explanation\\n\\n* For each row, calculate the prefix sum.\\n* For each pair of columns,\\n* calculate the accumulated sum of rows.\\n* Now this problem is same to, \"Find the Subarray with Target Sum\".\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162925,
                "title": "number-of-submatrices-that-sum-to-target-optimization-from-brute-force-explained",
                "content": "There are a few solution mentioned by others but most have directly given the most optimal solution. Here, I will try to start from the brute-force approach and try to explain the various optimizations that can be done to finally arrive at the optimal solution.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force Approach) [Rejected]***\\n\\nLet\\'s start with the most basic approach to this problem. Take all the submatrices possible for the given matrix and check if their sum is equal to `target`.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\\n\\n***Time Complexity :*** **`O((M*N)^3)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Compute prefix sum for each Row or Column)***\\n\\nWe can optimize the above approach by reducing the time complexity of the `SUM` function in the above solution. We know that in a given array, the sum of range [i,j] can be calculated by `prefixSum[j] - prefixSum[i - 1]`. We can use this to optimize the solution.\\n\\nAfter computing prefix sum for each row of matrix (*you can do it for column as well*), we can get the sum of a given range in O(1) time. Thus, for any submatrix of the main matrix, we just need to iterate over all its rows and we can get sum of given range (`[colStart, colEnd]`) in O(1) time.\\n\\n1. We just start from row 0, calculate the sum for that row for the range `[colStart, colEnd]`.\\n2. Extend the sum by perform step-1 for row 1, row 2, ... and so on till last row.\\n3. Repeat this process for every `[colStart, colEnd]` combination.\\n\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O((M*N)^2)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(1)`**, since we are modifying the given matrix itself. If we use a new prefix sum matrix, the space complexity would be `O(M*N)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Further Optimization in Solution - II)***\\n\\nWe can further optimize the solution by using hashmap. The optimization done here is similar to the one in solution of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/solution/).\\n\\nBasically, we will be maintaining a running submatrix sum starting from row 0 till m, for a given `[colStart, colEnd]` range. Each sum value and number of its occurence will be stored in hashmap. If there\\'s a submatrix which was found such that `cursum` at that time was equal to present sum (`cursum`) - target, then we are sure that there were occurences of submatrices which had sum equal to `target` and the count is given by `mp[cursum - target]`.\\n\\nIf the explanation didn\\'t make the approach clear, I really suggest you to try the *560. Subarray Sum Equals K* problem and read the hashmap solution. It took me some time reading that before I was able to clearly understand this solution.\\n\\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\\n***Time Complexity :*** **`O(N*N*M)`**, where `M` is the number of rows and `N` is the number of columns  in the given matrix.\\n***Space Complexity :*** **`O(N)`**\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor(int rowStart = 0; rowStart < m; rowStart++)\\n\\t\\tfor(int rowSize = 1; rowStart + rowSize <= m; rowSize++)\\n\\t\\t\\tfor(int colStart = 0; colStart < n; colStart++)\\n\\t\\t\\t\\tfor(int colSize = 1; colStart + colSize <= n; colSize++)\\n\\t\\t\\t\\t\\tif(SUM(A, rowStart, rowSize, colStart, colSize) == target)\\n\\t\\t\\t\\t\\t\\tres++;\\n\\treturn res;    \\n}\\n// Calculates the sum of a submatrix with given bounds\\nint SUM(vector<vector<int> > &A, int rStart, int rSize, int cStart, int cSize){\\n\\tint subMatrixSum = 0;\\n\\tfor(int i = rStart; i < rStart + rSize; i++)\\n\\t\\tfor(int j = cStart; j < cStart + cSize; j++)\\n\\t\\t\\tsubMatrixSum += A[i][j];\\n\\treturn subMatrixSum;\\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\t// calculating prefix sum for each row of matrix\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t// calculate sum of each submatrix and check if it is equal to target\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tfor(int rowStart = 0; rowStart < m; rowStart++){\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int rowEnd = rowStart; rowEnd < m; rowEnd++){\\n\\t\\t\\t\\t\\tsum += A[rowEnd][colEnd] - (colStart ? A[rowEnd][colStart - 1] : 0);\\n\\t\\t\\t\\t\\tif(sum == target) res++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```\n```\\nint numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n\\tint res = 0, m = size(A), n = size(A[0]);\\n\\tfor (int row = 0; row < m; row++)\\n\\t\\tfor (int col = 1; col < n; col++)\\n\\t\\t\\tA[row][col] += A[row][col - 1];\\n\\t//         cursum, occurences\\n\\tunordered_map<int, int> mp;\\n\\tfor (int colStart = 0; colStart < n; colStart++) {\\n\\t\\tfor (int colEnd = colStart; colEnd < n; colEnd++) {\\n\\t\\t\\tint cursum = 0;\\n\\t\\t\\tmp = {{0, 1}};\\n\\t\\t\\tfor(int row = 0; row < m; row++){\\n\\t\\t\\t\\tcursum += A[row][colEnd] - (colStart ? A[row][colStart - 1] : 0);    \\n\\t\\t\\t\\t// mp[sum-target] will give number of submatrices found having sum as \\'sum - target\\'\\n\\t\\t\\t\\tres += mp[cursum - target];\\n\\t\\t\\t\\tmp[cursum]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162873,
                "title": "c-prefix-sum-explanation-with-pictures-424ms-9mb",
                "content": "The problem is split in two parts. \\nFirst, compute 2D prefix sum matrix ```ps```, so that element ```p[i][j]``` is equal to the sum of elements in submatrix ```matrix[x][y]``` with ```0 <= x <= i, 0 <= y <= j```. For this purpose we compute 1D prefix sums for the first row and first column and then use the formula:\\n```ps[i][j] = matrix[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1]```\\n\\n\\nHere is illustration:\\n<img src=\"https://assets.leetcode.com/users/images/fad46894-4b59-48a9-a0f8-a6e969cc7b29_1618664366.132954.png\" alt=\"drawing\" height=\"200\"/>\\n\\nThe sum of elements from ```(0,0)``` to ```(i,j)``` consists of element ```matrix[i][j]``` and sums of elemnts in submatrices ```A,B,C```. \\n\\nSum of elements in ```A``` is simply ```ps[i-1][j-1]```.\\nElements in ```B```: ```ps[i][j-1] - ps[i-1][j-1]```.\\nElements in ```C```: ```ps[i-1][j] - ps[i-1][j-1]```.\\nSumming of all this \\n\\nSecond part of the solution: use the prefix sum matrix to quickly compute sums of all the possible submatrices:\\n<img src=\"https://assets.leetcode.com/users/images/1d8e4609-5d06-4ad8-b97e-9f4af78e9906_1618665165.0758274.png\" alt=\"drawing\" height=\"250\"/>\\nSum of elements in submatrix ```matrix[x][y]``` with ```i0 <= x <= i1, j0 <= y <= j1``` is a difference between elements in ```D``` and elements in ```A```,```B``` and ```C```.  \\n\\nSum in ```D``` and ```A``` are prefix sums ```ps[i1][j1]``` and ```ps[i0-1][j0-1]```. For the remaining two submatrices we get:\\n```B=ps[i1][j0-1] - ps[i0-1][j0-1]```\\n```C=ps[i0-1][j1] - ps[i0-1][j0-1]```\\n\\nHence, the final formula is:\\n```sum = ps[i1][j1]-ps[i1][j0-1]-ps[i0-1][j1]+ps[i0-1][j0-1]```\\n\\nThe corner cases are when ```j0=0``` or ```i0=0```.\\n\\n```\\nclass Solution {\\n    int ps[101][101];\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int target) {\\n        ios_base::sync_with_stdio(false);\\n        size_t n{ M.size() }, m{ M[0].size() };\\n        \\n\\t\\t// compute prefix sum\\n        ps[0][0] = M[0][0];\\n        for (int i = 1; i < n; i++) ps[i][0] = M[i][0] + ps[i-1][0];\\n        for (int j = 1; j < m; j++) ps[0][j] = M[0][j] + ps[0][j-1];\\n        \\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                ps[i][j] = M[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1];\\n\\n        \\n        int count{};\\n        // test all submatrices\\n        for (int i0 = 0; i0 < n; i0++)\\n            for (int j0 = 0; j0 < m; j0++)\\n                for (int i1 = i0; i1 < n; i1++)\\n                    for (int j1 = j0; j1 < m; j1++) {\\n                        int sum{ ps[i1][j1] };\\n\\n                        if (i0 > 0) sum -= ps[i0 - 1][j1];\\n                        if (j0 > 0) sum -= ps[i1][j0-1];\\n                        if (i0 > 0 && j0 > 0) sum += ps[i0 - 1][j0 - 1];\\n\\n                        if (sum == target) count++;\\n                    }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```ps```\n```p[i][j]```\n```matrix[x][y]```\n```0 <= x <= i, 0 <= y <= j```\n```ps[i][j] = matrix[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1]```\n```(0,0)```\n```(i,j)```\n```matrix[i][j]```\n```A,B,C```\n```A```\n```ps[i-1][j-1]```\n```B```\n```ps[i][j-1] - ps[i-1][j-1]```\n```C```\n```ps[i-1][j] - ps[i-1][j-1]```\n```matrix[x][y]```\n```i0 <= x <= i1, j0 <= y <= j1```\n```D```\n```A```\n```B```\n```C```\n```D```\n```A```\n```ps[i1][j1]```\n```ps[i0-1][j0-1]```\n```B=ps[i1][j0-1] - ps[i0-1][j0-1]```\n```C=ps[i0-1][j1] - ps[i0-1][j0-1]```\n```sum = ps[i1][j1]-ps[i1][j0-1]-ps[i0-1][j1]+ps[i0-1][j0-1]```\n```j0=0```\n```i0=0```\n```\\nclass Solution {\\n    int ps[101][101];\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& M, int target) {\\n        ios_base::sync_with_stdio(false);\\n        size_t n{ M.size() }, m{ M[0].size() };\\n        \\n\\t\\t// compute prefix sum\\n        ps[0][0] = M[0][0];\\n        for (int i = 1; i < n; i++) ps[i][0] = M[i][0] + ps[i-1][0];\\n        for (int j = 1; j < m; j++) ps[0][j] = M[0][j] + ps[0][j-1];\\n        \\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                ps[i][j] = M[i][j] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1];\\n\\n        \\n        int count{};\\n        // test all submatrices\\n        for (int i0 = 0; i0 < n; i0++)\\n            for (int j0 = 0; j0 < m; j0++)\\n                for (int i1 = i0; i1 < n; i1++)\\n                    for (int j1 = j0; j1 < m; j1++) {\\n                        int sum{ ps[i1][j1] };\\n\\n                        if (i0 > 0) sum -= ps[i0 - 1][j1];\\n                        if (j0 > 0) sum -= ps[i1][j0-1];\\n                        if (i0 > 0 && j0 > 0) sum += ps[i0 - 1][j0 - 1];\\n\\n                        if (sum == target) count++;\\n                    }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700090,
                "title": "c-explained-detailed-dp-prefix-sum",
                "content": "**!!!Please upvote if you like it..**\\nThe given question ask to `count the number of sub-matrix whose sum of all element is equal to target value.`\\n\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\n**How to find all sub-matrix??**\\n->Let\\'s think about 1-d array when we ask to f`ind all possible sub array we use prefix sum and do it `easily....\\n**Here is a case of 2-D matrix..**\\nIDEA:\\uD83D\\uDCAF\\n1.To use 2D-prefix sum to store sum of all sub-matrix .\\n2.Generate all  possible sub matrix-cordinate and find sum  and count possible value.\\n3.Checking will be of O(1) time.\\n\\n`1.How to create 2-d prefix sum??`\\n[![image](https://assets.leetcode.com/users/images/77f26df6-deac-4287-ac58-a6de3b77fd85_1642519275.3614054.jpeg)\\n` 2.Genrating all possible submatrix co-rdinate:`\\nThis can be done using 4-loops that  help to all sub-matrix.\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int dp[n+1][m+1];//2-ddp for prefix sum\\n       \\n       \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0||j==0)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i-1][j-1];//using prefix dp formulae\\n                    \\n                }\\n            }\\n        }\\n        int count=0;\\n\\t\\t//generate all possible sub matrix.\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                for(int k=i;k<=n;k++)\\n                {\\n                    for(int l=j;l<=m;l++)\\n                    {\\n                      int ans=dp[i-1][j-1]+dp[k][l]-dp[i-1][l]-dp[k][j-1];\\n                        if(ans==target)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return count;\\n       \\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int dp[n+1][m+1];//2-ddp for prefix sum\\n       \\n       \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0||j==0)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    \\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i-1][j-1];//using prefix dp formulae\\n                    \\n                }\\n            }\\n        }\\n        int count=0;\\n\\t\\t//generate all possible sub matrix.\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                for(int k=i;k<=n;k++)\\n                {\\n                    for(int l=j;l<=m;l++)\\n                    {\\n                      int ans=dp[i-1][j-1]+dp[k][l]-dp[i-1][l]-dp[k][j-1];\\n                        if(ans==target)\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return count;\\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299066,
                "title": "c-easy-solution-detailed-explanation",
                "content": "**Prerequisite:** https://leetcode.com/problems/subarray-sum-equals-k/ (if you don\\'t know this question, please first solve it. Otherwise, understanding current problem is difficult)\\n```\\nint subarraySum(vector<int>& nums, int k) {\\n\\tunordered_map<int,int> um;\\n\\tum[0] = 1;\\n\\tint curr = 0;\\n\\tint ans = 0;\\n\\tfor(auto it: nums){\\n\\t\\tcurr += it;\\n\\t\\tint rem = curr-k;\\n\\t\\tif(um.find(rem) != um.end()){\\n\\t\\t\\tans += um[rem];\\n\\t\\t}\\n\\t\\tum[curr] += 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nBack to this problem:\\n```\\nclass Solution {\\npublic:\\n    int subarraySum(vector<int> &nums, int k){\\n        unordered_map<int,int> um;\\n        um[0] = 1;\\n        int curr = 0;\\n        int ans = 0;\\n        for(auto it: nums){    \\n            curr += it;\\n            int rem = curr-k;\\n            if(um.find(rem) != um.end()){\\n                ans += um[rem];\\n            }\\n            um[curr] += 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int ans = 0;\\n\\t\\t// Each iteration calculates the count for submatrix from row i to matrix.size()\\n        for(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t// Sum stores the sum of the elements from row i to j \\n            vector<int> sum(matrix[0].size(), 0);\\n            for(int j=i; j<matrix.size(); j++){\\n                for(int k=0; k<matrix[0].size(); k++){\\n                    sum[k] += matrix[j][k];\\n                }\\n\\t\\t\\t\\t// Now calculate the count for the submatrix from row i to j\\n                ans += subarraySum(sum, target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint subarraySum(vector<int>& nums, int k) {\\n\\tunordered_map<int,int> um;\\n\\tum[0] = 1;\\n\\tint curr = 0;\\n\\tint ans = 0;\\n\\tfor(auto it: nums){\\n\\t\\tcurr += it;\\n\\t\\tint rem = curr-k;\\n\\t\\tif(um.find(rem) != um.end()){\\n\\t\\t\\tans += um[rem];\\n\\t\\t}\\n\\t\\tum[curr] += 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int subarraySum(vector<int> &nums, int k){\\n        unordered_map<int,int> um;\\n        um[0] = 1;\\n        int curr = 0;\\n        int ans = 0;\\n        for(auto it: nums){    \\n            curr += it;\\n            int rem = curr-k;\\n            if(um.find(rem) != um.end()){\\n                ans += um[rem];\\n            }\\n            um[curr] += 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int ans = 0;\\n\\t\\t// Each iteration calculates the count for submatrix from row i to matrix.size()\\n        for(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t// Sum stores the sum of the elements from row i to j \\n            vector<int> sum(matrix[0].size(), 0);\\n            for(int j=i; j<matrix.size(); j++){\\n                for(int k=0; k<matrix[0].size(); k++){\\n                    sum[k] += matrix[j][k];\\n                }\\n\\t\\t\\t\\t// Now calculate the count for the submatrix from row i to j\\n                ans += subarraySum(sum, target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2298548,
                "title": "c-java-python-subarray-sum-explained",
                "content": "**Plz Upvote if found helpful**\\n\\n**Explaination:**\\nThis problem is essentially a 2-dimensional version of #560. Subarray Sum Equals K (S.S.E.K). By using a prefix sum on each row or each column, we can compress this problem down to either N^2 iterations of the **O(M)** SSEK, or M^2 iterations of the **O(N)** SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a result map (res) to store the different values found as we iterate through the array while keeping a running sum (csum). Just as in the case with a prefix sum array, the sum of a subarray between i and j is equal to the sum of the subarray from 0 to j minus the sum of the subarray from 0 to i-1.\\n\\nRather than iteratively checking if sum[0,j] - sum[0,i-1] = T for every pair of i, j values, we can flip it around to sum[0,j] - T = sum[0,i-1] and since every earlier sum value has been stored in res, we can simply perform a lookup on sum[0,j] - T to see if there are any matches.\\n\\nWhen extrapolating this solution to our 2-dimensional matrix (M), we will need to first prefix sum the rows or columns, (which we can do in-place to avoid extra space, as we will not need the original values again). Then we should iterate through M again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a 1-dimensional array and apply the SSEK algorithm.\\n\\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n**C++  Code**\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Java Code:**\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Python Code**\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```\\n\\n**Please Upvote if found Helpful**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size() , cols = matrix[0].size();\\n        \\n        if(rows < 1){\\n            return 0;\\n        }\\n        \\n        // calculate prefix sum for rows\\n        for(int row = 0 ; row < rows ; row++){\\n            for(int col = 1 ; col < cols ;col++){\\n                matrix[row][col] =  matrix[row][col] + matrix[row][col -1];\\n            }\\n        }\\n      \\n        int count = 0 , sum ;\\n        unordered_map<int , int> counter;\\n        for(int colstart = 0 ; colstart < cols ;colstart++){\\n            for(int col = colstart ; col < cols; col++){\\n                counter.clear();\\n                counter[0] = 1;\\n                sum =0;\\n                for(int row = 0 ; row < rows ;row++){\\n                    sum += matrix[row][col] - (colstart > 0 ? matrix[row][colstart - 1] : 0 );\\n                    count += (counter.find(sum- target) != counter.end() ? counter[sum-target] : 0);\\n                    counter[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] M, int T) {\\n        int xlen = M[0].length, ylen = M.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : M)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += M[i][k] - (j > 0 ? M[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - T, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        xlen, ylen, ans = len(M[0]), len(M), 0\\n        for r in M:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res, csum = {0: 1}, 0\\n                for r in M:\\n                    csum += r[k] - (r[j-1] if j else 0)\\n                    if csum - T in res: ans += res[csum-T]\\n                    res[csum] = res[csum] + 1 if csum in res else 1  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562478,
                "title": "c-compact-prefix-sum-explained-65-speed-100-memory",
                "content": "For all possible row ranges, calculate cumulative matrix sums column by column identifying when sum equals target or when sum equals a previous sum (in the same row range) minus the target. In the y direction, the cumulative sum is added to each column incrementally using a vector representing the column sum of interest in the row.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int count = 0;\\n        \\n        for (int i = 0; i < m; i++){                      //Iterating over all possible row ranges between row i and row j\\n            vector<int> CumulativeColumns = matrix[i];    //Instead of setting up a prefix sum matrix, add to columns as we go row by row\\n            \\n            for (int j = i; j < m; j++){\\n                unordered_map<int,int> sumCount;          //track occurrences of corner matrix sums for the current row range\\n                int totalSum = 0;\\n                \\n                for (int k = 0; k < n; k++){\\n                    totalSum += CumulativeColumns[k];        //within the current row range, at every row cumulatively build matrix sums using cumulative column sums column by column\\n                    if (totalSum == target) count++;         //if the target is found or if a sum is found that has a difference with a previous sum in the same top/bottom bounds exactly equal to target, add submatrices found\\n                    if (sumCount.count(totalSum-target)) count += sumCount[totalSum-target];\\n                    sumCount[totalSum]++;                    //Store the current cumulative sum to be used later in the row to calculate target matrix counts        \\n                    if (j < m - 1) CumulativeColumns[k] += matrix[j+1][k];   //Increment the cumulative column sum for the next row iteration in the current row range if necessary\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int count = 0;\\n        \\n        for (int i = 0; i < m; i++){                      //Iterating over all possible row ranges between row i and row j\\n            vector<int> CumulativeColumns = matrix[i];    //Instead of setting up a prefix sum matrix, add to columns as we go row by row\\n            \\n            for (int j = i; j < m; j++){\\n                unordered_map<int,int> sumCount;          //track occurrences of corner matrix sums for the current row range\\n                int totalSum = 0;\\n                \\n                for (int k = 0; k < n; k++){\\n                    totalSum += CumulativeColumns[k];        //within the current row range, at every row cumulatively build matrix sums using cumulative column sums column by column\\n                    if (totalSum == target) count++;         //if the target is found or if a sum is found that has a difference with a previous sum in the same top/bottom bounds exactly equal to target, add submatrices found\\n                    if (sumCount.count(totalSum-target)) count += sumCount[totalSum-target];\\n                    sumCount[totalSum]++;                    //Store the current cumulative sum to be used later in the row to calculate target matrix counts        \\n                    if (j < m - 1) CumulativeColumns[k] += matrix[j+1][k];   //Increment the cumulative column sum for the next row iteration in the current row range if necessary\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297552,
                "title": "c-easy-solution-without-hashmap-prefix-sum-easy-understanding",
                "content": "# **C++ Easy Solution Without Hashmap || Prefix Sum || Easy Understanding**\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size(),count=0;\\n        vector<vector<int>>temp(n+1,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp[i+1][j]=temp[i][j]+matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<=n;j++){\\n                for(int k=0;k<m;k++){\\n                    int sum=0;\\n                    for(int l=k;l<m;l++){\\n                        sum+=temp[j][l]-temp[i][l];\\n                        if(sum==target){\\n                            // cout<<j<<\" \"<<i<<\" \"<<k<<endl;\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size(),count=0;\\n        vector<vector<int>>temp(n+1,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp[i+1][j]=temp[i][j]+matrix[i][j];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<=n;j++){\\n                for(int k=0;k<m;k++){\\n                    int sum=0;\\n                    for(int l=k;l<m;l++){\\n                        sum+=temp[j][l]-temp[i][l];\\n                        if(sum==target){\\n                            // cout<<j<<\" \"<<i<<\" \"<<k<<endl;\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1162721,
                "title": "python-go-o-w-2-h-by-prefix-sum-w-hint",
                "content": "Python O(w^2 * h)  by prefix sum\\n\\n---\\n\\n**Hint**:\\n\\nThis is **2D extented version** of [Leetcode 560 Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\nThe concept of **prefix sum** and **dictionary** technique can be used again to help us.\\n\\n---\\n\\n**Implementation** by dictionary in Python\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        # height and width of matrix\\n        h, w = len(matrix), len(matrix[0])\\n        \\n\\t\\t\\n        # update prefix sum on each row\\n        for y in range(h):\\n            for x in range(1,w):\\n                matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n                \\n        \\n        # number of submatrices that sum to target\\n        counter = 0\\n        \\n        # sliding windows on x-axis, in range [left, right]\\n        for left in range(w):\\n            for right in range(left, w):\\n                \\n                # accumulation of area so far\\n                accumulation = {0: 1}\\n                \\n                # area of current submatrices, bounded by [left, right] with height y\\n                area = 0\\n                \\n                # scan each possible height on y-axis\\n                for y in range(h):\\n                    \\n                    if left > 0:\\n                        area += matrix[y][right] - matrix[y][left-1]\\n                    \\n                    else:\\n                        area += matrix[y][right]\\n                    \\n                    # if ( area - target ) exist, then target must exist in submatrices\\n                    counter += accumulation.get( area - target, 0)\\n                    \\n                    # update dictionary with current accumulation area\\n                    accumulation[area] = accumulation.get(area, 0) + 1\\n        \\n        return counter\\n```\\n\\n---\\n\\n**Implementatin** by map in Go\\n\\n```\\nfunc numSubmatrixSumTarget(matrix [][]int, target int) int {\\n    \\n    // height and width of matrix\\n    h, w := len(matrix), len(matrix[0])\\n    \\n    // update prefix sum on each row\\n    for y := 0 ; y < h ; y++{\\n        for x:= 1 ; x < w; x++{\\n            matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n        }\\n    }\\n    \\n    // number of submatrices that sum to target\\n    counter := 0\\n    \\n    // sliding windows on x-axis, in range[left, right]\\n    for left := 0 ; left < w ; left ++{\\n        for right := left ; right < w ; right++{\\n            \\n            // accumulation for area so far\\n            accumulation := map[int]int{ 0 : 1}\\n            \\n            // area of current submatrices, bounded by [left, right] with height y\\n            area := 0\\n            \\n            // scan each possible height on y-axis\\n            for y := 0 ; y < h ; y++{\\n                \\n                if left > 0 {\\n                    area += matrix[y][right] - matrix[y][left-1]\\n                }else{\\n                    area += matrix[y][right]\\n                }\\n                \\n                // if ( area - target ) exists, then target must exist in submatrices\\n                counter += accumulation[ (area - target) ]\\n                \\n                // update dictionary with current accumulation area\\n                accumulation[area] += 1\\n                \\n            }\\n            \\n        }//end of right loop\\n        \\n    }//end of left loop\\n    \\n    return counter\\n    \\n}\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1]  [Leetcode 560 Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about dictioanry](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\\n\\n[2] [Golang official docs about map[]](https://blog.golang.org/maps)\\n\\n[3] [Wiki: prefix sum](https://en.wikipedia.org/wiki/Prefix_sum)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        # height and width of matrix\\n        h, w = len(matrix), len(matrix[0])\\n        \\n\\t\\t\\n        # update prefix sum on each row\\n        for y in range(h):\\n            for x in range(1,w):\\n                matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n                \\n        \\n        # number of submatrices that sum to target\\n        counter = 0\\n        \\n        # sliding windows on x-axis, in range [left, right]\\n        for left in range(w):\\n            for right in range(left, w):\\n                \\n                # accumulation of area so far\\n                accumulation = {0: 1}\\n                \\n                # area of current submatrices, bounded by [left, right] with height y\\n                area = 0\\n                \\n                # scan each possible height on y-axis\\n                for y in range(h):\\n                    \\n                    if left > 0:\\n                        area += matrix[y][right] - matrix[y][left-1]\\n                    \\n                    else:\\n                        area += matrix[y][right]\\n                    \\n                    # if ( area - target ) exist, then target must exist in submatrices\\n                    counter += accumulation.get( area - target, 0)\\n                    \\n                    # update dictionary with current accumulation area\\n                    accumulation[area] = accumulation.get(area, 0) + 1\\n        \\n        return counter\\n```\n```\\nfunc numSubmatrixSumTarget(matrix [][]int, target int) int {\\n    \\n    // height and width of matrix\\n    h, w := len(matrix), len(matrix[0])\\n    \\n    // update prefix sum on each row\\n    for y := 0 ; y < h ; y++{\\n        for x:= 1 ; x < w; x++{\\n            matrix[y][x] = matrix[y][x] + matrix[y][x-1]\\n        }\\n    }\\n    \\n    // number of submatrices that sum to target\\n    counter := 0\\n    \\n    // sliding windows on x-axis, in range[left, right]\\n    for left := 0 ; left < w ; left ++{\\n        for right := left ; right < w ; right++{\\n            \\n            // accumulation for area so far\\n            accumulation := map[int]int{ 0 : 1}\\n            \\n            // area of current submatrices, bounded by [left, right] with height y\\n            area := 0\\n            \\n            // scan each possible height on y-axis\\n            for y := 0 ; y < h ; y++{\\n                \\n                if left > 0 {\\n                    area += matrix[y][right] - matrix[y][left-1]\\n                }else{\\n                    area += matrix[y][right]\\n                }\\n                \\n                // if ( area - target ) exists, then target must exist in submatrices\\n                counter += accumulation[ (area - target) ]\\n                \\n                // update dictionary with current accumulation area\\n                accumulation[area] += 1\\n                \\n            }\\n            \\n        }//end of right loop\\n        \\n    }//end of left loop\\n    \\n    return counter\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486864,
                "title": "c-short-easy-solution",
                "content": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int count = 0;\\n        for(int L=0; L<cols; L++) {\\n            vector<int> running_rows(rows,0); //intialize the running row\\n            for(int R=L; R<cols; R++) { //calculate running rows sum\\n                for(int i=0; i<rows; i++) running_rows[i] += matrix[i][R]; \\n                int sum = 0;\\n                unordered_map<int, int> visited;\\n                for(int i=0; i<rows; i++) { //check for subarrays in every running row\\n                    visited[sum]++;\\n                    sum = sum + running_rows[i];\\n                    if(visited[sum - target]) \\n                        count += visited[sum - target];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nRuntime - O(cols^2 rows) i.e cubic runtime\\nSpace - O(rows)\\n\\nTo understand what are running rows, watch : https://www.youtube.com/watch?v=-FgseNO-6Gk\\nTo understand how I\\'m checking for subarrays in every single running row, try : https://leetcode.com/problems/subarray-sum-equals-k/ or check out this video on youtube to understand the solution https://www.youtube.com/watch?v=AmlVSNBHzJg",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int count = 0;\\n        for(int L=0; L<cols; L++) {\\n            vector<int> running_rows(rows,0); //intialize the running row\\n            for(int R=L; R<cols; R++) { //calculate running rows sum\\n                for(int i=0; i<rows; i++) running_rows[i] += matrix[i][R]; \\n                int sum = 0;\\n                unordered_map<int, int> visited;\\n                for(int i=0; i<rows; i++) { //check for subarrays in every running row\\n                    visited[sum]++;\\n                    sum = sum + running_rows[i];\\n                    if(visited[sum - target]) \\n                        count += visited[sum - target];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336388,
                "title": "java-o-n-3-with-detailed-explanation-step-by-step",
                "content": "* The idea is to fix the left and right columns one by one and count sub-arrays for every left and right column pair. Calculate sum of elements in every row from left to right and store these sums in an array say temp[]. So temp[i] indicates sum of elements from left to right in row i.\\n\\n* Count sub-arrays in temp[] having sum equal to  target. This count is the number of sub-matrices having sum equal to  target with left and right as boundary columns. Sum up all the counts for each temp[] with different left and right column pairs.\\n\\n```\\nclass Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        // Number of columns\\n        int n=matrix[0].length;\\n        // Number of rows\\n        int m=matrix.length;\\n        // store the total count of such sub matrices in result variable\\n        int result=0;\\n        \\n        // Fix the left boundary\\n        for(int left=0;left<n;left++){\\n            // Fix the right boundary\\n            int[] temp=new int[m];\\n            for(int right=left;right<n;right++){\\n                // Compute sum of row elements between the left and right boundary\\n                for(int k=0;k<m;k++){\\n                    temp[k]+=matrix[k][right];\\n                }\\n                // Check for target sum\\n                result+=subArraySumToTarget(temp,target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Works in O(n)\\n    int subArraySumToTarget(int[] temp,int target){\\n        // Use a hashmap of running sum and frequency of that sum\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int runningSum=0;\\n        int count=0;\\n        map.put(0,1);\\n        for(int i=0;i<temp.length;i++){\\n            runningSum+=temp[i];\\n            if(map.containsKey(runningSum-target)){\\n                count+=map.get(runningSum-target);\\n            }\\n            map.put(runningSum,map.getOrDefault(runningSum,0)+1);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        // Number of columns\\n        int n=matrix[0].length;\\n        // Number of rows\\n        int m=matrix.length;\\n        // store the total count of such sub matrices in result variable\\n        int result=0;\\n        \\n        // Fix the left boundary\\n        for(int left=0;left<n;left++){\\n            // Fix the right boundary\\n            int[] temp=new int[m];\\n            for(int right=left;right<n;right++){\\n                // Compute sum of row elements between the left and right boundary\\n                for(int k=0;k<m;k++){\\n                    temp[k]+=matrix[k][right];\\n                }\\n                // Check for target sum\\n                result+=subArraySumToTarget(temp,target);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Works in O(n)\\n    int subArraySumToTarget(int[] temp,int target){\\n        // Use a hashmap of running sum and frequency of that sum\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int runningSum=0;\\n        int count=0;\\n        map.put(0,1);\\n        for(int i=0;i<temp.length;i++){\\n            runningSum+=temp[i];\\n            if(map.containsKey(runningSum-target)){\\n                count+=map.get(runningSum-target);\\n            }\\n            map.put(runningSum,map.getOrDefault(runningSum,0)+1);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297831,
                "title": "easy-prefix-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int n,m;\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        n=matrix.size(),m=matrix[0].size();\\n        fun(matrix);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               int si=i,sj=j;\\n               \\n                for(int p=si;p<n;p++){\\n                    for(int q=sj;q<m;q++){\\n                     \\n                        if(p==si && q==sj){\\n                           \\n                            ans+=(target==matrix[p][q])?1:0;\\n                        }else{\\n                          \\n                             ans+=(target==getans(si,sj,p,q))?1:0;\\n                        }\\n                    }\\n                }\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n   void fun(vector<vector<int>>& matrix){\\n        dp[0][0]=matrix[0][0];      // Getting the sum of matrix from index(0,0) for every (i,j);\\n        for(int i=1;i<m;i++){\\n            dp[0][i]=(dp[0][i-1]+matrix[0][i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]=(dp[i-1][0]+matrix[i][0]);\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i][j];\\n            }\\n        }\\n       \\n    }\\n    \\n  int getans(int si,int sj,int ei,int ej){\\n        if(si==0 && sj==0){\\n            return dp[ei][ej];\\n        }else if(si==0 && sj!=0){\\n            return dp[ei][ej]-dp[ei][sj-1];\\n        }else if(si!=0 && sj==0){\\n            return dp[ei][ej]-dp[si-1][ej];\\n        }else{\\n             return dp[ei][ej]-dp[ei][sj-1]-dp[si-1][ej]+dp[si-1][sj-1];\\n        }\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int n,m;\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        n=matrix.size(),m=matrix[0].size();\\n        fun(matrix);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               int si=i,sj=j;\\n               \\n                for(int p=si;p<n;p++){\\n                    for(int q=sj;q<m;q++){\\n                     \\n                        if(p==si && q==sj){\\n                           \\n                            ans+=(target==matrix[p][q])?1:0;\\n                        }else{\\n                          \\n                             ans+=(target==getans(si,sj,p,q))?1:0;\\n                        }\\n                    }\\n                }\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n   void fun(vector<vector<int>>& matrix){\\n        dp[0][0]=matrix[0][0];      // Getting the sum of matrix from index(0,0) for every (i,j);\\n        for(int i=1;i<m;i++){\\n            dp[0][i]=(dp[0][i-1]+matrix[0][i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            dp[i][0]=(dp[i-1][0]+matrix[i][0]);\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i][j];\\n            }\\n        }\\n       \\n    }\\n    \\n  int getans(int si,int sj,int ei,int ej){\\n        if(si==0 && sj==0){\\n            return dp[ei][ej];\\n        }else if(si==0 && sj!=0){\\n            return dp[ei][ej]-dp[ei][sj-1];\\n        }else if(si!=0 && sj==0){\\n            return dp[ei][ej]-dp[si-1][ej];\\n        }else{\\n             return dp[ei][ej]-dp[ei][sj-1]-dp[si-1][ej]+dp[si-1][sj-1];\\n        }\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297649,
                "title": "c-91-faster-easy-to-understand-have-a-look-explained",
                "content": "\\nclass Solution {\\npublic:\\n\\n    // this part you have already solve on leetcode here we are just solving famous leetcode problem number of subarrays with sum k\\n\\t// we are just converting this bigger problem into one of the most renowed problem\\n\\t\\t\\n\\t\\tint solve(vector<int>&nums,int k)\\n    {unordered_map<int,int>mp;\\n     int cs=0;\\n     int ans=0;\\n     for(int i=0;i<nums.size();++i)\\n     {\\n         cs+=nums[i];\\n         if(cs==k)\\n         {\\n            ans++; \\n         }\\n         if(mp.find(cs-k)!=mp.end())\\n         {\\n             ans+=mp[cs-k];\\n          \\n         }\\n         mp[cs]++;\\n     }\\n     return ans;\\n        \\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& a, int t) {\\n         int ans=0;\\n        //we will actually work row wise because we already know  the problem to find number of subarray in a row with a given sum\\n        for(int srow=0;srow<a.size();++srow)\\n        {vector<int>v(a[0].size(),0);\\n            for(int crow =srow;crow<a.size();++crow)//crow-->currrow\\n            {\\n                // now storing sum in  a particular array\\n                for(int j=0;j<a[0].size();++j)\\n                {\\n                    v[j]+=a[crow][j];\\n                }\\n                ans+=solve(v,t);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n/*\\n**Taking an example**\\n**step 1--\\nsolving like this\\n1 1 1 1->srow v=> 1 1 1 1\\n1 1 1 1       v=> 2 2 2 2\\n1 1 1 1       v=> 3 3 3 3\\n1 1 1 1       v=> 4 4 4 4\\nstep 2--\\n1 1 1 1 \\n1 1 1 1=>srow v=> 1 1 1 1\\n1 1 1 1       v=> 2 2 2 2\\n1 1 1 1       v=> 3 3 3 3\\nstep 3--\\n1 1 1 1 \\n1 1 1 1\\n1 1 1 1  =>srow v=> 1 1 1 1    \\n1 1 1 1        v=> 2 2 2 2\\nstep 4--\\n1 1 1 1 \\n1 1 1 1\\n1 1 1 1  \\n1 1 1 1   =>srow v=> 1 1 1 1    \\nevery time  we are calculating the cumulative sum starting from the srow index\\nand you will get your ans**\\n*/\\n**Upvote if it helped**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // this part you have already solve on leetcode here we are just solving famous leetcode problem number of subarrays with sum k\\n\\t// we are just converting this bigger problem into one of the most renowed problem\\n\\t\\t\\n\\t\\tint solve(vector<int>&nums,int k)\\n    {unordered_map<int,int>mp;\\n     int cs=0;\\n     int ans=0;\\n     for(int i=0;i<nums.size();++i)\\n     {\\n         cs+=nums[i];\\n         if(cs==k)\\n         {\\n            ans++; \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 303755,
                "title": "java-simple-solution-with-explanation",
                "content": "* Counting all sub-arrays with a given sum k for 1-Dimensional array can be used to reduce the time complexity.\\n* We fix the left and right columns one by one and count sub-arrays for every left and right column pair.\\n* The sum of elements in every row from left to right and store these sums in a temporary array say temp[].\\n* So temp[i] indicates sum of elements from left to right in row i.\\n* Count sub-arrays in temp[] having sum k.\\n* Sum up all the counts for each temp[] with different left and right column pairs.\\n```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] temp = new int[m];\\n        int ans=0;\\n        for (int left = 0;left<n;left++) {\\n            Arrays.fill(temp,0);\\n            for (int right=left;right<n;right++) {\\n                for (int i=0;i<m;i++) {\\n                    temp[i]+=matrix[i][right];\\n                }\\n                ans+= subCount(temp,target);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int subCount(int[] temp,int target) {\\n        HashMap<Integer, Integer> prevSum = new HashMap<>();\\n\\n        int res = 0;\\n        int currentSum = 0;\\n\\n        for (int t : temp) {\\n\\n            currentSum += t;\\n            if (currentSum == target) {\\n                res++;\\n            }\\n            if (prevSum.containsKey(currentSum - target)) {\\n                res += prevSum.get(currentSum - target);\\n            }\\n            prevSum.merge(currentSum, 1, (a, b) -> a + b);\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int[] temp = new int[m];\\n        int ans=0;\\n        for (int left = 0;left<n;left++) {\\n            Arrays.fill(temp,0);\\n            for (int right=left;right<n;right++) {\\n                for (int i=0;i<m;i++) {\\n                    temp[i]+=matrix[i][right];\\n                }\\n                ans+= subCount(temp,target);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int subCount(int[] temp,int target) {\\n        HashMap<Integer, Integer> prevSum = new HashMap<>();\\n\\n        int res = 0;\\n        int currentSum = 0;\\n\\n        for (int t : temp) {\\n\\n            currentSum += t;\\n            if (currentSum == target) {\\n                res++;\\n            }\\n            if (prevSum.containsKey(currentSum - target)) {\\n                res += prevSum.get(currentSum - target);\\n            }\\n            prevSum.merge(currentSum, 1, (a, b) -> a + b);\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298375,
                "title": "c-easy-to-understand-explained-prefix-map",
                "content": "HOPE IT HELPS...\\n\\nCODE : \\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int r,c;\\n        r = mat.size();\\n        c = mat[0].size();\\n        int prefix[r+1][c];\\n        prefix[r-1][c-1] = mat[r-1][c-1];\\n        prefix[r][c-1] = 0;\\n        for(int i = c-2 ; i >= 0 ; i--)\\n        {\\n            prefix[r-1][i] = prefix[r-1][i+1] + mat[r-1][i];\\n            prefix[r][i] = 0;\\n        }\\n        for(int j = r-2 ; j >= 0 ; j--)\\n            prefix[j][c-1] = prefix[j+1][c-1] + mat[j][c-1];\\n        for(int i = r-2 ; i >= 0 ; i--)\\n            for(int j = c-2 ; j >= 0 ;j--)\\n                prefix[i][j] = prefix[i+1][j] + prefix[i][j+1] - prefix[i+1][j+1] + mat[i][j];\\n      \\n        int cnt = 0;\\n        for(int i = 0 ; i < r ; i++)\\n        {\\n            for(int j = i+1; j <= r ; j++)\\n            {\\n                map<int , int> mp;\\n                mp[0] = 1;\\n                for(int k = c-1 ; k >= 0 ; k--)\\n                {\\n                    int sum = prefix[i][k] - prefix[j][k];\\n                    int reqSum = sum - target;\\n                    cnt += mp[reqSum];\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nEXPLANATION (By pictures)  : \\n![image](https://assets.leetcode.com/users/images/21d220cd-db50-4c51-9fd6-5b8648c51c84_1658128270.3572967.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/853219d3-7a98-4747-83db-7bcd862483e7_1658128300.1421673.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/981838f9-f919-4724-bc0e-74267d482c7f_1658128331.2134755.jpeg)\\n\\nCOMPLEXITY : \\n\\n\\n![image](https://assets.leetcode.com/users/images/81f93fd5-cc8e-4954-9a9a-5d771219c759_1658128365.2356606.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int r,c;\\n        r = mat.size();\\n        c = mat[0].size();\\n        int prefix[r+1][c];\\n        prefix[r-1][c-1] = mat[r-1][c-1];\\n        prefix[r][c-1] = 0;\\n        for(int i = c-2 ; i >= 0 ; i--)\\n        {\\n            prefix[r-1][i] = prefix[r-1][i+1] + mat[r-1][i];\\n            prefix[r][i] = 0;\\n        }\\n        for(int j = r-2 ; j >= 0 ; j--)\\n            prefix[j][c-1] = prefix[j+1][c-1] + mat[j][c-1];\\n        for(int i = r-2 ; i >= 0 ; i--)\\n            for(int j = c-2 ; j >= 0 ;j--)\\n                prefix[i][j] = prefix[i+1][j] + prefix[i][j+1] - prefix[i+1][j+1] + mat[i][j];\\n      \\n        int cnt = 0;\\n        for(int i = 0 ; i < r ; i++)\\n        {\\n            for(int j = i+1; j <= r ; j++)\\n            {\\n                map<int , int> mp;\\n                mp[0] = 1;\\n                for(int k = c-1 ; k >= 0 ; k--)\\n                {\\n                    int sum = prefix[i][k] - prefix[j][k];\\n                    int reqSum = sum - target;\\n                    cnt += mp[reqSum];\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492231,
                "title": "java-o-r-r-c-or-o-c-c-r-solution",
                "content": "* Convert it to 1-D array, then the problem turns into \"search for subarray sums that equal to the target\", which uses hashmap to track prefix sum count during iteration.\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0, r = matrix.length, c = matrix[0].length;\\n        \\n        for (int i = 0; i < c; i++) {\\n            int[] rowSums = new int[r];\\n            for (int j = i; j < c; j++) {\\n                Map<Integer, Integer> count = new HashMap<>();\\n                count.put(0, 1);\\n                int prefixSum = 0;\\n                for (int k = 0; k < r; k++) {\\n                    rowSums[k] += matrix[k][j];\\n                    prefixSum += rowSums[k];\\n                    res += count.getOrDefault(prefixSum - target, 0);\\n                    count.put(prefixSum, count.getOrDefault(prefixSum, 0) + 1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0, r = matrix.length, c = matrix[0].length;\\n        \\n        for (int i = 0; i < c; i++) {\\n            int[] rowSums = new int[r];\\n            for (int j = i; j < c; j++) {\\n                Map<Integer, Integer> count = new HashMap<>();\\n                count.put(0, 1);\\n                int prefixSum = 0;\\n                for (int k = 0; k < r; k++) {\\n                    rowSums[k] += matrix[k][j];\\n                    prefixSum += rowSums[k];\\n                    res += count.getOrDefault(prefixSum - target, 0);\\n                    count.put(prefixSum, count.getOrDefault(prefixSum, 0) + 1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300524,
                "title": "c-o-n-4-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                \\n                vector<int>tmp(m, 0);\\n                for(int k=i; k<n; k++){\\n                    int s = 0;\\n                    for(int l=j; l<m; l++){\\n                        s += matrix[k][l];\\n                        tmp[l] += s;\\n                        if(tmp[l]==target)\\n                            ans++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nComplextiy:\\n\\u2981\\tTime: O((m*n)^2)\\n\\u2981\\tSpace: O(n)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                \\n                vector<int>tmp(m, 0);\\n                for(int k=i; k<n; k++){\\n                    int s = 0;\\n                    for(int l=j; l<m; l++){\\n                        s += matrix[k][l];\\n                        tmp[l] += s;\\n                        if(tmp[l]==target)\\n                            ans++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298094,
                "title": "c-hashmap-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tA[i][j] += A[i][j - 1];\\n\\n\\t\\tunordered_map<int, int> counter;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tcounter = {{0,1}};\\n\\t\\t\\t\\tint cur = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n\\t\\t\\t\\t  res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n\\t\\t\\t\\t  counter[cur]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tA[i][j] += A[i][j - 1];\\n\\n\\t\\tunordered_map<int, int> counter;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tcounter = {{0,1}};\\n\\t\\t\\t\\tint cur = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n\\t\\t\\t\\t  res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0;\\n\\t\\t\\t\\t  counter[cur]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747611,
                "title": "c-prefix-sum-subarray-sum-based-explanation",
                "content": "The problem can be reduced to finding subarray sum in a 1D array with target value. We can find the 1D subarray sum for each combination of rows and then each subarray sum takes O(n) which makes the total time complexity O(n^3) since there will be n^2 combinations of rows.\\n\\nFirst we calculate the row prefix sum for the matrix so that each time we need to find the elements of rows r1 to r2 we can get it in O(n) since we won\\'t need to sum all the elements in the row range again. And the sum of that row range can be calculated as sum[r2] - sum[r1-1]. \\nFor Example1 the row prefix sum matrix would be: \\n```\\n0 1 0                                          0 1 0\\n1 1 1                 =>                       1 2 1\\n0 1 0                                          1 3 1\\n\\nRange [1,2] would sum to: [1 3 1]-[0 1 0] = [1 2 1] in the original matrix.\\n```\\nAnd then we can find the subarray sum equal to target in the above formed 1D array in linear time. For this refer [@560](https://leetcode.com/problems/subarray-sum-equals-k). And in the above 1D array any subarray sum from index l,r would correspond to sum of submatrix having upper left as [r1,l] and lower right as [r2,r]. Thus we can just find the subarray sum for a 1D array for each combination of rows and we would be covering all the possible submatrices.\\n\\n**Implementation:**\\n\\n```\\nclass Solution {\\npublic:\\n    int checksub(vector<vector<int>>& matrix,int r1,int r2,int target){\\n        unordered_map<int,int> m;\\n        int curr=0,ans=0;\\n        m[0]=1;\\n\\t\\t//  ith element of 1D array = matrix[r2][i]-matrix[r1-1][i]\\n        for(int i=0;i<matrix[0].size();i++){                  \\n            if(r1>0)                    \\n                curr+=matrix[r2][i]-matrix[r1-1][i];\\n            else\\n                curr+=matrix[r2][i];\\n            \\n            if(m.find(curr-target)!=m.end())\\n                ans+=m[curr-target];\\n            m[curr]++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int m=matrix.size(),n=matrix[0].size();\\n        if(m==0 || n==0)\\n            return 0;\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)       // Creating row prefix sum matrix\\n            for(int j=0;j<n;j++){\\n                if(i>0)\\n                    matrix[i][j]+=matrix[i-1][j];\\n            }\\n        int ans=0;\\n        for(int i=0;i<m;i++)     // For each row pair find 1D subarray sum with target\\n            for(int j=i;j<m;j++)  \\n                ans+=checksub(matrix,i,j,target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0 1 0                                          0 1 0\\n1 1 1                 =>                       1 2 1\\n0 1 0                                          1 3 1\\n\\nRange [1,2] would sum to: [1 3 1]-[0 1 0] = [1 2 1] in the original matrix.\\n```\n```\\nclass Solution {\\npublic:\\n    int checksub(vector<vector<int>>& matrix,int r1,int r2,int target){\\n        unordered_map<int,int> m;\\n        int curr=0,ans=0;\\n        m[0]=1;\\n\\t\\t//  ith element of 1D array = matrix[r2][i]-matrix[r1-1][i]\\n        for(int i=0;i<matrix[0].size();i++){                  \\n            if(r1>0)                    \\n                curr+=matrix[r2][i]-matrix[r1-1][i];\\n            else\\n                curr+=matrix[r2][i];\\n            \\n            if(m.find(curr-target)!=m.end())\\n                ans+=m[curr-target];\\n            m[curr]++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int m=matrix.size(),n=matrix[0].size();\\n        if(m==0 || n==0)\\n            return 0;\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)       // Creating row prefix sum matrix\\n            for(int j=0;j<n;j++){\\n                if(i>0)\\n                    matrix[i][j]+=matrix[i-1][j];\\n            }\\n        int ans=0;\\n        for(int i=0;i<m;i++)     // For each row pair find 1D subarray sum with target\\n            for(int j=i;j<m;j++)  \\n                ans+=checksub(matrix,i,j,target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2533076,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n\\tpublic int numSubmatrixSumTarget(int[][] arr, int target) {\\n\\t\\tint n = arr.length;\\n\\t\\tint m = arr[0].length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[m];\\n\\t\\t\\tfor (int row = i; row < n; row++) {\\n\\t\\t\\t\\tfor (int col = 0; col < m; col++) {\\n\\t\\t\\t\\t\\ttemp[col] += arr[row][col];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount += helper(temp, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic int helper(int[] arr, int target) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, 1);\\n\\t\\tint count = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tcount += map.getOrDefault(sum - target, 0);\\n\\t\\t\\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int numSubmatrixSumTarget(int[][] arr, int target) {\\n\\t\\tint n = arr.length;\\n\\t\\tint m = arr[0].length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[m];\\n\\t\\t\\tfor (int row = i; row < n; row++) {\\n\\t\\t\\t\\tfor (int col = 0; col < m; col++) {\\n\\t\\t\\t\\t\\ttemp[col] += arr[row][col];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount += helper(temp, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\n\\tpublic int helper(int[] arr, int target) {\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, 1);\\n\\t\\tint count = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tcount += map.getOrDefault(sum - target, 0);\\n\\t\\t\\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300710,
                "title": "very-easy-explanation-solution-subarray-sum-equal-to-k",
                "content": "Before you go with this problem I will suggest you to first solve [Subarray Sum Equal to K](https://leetcode.com/problems/subarray-sum-equals-k/). This problem is quite modified version of that problem. Upvote if you like it.\\n\\n\\n**Approach**\\nFirst we will find the subarrays that contribute to sum equal to target, considering each row.\\n\\n| a | b | c | ------------------row1 \\n| d | e | f  | ------------------row2\\n| g | h | i  |-------------------row3\\n\\n\\n\\nCombine consecutive rows and find answer again, as submatrix can also combination of two or more rows.\\n\\n| a          | b           | c        |            ------find for this\\n| d+a      | e+b      | f+c     |             -----find for this row\\n| g+d+a  | h+e+b | i+f+c   |             ------find for this row\\n\\nsimilarly,\\n\\n| d     | e      | f     |                    -----for this row\\n| g+d | h+e  | i+f  |                    -----for this row\\n\\nand,\\n| g | h | i  |                                -----for this row\\n\\n\\nadd the answers of all these rows, and have the final answer,\\n\\n\\n**My Solution**\\n```\\nclass Solution {\\npublic:\\n    int sumEqualToK(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        mp[0] =1;\\n        int sum = 0,ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            ans += mp[sum-k];   \\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int count=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<int> prefSum(matrix[i].size(),0);\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int k=0;k<matrix[j].size();k++)\\n                {\\n                    prefSum[k] += matrix[j][k];\\n                }\\n                count += sumEqualToK(prefSum, target);\\n\\n            }  \\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumEqualToK(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        mp[0] =1;\\n        int sum = 0,ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            ans += mp[sum-k];   \\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int count=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<int> prefSum(matrix[i].size(),0);\\n            for(int j=i;j<matrix.size();j++)\\n            {\\n                for(int k=0;k<matrix[j].size();k++)\\n                {\\n                    prefSum[k] += matrix[j][k];\\n                }\\n                count += sumEqualToK(prefSum, target);\\n\\n            }  \\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297893,
                "title": "brute-force-and-optimised-number-of-submatrices-that-sum-to-target",
                "content": "From Bruteforce to optimised code.\\n**Brute force code(TLE)**\\nSimply check sum of all possible (x1, y1), (x2, y2) pairs in matrix.\\nWe can easily optmise this using prefix 2 D array\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + matrix[i-1][j-1];\\n\\n        int cnt = 0;\\n\\n        for(int i = 1; i<=n; i++) {\\n            for(int j = 1; j<=m; j++) {\\n                for(int k = i; k <= n; k++) {\\n                    for(int l = j; l <=m; l++) {\\n                        if(pre[k][l] - pre[k][j-1] - pre[i - 1][l] + pre[i - 1][j - 1] == target) {\\n                            cout << k << \" \" << l << \" \" << i << \" \" << j << \"\\\\n\";\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n            }\\n        }      \\n\\n        return cnt;\\n    }\\n};\\n```\\nBut this code leads to TLE since it is O(N^4)\\n\\n**Optimised approach**\\nWe can iterate over all column pairs and store the prefix sum of rows between two columns.\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] = matrix[i-1][j-1] + pre[i][j-1];\\n\\n\\n        unordered_map<int, int>hsh;\\n        int res = 0;\\n\\n        for(int col1 = 1; col1 <= m; col1++) {\\n            for(int col2 = col1; col2 <= m; col2++) {\\n                hsh = {{0, 1}};\\n                int curr = 0;\\n                for(int row = 1; row <= n; row++) {\\n                    curr += pre[row][col2] - pre[row][col1 - 1];\\n                    if(hsh.count(curr - target))\\n                        res += hsh[curr - target];\\n                    hsh[curr]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nTime Complexity: O(N^3)\\n\\nThank You \\u2764\\uFE0F",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1] + matrix[i-1][j-1];\\n\\n        int cnt = 0;\\n\\n        for(int i = 1; i<=n; i++) {\\n            for(int j = 1; j<=m; j++) {\\n                for(int k = i; k <= n; k++) {\\n                    for(int l = j; l <=m; l++) {\\n                        if(pre[k][l] - pre[k][j-1] - pre[i - 1][l] + pre[i - 1][j - 1] == target) {\\n                            cout << k << \" \" << l << \" \" << i << \" \" << j << \"\\\\n\";\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n            }\\n        }      \\n\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n\\n        vector<vector<int>>pre(n + 1, vector<int>(m + 1, 0));\\n\\n        for(int i = 1; i<=n; i++)\\n            for(int j = 1; j<=m; j++)\\n                pre[i][j] = matrix[i-1][j-1] + pre[i][j-1];\\n\\n\\n        unordered_map<int, int>hsh;\\n        int res = 0;\\n\\n        for(int col1 = 1; col1 <= m; col1++) {\\n            for(int col2 = col1; col2 <= m; col2++) {\\n                hsh = {{0, 1}};\\n                int curr = 0;\\n                for(int row = 1; row <= n; row++) {\\n                    curr += pre[row][col2] - pre[row][col1 - 1];\\n                    if(hsh.count(curr - target))\\n                        res += hsh[curr - target];\\n                    hsh[curr]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 816242,
                "title": "o-n-3-solution-c-approach-fully-explained-must-watch",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    \\n    APPROACH :\\n    \\n    GIVEN ARRAY\\n    \\n    0 1 0\\n    1 1 1\\n    0 1 0\\n    \\n    no of rows(m) = 3;\\n    no of cols(n) = 4;\\n    \\n    First construct a prefix sum array of size {m+1 , n}\\n    \\n    And calculate prefix sum for every column\\n    \\n    Prefix Sum array\\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    1 3 1\\n    \\n    Now for each row\\n    \\n        We search for all the downward sub matrics end {i,j}\\n        here i>=row and i<m\\n        and j>=0 and j<n\\n        \\n        we sum prefixSum[i+1][0] to prefixSum[i+1][j] to calulate sum of all the elements from (0,0) to (i,j) (Let Say sum)\\n        we sum prefixSum[row][0] to prefixSum[row][j] to calulate sum of all the elements from (0,0) to (row-1,j) (Let Say Subsum)\\n        \\n        for each j\\n            if we subtract sum = (sum- Subsum), we get sum of all the elements from (row,0) to (i,j)\\n            \\n            if(sum=target) in increase the counter\\n            \\n            for for this sum we check if (sum-target) exists in the map or not;\\n            if exsits we can confirm that how many times we have encountered an l (0<l<j) \\n                Such that\\n                    sum of all the elements from (row,0) to (i,l) is (sum-target)\\n                    Which indirectly confirms sum of all the elements from (row,l+1) to (i,j) is target\\n                    \\n            Increase mp[sum] by 1\\n    \\n    \\n    */\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int pre[m+1][n];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<n;j++){\\n                pre[i][j]=0;\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<m;i++){\\n            \\n                pre[i+1][j]=pre[i][j]+matrix[i][j];\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n   /*     \\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    0 3 0\\n    */\\n        \\n        for(int row =0 ; row<m; row++){\\n            \\n            for(int i=row; i<m;i++){\\n                mp.clear();\\n                int sum=0;\\n                for(int j=0; j<n;j++){\\n                     sum+= pre[i+1][j]-pre[row][j];\\n                    if(sum==target)\\n                        cnt++;\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        cnt+=mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    \\n    APPROACH :\\n    \\n    GIVEN ARRAY\\n    \\n    0 1 0\\n    1 1 1\\n    0 1 0\\n    \\n    no of rows(m) = 3;\\n    no of cols(n) = 4;\\n    \\n    First construct a prefix sum array of size {m+1 , n}\\n    \\n    And calculate prefix sum for every column\\n    \\n    Prefix Sum array\\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    1 3 1\\n    \\n    Now for each row\\n    \\n        We search for all the downward sub matrics end {i,j}\\n        here i>=row and i<m\\n        and j>=0 and j<n\\n        \\n        we sum prefixSum[i+1][0] to prefixSum[i+1][j] to calulate sum of all the elements from (0,0) to (i,j) (Let Say sum)\\n        we sum prefixSum[row][0] to prefixSum[row][j] to calulate sum of all the elements from (0,0) to (row-1,j) (Let Say Subsum)\\n        \\n        for each j\\n            if we subtract sum = (sum- Subsum), we get sum of all the elements from (row,0) to (i,j)\\n            \\n            if(sum=target) in increase the counter\\n            \\n            for for this sum we check if (sum-target) exists in the map or not;\\n            if exsits we can confirm that how many times we have encountered an l (0<l<j) \\n                Such that\\n                    sum of all the elements from (row,0) to (i,l) is (sum-target)\\n                    Which indirectly confirms sum of all the elements from (row,l+1) to (i,j) is target\\n                    \\n            Increase mp[sum] by 1\\n    \\n    \\n    */\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int pre[m+1][n];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<n;j++){\\n                pre[i][j]=0;\\n            }\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<m;i++){\\n            \\n                pre[i+1][j]=pre[i][j]+matrix[i][j];\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n   /*     \\n    0 0 0\\n    0 1 0\\n    1 2 1\\n    0 3 0\\n    */\\n        \\n        for(int row =0 ; row<m; row++){\\n            \\n            for(int i=row; i<m;i++){\\n                mp.clear();\\n                int sum=0;\\n                for(int j=0; j<n;j++){\\n                     sum+= pre[i+1][j]-pre[row][j];\\n                    if(sum==target)\\n                        cnt++;\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        cnt+=mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800988,
                "title": "javascript-2d-prefix-sums-clean-and-simple",
                "content": "```js\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    const prefixSums = new Array(matrix.length + 1)\\n        .fill()\\n        .map(() => new Array(matrix[0].length + 1).fill(0));\\n    \\n    for (let i = 1; i <= matrix.length; i++) {\\n        for (let j = 1; j <= matrix[0].length; j++) {\\n            prefixSums[i][j] = matrix[i-1][j-1] + prefixSums[i-1][j] + prefixSums[i][j-1] - prefixSums[i-1][j-1];\\n        }\\n    }\\n    \\n    let count = 0;\\n    for (let r1 = 1; r1 <= matrix.length; r1++) {\\n        for (let r2 = r1; r2 <= matrix.length; r2++) {\\n            const counts = {};\\n            counts[0] = 1;\\n            for (let c = 1; c <= matrix[0].length; c++) {\\n                const sum = prefixSums[r2][c] - prefixSums[r1 - 1][c];\\n                count += counts[sum - target] || 0;\\n                counts[sum] = (counts[sum] || 0) + 1;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    const prefixSums = new Array(matrix.length + 1)\\n        .fill()\\n        .map(() => new Array(matrix[0].length + 1).fill(0));\\n    \\n    for (let i = 1; i <= matrix.length; i++) {\\n        for (let j = 1; j <= matrix[0].length; j++) {\\n            prefixSums[i][j] = matrix[i-1][j-1] + prefixSums[i-1][j] + prefixSums[i][j-1] - prefixSums[i-1][j-1];\\n        }\\n    }\\n    \\n    let count = 0;\\n    for (let r1 = 1; r1 <= matrix.length; r1++) {\\n        for (let r2 = r1; r2 <= matrix.length; r2++) {\\n            const counts = {};\\n            counts[0] = 1;\\n            for (let c = 1; c <= matrix[0].length; c++) {\\n                const sum = prefixSums[r2][c] - prefixSums[r1 - 1][c];\\n                count += counts[sum - target] || 0;\\n                counts[sum] = (counts[sum] || 0) + 1;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693111,
                "title": "python-beat-97-25-easy-understanding",
                "content": "```\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m = len(matrix[0])\\n        n = len(matrix)\\n        res = 0\\n        \\n        prefix = [[0] * m for _ in range(n)]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i == 0:\\n                    prefix[i][j] = matrix[i][j]\\n                else:\\n                    prefix[i][j] = matrix[i][j] + prefix[i-1][j]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                d = {0:1}\\n                cur = 0\\n                for k in range(m):\\n                    if i == 0:\\n                        cur += prefix[j][k]\\n                    else:\\n                        cur += prefix[j][k] - prefix[i-1][k]\\n                \\n                    if cur - target in d:\\n                        res += d[cur-target]\\n\\n                    if cur in d:\\n                        d[cur] += 1\\n                    else:\\n                        d[cur] = 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        m = len(matrix[0])\\n        n = len(matrix)\\n        res = 0\\n        \\n        prefix = [[0] * m for _ in range(n)]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                if i == 0:\\n                    prefix[i][j] = matrix[i][j]\\n                else:\\n                    prefix[i][j] = matrix[i][j] + prefix[i-1][j]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                d = {0:1}\\n                cur = 0\\n                for k in range(m):\\n                    if i == 0:\\n                        cur += prefix[j][k]\\n                    else:\\n                        cur += prefix[j][k] - prefix[i-1][k]\\n                \\n                    if cur - target in d:\\n                        res += d[cur-target]\\n\\n                    if cur in d:\\n                        d[cur] += 1\\n                    else:\\n                        d[cur] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620241,
                "title": "cpp-brute-force-o-n-6-time-complexity-just-for-fun-time-limit-exceeds",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int sum(vector<vector<int>>& matrix, int i,int j,int k,int l){\\n        int s=0;\\n        for(int p=i;p<=k;p++){\\n            for(int q=j;q<=l;q++){\\n                s+=matrix[p][q];\\n            }\\n        }\\n        return s;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int c=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                for(int k=i;k<matrix.size();k++){\\n                    for(int l=j;l<matrix[k].size();l++){\\n                        if(sum(matrix,i,j,k,l)==target)\\n                            c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sum(vector<vector<int>>& matrix, int i,int j,int k,int l){\\n        int s=0;\\n        for(int p=i;p<=k;p++){\\n            for(int q=j;q<=l;q++){\\n                s+=matrix[p][q];\\n            }\\n        }\\n        return s;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int c=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                for(int k=i;k<matrix.size();k++){\\n                    for(int l=j;l<matrix[k].size();l++){\\n                        if(sum(matrix,i,j,k,l)==target)\\n                            c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470445,
                "title": "python-solution-o-n-3-beats-98",
                "content": "This question is related to https://leetcode.com/problems/subarray-sum-equals-k/. We can use the same idea to find out the number of subarray with target sum for one row in linear time. Basically, we generate O(m^2) combinations of rows and apply O(n) algorithm to find the target sum for each combination. \\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        def num_for_one_row(nums):\\n            prev = {}\\n            prev[0] = 1\\n            cur_sum = 0\\n            ans = 0\\n            for num in nums:\\n                cur_sum += num\\n                if cur_sum - target in prev:\\n                    ans += prev[cur_sum - target]\\n                if cur_sum not in prev:\\n                    prev[cur_sum] = 1\\n                else:\\n                    prev[cur_sum] += 1\\n            return ans \\n        \\n        res = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        for i in range(m):\\n            nums = [0]*n\\n            for j in range(i,m):\\n                for k in range(n):\\n                    nums[k]+=matrix[j][k]\\n                res += num_for_one_row(nums)\\n                \\n        return res\\n```\\n\\nIn this solution, the time complexity is O(m^2*n)  where m is the number of rows and n is the number of columns. The space complexity is O(n).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        def num_for_one_row(nums):\\n            prev = {}\\n            prev[0] = 1\\n            cur_sum = 0\\n            ans = 0\\n            for num in nums:\\n                cur_sum += num\\n                if cur_sum - target in prev:\\n                    ans += prev[cur_sum - target]\\n                if cur_sum not in prev:\\n                    prev[cur_sum] = 1\\n                else:\\n                    prev[cur_sum] += 1\\n            return ans \\n        \\n        res = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        for i in range(m):\\n            nums = [0]*n\\n            for j in range(i,m):\\n                for k in range(n):\\n                    nums[k]+=matrix[j][k]\\n                res += num_for_one_row(nums)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298611,
                "title": "python-99-94-fastest",
                "content": "```\\ndef numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:    \\n        n,m = len(matrix),len(matrix[0])\\n        dp = [[0]*m for _ in range(n)]\\n        \\n        # make prefix sum for every row\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] = matrix[i][j] + (dp[i][j-1] if j-1>=0 else 0)\\n        # print(*dp,sep=\"\\\\n\")        \\n        ans = 0\\n        # for every column see row sum\\n        for i in range(m):\\n            for j in range(i,m):\\n                d = {0:1}\\n                s = 0\\n                for r in range(n):\\n                    s += dp[r][j] - (dp[r][i-1] if i-1>=0 else 0)\\n                    if s-target in d:\\n                        ans += d[s-target] \\n                        \\n                    if s in d:\\n                        d[s] += 1\\n                    else:\\n                        d[s] = 1\\n                        \\n        return ans\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ndef numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:    \\n        n,m = len(matrix),len(matrix[0])\\n        dp = [[0]*m for _ in range(n)]\\n        \\n        # make prefix sum for every row\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] = matrix[i][j] + (dp[i][j-1] if j-1>=0 else 0)\\n        # print(*dp,sep=\"\\\\n\")        \\n        ans = 0\\n        # for every column see row sum\\n        for i in range(m):\\n            for j in range(i,m):\\n                d = {0:1}\\n                s = 0\\n                for r in range(n):\\n                    s += dp[r][j] - (dp[r][i-1] if i-1>=0 else 0)\\n                    if s-target in d:\\n                        ans += d[s-target] \\n                        \\n                    if s in d:\\n                        d[s] += 1\\n                    else:\\n                        d[s] = 1\\n                        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2298559,
                "title": "python-prefix-sum-hashmap-with-explanation",
                "content": "To solve this probelm, let us solve [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) at first.\\n\\n### 560. Subarray Sum Equals K\\nThe basic idea it to handle this problem with `hashmap`. The hashmap will store with the key being any particular `sum`, and the value being the number of time it has happened yet. Suppose we iterate the arrary from left to right and keep track of cumulative sum up to `i` in each position.\\n\\nIf there is an increase of `k` in `preSum[i]`, we can find `preSum[j] = preSum[i] + k`. (j > i)\\n\\nThe origin problem `find a subarry whose sum equals to k (preSum[j] - preSum[i])` can be changed to `find a subarray whose sum equals to preSum[i] (preSum[j] - k)`\\n\\nSo, the solution is here:\\n```python\\n```python\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        pre_sum = 0\\n        res = defaultdict(int)\\n        res[0] = 1 # it means that we\\'ve already seen sum of 0 once before iterating the list.\\n        \\n        for num in nums:\\n            pre_sum += num\\n            ans += res[pre_sum - k]\\n            res[pre_sum] += 1\\n        return ans\\n```\\n\\n### 1074. Number of Submatrices That Sum to Target\\nActually, this problem is a variation of `560`. We enumerate the submatrixs by setting different `upper` and `lower` boundaries. Then we calculate the `sum` of each column. So the origin problem can be changed to:\\n- Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\\n\\nFor the calculation of sum of each column, every time we extend lower boundary `j` downwards, the elements in the `jth` row of the matrix are added to the `sum`.\\n\\n```python\\nclass Solution:\\n    def numSubmatrixSumTarget(self, M: List[List[int]], T: int) -> int:\\n        def subarrSum(nums, target):\\n            res = defaultdict(int)\\n            res[0] = 1\\n            ans, pre_sum = 0, 0\\n            \\n            for num in nums:\\n                pre_sum += num\\n                ans += res[pre_sum - target]\\n                res[pre_sum] += 1\\n            return ans\\n                \\n                \\n        rows, cols = len(M), len(M[0])\\n        ans = 0\\n        for i1 in range(rows):\\n            total = [0]*cols\\n            for i2 in range(i1, rows):\\n                for j in range(cols):\\n                    total[j] += M[i2][j]\\n                ans += subarrSum(total, T)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```python\\n```\n```\\n\\n### 1074. Number of Submatrices That Sum to Target\\nActually, this problem is a variation of `560`. We enumerate the submatrixs by setting different `upper` and `lower` boundaries. Then we calculate the `sum` of each column. So the origin problem can be changed to:\\n- Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\\n\\nFor the calculation of sum of each column, every time we extend lower boundary `j` downwards, the elements in the `jth` row of the matrix are added to the `sum`.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297678,
                "title": "91-faster-and-memory-efficient-solution",
                "content": "\\t\\n\\tclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        ans = 0\\n        \\n        for i in range(m): # enum upper bound\\n            total = [0] * n\\n            \\n            for j in range(i, m): # enum lower bound\\n                for c in range(n):\\n                    # update each row\\'s sum\\n                    total[c] += matrix[j][c]\\n                    \\n                ans += self.subarrSum(total, target)\\n                \\n                \\n        return ans\\n    \\n    \\n    \\n    def subarrSum(self, nums, k):\\n        hashmap = defaultdict(int)\\n        hashmap[0] = 1\\n\\n        cnt = presum = 0\\n        for x in nums:\\n            presum += x \\n\\n            if presum - k in hashmap:\\n                cnt += hashmap[presum-k]\\n\\n            hashmap[presum] += 1\\n\\n        return cnt",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\n\\tclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        ans = 0\\n        \\n        for i in range(m): # enum upper bound\\n            total = [0] * n\\n            \\n            for j in range(i, m): # enum lower bound\\n                for c in range(n):\\n                    # update each row\\'s sum\\n                    total[c] += matrix[j][c]\\n                    \\n                ans += self.subarrSum(total, target)\\n                \\n                \\n        return ans\\n    \\n    \\n    \\n    def subarrSum(self, nums, k):\\n        hashmap = defaultdict(int)\\n        hashmap[0] = 1\\n\\n        cnt = presum = 0\\n        for x in nums:\\n            presum += x \\n\\n            if presum - k in hashmap:\\n                cnt += hashmap[presum-k]\\n\\n            hashmap[presum] += 1\\n\\n        return cnt",
                "codeTag": "Java"
            },
            {
                "id": 2297572,
                "title": "c-easy-prefix-sum-sliding-window",
                "content": "````\\nclass Solution\\n{\\n    public:\\n        int numSubmatrixSumTarget(vector<vector < int>> &matrix, int target)\\n        {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n            }\\n            \\n            int count = 0;\\n            \\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = i; j < n; j++)\\n                {\\n                    map<int, int> mp;\\n                    mp[0] = 1;\\n                    int sum = 0;\\n                    for (int k = 0; k < m; k++)\\n                    {\\n                        sum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n                        count += mp[sum - target];\\n                        mp[sum]++;\\n                    }\\n                }\\n            }\\n            \\n            return count;\\n        }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution\\n{\\n    public:\\n        int numSubmatrixSumTarget(vector<vector < int>> &matrix, int target)\\n        {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            for (int i = 0; i < m; i++)\\n            {\\n                for (int j = 1; j < n; j++)\\n                {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n            }\\n            \\n            int count = 0;\\n            \\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = i; j < n; j++)\\n                {\\n                    map<int, int> mp;\\n                    mp[0] = 1;\\n                    int sum = 0;\\n                    for (int k = 0; k < m; k++)\\n                    {\\n                        sum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n                        count += mp[sum - target];\\n                        mp[sum]++;\\n                    }\\n                }\\n            }\\n            \\n            return count;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128489,
                "title": "java-easy-explained-very-simple-o-m-n-m",
                "content": "```\\nsee u can first find the row prefix sum\\nthen take two pointer one on 0 and other on say x  then traverse row and as u did in to find the subarray sum equal to k just do that that is sum-target+target=sum if u can store sum at some point u will realise that u are finding target because sum-(sum-target)=target if u have the count of sum-target u hv to just add it up\\n```\\n\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target)\\n    {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        long dp[][]=new long[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][0]=matrix[i][0];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j]=dp[i][j-1]+matrix[i][j];\\n            }\\n        }\\n        int count=0;\\n        for(int start=0;start<m;start++)\\n        {\\n            for(int end=start;end<m;end++)\\n            {\\n                HashMap<Long,Integer> map=new  HashMap<Long,Integer>();\\n                long sum=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    long pre=start!=0?dp[i][start-1]:0;\\n                    sum+=dp[i][end]-pre;\\n                    if(map.containsKey(sum-target))\\n                    {\\n                        count+=map.get(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```\\n\\n# ***PLS UPVOTE IF U LIKE THE SOLUTION* **",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nsee u can first find the row prefix sum\\nthen take two pointer one on 0 and other on say x  then traverse row and as u did in to find the subarray sum equal to k just do that that is sum-target+target=sum if u can store sum at some point u will realise that u are finding target because sum-(sum-target)=target if u have the count of sum-target u hv to just add it up\\n```\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target)\\n    {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        long dp[][]=new long[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][0]=matrix[i][0];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j]=dp[i][j-1]+matrix[i][j];\\n            }\\n        }\\n        int count=0;\\n        for(int start=0;start<m;start++)\\n        {\\n            for(int end=start;end<m;end++)\\n            {\\n                HashMap<Long,Integer> map=new  HashMap<Long,Integer>();\\n                long sum=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    long pre=start!=0?dp[i][start-1]:0;\\n                    sum+=dp[i][end]-pre;\\n                    if(map.containsKey(sum-target))\\n                    {\\n                        count+=map.get(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163041,
                "title": "c-dp-brute-force-and-2-sum-flavored-a-legend-a-1-d-guy-manage-2-d-dream",
                "content": "Approach 1: DP [1]\\nTime/Space: O(M*N^2); O(1); where M, N is the row and column size of the given matrix\\nmotivation:\\nIt is about a legend a 1-D guy manage 2-D dream\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        for(int l = 0; l < n; l++) // l: left column index\\n            for(int r = l; r < n; r++){ //r: right column index\\n                unordered_map<int, int> counts{{0, 1}};\\n                int cur = 0; //this guy working hard, coming from 1-D world, but can watch 2-D by collecting runnign rums of different rows between col l & r\\n                for(int i = 0; i < m; i++){\\n                    cur += matrix[i][r] - (l > 0 ? matrix[i][l - 1] : 0);                    \\n                    ans += counts[cur - target];\\n                    ++counts[cur];\\n                }                \\n            }\\n        return ans;        \\n    }\\n};\\n```\\n\\n\\nApproach 2: DP brute force (WARNING: will cause TLE error)\\nTime/Space: O(N^4); O(N)\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> sums(m + 1, vector<int>(n + 1, 0));\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + matrix[i-1][j-1];\\n        \\n        int ans = 0;\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                for(int r = 1; r <= i; r++)\\n                    for(int c = 1; c <= j; c++)\\n                        if(target == sums[i][j] - sums[i][c - 1] - sums[r - 1][j] + sums[r - 1][c - 1]) ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\n[1] https://www.cnblogs.com/grandyang/p/14588186.html",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        for(int i = 0; i < m; i++)\\n            for(int j = 1; j < n; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        for(int l = 0; l < n; l++) // l: left column index\\n            for(int r = l; r < n; r++){ //r: right column index\\n                unordered_map<int, int> counts{{0, 1}};\\n                int cur = 0; //this guy working hard, coming from 1-D world, but can watch 2-D by collecting runnign rums of different rows between col l & r\\n                for(int i = 0; i < m; i++){\\n                    cur += matrix[i][r] - (l > 0 ? matrix[i][l - 1] : 0);                    \\n                    ans += counts[cur - target];\\n                    ++counts[cur];\\n                }                \\n            }\\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> sums(m + 1, vector<int>(n + 1, 0));\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                sums[i][j] = sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1] + matrix[i-1][j-1];\\n        \\n        int ans = 0;\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                for(int r = 1; r <= i; r++)\\n                    for(int c = 1; c <= j; c++)\\n                        if(target == sums[i][j] - sums[i][c - 1] - sums[r - 1][j] + sums[r - 1][c - 1]) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046314,
                "title": "simple-java-solution-no-hash-map",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int ans = 0;\\n\\n        for(int i = 0; i<matrix[0].length;i++){//left col\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){//right col\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];//add left to right\\n                    if(sum[j]==target)ans++;            \\n                }\\n                for(int j = 0; j<matrix.length;j++){//up row\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){//down row\\n                        summe+=sum[n];add up to down\\n                        if(n!=j&&summe==target)ans++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int ans = 0;\\n\\n        for(int i = 0; i<matrix[0].length;i++){//left col\\n            int[] sum = new int[matrix.length];\\n            for(int m = i; m<matrix[0].length;m++){//right col\\n                for(int j = 0; j<matrix.length;j++){\\n                    sum[j]+=matrix[j][m];//add left to right\\n                    if(sum[j]==target)ans++;            \\n                }\\n                for(int j = 0; j<matrix.length;j++){//up row\\n                    int summe=0;    \\n                    for(int n = j; n<matrix.length;n++){//down row\\n                        summe+=sum[n];add up to down\\n                        if(n!=j&&summe==target)ans++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941587,
                "title": "dynamic-programming-approach-with-video-explanation",
                "content": "https://www.youtube.com/watch?v=i5UoDZbQ94Q",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=i5UoDZbQ94Q",
                "codeTag": "Unknown"
            },
            {
                "id": 684948,
                "title": "c-well-commented-o-n-n-m-std-unordered-map-explanation-maximumsumsubmatrix",
                "content": "In a nutshell the approach is to choose all pairs of rows and shrink the bundle (chosen rows  alongwith rows in between them) into an array (summing up entries in each column together) and now **finding the number of subarrays in this array whose sum is equal to the target in O(M).**\\n\\nThe overall complexity becomes O(N * N * M).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //Another classical problem of finding number of subarrays having sum equal to target in the array\\n    int numSubarraySumTarget(vector<int> &arr,int target){\\n        int num_of_subarray=0;\\n        unordered_map<int,int> mp;\\n        mp.insert({0,1});\\n        int curr_sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            curr_sum+=arr[i];\\n            if(mp.find(curr_sum-target)!=mp.end()) num_of_subarray+=mp[curr_sum-target];\\n            mp[curr_sum]++;\\n        }\\n        return num_of_subarray;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();        //number of rows in the matrix\\n        if(n==0) return 0;          //If there are no rows in a matrix then there is no submatrix for any target \\n        int m=matrix[0].size();     //number of columns in the matrix\\n        \\n        int number_of_submatrices=0;\\n        \\n        \\n        //choosing two rows adding there elements of same columns and creating the array out of it / Simply shrinking the bundle of rows to a 1-D array\\n        for(int row_x1=0;row_x1<n;row_x1++){\\n            vector<int> sum_array(m,0);\\n            for(int row_x2=row_x1;row_x2<n;row_x2++){\\n                \\n                for(int i=0;i<m;i++) sum_array[i]+=matrix[row_x2][i];\\n                \\n                //Find the number of subarrays that equal to the target in this shrinked array. \\n                number_of_submatrices+=numSubarraySumTarget(sum_array,target);\\n                \\n            }\\n            \\n        }\\n        \\n        return number_of_submatrices;\\n    }\\n};\\n```\\n\\n***There is another variation of the same problem where we find the submatrix with the maximum sum.This can be done by following the first part of choosing rows and bundelling up similarly and then applying the kaden\\'s algorithm of the array in O(M).***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Another classical problem of finding number of subarrays having sum equal to target in the array\\n    int numSubarraySumTarget(vector<int> &arr,int target){\\n        int num_of_subarray=0;\\n        unordered_map<int,int> mp;\\n        mp.insert({0,1});\\n        int curr_sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            curr_sum+=arr[i];\\n            if(mp.find(curr_sum-target)!=mp.end()) num_of_subarray+=mp[curr_sum-target];\\n            mp[curr_sum]++;\\n        }\\n        return num_of_subarray;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n=matrix.size();        //number of rows in the matrix\\n        if(n==0) return 0;          //If there are no rows in a matrix then there is no submatrix for any target \\n        int m=matrix[0].size();     //number of columns in the matrix\\n        \\n        int number_of_submatrices=0;\\n        \\n        \\n        //choosing two rows adding there elements of same columns and creating the array out of it / Simply shrinking the bundle of rows to a 1-D array\\n        for(int row_x1=0;row_x1<n;row_x1++){\\n            vector<int> sum_array(m,0);\\n            for(int row_x2=row_x1;row_x2<n;row_x2++){\\n                \\n                for(int i=0;i<m;i++) sum_array[i]+=matrix[row_x2][i];\\n                \\n                //Find the number of subarrays that equal to the target in this shrinked array. \\n                number_of_submatrices+=numSubarraySumTarget(sum_array,target);\\n                \\n            }\\n            \\n        }\\n        \\n        return number_of_submatrices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542947,
                "title": "easy-to-understand-solution",
                "content": "It is actually a combination of 2 problems but slightly twisted:\\nproblem 1: Find number of sub arrays with target sum\\nproblem 2: Find largest sub matrix with target sum\\n\\nFor problem 1: I followed the same hashmap approach as listed in this leetcode problem: https://leetcode.com/problems/subarray-sum-equals-k/solution/\\nFor problem 2: here is an excellent video which you will understand in 1 go. https://www.youtube.com/watch?time_continue=173&v=yCQN096CwWM&feature=emb_logo\\n\\nNow just twist problem 2 and instead of saying find Maximum Sum Rectangular Submatrix, find all subarrays with sum equal to k.\\n\\nIf you understand problem 2 deeply then you will understand that the problem is actually very simple and not complex at all.\\n\\n***Java***\\n```\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix == null) {\\n            return 0;\\n        }\\n        int rowLen = matrix.length;\\n        int colLen = matrix[0].length;\\n        int answer = 0;\\n\\n        for(int left = 0;left < colLen;left++) {\\n            int[] tempArr = new int[rowLen];\\n            for(int right = left; right < colLen; right++) {\\n                for(int row = 0; row < rowLen; row++) {\\n                    tempArr[row] = tempArr[row] + matrix[row][right];\\n                }\\n                answer = answer + subarraySum(tempArr, target);\\n            }\\n        }\\n        return answer;\\n    }\\n\\n    public int subarraySum(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int ans = 0;\\n        int sumSoFar = 0;\\n        for(int i=0;i<arr.length ;i++) {\\n            sumSoFar = sumSoFar + arr[i];\\n            int requiredSum = sumSoFar - target;\\n            if(map.containsKey(requiredSum)) {\\n                ans = ans + map.get(requiredSum);\\n            }\\n            map.put(sumSoFar, map.get(sumSoFar) != null ? map.get(sumSoFar) + 1 : 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "It is actually a combination of 2 problems but slightly twisted:\\nproblem 1: Find number of sub arrays with target sum\\nproblem 2: Find largest sub matrix with target sum\\n\\nFor problem 1: I followed the same hashmap approach as listed in this leetcode problem: https://leetcode.com/problems/subarray-sum-equals-k/solution/\\nFor problem 2: here is an excellent video which you will understand in 1 go. https://www.youtube.com/watch?time_continue=173&v=yCQN096CwWM&feature=emb_logo\\n\\nNow just twist problem 2 and instead of saying find Maximum Sum Rectangular Submatrix, find all subarrays with sum equal to k.\\n\\nIf you understand problem 2 deeply then you will understand that the problem is actually very simple and not complex at all.\\n\\n***Java***\\n```\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix == null) {\\n            return 0;\\n        }\\n        int rowLen = matrix.length;\\n        int colLen = matrix[0].length;\\n        int answer = 0;\\n\\n        for(int left = 0;left < colLen;left++) {\\n            int[] tempArr = new int[rowLen];\\n            for(int right = left; right < colLen; right++) {\\n                for(int row = 0; row < rowLen; row++) {\\n                    tempArr[row] = tempArr[row] + matrix[row][right];\\n                }\\n                answer = answer + subarraySum(tempArr, target);\\n            }\\n        }\\n        return answer;\\n    }\\n\\n    public int subarraySum(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        int ans = 0;\\n        int sumSoFar = 0;\\n        for(int i=0;i<arr.length ;i++) {\\n            sumSoFar = sumSoFar + arr[i];\\n            int requiredSum = sumSoFar - target;\\n            if(map.containsKey(requiredSum)) {\\n                ans = ans + map.get(requiredSum);\\n            }\\n            map.put(sumSoFar, map.get(sumSoFar) != null ? map.get(sumSoFar) + 1 : 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 392399,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        row,col = len(matrix),len(matrix[0])\\n        for k in xrange(row):\\n            nums = [0 for _ in xrange(col)]\\n            for i in xrange(k,row):\\n                for j in xrange(col):\\n                    nums[j] += matrix[i][j]\\n                res += self.check(nums,target)\\n        return res\\n    \\n    def check(self,nums,target):\\n        counter,res = defaultdict(int),0\\n        counter[0],cum_sum = 1,0\\n        for i,num in enumerate(nums):\\n            cum_sum += num\\n            res += counter[cum_sum - target]\\n            counter[cum_sum] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        row,col = len(matrix),len(matrix[0])\\n        for k in xrange(row):\\n            nums = [0 for _ in xrange(col)]\\n            for i in xrange(k,row):\\n                for j in xrange(col):\\n                    nums[j] += matrix[i][j]\\n                res += self.check(nums,target)\\n        return res\\n    \\n    def check(self,nums,target):\\n        counter,res = defaultdict(int),0\\n        counter[0],cum_sum = 1,0\\n        for i,num in enumerate(nums):\\n            cum_sum += num\\n            res += counter[cum_sum - target]\\n            counter[cum_sum] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303774,
                "title": "from-o-n-4-to-o-n-3",
                "content": "O(N^4):\\n* Enumerate all (r0, r1, c0, c1) pairs. Each variable is 1 layer in a nested loop. With 4 levels of loop, complexity gets to O(N^4).\\n\\nO(N^3):\\n* Enumerate all (c0, c1) pairs. This gives O(N^2) complexity.\\n* Then, for a pair, we get a sub-slice of the matrix. We compute the prefix-sum that says (what\\'s the sum of the first `r` rows in the slice?) and convert this into \"find a subsequence that sums to a certain target\" problem. This can be solved in O(N) by storing all prefix sums into a hash table.\\n* In total, the O(N) loop is nested in the O(N^2) loop, giving O(N^3) overall.\\n\\nIn the following code, setting variable `SLOW` to true gives O(N^4). Setting it to false gives O(N^3).\\n\\n(However I was not debugging fast enough so I could not submit the solution before the end of the context X_X )\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int R = int(matrix.size()), C = int(matrix[0].size());\\n\\t\\tint the_sum = 0;\\n\\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n\\t\\t\\t\\tthe_sum += int(abs(matrix[r][c]));\\n                if (c>0) matrix[r][c] += matrix[r][c-1];\\n            }\\n        }\\n\\n\\t\\tif (target > the_sum) return 0;\\n\\t\\tif (target < -the_sum)return 0;\\n        \\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n                if (r>0) matrix[r][c] += matrix[r-1][c];\\n            }\\n        }\\n        \\n        if (0) {\\n            for (int r=0; r<R; r++) {\\n                for (int c=0; c<C; c++) {\\n                    printf(\"%d \", matrix[r][c]);\\n                }\\n                printf(\"\\\\n\");\\n            }\\n        }\\n        \\n        int ret = 0;\\n\\n\\t\\tconst bool SLOW = false;\\n\\t\\tif (SLOW) {\\n\\t\\t\\tfor (int r0=0; r0<R; r0++) {\\n\\t\\t\\t\\tfor (int c0=0; c0<C; c0++) {\\n\\t\\t\\t\\t\\tfor (int r1=r0; r1<R; r1++) {\\n\\t\\t\\t\\t\\t\\tfor (int c1=c0; c1<C; c1++) {\\n\\t\\t\\t\\t\\t\\t\\tint x = matrix[r1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0) x -= matrix[r0-1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (c0>0) x -= matrix[r1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0 && c0>0) x += matrix[r0-1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\t//printf(\"[%d,%d,%d,%d] = %d\\\\n\", r0,c0,r1,c1,x);\\n\\t\\t\\t\\t\\t\\t\\tif (x == target) {\\n\\t\\t\\t\\t\\t\\t\\t\\tret++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int c0 = 0; c0 < C; c0 ++) {\\n\\t\\t\\t\\tfor (int c1 = c0; c1 < C; c1 ++) {\\n\\t\\t\\t\\t\\tunordered_map<int, int> prefix_sums;\\n\\t\\t\\t\\t\\tfor (int r=0; r<R; r++) {\\n\\t\\t\\t\\t\\t\\tint curr = matrix[r][c1];\\n\\t\\t\\t\\t\\t\\tif (c0 > 0) curr -= matrix[r][c0-1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tint key = -(target - curr);\\n\\t\\t\\t\\t\\t\\tif (prefix_sums.find(key) != prefix_sums.end()) {\\n\\t\\t\\t\\t\\t\\t\\tret += prefix_sums[key];\\n\\t\\t\\t\\t\\t\\t}\\n//\\t\\t\\t\\t\\t\\tprintf(\"Cols[%d,%d] Rows[0,%d] sum=%d, key=%d\\\\n\", c0, c1, r, curr, key);\\n\\t\\t\\t\\t\\t\\tif (curr == target) ret ++;\\n\\n\\t\\t\\t\\t\\t\\tprefix_sums[curr] ++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return ret;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int R = int(matrix.size()), C = int(matrix[0].size());\\n\\t\\tint the_sum = 0;\\n\\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n\\t\\t\\t\\tthe_sum += int(abs(matrix[r][c]));\\n                if (c>0) matrix[r][c] += matrix[r][c-1];\\n            }\\n        }\\n\\n\\t\\tif (target > the_sum) return 0;\\n\\t\\tif (target < -the_sum)return 0;\\n        \\n        for (int r=0; r<R; r++) {\\n            for (int c=0; c<C; c++) {\\n                if (r>0) matrix[r][c] += matrix[r-1][c];\\n            }\\n        }\\n        \\n        if (0) {\\n            for (int r=0; r<R; r++) {\\n                for (int c=0; c<C; c++) {\\n                    printf(\"%d \", matrix[r][c]);\\n                }\\n                printf(\"\\\\n\");\\n            }\\n        }\\n        \\n        int ret = 0;\\n\\n\\t\\tconst bool SLOW = false;\\n\\t\\tif (SLOW) {\\n\\t\\t\\tfor (int r0=0; r0<R; r0++) {\\n\\t\\t\\t\\tfor (int c0=0; c0<C; c0++) {\\n\\t\\t\\t\\t\\tfor (int r1=r0; r1<R; r1++) {\\n\\t\\t\\t\\t\\t\\tfor (int c1=c0; c1<C; c1++) {\\n\\t\\t\\t\\t\\t\\t\\tint x = matrix[r1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0) x -= matrix[r0-1][c1];\\n\\t\\t\\t\\t\\t\\t\\tif (c0>0) x -= matrix[r1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\tif (r0>0 && c0>0) x += matrix[r0-1][c0-1];\\n\\t\\t\\t\\t\\t\\t\\t//printf(\"[%d,%d,%d,%d] = %d\\\\n\", r0,c0,r1,c1,x);\\n\\t\\t\\t\\t\\t\\t\\tif (x == target) {\\n\\t\\t\\t\\t\\t\\t\\t\\tret++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int c0 = 0; c0 < C; c0 ++) {\\n\\t\\t\\t\\tfor (int c1 = c0; c1 < C; c1 ++) {\\n\\t\\t\\t\\t\\tunordered_map<int, int> prefix_sums;\\n\\t\\t\\t\\t\\tfor (int r=0; r<R; r++) {\\n\\t\\t\\t\\t\\t\\tint curr = matrix[r][c1];\\n\\t\\t\\t\\t\\t\\tif (c0 > 0) curr -= matrix[r][c0-1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tint key = -(target - curr);\\n\\t\\t\\t\\t\\t\\tif (prefix_sums.find(key) != prefix_sums.end()) {\\n\\t\\t\\t\\t\\t\\t\\tret += prefix_sums[key];\\n\\t\\t\\t\\t\\t\\t}\\n//\\t\\t\\t\\t\\t\\tprintf(\"Cols[%d,%d] Rows[0,%d] sum=%d, key=%d\\\\n\", c0, c1, r, curr, key);\\n\\t\\t\\t\\t\\t\\tif (curr == target) ret ++;\\n\\n\\t\\t\\t\\t\\t\\tprefix_sums[curr] ++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118690,
                "title": "easy-java-solution-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        //Calculating prefix sum in all rows\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                matrix[i][j] = matrix[i][j-1] + matrix[i][j]; \\n            }\\n        }\\n\\n        //applying prefix Sum - HashMap technique\\n        for(int i=0;i<matrix.length;i++){\\n            int[] arr = new int[matrix[0].length+1];\\n            for(int j = i;j<matrix.length;j++){\\n                for(int k=0;k<matrix[0].length;k++){\\n                    arr[k+1] = arr[k+1] + matrix[j][k];\\n                }\\n                result += targetSum(arr,target);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    // method for prefix sum - HashMap techinique\\n    private int targetSum(int[] arr,int k){\\n        int result = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(map.containsKey(arr[i]-k))\\n                result += map.get(arr[i]-k);\\n                map.put(arr[i],map.getOrDefault(arr[i],0) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        //Calculating prefix sum in all rows\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                matrix[i][j] = matrix[i][j-1] + matrix[i][j]; \\n            }\\n        }\\n\\n        //applying prefix Sum - HashMap technique\\n        for(int i=0;i<matrix.length;i++){\\n            int[] arr = new int[matrix[0].length+1];\\n            for(int j = i;j<matrix.length;j++){\\n                for(int k=0;k<matrix[0].length;k++){\\n                    arr[k+1] = arr[k+1] + matrix[j][k];\\n                }\\n                result += targetSum(arr,target);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    // method for prefix sum - HashMap techinique\\n    private int targetSum(int[] arr,int k){\\n        int result = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(map.containsKey(arr[i]-k))\\n                result += map.get(arr[i]-k);\\n                map.put(arr[i],map.getOrDefault(arr[i],0) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658472,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix && Hashmap***\\n\\n* ***Time Complexity :- O(N * N * M)***\\n\\n* ***Sapce Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // this function is for finding the no. of subarray which has sum equal to target\\n    \\n    int find(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        int count = 0;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += arr[i];\\n            \\n            int need = curr_sum - target;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // arr will store the prefix sum between row [i, k]\\n            \\n            vector<int> arr(m, 0);\\n            \\n            for(int k = i; k < n; k++)\\n            {\\n                for(int j = 0; j < m; j++)\\n                {\\n                    arr[j] += matrix[k][j];\\n                }\\n                \\n                // call find function\\n                \\n                count += find(arr, target);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // this function is for finding the no. of subarray which has sum equal to target\\n    \\n    int find(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        \\n        int count = 0;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += arr[i];\\n            \\n            int need = curr_sum - target;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // arr will store the prefix sum between row [i, k]\\n            \\n            vector<int> arr(m, 0);\\n            \\n            for(int k = i; k < n; k++)\\n            {\\n                for(int j = 0; j < m; j++)\\n                {\\n                    arr[j] += matrix[k][j];\\n                }\\n                \\n                // call find function\\n                \\n                count += find(arr, target);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300781,
                "title": "c-modified-kadene-s-algorithm-o-n-n-m-m",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //number of subarrays having sum equals to k\\n    int go(vector<int> &nums, int k)\\n    {\\n        unordered_map<int,int> m;\\n        \\n        int sum=0,ans=0;\\n        \\n        m[0] = 1;\\n        \\n        for(int num:nums)\\n        {\\n            sum += num;\\n            int target = sum - k;\\n            if(m.count(target))\\n                ans += m[target];\\n            \\n            m[sum]++;\\n        }\\n        return ans;\\n    } \\n    //----------------------------------------------------------------\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        int res = 0;\\n       \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp(m,0);         \\n            for(int j=i; j<n; j++)\\n            {\\n                for(int k=0; k<m; k++)\\n                    temp[k] += matrix[j][k];\\n                \\n                //all sub-matrices between row i and j.\\n                res += go(temp, target);\\n            }       \\n        }\\n        return res;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //number of subarrays having sum equals to k\\n    int go(vector<int> &nums, int k)\\n    {\\n        unordered_map<int,int> m;\\n        \\n        int sum=0,ans=0;\\n        \\n        m[0] = 1;\\n        \\n        for(int num:nums)\\n        {\\n            sum += num;\\n            int target = sum - k;\\n            if(m.count(target))\\n                ans += m[target];\\n            \\n            m[sum]++;\\n        }\\n        return ans;\\n    } \\n    //----------------------------------------------------------------\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        int res = 0;\\n       \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp(m,0);         \\n            for(int j=i; j<n; j++)\\n            {\\n                for(int k=0; k<m; k++)\\n                    temp[k] += matrix[j][k];\\n                \\n                //all sub-matrices between row i and j.\\n                res += go(temp, target);\\n            }       \\n        }\\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300652,
                "title": "similar-to-subarray-with-target-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int ro=matrix.size(),co=matrix[0].size();\\n        \\n        if(ro<1)\\n            return 0;\\n        //prefix sum \\n        for(int r=0;r<ro;r++)\\n            for(int c=1;c<co;c++)\\n                matrix[r][c]+=matrix[r][c-1];\\n        \\n        int count=0;\\n        for(int c1=0;c1<co;c1++)\\n        for(int c2=c1;c2<co;c2++)\\n        {\\n            //appling \"subarray with sum k\" between the c1 and c2 || no of element is no of rows  \\n            unordered_map<int,int>mp;\\n            int sum=0;\\n            mp[0]=1;\\n            for(int r=0;r<ro;r++)\\n            {\\n                sum+=matrix[r][c2]-(c1>0?matrix[r][c1-1]:0);// sum of row between c1 and c2;\\n                    int find=sum-target;          \\n                if(mp.find(find)!=mp.end())\\n                    count+=mp[find];\\n                mp[sum]++;\\n            }\\n        }\\n        return count++;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int ro=matrix.size(),co=matrix[0].size();\\n        \\n        if(ro<1)\\n            return 0;\\n        //prefix sum \\n        for(int r=0;r<ro;r++)\\n            for(int c=1;c<co;c++)\\n                matrix[r][c]+=matrix[r][c-1];\\n        \\n        int count=0;\\n        for(int c1=0;c1<co;c1++)\\n        for(int c2=c1;c2<co;c2++)\\n        {\\n            //appling \"subarray with sum k\" between the c1 and c2 || no of element is no of rows  \\n            unordered_map<int,int>mp;\\n            int sum=0;\\n            mp[0]=1;\\n            for(int r=0;r<ro;r++)\\n            {\\n                sum+=matrix[r][c2]-(c1>0?matrix[r][c1-1]:0);// sum of row between c1 and c2;\\n                    int find=sum-target;          \\n                if(mp.find(find)!=mp.end())\\n                    count+=mp[find];\\n                mp[sum]++;\\n            }\\n        }\\n        return count++;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300306,
                "title": "c-detailed-explained-solution-with-workflow",
                "content": "Steps involved here:\\n1. We will create a prefixSum Array - (Loops1 in diagram)\\n2. We use LoopA to leave behind the checked columns. Each iteration the matrix which we will check will decrease by 1 column.\\nthis line will take care of that - ![image](https://assets.leetcode.com/users/images/07475203-3d6c-43b7-b4da-ffbdeda1a584_1658163863.0686345.png)\\n\\n![image](https://assets.leetcode.com/users/images/53c6a404-38e4-40ba-b7bd-b30868469365_1658162903.8814688.png)\\n\\n3. LoopB to check all the posisble sums in the active sub matrix\\n![image](https://assets.leetcode.com/users/images/b6edd7c7-c86f-4fd1-a1c2-56e56ce550f8_1658163012.0017807.png)\\n\\n\\n4. Loop C to iterate over each row and find the number of sums we can get.\\n![image](https://assets.leetcode.com/users/images/9081460c-72b8-4f73-84b4-b2241ed3403a_1658163139.1419709.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/9c52cb1c-da8b-4380-b22e-bdcd4bbc77c3_1658162353.179597.png)\\n\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        for(int i=0; i< matrix.Length; i++){\\n            for(int j=1; j< matrix[0].Length; j++){\\n                matrix[i][j] += matrix[i][j-1]; \\n            }\\n        }\\n        int counter = 0;\\n        //this loop will remove previous column by 1 so that remaining columns will be checked\\n        for(int col1=0; col1 < matrix[0].Length; col1++){\\n            //this loop will be used to check the column starting from above and ending till end\\n            for(int col2=col1; col2< matrix[0].Length; col2++){\\n                Dictionary<int,int> records = new Dictionary<int,int>();\\n                records[0] = 1;\\n                int sum = 0;\\n                for(int row=0; row < matrix.Length; row++){\\n                    sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);\\n                    int prefixSum = sum - target;\\n                    if(records.ContainsKey(prefixSum)){\\n                        counter += records[prefixSum];\\n                    }\\n                    if(records.ContainsKey(sum))\\n                        records[sum] += 1;\\n                    else\\n                    records[sum] = 1;\\n                    \\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        for(int i=0; i< matrix.Length; i++){\\n            for(int j=1; j< matrix[0].Length; j++){\\n                matrix[i][j] += matrix[i][j-1]; \\n            }\\n        }\\n        int counter = 0;\\n        //this loop will remove previous column by 1 so that remaining columns will be checked\\n        for(int col1=0; col1 < matrix[0].Length; col1++){\\n            //this loop will be used to check the column starting from above and ending till end\\n            for(int col2=col1; col2< matrix[0].Length; col2++){\\n                Dictionary<int,int> records = new Dictionary<int,int>();\\n                records[0] = 1;\\n                int sum = 0;\\n                for(int row=0; row < matrix.Length; row++){\\n                    sum += matrix[row][col2] - (col1 > 0 ? matrix[row][col1-1] : 0);\\n                    int prefixSum = sum - target;\\n                    if(records.ContainsKey(prefixSum)){\\n                        counter += records[prefixSum];\\n                    }\\n                    if(records.ContainsKey(sum))\\n                        records[sum] += 1;\\n                    else\\n                    records[sum] = 1;\\n                    \\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299842,
                "title": "prefix-sum-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n   int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];  // prefix sum of matrix row wise \\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0; \\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int numSubmatrixSumTarget(vector<vector<int>>& A, int target) {\\n        int res = 0, m = A.size(), n = A[0].size();\\n        for (int i = 0; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                A[i][j] += A[i][j - 1];  // prefix sum of matrix row wise \\n\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                counter = {{0,1}};\\n                int cur = 0;\\n                for (int k = 0; k < m; k++) {\\n                    cur += A[k][j] - (i > 0 ? A[k][i - 1] : 0);\\n                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : 0; \\n                    counter[cur]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299771,
                "title": "python-using-range-sum-query-2d-o-m-2n-m-n-faster-99",
                "content": "Similar to [LC 304: Range Sum Query 2D| Approach 4](https://leetcode.com/problems/range-sum-query-2d-immutable/), create a 2D cache : dp such that  dp(row,col) is the sum of the subarray (0,0) to (row,col)\\n\\nNow, applying logic similar to [LC 560: Subarray sum equals k](https://leetcode.com/problems/subarray-sum-equals-k/) we need to create a hashmap but since this is in 2D, we fix the row limits row1 and row2. Then iterate through the columns calculating the presum of the subarray up till that column for the fixed (row1, row2), simultaneuously increasing the hashmap value by 1.\\nFor a given presum, if presum-target exists in the hash, we increase the ans count by the value of hash[presum-target]\\n\\nNote: We don\\'t increment the presum variable and instead assign it directly since our 2d dp already accounts for the prefix sum up until that point! \\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        if len(matrix)>len(matrix[0]):\\n            new=[[0]*len(matrix) for i in range(len(matrix[0]))]\\n            for i in range(len(matrix)):\\n                for j in range(len(matrix[0])):\\n                    new[j][i]=matrix[i][j]\\n            return self.numSubmatrixSumTarget(new,target)\\n\\n\\n        self.dp=[[0]*(len(matrix[0])+1)for i in range(len(matrix)+1)]\\n        for i in range(1,len(matrix)+1):\\n            for j in range(1,len(matrix[0])+1):\\n                self.dp[i][j]=self.dp[i][j-1]+self.dp[i-1][j]-self.dp[i-1][j-1]+matrix[i-1][j-1]\\n        \\n        ans=0\\n        for row1 in range(len(matrix)):\\n            for row2 in range(row1,len(matrix)):\\n                pres=0\\n                myhash={0:1}\\n                for col1 in range(len(matrix[0])):\\n                        presum=self.dp[row2+1][col1+1]-self.dp[row1][col1+1]\\n                        if presum-target in myhash:\\n                            ans+=myhash[pres-target]\\n                        myhash[pres]=myhash.get(pres,0)+1\\n                        \\n        return(ans)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        \\n        if len(matrix)>len(matrix[0]):\\n            new=[[0]*len(matrix) for i in range(len(matrix[0]))]\\n            for i in range(len(matrix)):\\n                for j in range(len(matrix[0])):\\n                    new[j][i]=matrix[i][j]\\n            return self.numSubmatrixSumTarget(new,target)\\n\\n\\n        self.dp=[[0]*(len(matrix[0])+1)for i in range(len(matrix)+1)]\\n        for i in range(1,len(matrix)+1):\\n            for j in range(1,len(matrix[0])+1):\\n                self.dp[i][j]=self.dp[i][j-1]+self.dp[i-1][j]-self.dp[i-1][j-1]+matrix[i-1][j-1]\\n        \\n        ans=0\\n        for row1 in range(len(matrix)):\\n            for row2 in range(row1,len(matrix)):\\n                pres=0\\n                myhash={0:1}\\n                for col1 in range(len(matrix[0])):\\n                        presum=self.dp[row2+1][col1+1]-self.dp[row1][col1+1]\\n                        if presum-target in myhash:\\n                            ans+=myhash[pres-target]\\n                        myhash[pres]=myhash.get(pres,0)+1\\n                        \\n        return(ans)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298801,
                "title": "least-runtime-solution",
                "content": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        answer = 0\\n        \\n        for i in range(n):\\n            for j in range(1, m):\\n                matrix[i][j] += matrix[i][j - 1]\\n                \\n        for j in range(m):\\n            for k in range(j, m):\\n                d, c = {0: 1}, 0\\n                for i in range(n):\\n                    c += matrix[i][k] - (matrix[i][j - 1] if j else 0)\\n                    if c - target in d:\\n                        answer += d[c - target]\\n                    d[c] = d[c] + 1 if c in d else 1  \\n        return answer\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        answer = 0\\n        \\n        for i in range(n):\\n            for j in range(1, m):\\n                matrix[i][j] += matrix[i][j - 1]\\n                \\n        for j in range(m):\\n            for k in range(j, m):\\n                d, c = {0: 1}, 0\\n                for i in range(n):\\n                    c += matrix[i][k] - (matrix[i][j - 1] if j else 0)\\n                    if c - target in d:\\n                        answer += d[c - target]\\n                    d[c] = d[c] + 1 if c in d else 1  \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297508,
                "title": "javascript-prefix-sum-solution",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {number}\\n */\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    var sumMatrix = [],sum,hash={},counterPart,ans=0,prefixSum=0;\\n    //Do rowwise sum\\n    for(let i=0;i<matrix.length;i++){\\n        sum=0;\\n        for(let j=0;j<matrix[i].length;j++){\\n            sum+=matrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    \\n    //Do columnwise sum\\n    for(let j=0;j<matrix[0].length;j++){\\n        sum=0;\\n        for(let i=0;i<matrix.length;i++){\\n            sum+=sumMatrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    //Check all submatrices one by one \\n    for(let i1=0;i1<sumMatrix.length;i1++){\\n        for(let i2=i1;i2<sumMatrix.length;i2++){\\n            hash={};\\n            hash[0]=1;\\n            for(let j=0;j<sumMatrix[i1].length;j++){\\n                if(i1>0){\\n                    prefixSum = sumMatrix[i2][j]-sumMatrix[i1-1][j];\\n                }else{\\n                    prefixSum = sumMatrix[i2][j];\\n                }\\n                counterPart = prefixSum-target;\\n                if(hash[counterPart]!==undefined){\\n                    ans+=hash[counterPart];\\n                }\\n                if(hash[prefixSum]===undefined){\\n                    hash[prefixSum]=1\\n                }else{\\n                    hash[prefixSum]++;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {number}\\n */\\nvar numSubmatrixSumTarget = function(matrix, target) {\\n    var sumMatrix = [],sum,hash={},counterPart,ans=0,prefixSum=0;\\n    //Do rowwise sum\\n    for(let i=0;i<matrix.length;i++){\\n        sum=0;\\n        for(let j=0;j<matrix[i].length;j++){\\n            sum+=matrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    \\n    //Do columnwise sum\\n    for(let j=0;j<matrix[0].length;j++){\\n        sum=0;\\n        for(let i=0;i<matrix.length;i++){\\n            sum+=sumMatrix[i][j];\\n            if(sumMatrix[i]===undefined){\\n                sumMatrix[i]=[];\\n            }\\n            sumMatrix[i][j]=sum;\\n        }\\n    }\\n    //Check all submatrices one by one \\n    for(let i1=0;i1<sumMatrix.length;i1++){\\n        for(let i2=i1;i2<sumMatrix.length;i2++){\\n            hash={};\\n            hash[0]=1;\\n            for(let j=0;j<sumMatrix[i1].length;j++){\\n                if(i1>0){\\n                    prefixSum = sumMatrix[i2][j]-sumMatrix[i1-1][j];\\n                }else{\\n                    prefixSum = sumMatrix[i2][j];\\n                }\\n                counterPart = prefixSum-target;\\n                if(hash[counterPart]!==undefined){\\n                    ans+=hash[counterPart];\\n                }\\n                if(hash[prefixSum]===undefined){\\n                    hash[prefixSum]=1\\n                }else{\\n                    hash[prefixSum]++;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297345,
                "title": "using-subarray-sum-build-through-matrix-easy-way-o-n-3",
                "content": "```\\n int kadene(vector<int>&nums,int target){\\n       unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:nums)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int ans=0;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int>res=matrix[i];\\n             ans+=kadene(res,target);\\n            for(int j=i+1;j<matrix.size();j++){\\n                for(int k=0;k<matrix[0].size();k++){\\n                     res[k]+=matrix[j][k];\\n                }\\n                   ans+=kadene(res,target);\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int kadene(vector<int>&nums,int target){\\n       unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:nums)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int ans=0;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int>res=matrix[i];\\n             ans+=kadene(res,target);\\n            for(int j=i+1;j<matrix.size();j++){\\n                for(int k=0;k<matrix[0].size();k++){\\n                     res[k]+=matrix[j][k];\\n                }\\n                   ans+=kadene(res,target);\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297272,
                "title": "daily-leetcoding-challenge-july-day-18",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Number of Subarrays that Sum to Target: Horizontal 1D Prefix Sum \n\n  \n**Approach 2:** Number of Subarrays that Sum to Target: Vertical 1D Prefix Sum \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2185624,
                "title": "c-code",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int solveIn1D(vector<int>&colSum,int target)\\n    {\\n        unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:colSum)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n        \\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           vector<int>colSum(m,0);\\n            for(int k=i;k<n;k++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                     colSum[j]+=matrix[k][j];\\n                }\\n                ans+=solveIn1D(colSum, target);\\n               \\n            }\\n                \\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solveIn1D(vector<int>&colSum,int target)\\n    {\\n        unordered_map<int,int>mp;\\n         mp[0]=1;\\n        int sum=0,count=0;\\n        for(auto c:colSum)\\n        {\\n            sum+=c;\\n            count+=mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return count;\\n        \\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(),m=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           vector<int>colSum(m,0);\\n            for(int k=i;k<n;k++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                     colSum[j]+=matrix[k][j];\\n                }\\n                ans+=solveIn1D(colSum, target);\\n               \\n            }\\n                \\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118388,
                "title": "python-sol-easy-explained-very-simple-commented",
                "content": "\\n# EXPLANATION\\n```\\nThe problem can be solved by using the following idea\\n\\nWe take two boundary for the column and add all the elements for each row within the column .\\nNow our 2D matrix is changed to a single array in which we need to find the subarray having sum = target\\n\\nWe use prefixsum so we dont need to do the sum again and again\\n```\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # find the rows and columns of the matrix\\n        n,m = len(matrix) , len(matrix[0])\\n        # find the prefix sum for each row\\n        for i in range(n):\\n            for j in range(1,m):\\n                matrix[i][j] += matrix[i][j-1]\\n        ans = 0\\n        # fix the left boundary of the column\\n        for start in range(m):\\n            # fix the right boundary of the column\\n            for end in range(start,m):\\n                # a dictionary to map data\\n                d = defaultdict(lambda:0)\\n                d[0] = 1\\n                summ = 0\\n                # now we do check at each row\\n                for i in range(n):\\n                    curr = matrix[i][end]\\n                    if start > 0: curr -= matrix[i][start-1]\\n                    summ += curr\\n                    ans += d[summ - target]\\n                    d[summ] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nThe problem can be solved by using the following idea\\n\\nWe take two boundary for the column and add all the elements for each row within the column .\\nNow our 2D matrix is changed to a single array in which we need to find the subarray having sum = target\\n\\nWe use prefixsum so we dont need to do the sum again and again\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # find the rows and columns of the matrix\\n        n,m = len(matrix) , len(matrix[0])\\n        # find the prefix sum for each row\\n        for i in range(n):\\n            for j in range(1,m):\\n                matrix[i][j] += matrix[i][j-1]\\n        ans = 0\\n        # fix the left boundary of the column\\n        for start in range(m):\\n            # fix the right boundary of the column\\n            for end in range(start,m):\\n                # a dictionary to map data\\n                d = defaultdict(lambda:0)\\n                d[0] = 1\\n                summ = 0\\n                # now we do check at each row\\n                for i in range(n):\\n                    curr = matrix[i][end]\\n                    if start > 0: curr -= matrix[i][start-1]\\n                    summ += curr\\n                    ans += d[summ - target]\\n                    d[summ] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271854,
                "title": "c-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/85f0b8b6-ab82-472b-ae76-2db6bf01f1e1_1623670028.9009478.jpeg)\\n\\nclass Solution {\\npublic:\\n\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int k) {\\n        // same logic as count subarray with sum k HASHING\\n        \\n        int row = A.size();\\n        int col = A[0].size();\\n        \\n\\t\\t//Calculating Prefix Sum of Columns\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n                A[i][j]+=A[i][j-1]; \\n        }\\n        \\n        int count = 0;\\n        \\n        for(int c1=0;c1<col;c1++)\\n        {\\n            for(int c2=c1;c2<col;c2++)\\n            {\\n                unordered_map<int,int>mp;\\n                int sum=0;\\n                mp[sum]=1;\\n                \\n                for(int r=0;r<row;r++)\\n                {\\n                    sum +=A[r][c2] - (c1>0 ? A[r][c1-1] : 0);\\n                    \\n                    if(mp.find(sum-k)!=mp.end())\\n                        count+=mp[sum-k];\\n                    \\n                    mp[sum]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int k) {\\n        // same logic as count subarray with sum k HASHING\\n        \\n        int row = A.size();\\n        int col = A[0].size();\\n        \\n\\t\\t//Calculating Prefix Sum of Columns\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n                A[i][j]+=A[i][j-1]; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1170050,
                "title": "using-map-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=1;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmatrix[i][j]+=matrix[i][j-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmap<int,int>mp;\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmp.clear();\\n\\t\\t\\t\\t\\tmp[0]=1;\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\tfor(int k=0;k<n;k++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsum+=matrix[k][j]-(i>0 ?matrix[k][i-1]:0);\\n\\t\\t\\t\\t\\t\\tif(mp.find(sum-target)!=mp.end())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcount+=mp[sum-target];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmp[sum]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=1;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmatrix[i][j]+=matrix[i][j-1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1162790,
                "title": "ruby-dp",
                "content": "```\\n# @param {Integer[][]} matrix\\n# @param {Integer} target\\n# @return {Integer}\\ndef num_submatrix_sum_target(matrix, target)\\n  m, n = matrix.count, matrix[0].count\\n  m.times{|x| (n-1).times{|y| matrix[x][y+1] += matrix[x][y]}}\\n\\n  result = 0\\n  \\n  n.times do |y1|\\n    (y1...n).each do |y2|\\n      h = {0 => 1}\\n      s = 0\\n\\n      m.times do |x|\\n        s += matrix[x][y2] - (y1 > 0 ? matrix[x][y1-1] : 0)\\n        result += h[s - target] || 0\\n        h[s] = (h[s] || 0) + 1\\n      end\\n    end\\n  end\\n  \\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```\\n# @param {Integer[][]} matrix\\n# @param {Integer} target\\n# @return {Integer}\\ndef num_submatrix_sum_target(matrix, target)\\n  m, n = matrix.count, matrix[0].count\\n  m.times{|x| (n-1).times{|y| matrix[x][y+1] += matrix[x][y]}}\\n\\n  result = 0\\n  \\n  n.times do |y1|\\n    (y1...n).each do |y2|\\n      h = {0 => 1}\\n      s = 0\\n\\n      m.times do |x|\\n        s += matrix[x][y2] - (y1 > 0 ? matrix[x][y1-1] : 0)\\n        result += h[s - target] || 0\\n        h[s] = (h[s] || 0) + 1\\n      end\\n    end\\n  end\\n  \\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1162625,
                "title": "hashmap-implementation-c-break-down",
                "content": "->Calculate the prefix sum of each element of a row\\n->picking every pair. of column accumulate the row sum to it\\n-> now the question is been break down to finding the number of subarrays with a target sum.\\n\\t\\n\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n\\t\\t//calculate the prefix sum of each row\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        unordered_map<int,int> mp;   //to store a already seen sum (its frequency)\\n        \\n        for(int j=0; j<m; j++){ // starting column index\\n            for(int k=j; k<m; k++){  // ending column index \\n                mp.clear();  //clear the map to wipe out previous data\\n                mp = {{0,1}}; //initialize the map\\n                \\n                int curr = 0;\\n                \\n                for(int i=0; i<n; i++){\\n                    curr += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);  // subtact the prefix sum of a[left-1] from a[rught] to find the sum from left to right.\\n                    \\n                    ans += mp.find(curr - target) != mp.end() ? mp[curr - target] : 0; \\n                    \\n                    mp[curr]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "->Calculate the prefix sum of each element of a row\\n->picking every pair. of column accumulate the row sum to it\\n-> now the question is been break down to finding the number of subarrays with a target sum.\\n\\t\\n\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n\\t\\t//calculate the prefix sum of each row\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int ans = 0;\\n        unordered_map<int,int> mp;   //to store a already seen sum (its frequency)\\n        \\n        for(int j=0; j<m; j++){ // starting column index\\n            for(int k=j; k<m; k++){  // ending column index \\n                mp.clear();  //clear the map to wipe out previous data\\n                mp = {{0,1}}; //initialize the map\\n                \\n                int curr = 0;\\n                \\n                for(int i=0; i<n; i++){\\n                    curr += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);  // subtact the prefix sum of a[left-1] from a[rught] to find the sum from left to right.\\n                    \\n                    ans += mp.find(curr - target) != mp.end() ? mp[curr - target] : 0; \\n                    \\n                    mp[curr]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1162570,
                "title": "java-clean-solution-o-r2-c-compexity",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int [] dp = new int [matrix[0].length];\\n        int res = 0;\\n        for(int i = 0;i <matrix.length;i++){\\n            for(int j =i; j < matrix.length;j++){\\n                count.put(0, 1);\\n                res += numSubmatrixSumTarget(i, j, matrix, target, count, dp);\\n                count.clear();\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int numSubmatrixSumTarget(int first, int second, int [][] matrix, int target, HashMap<Integer, Integer> count, int [] dp){\\n        int res = 0;\\n        int sum = 0;\\n        for(int i  = 0;i<matrix[first].length;i++){\\n            sum += matrix[second][i];\\n            dp[i] = sum+ (first == second?0:dp[i]);\\n            res += count.getOrDefault(dp[i] - target, 0);\\n            count.put(dp[i], count.getOrDefault(dp[i], 0)+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int [] dp = new int [matrix[0].length];\\n        int res = 0;\\n        for(int i = 0;i <matrix.length;i++){\\n            for(int j =i; j < matrix.length;j++){\\n                count.put(0, 1);\\n                res += numSubmatrixSumTarget(i, j, matrix, target, count, dp);\\n                count.clear();\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int numSubmatrixSumTarget(int first, int second, int [][] matrix, int target, HashMap<Integer, Integer> count, int [] dp){\\n        int res = 0;\\n        int sum = 0;\\n        for(int i  = 0;i<matrix[first].length;i++){\\n            sum += matrix[second][i];\\n            dp[i] = sum+ (first == second?0:dp[i]);\\n            res += count.getOrDefault(dp[i] - target, 0);\\n            count.put(dp[i], count.getOrDefault(dp[i], 0)+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162515,
                "title": "easy-c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\n   public:\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int\\n   target) {\\n      int ans = 0;\\n      int col = matrix[0].size();\\n      int row = matrix.size();\\n      for(int i = 0; i < row; i++){\\n         for(int j = 1; j < col; j++){\\n            matrix[i][j] += matrix[i][j - 1];\\n         }\\n      }\\n      unordered_map <int, int> m;\\n      for(int i = 0; i < col; i++){\\n         for(int j = i; j < col; j++){\\n            m.clear();\\n            m[0] = 1;\\n            int sum = 0;\\n            for(int k = 0; k < row; k++){\\n               int current = matrix[k][j];\\n               if(i - 1 >= 0)current -= matrix[k][i - 1];\\n               sum += current;\\n               ans += m[target - sum];\\n               m[-sum]++;\\n            }\\n         }\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int\\n   target) {\\n      int ans = 0;\\n      int col = matrix[0].size();\\n      int row = matrix.size();\\n      for(int i = 0; i < row; i++){\\n         for(int j = 1; j < col; j++){\\n            matrix[i][j] += matrix[i][j - 1];\\n         }\\n      }\\n      unordered_map <int, int> m;\\n      for(int i = 0; i < col; i++){\\n         for(int j = i; j < col; j++){\\n            m.clear();\\n            m[0] = 1;\\n            int sum = 0;\\n            for(int k = 0; k < row; k++){\\n               int current = matrix[k][j];\\n               if(i - 1 >= 0)current -= matrix[k][i - 1];\\n               sum += current;\\n               ans += m[target - sum];\\n               m[-sum]++;\\n            }\\n         }\\n      }\\n      return ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131751,
                "title": "same-as-target-sum-for-1d",
                "content": "```python\\ndef findSubarray(nums, target):\\n    counts, cur, ans = {0: 1}, 0, 0\\n    for n in nums:\\n        cur += n\\n        need = cur - target\\n        if need in counts:\\n            ans += counts[need]\\n        counts[cur] = counts.get(cur, 0) + 1\\n    return ans\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        M, N, total = len(matrix), len(matrix[0]), 0\\n        for r in range(N):\\n            columns = [0] * M\\n            for j in range(r, N):\\n                for i in range(M):\\n                    columns[i] += matrix[i][j]\\n                total += findSubarray(columns, target)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```python\\ndef findSubarray(nums, target):\\n    counts, cur, ans = {0: 1}, 0, 0\\n    for n in nums:\\n        cur += n\\n        need = cur - target\\n        if need in counts:\\n            ans += counts[need]\\n        counts[cur] = counts.get(cur, 0) + 1\\n    return ans\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        M, N, total = len(matrix), len(matrix[0]), 0\\n        for r in range(N):\\n            columns = [0] * M\\n            for j in range(r, N):\\n                for i in range(M):\\n                    columns[i] += matrix[i][j]\\n                total += findSubarray(columns, target)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014774,
                "title": "c-36ms-9-1mb-beat-100-both-in-time-space",
                "content": "The whole idea is to calculate the sum of the row prefix and the sum of the column prefix(using row prefix), the submatrix can be described by row & column prefix.\\nYeah, I defined a special version of hashtable(linear probe) instead of using `unordered_map` in STL.\\nDO NOT USE `vector` OR `unordered_map` which may causing TLE (STL in Leetcode is not stable).\\n```\\n#define HT_LENGTH 256\\n\\nstruct HashTable {\\n    int keys[HT_LENGTH];\\n    int vals[HT_LENGTH];\\n    \\n    HashTable() { this->clear();}\\n    \\n    void clear() {\\n        keys[0] = 0; vals[0] = 1;\\n        for (int i = 1;i < HT_LENGTH;i++) keys[i] = -1;\\n    }\\n    \\n    int find(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1)  return 0;\\n            if (keys[ikey] == key) return vals[ikey];\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n        return false;\\n    }\\n    \\n    void inc(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1) {\\n                keys[ikey] = key;\\n                vals[ikey] = 1;\\n                return;\\n            }\\n            if (keys[ikey] == key) {\\n                vals[ikey]++;\\n                return;\\n            }\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    HashTable ht;\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rprefix[100][101];\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ret = 0;\\n        for (int i = 0;i < m;i++) {\\n            rprefix[i][0] = 0;\\n            for (int j = 1;j <= n;j ++) {\\n                rprefix[i][j] = rprefix[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1;i <= n;i++) {\\n            for (int j = i;j <= n;j++) {\\n                ht.clear();\\n                int cprefix = 0;\\n                for (int row = 0;row < m;row++) {\\n                    cprefix += rprefix[row][j] - rprefix[row][i - 1];\\n                    ret += ht.find(cprefix - target);\\n                    ht.inc(cprefix);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define HT_LENGTH 256\\n\\nstruct HashTable {\\n    int keys[HT_LENGTH];\\n    int vals[HT_LENGTH];\\n    \\n    HashTable() { this->clear();}\\n    \\n    void clear() {\\n        keys[0] = 0; vals[0] = 1;\\n        for (int i = 1;i < HT_LENGTH;i++) keys[i] = -1;\\n    }\\n    \\n    int find(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1)  return 0;\\n            if (keys[ikey] == key) return vals[ikey];\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n        return false;\\n    }\\n    \\n    void inc(int key) {\\n        uint32_t ikey = (uint32_t)key % HT_LENGTH;\\n        for (int i = 0;i < HT_LENGTH;i++) {\\n            if (keys[ikey] == -1) {\\n                keys[ikey] = key;\\n                vals[ikey] = 1;\\n                return;\\n            }\\n            if (keys[ikey] == key) {\\n                vals[ikey]++;\\n                return;\\n            }\\n            ikey = ++ikey == HT_LENGTH ? 0 : ikey;\\n        }\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    HashTable ht;\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rprefix[100][101];\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ret = 0;\\n        for (int i = 0;i < m;i++) {\\n            rprefix[i][0] = 0;\\n            for (int j = 1;j <= n;j ++) {\\n                rprefix[i][j] = rprefix[i][j - 1] + matrix[i][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1;i <= n;i++) {\\n            for (int j = i;j <= n;j++) {\\n                ht.clear();\\n                int cprefix = 0;\\n                for (int row = 0;row < m;row++) {\\n                    cprefix += rprefix[row][j] - rprefix[row][i - 1];\\n                    ret += ht.find(cprefix - target);\\n                    ht.inc(cprefix);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960894,
                "title": "c-prefix-sums-subarray-sums",
                "content": "```\\npublic class Solution\\n{\\n  public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n  {\\n    var ans = 0;\\n    var pre = new int[matrix.Length + 1, matrix[0].Length];\\n\\n    // prefix sums for cols\\n    for (var i = 0; i < matrix.Length; i++)\\n      for (var j = 0; j < matrix[0].Length; j++)\\n        pre[i + 1, j] = pre[i, j] + matrix[i][j];\\n\\n    // subarray sums equal to target\\n    // where array equals to prefix sums\\n    for (var r1 = 0; r1 < matrix.Length; r1++)\\n    {\\n      for (var r2 = r1; r2 < matrix.Length; r2++)\\n      {\\n        var curr = 0;\\n        var dict = new Dictionary<int, int>();\\n\\n        for (var j = 0; j < matrix[0].Length; j++)\\n        {\\n          var el = pre[r2 + 1, j] - pre[r1, j];\\n          curr += el;\\n\\n          if (curr == target)\\n            ans++;\\n\\n          if (dict.ContainsKey(curr - target))\\n            ans += dict[curr - target];\\n\\n          dict[curr] = dict.ContainsKey(curr)\\n            ? dict[curr] + 1\\n            : 1;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n  {\\n    var ans = 0;\\n    var pre = new int[matrix.Length + 1, matrix[0].Length];\\n\\n    // prefix sums for cols\\n    for (var i = 0; i < matrix.Length; i++)\\n      for (var j = 0; j < matrix[0].Length; j++)\\n        pre[i + 1, j] = pre[i, j] + matrix[i][j];\\n\\n    // subarray sums equal to target\\n    // where array equals to prefix sums\\n    for (var r1 = 0; r1 < matrix.Length; r1++)\\n    {\\n      for (var r2 = r1; r2 < matrix.Length; r2++)\\n      {\\n        var curr = 0;\\n        var dict = new Dictionary<int, int>();\\n\\n        for (var j = 0; j < matrix[0].Length; j++)\\n        {\\n          var el = pre[r2 + 1, j] - pre[r1, j];\\n          curr += el;\\n\\n          if (curr == target)\\n            ans++;\\n\\n          if (dict.ContainsKey(curr - target))\\n            ans += dict[curr - target];\\n\\n          dict[curr] = dict.ContainsKey(curr)\\n            ? dict[curr] + 1\\n            : 1;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888457,
                "title": "c-n-4-and-n-3",
                "content": "```O(n^4)```\\n```\\n    int numSubmatrixSumTarget(vector<vector<int>>& arr, int target) {\\n         int R = arr.size(); if (R == 0) return 0; int C = arr[0].size();    \\n         vector<vector<int>> sum(R + 1, vector<int> (C + 1, 0));\\n        \\n        for (int r = 1; r <= R; r ++) {\\n            for (int c = 1; c <= C; c ++) {\\n                sum[r][c] = arr[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for (int r = 1; r <= R; r ++) {\\n            for (int c = 1; c <= C; c ++) {\\n                int cnt = 0;\\n                for (int r1 = 1; r1 <= r; r1 ++) {\\n                    for (int c1 = 1; c1 <= c; c1 ++) {\\n                        int arrsum = sum[r][c] - sum[r1 - 1][c] - sum[r][c1 - 1] + sum[r1 - 1][c1 - 1];\\n                        if (arrsum == target) {\\n                            cnt ++;\\n                        }       \\n                    }\\n                }\\n                count += cnt;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\n\\t// O(N^3)\\n\\tint numSubmatrixSumTarget(vector<vector<int>>& arr, int target) {\\n         int R = arr.size(); if (R == 0) return 0; int C = arr[0].size();    \\n         vector<vector<int>> sum(R + 1, vector<int> (C + 1, 0));\\n        \\n        for (int r = 1; r <= R; r ++) {\\n            for (int c = 1; c <= C; c ++) {\\n                sum[r][c] = arr[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        map<pair<int, int>, int> m; // {col, sum} -> frequency\\n        for (int c = 0; c <= C; c ++) m[{c, 0}] ++;        \\n        \\n            for (int c = 1; c <= C; c ++) {\\n                for (int c1 = 1; c1 <= c; c1 ++) {\\n                    for (int r = 1; r <= R; r ++) { // you beauty! for each row for each c and c1 < c\\n\\t\\t\\t\\t\\t\\tint sum1 = sum[r][c] - sum[r][c1 - 1];\\n\\t\\t\\t\\t\\t\\tcount += m[{c, sum1 - target}];\\n\\t\\t\\t\\t\\t\\tm[{c, sum1}] ++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        return count;\\n    }\\n",
                "solutionTags": [],
                "code": "```O(n^4)```",
                "codeTag": "Unknown"
            },
            {
                "id": 718255,
                "title": "java-prefix-sum-hashmap",
                "content": "```\\n    public int numSubmatrixSumTarget(int[][] mx, int t) {\\n        int res = 0, m = mx.length, n = mx[0].length;\\n        for (int i = 0;i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                mx[i][j] += mx[i][j - 1];\\n            }\\n        }\\n        for (int l = 0; l < n; l++) {\\n            for (int r = l; r < n; r++) {\\n                Map<Integer, Integer> map = new HashMap<>(); \\n                map.put(0, 1);// init empty sub mx;\\n                for (int i = 0, sum = 0; i < m; i++) {\\n                    sum += (mx[i][r] - (l == 0 ? 0 : mx[i][l - 1]));\\n                    res += map.getOrDefault(sum - t, 0);\\n                    map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numSubmatrixSumTarget(int[][] mx, int t) {\\n        int res = 0, m = mx.length, n = mx[0].length;\\n        for (int i = 0;i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                mx[i][j] += mx[i][j - 1];\\n            }\\n        }\\n        for (int l = 0; l < n; l++) {\\n            for (int r = l; r < n; r++) {\\n                Map<Integer, Integer> map = new HashMap<>(); \\n                map.put(0, 1);// init empty sub mx;\\n                for (int i = 0, sum = 0; i < m; i++) {\\n                    sum += (mx[i][r] - (l == 0 ? 0 : mx[i][l - 1]));\\n                    res += map.getOrDefault(sum - t, 0);\\n                    map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591215,
                "title": "convert-the-problem-to-range-sum-2d-array-immutable-o-x-2-solution",
                "content": "**X = rows * cols**\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        NumMatrix nm = new NumMatrix(matrix);\\n        int count = 0;\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        for(int i0 = 0 ; i0 < r; i0++){\\n            for(int j0 = 0 ; j0 < c; j0++){\\n                for(int i1 = i0 ; i1 < r; i1++){\\n                    for(int j1 = j0 ; j1 < c; j1++){\\n                       if(nm.sumRegion(i0,j0,i1,j1) == target){\\n                           count++;\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\nclass NumMatrix {\\n    int[][] ps;\\n    public NumMatrix(int[][] matrix) {\\n      if (matrix == null || matrix.length == 0) return;\\n      ps = new int[matrix.length + 1][matrix[0].length + 1];\\n      int r = ps.length;\\n      int c = ps[0].length;\\n      for (int i = 1; i < r; i++) {\\n        for (int j = 1; j < c; j++) {\\n          int top = ps[i - 1][j];\\n          int left = ps[i][j - 1];\\n          int diag = ps[i - 1][j - 1];\\n          int current = matrix[i - 1][j - 1];\\n          ps[i][j] = current + top + left  - diag;\\n        }\\n      }\\n    }\\n    \\n    public int sumRegion(int x1, int y1, int x2, int y2) {\\n      if (ps == null) return 0;\\n      x2++;\\n      y2++;\\n      x1++;\\n      y1++;\\n      int current = ps[x2][y2];\\n      int top = ps[x1 - 1][y2];\\n      int left = ps[x2][y1 - 1];\\n      int diag = ps[x1-1][y1-1];\\n      return current - top - left + diag;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        NumMatrix nm = new NumMatrix(matrix);\\n        int count = 0;\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        for(int i0 = 0 ; i0 < r; i0++){\\n            for(int j0 = 0 ; j0 < c; j0++){\\n                for(int i1 = i0 ; i1 < r; i1++){\\n                    for(int j1 = j0 ; j1 < c; j1++){\\n                       if(nm.sumRegion(i0,j0,i1,j1) == target){\\n                           count++;\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\nclass NumMatrix {\\n    int[][] ps;\\n    public NumMatrix(int[][] matrix) {\\n      if (matrix == null || matrix.length == 0) return;\\n      ps = new int[matrix.length + 1][matrix[0].length + 1];\\n      int r = ps.length;\\n      int c = ps[0].length;\\n      for (int i = 1; i < r; i++) {\\n        for (int j = 1; j < c; j++) {\\n          int top = ps[i - 1][j];\\n          int left = ps[i][j - 1];\\n          int diag = ps[i - 1][j - 1];\\n          int current = matrix[i - 1][j - 1];\\n          ps[i][j] = current + top + left  - diag;\\n        }\\n      }\\n    }\\n    \\n    public int sumRegion(int x1, int y1, int x2, int y2) {\\n      if (ps == null) return 0;\\n      x2++;\\n      y2++;\\n      x1++;\\n      y1++;\\n      int current = ps[x2][y2];\\n      int top = ps[x1 - 1][y2];\\n      int left = ps[x2][y1 - 1];\\n      int diag = ps[x1-1][y1-1];\\n      return current - top - left + diag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556875,
                "title": "c-o-n-2-m-time-o-n-m-space-with-comments-in-code",
                "content": "The idea is like many others pointed out  - to use DP and calculate prefix sums either for rows or for columns, I used rows below. \\n\\nAfter that by changing the width of the submatrix (imaging vertically slicing it),we go from top to the bottom processing each row and calculate the sum of the submatrix composed of the intervals limited by the left and right border of the slice. Prefix sums in dp array calculated before help here. What we get as a result is a prefix sum of submatrices.\\n\\nFor every such submatrix we check if we could start somewhere in the past and sum to the target by using a hashtable where we store the count of every submatrix prefix we\\'ve seen.\\n\\nWe essentially check if we\\'ve seen the prefix = currentsum-target before and how many times and sum these values to get the answer. Hope it helps!\\n\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) \\n    {\\n        if(matrix==null || matrix.Length ==0)\\n        {\\n            return 0;\\n        }\\n        \\n        int w = matrix[0].Length;\\n        int h = matrix.Length;\\n        \\n        // use new matrix, however if reuseif allowed it\\'s possible to have O(1) space\\n        // by overwriting the values in the source matrix\\n        int[,] dp = new int[h,w+1];\\n        \\n        for (int i = 0; i < h; i++) {\\n            for (int j = 0; j < w; j++) {\\n                //prefix sum for the row\\n                dp[i,j+1] = dp[i,j] + matrix[i][j];\\n            }\\n        }\\n        \\n        // holds the remainder sums of the matrices which could serve as a\\n        // starting point for our submatrix.\\n        Dictionary<int, int> starts = new Dictionary<int,int>();\\n\\n        int res = 0;\\n        // iterate through all possible vertical submatrices\\n        for (int i = 1; i <= w; i++) \\n        {\\n            for (int j = i; j <= w; j++) \\n            {\\n                starts.Clear();\\n                starts[0] = 1;\\n                \\n                // holds the submatrix sum, it\\'s the frontier of the imaginary 1D array where each\\n                // element is a matrix sum seen up and including this element, can be seen as a prefix sum of submatrices\\n                int end = 0;\\n                \\n                for (int k = 0; k < h; k++) \\n                {\\n                    // find the sum of the matrix elements up to this point,\\n                    // by summing up the interval sums [i,j] row by row using the prefix sums calculated before\\n                    end += dp[k,j] - dp[k,i - 1];\\n                    \\n                    // \"start\" prefix sum, \\n                    // it means that  if somewhere in the past we saw sum==start -> \\n                    // we found a suitable matrix now as we could start from there.\\n                    // end-start = target => start = end - target;\\n                    int start = end - target; \\n                    \\n                    // add the number of matrices we\\'ve seen so far, so that they had the sum equal to the\\n                    // complement we need\\n                    res += starts.ContainsKey(start) ? starts[start]: 0;\\n                    \\n                    // log the sum for the current matrix, \\n                    // it will serve as a start prefix sum (\"start\") later when will be checking for possible complements\\n                    starts[end] = (starts.ContainsKey(end) ? starts[end]+1 : 1);                 \\n                }\\n            }\\n        }            \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) \\n    {\\n        if(matrix==null || matrix.Length ==0)\\n        {\\n            return 0;\\n        }\\n        \\n        int w = matrix[0].Length;\\n        int h = matrix.Length;\\n        \\n        // use new matrix, however if reuseif allowed it\\'s possible to have O(1) space\\n        // by overwriting the values in the source matrix\\n        int[,] dp = new int[h,w+1];\\n        \\n        for (int i = 0; i < h; i++) {\\n            for (int j = 0; j < w; j++) {\\n                //prefix sum for the row\\n                dp[i,j+1] = dp[i,j] + matrix[i][j];\\n            }\\n        }\\n        \\n        // holds the remainder sums of the matrices which could serve as a\\n        // starting point for our submatrix.\\n        Dictionary<int, int> starts = new Dictionary<int,int>();\\n\\n        int res = 0;\\n        // iterate through all possible vertical submatrices\\n        for (int i = 1; i <= w; i++) \\n        {\\n            for (int j = i; j <= w; j++) \\n            {\\n                starts.Clear();\\n                starts[0] = 1;\\n                \\n                // holds the submatrix sum, it\\'s the frontier of the imaginary 1D array where each\\n                // element is a matrix sum seen up and including this element, can be seen as a prefix sum of submatrices\\n                int end = 0;\\n                \\n                for (int k = 0; k < h; k++) \\n                {\\n                    // find the sum of the matrix elements up to this point,\\n                    // by summing up the interval sums [i,j] row by row using the prefix sums calculated before\\n                    end += dp[k,j] - dp[k,i - 1];\\n                    \\n                    // \"start\" prefix sum, \\n                    // it means that  if somewhere in the past we saw sum==start -> \\n                    // we found a suitable matrix now as we could start from there.\\n                    // end-start = target => start = end - target;\\n                    int start = end - target; \\n                    \\n                    // add the number of matrices we\\'ve seen so far, so that they had the sum equal to the\\n                    // complement we need\\n                    res += starts.ContainsKey(start) ? starts[start]: 0;\\n                    \\n                    // log the sum for the current matrix, \\n                    // it will serve as a start prefix sum (\"start\") later when will be checking for possible complements\\n                    starts[end] = (starts.ContainsKey(end) ? starts[end]+1 : 1);                 \\n                }\\n            }\\n        }            \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520659,
                "title": "one-simple-graph-can-explain-the-algorithm-entirely-and-clearly-2d-prefix-sum",
                "content": "One graph can explain everything. \\n\\n![image](https://assets.leetcode.com/users/qiuqiushasha/image_1582667961.png)\\n\\n\\n```Scala\\n  def numSubmatrixSumTarget(matrix: Array[Array[Int]], target: Int): Int = {\\n\\n    val m = matrix.length\\n    val n = matrix(0).length\\n    if (m == 1 && n == 1) return if (matrix(0)(0) == target) 1 else 0\\n    var res = 0\\n    val table = Array.ofDim[Int](m, n + 1)\\n    for (i <- 0 until m; j <- 1 to n) table(i)(j) = table(i)(j - 1) + matrix(i)(j - 1)\\n    for (i <- 1 to n; j <- i to n) {\\n      var prefixSum = 0\\n      import scala.collection.mutable.Map\\n      val map = Map[Int, Int]()\\n      map.put(0, 1)\\n      for (k <- 0 until m) {\\n        prefixSum += table(k)(j) - table(k)(i - 1)\\n        res += map.getOrElse(prefixSum - target, 0)\\n        map.put(prefixSum, map.getOrElse(prefixSum, 0) + 1)\\n      }\\n    }\\n    res\\n  }\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  def numSubmatrixSumTarget(matrix: Array[Array[Int]], target: Int): Int = {\\n\\n    val m = matrix.length\\n    val n = matrix(0).length\\n    if (m == 1 && n == 1) return if (matrix(0)(0) == target) 1 else 0\\n    var res = 0\\n    val table = Array.ofDim[Int](m, n + 1)\\n    for (i <- 0 until m; j <- 1 to n) table(i)(j) = table(i)(j - 1) + matrix(i)(j - 1)\\n    for (i <- 1 to n; j <- i to n) {\\n      var prefixSum = 0\\n      import scala.collection.mutable.Map\\n      val map = Map[Int, Int]()\\n      map.put(0, 1)\\n      for (k <- 0 until m) {\\n        prefixSum += table(k)(j) - table(k)(i - 1)\\n        res += map.getOrElse(prefixSum - target, 0)\\n        map.put(prefixSum, map.getOrElse(prefixSum, 0) + 1)\\n      }\\n    }\\n    res\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 471030,
                "title": "python-easy-to-understand-using-560-beats-91-explained-in-description",
                "content": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        count = 0\\n        for i in range(m):\\n            nums = [0] * n\\n            for j in range(i, m):\\n                for k in range(n):\\n                    nums[k] += matrix[j][k]\\n                print(nums)\\n                count += self.subarraySum(nums, target)\\n        return count\\n    \\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        freq_map = {0: 1}\\n        result = 0\\n        curr_sum = 0 \\n        for i in range(len(nums)):\\n            curr_sum += nums[i]\\n            if curr_sum - k in freq_map:\\n                result+=freq_map[curr_sum - k]\\n            freq_map[curr_sum] = freq_map.get(curr_sum, 0) + 1\\n        return result\\n```\\t\\t\\n\\nExample:\\ntarget = 0 \\n[[ 1, -1,  2],\\n [ 0,  1, -2],\\n [-3, 2,  1 ]]\\nThis is the easiest way to think about this problem: \\n1) We need to find the number of rectangles in the matrix that sum upto the target. \\nThe first time SubarraySum() from problem #560 is called, only the first row of the matrix is sent. The function will return the number of contiguous sub arrays which add upto 0. For the first row this is just 1,  the array containing [1, -1]\\n\\n2) The second time it is called, the input to the function is the sum of the first and second rows: [1, 0, 0]. By doing this we are in a way \"collapsing\" the second row into the first. The number of subarrays in this combined array that add upto 0 will give us the number of submatrices with sizes in the range (2, 6). [why is it in the range 2,6? keep reading]\\n\\n3)  The third time it is called the input to the function is the sum of first, second and third rows: [-2, 2, 1]. The subarraySum function will find that the only contiguous sub array that adds to 0 is [-2, 2]. [-2,2]  essentially represents: \\n[[ 1, -1],\\n [ 0,  1],\\n [-3, 2]]\\nin the original array\\n4) Similarly subarraySum is called a total of 8 times. \\nO(M^2 *N)\\nHope this helps.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        count = 0\\n        for i in range(m):\\n            nums = [0] * n\\n            for j in range(i, m):\\n                for k in range(n):\\n                    nums[k] += matrix[j][k]\\n                print(nums)\\n                count += self.subarraySum(nums, target)\\n        return count\\n    \\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        freq_map = {0: 1}\\n        result = 0\\n        curr_sum = 0 \\n        for i in range(len(nums)):\\n            curr_sum += nums[i]\\n            if curr_sum - k in freq_map:\\n                result+=freq_map[curr_sum - k]\\n            freq_map[curr_sum] = freq_map.get(curr_sum, 0) + 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431893,
                "title": "prefix-sum-and-hash-table-time-complxity-o-n-3-faster-than-95-84",
                "content": "Runtime: 3540 ms, faster than 95.84% of C++ online submissions for Number of Submatrices That Sum to Target.\\nMemory Usage: 456.8 MB, less than 100.00% of C++ online submissions for Number of Submatrices That Sum to Target.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t rows = matrix.size(), cols = matrix[0].size();\\n\\n        // calculate prefix sum\\n        for (size_t row = 0; row < rows; ++row) {\\n            for (size_t col = 1; col < cols; ++col) {\\n                matrix[row][col] += matrix[row][col - 1];\\n            }\\n        }\\n        for (size_t col = 0; col < cols; ++col) {\\n            for (size_t row = 1; row < rows; ++row) {\\n                matrix[row][col] += matrix[row - 1][col];\\n            }\\n        }\\n\\n        int cnt = 0;\\n        // calculate the sum of matrix[r1, r2][c1, c2]\\n        // target = matrix[r2][c2] - matrix[r1 - 1][c2] - matrix[r2][c1 - 1] + matrix[r1 - 1][c1 - 1]\\n        // ==> seperate c1 and c2\\n        // ==> matrix[r2][c2] - matrix[r1 - 1][c2] = target + (matrix[r2][c1 - 1] - matrix[r1 - 1][c1 - 1])\\n        for (size_t r1 = 0; r1 < rows; ++r1) {\\n            for (size_t r2 = r1; r2 < rows; ++r2) {\\n\\t\\t\\t\\t// Instead of iteration by c1 then by c2 (this solution\\'s time complxity is O(N^4)), \\n\\t\\t\\t\\t// cache data in hash table when iterating c and then find result in hash table during later iteration.\\n\\t\\t\\t\\t// In this way, the time complxity reduces to O(N^3)\\n                unordered_multiset<int> sums;  // cache the sums of matrix[r1...r2][0...c] to reduce the loop by one layer\\n                for (size_t c = 0; c < cols; ++c) {\\n                    int sum = r1 == 0 ? matrix[r2][c] : matrix[r2][c] - matrix[r1 - 1][c];\\n                    if (sum == target) ++cnt;\\n                    cnt += sums.count(sum - target);\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t rows = matrix.size(), cols = matrix[0].size();\\n\\n        // calculate prefix sum\\n        for (size_t row = 0; row < rows; ++row) {\\n            for (size_t col = 1; col < cols; ++col) {\\n                matrix[row][col] += matrix[row][col - 1];\\n            }\\n        }\\n        for (size_t col = 0; col < cols; ++col) {\\n            for (size_t row = 1; row < rows; ++row) {\\n                matrix[row][col] += matrix[row - 1][col];\\n            }\\n        }\\n\\n        int cnt = 0;\\n        // calculate the sum of matrix[r1, r2][c1, c2]\\n        // target = matrix[r2][c2] - matrix[r1 - 1][c2] - matrix[r2][c1 - 1] + matrix[r1 - 1][c1 - 1]\\n        // ==> seperate c1 and c2\\n        // ==> matrix[r2][c2] - matrix[r1 - 1][c2] = target + (matrix[r2][c1 - 1] - matrix[r1 - 1][c1 - 1])\\n        for (size_t r1 = 0; r1 < rows; ++r1) {\\n            for (size_t r2 = r1; r2 < rows; ++r2) {\\n\\t\\t\\t\\t// Instead of iteration by c1 then by c2 (this solution\\'s time complxity is O(N^4)), \\n\\t\\t\\t\\t// cache data in hash table when iterating c and then find result in hash table during later iteration.\\n\\t\\t\\t\\t// In this way, the time complxity reduces to O(N^3)\\n                unordered_multiset<int> sums;  // cache the sums of matrix[r1...r2][0...c] to reduce the loop by one layer\\n                for (size_t c = 0; c < cols; ++c) {\\n                    int sum = r1 == 0 ? matrix[r2][c] : matrix[r2][c] - matrix[r1 - 1][c];\\n                    if (sum == target) ++cnt;\\n                    cnt += sums.count(sum - target);\\n                    sums.insert(sum);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357633,
                "title": "java-solution",
                "content": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\tint m = matrix.length;\\n\\tint n = matrix[0].length;\\n\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tMap<Integer, Integer> cnt = new HashMap<>();\\n\\t\\t\\tcnt.put(0, 1);\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\tsum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\tans += cnt.getOrDefault(sum - target, 0);\\n\\t\\t\\t\\tcnt.put(sum, cnt.getOrDefault(sum, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n\\tint m = matrix.length;\\n\\tint n = matrix[0].length;\\n\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\t\\t}\\n\\t}\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tMap<Integer, Integer> cnt = new HashMap<>();\\n\\t\\t\\tcnt.put(0, 1);\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\tsum += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\tans += cnt.getOrDefault(sum - target, 0);\\n\\t\\t\\t\\tcnt.put(sum, cnt.getOrDefault(sum, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 305264,
                "title": "c-optimal-time-complexity-with-preprocessing-practice-in-2019",
                "content": "It is hard level algorithm. The challenge is to lower time complexity and avoid redundant calculation. I will write down what I learn later, this solution is written just by code study one of most popular post. \\n\\n**Case study matrix with value 1, 5 x 5, target value 4**\\n\\nLet us work on a case study a matrix with value 1, 5 x 5, target value 4. Let us count how many submatrix with value 4. \\n\\n 1    1     1    1     1\\n 1    1     1    1     1\\n 1    1     1    1     1\\n 1    1     1    1     1\\n 1    1     1    1     1\\n\\nCase: Rows = 1\\n\\nFirst we can try one row, how many submatrix with value 4, we know that the matrix should be 4 columns, each row there are two options, starting from column = 0 or column = 1; all five rows should be counted. Total is 2 x 5 = 10;\\n\\nBut in general, we should try all options for column in total, from 1 to 5. \\n\\nCase: Rows = 2\\nFirst we can try matrix 2 x 2, how many choices we have, there are 4 x 4 = 16 choices. \\n\\nBut in reality, we should try all options for 2 rows matrix, column can be from 1 to 5, target value is 4. \\n\\nI will add the detail to explain how to make this simple case work, and also time complexity is optimal. The posts I study are [here](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/303773/C%2B%2B-O(n3)-Simple-1D-Subarray-target-sum-applied-to-2D-array). \\n\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n        {\\n            var rows = matrix.Length;\\n            var columns = matrix[0].Length;\\n            var sum =  new int[columns];            \\n        \\n            int answer = 0;\\n            for (int row = 0; row < rows; row++)\\n            {\\n                for (int col = 0; col < columns; col++)\\n                {\\n                    sum[col] = 0;\\n                }\\n            \\n                for(int subRow = row; subRow < rows; subRow++)\\n                {\\n                    for (int col = 0; col < columns; col++)\\n                    {\\n                        sum[col] += matrix[subRow][col];\\n                    }\\n                \\n                    var preSet = new Dictionary<int,int>();\\n\\n                    int preSum = 0;\\n                    preSet.Add(preSum, 1);\\n                \\n                    for(int col = 0;col < columns;col++){\\n                        preSum += sum[col];\\n\\n                        int search = preSum - target;\\n\\n                        if(preSet.ContainsKey(search)){\\n                            answer += preSet[search];\\n                        }\\n\\n                        if (!preSet.ContainsKey(preSum))\\n                            preSet.Add(preSum, 0);\\n                        \\n                        preSet[preSum]++;\\n                    }\\n                }            \\n            }\\n        \\n            return answer;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target)\\n        {\\n            var rows = matrix.Length;\\n            var columns = matrix[0].Length;\\n            var sum =  new int[columns];            \\n        \\n            int answer = 0;\\n            for (int row = 0; row < rows; row++)\\n            {\\n                for (int col = 0; col < columns; col++)\\n                {\\n                    sum[col] = 0;\\n                }\\n            \\n                for(int subRow = row; subRow < rows; subRow++)\\n                {\\n                    for (int col = 0; col < columns; col++)\\n                    {\\n                        sum[col] += matrix[subRow][col];\\n                    }\\n                \\n                    var preSet = new Dictionary<int,int>();\\n\\n                    int preSum = 0;\\n                    preSet.Add(preSum, 1);\\n                \\n                    for(int col = 0;col < columns;col++){\\n                        preSum += sum[col];\\n\\n                        int search = preSum - target;\\n\\n                        if(preSet.ContainsKey(search)){\\n                            answer += preSet[search];\\n                        }\\n\\n                        if (!preSet.ContainsKey(preSum))\\n                            preSet.Add(preSum, 0);\\n                        \\n                        preSet[preSum]++;\\n                    }\\n                }            \\n            }\\n        \\n            return answer;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303765,
                "title": "my-java-solution",
                "content": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] = dp[i+1][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] += dp[i][j+1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int a = 0; a < m ; a++) {\\n            for(int b = 0; b < n; b++) {\\n                \\n                for(int c = a + 1; c <= m; c++) {\\n                    for(int d = b + 1; d <= n; d++) {\\n                        int sum = dp[c][d] - dp[c][b] - dp[a][d] + dp[a][b];\\n                        if(sum == target) res++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] = dp[i+1][j] + matrix[i][j];\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i+1][j+1] += dp[i][j+1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int a = 0; a < m ; a++) {\\n            for(int b = 0; b < n; b++) {\\n                \\n                for(int c = a + 1; c <= m; c++) {\\n                    for(int d = b + 1; d <= n; d++) {\\n                        int sum = dp[c][d] - dp[c][b] - dp[a][d] + dp[a][b];\\n                        if(sum == target) res++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3977216,
                "title": "concise-easy-to-understand-intuition-and-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor each pair of columns (i, j) from index i to j inclusive:\\n\\nCreate a hashmap (freq) to store the frequency of cumulative sums.\\nInitialize the cumulative sum sum as 0.\\nInitialize cumuColSum to track the cumulative column sums for each row, starting from column i to column j.\\nTraverse each row (k) from 0 to n-1:\\n\\nUpdate the cumuColSum[k] with the current value in matrix[k][j] plus the previous cumulative sum value.\\nIncrement the frequency of the current cumulative sum sum in the freq map.\\nUpdate sum by adding the current cumuColSum[k].\\nAt each step in row traversal:\\n\\nIncrement the count by the frequency of (sum - target) in the freq map. This implies that there are freq[sum - target] submatrices that sum to the target value ending at the current row.\\nThe count is the final result representing the total number of submatrices across all column pairs that sum up to the target value.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(m^2*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        int count =0;\\n\\n        for(int i=0;i<m;i++){\\n            vector<int> cumuColSum(n,0);\\n\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int> freq;\\n                int sum = 0;\\n                for(int k=0;k<n;k++){\\n                    cumuColSum[k] = matrix[k][j] + cumuColSum[k];\\n                    freq[sum]++;\\n                    sum += cumuColSum[k];\\n                    count += freq[sum-target];\\n                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        int count =0;\\n\\n        for(int i=0;i<m;i++){\\n            vector<int> cumuColSum(n,0);\\n\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int> freq;\\n                int sum = 0;\\n                for(int k=0;k<n;k++){\\n                    cumuColSum[k] = matrix[k][j] + cumuColSum[k];\\n                    freq[sum]++;\\n                    sum += cumuColSum[k];\\n                    count += freq[sum-target];\\n                    \\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567068,
                "title": "c-cleanest-code-with-comments-easiest-to-understand",
                "content": "Please Upvote\\nBasic idea: Fix the position of the upper and lower rows and add each column in the vertical direction to get a one-dimensional array. Then scan each presum from left to right and put it into a Hash table. Check to see if the current presum-target is already in the hash table. If it exists, then the sum of submatrix equals target.\\n\\nTime complexity: o(N^3)\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<r;i++){\\n            vector<int> v(c,0);\\n            //taking the sum of each column\\n            for(int j=i;j<r;j++){\\n                for(int k=0;k<c;k++)\\n                {\\n                    v[k]+=matrix[j][k];//taking the sum of each column(vertcially)\\n                }\\n                /*\\n                i:------------\\n                \\n                j:------------\\n                */\\n                //converted whole i to j submatric to a simple 1 d horizontal array by collecting the sum of columns vertcially\\n                //now thats a 1d problem of how many subarrays sum up to target\\n                map<int,int> mp;\\n                mp[0]=1;\\n                int sm=0;\\n                for(int p=0;p<v.size();p++){\\n                    sm+=v[p];\\n                    ans+=mp[sm-target];\\n                    mp[sm]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<r;i++){\\n            vector<int> v(c,0);\\n            //taking the sum of each column\\n            for(int j=i;j<r;j++){\\n                for(int k=0;k<c;k++)\\n                {\\n                    v[k]+=matrix[j][k];//taking the sum of each column(vertcially)\\n                }\\n                /*\\n                i:------------\\n                \\n                j:------------\\n                */\\n                //converted whole i to j submatric to a simple 1 d horizontal array by collecting the sum of columns vertcially\\n                //now thats a 1d problem of how many subarrays sum up to target\\n                map<int,int> mp;\\n                mp[0]=1;\\n                int sm=0;\\n                for(int p=0;p<v.size();p++){\\n                    sm+=v[p];\\n                    ans+=mp[sm-target];\\n                    mp[sm]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415777,
                "title": "c-prefix-sum-o-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // standard problem of number of subarrays with given target sum\\n    int func(vector<int> a,int target){\\n        map<int,int> mp;\\n        int pref = 0;\\n        mp[0]=1;\\n        int cnt=0;\\n        int n = a.size();\\n        for(int i=0;i<n;i++){\\n            pref+=a[i];\\n            // prefj-prefi = target\\n            // for current prefj looking for prefixes with sum of prefj-target\\n            if(mp.find(pref-target) != mp.end()) cnt+=mp[pref-target];\\n            mp[pref]++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int ans = 0;\\n        for(int row1 = 0;row1<n;row1++){\\n            vector<int> psum(m,0);\\n            for(int row2=row1;row2<n;row2++){\\n                for(int i=0;i<m;i++)psum[i]+=matrix[row2][i];\\n                ans+=func(psum,target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // standard problem of number of subarrays with given target sum\\n    int func(vector<int> a,int target){\\n        map<int,int> mp;\\n        int pref = 0;\\n        mp[0]=1;\\n        int cnt=0;\\n        int n = a.size();\\n        for(int i=0;i<n;i++){\\n            pref+=a[i];\\n            // prefj-prefi = target\\n            // for current prefj looking for prefixes with sum of prefj-target\\n            if(mp.find(pref-target) != mp.end()) cnt+=mp[pref-target];\\n            mp[pref]++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int ans = 0;\\n        for(int row1 = 0;row1<n;row1++){\\n            vector<int> psum(m,0);\\n            for(int row2=row1;row2<n;row2++){\\n                for(int i=0;i<m;i++)psum[i]+=matrix[row2][i];\\n                ans+=func(psum,target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300831,
                "title": "96-tc-and-71-sc-easy-python-solution",
                "content": "```\\ndef numSubmatrixSumTarget(self, mat: List[List[int]], target: int) -> int:\\n\\tm, n = len(mat), len(mat[0])\\n\\tfor i in range(m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tmat[i][j] += mat[i][j-1]\\n\\t\\tmat[i] = [0] + mat[i]\\n\\tans = 0\\n\\td = defaultdict(int)\\n\\tfor col1 in range(n):\\n\\t\\tfor col2 in range(col1+1, n+1):\\n\\t\\t\\ttemp = 0\\n\\t\\t\\td[0] = 1\\n\\t\\t\\tfor r in range(m):\\n\\t\\t\\t\\ttemp += mat[r][col2] - mat[r][col1]\\n\\t\\t\\t\\tif(temp - target in d):\\n\\t\\t\\t\\t\\tans += d[temp - target]\\n\\t\\t\\t\\td[temp] += 1\\n\\t\\t\\td.clear()\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef numSubmatrixSumTarget(self, mat: List[List[int]], target: int) -> int:\\n\\tm, n = len(mat), len(mat[0])\\n\\tfor i in range(m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tmat[i][j] += mat[i][j-1]\\n\\t\\tmat[i] = [0] + mat[i]\\n\\tans = 0\\n\\td = defaultdict(int)\\n\\tfor col1 in range(n):\\n\\t\\tfor col2 in range(col1+1, n+1):\\n\\t\\t\\ttemp = 0\\n\\t\\t\\td[0] = 1\\n\\t\\t\\tfor r in range(m):\\n\\t\\t\\t\\ttemp += mat[r][col2] - mat[r][col1]\\n\\t\\t\\t\\tif(temp - target in d):\\n\\t\\t\\t\\t\\tans += d[temp - target]\\n\\t\\t\\t\\td[temp] += 1\\n\\t\\t\\td.clear()\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2300379,
                "title": "c-variation-of-subarray-sum-equals-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        // STEP 01 : prefix sum\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        // STEP 02 : for every pair of column perform operation - subarray sum technique with \\n        //           with sliding window to get every apir of column\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                \\n                // since we handled every column pair now work on operation on every rows\\n                // subarray sum equals k technique\\n                int sum=0;\\n                unordered_map<int,int> mp;\\n                mp[0]=1;\\n                \\n                for(int row=0;row<n;row++){\\n                    \\n                    sum+=mat[row][c2];\\n                    \\n                    // remove extra left part(search space) if there \\n                    if(c1>0) sum-=mat[row][c1-1];\\n                    \\n                    // exact same as subarray sum equals k\\n                    int srch = sum-target;\\n                    \\n                    if(mp.find(srch)!=mp.end()) res += mp[srch];\\n                    \\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        // STEP 01 : prefix sum\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        // STEP 02 : for every pair of column perform operation - subarray sum technique with \\n        //           with sliding window to get every apir of column\\n        for(int c1=0;c1<m;c1++){\\n            for(int c2=c1;c2<m;c2++){\\n                \\n                // since we handled every column pair now work on operation on every rows\\n                // subarray sum equals k technique\\n                int sum=0;\\n                unordered_map<int,int> mp;\\n                mp[0]=1;\\n                \\n                for(int row=0;row<n;row++){\\n                    \\n                    sum+=mat[row][c2];\\n                    \\n                    // remove extra left part(search space) if there \\n                    if(c1>0) sum-=mat[row][c1-1];\\n                    \\n                    // exact same as subarray sum equals k\\n                    int srch = sum-target;\\n                    \\n                    if(mp.find(srch)!=mp.end()) res += mp[srch];\\n                    \\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300145,
                "title": "c-o-n-3-generic-solution-that-reduces-to-lc-560-subarray-sum-equals-k",
                "content": "The principal observation here is that this problem is reducable to solving multiple problems of the type [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) . How?\\n\\n- Finding all sub-matrices that sum to `target` can be tackled by going over all sub-matrices. We can do this traversal by consider all submatrices whose ends lie between column indices `lo` and `hi` (inclusive and `lo <= hi`) for all valid pairs of column indices `(lo, hi)`. We argue that each such **sub-problem** (i.e. all sub-matrices between a given pair of column indices `(lo, hi)` is an instance of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) . This we show below.\\n- Imagine that we have calculated the **prefix-sum for each row** of the `matrix` i.e. `sum[r][c]` holds the sum `matrix[r][0] + matrix[r][1] + ... + matrix[r][c]` for all `(r, c)`. (We don\\'t create a separate 2D array `sum` for this, but do it in-place in the input 2D array `matrix` itself, but using a separate 2D array avoids confusion when explaining the concept).\\n- Now, consider a pair of columns `lo` and `hi`. For each such pair, we can create an array (say `submat` such that `submat[r] = sum[r][hi] - sum[r][lo-1]` i.e. `submat[r]` is the sum of all values in the row `r` of the original matrix between columns `lo` and `hi` (inclusive). Finding all non-empty subarrays in `submat` that sum to target is precisely what we\\'re looking for as the **sub-problem**.\\n- We use the class `SubarraySumCount` that abstracts away the details of [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) in a clean interface.\\n\\n```\\n/*\\n// Usage:\\n    SubarraySumCount s {target};\\n    for(auto const &v : values)\\n        s.add(v);\\n    auto res = s.count();\\n// `res` holds the count of all non-empty subarrays from `values`\\n// that have a sum equal to `target`\\n\\n*/\\n\\ntemplate <typename T>\\nclass SubarraySumCount {\\n    static_assert(is_integral_v<T>, \"Must specify an Integral Type\");\\n    \\n    unordered_map<T, size_t> ct;\\n    T target;\\n    T cum {0};\\n    size_t res {0};\\npublic:\\n    SubarraySumCount(const T &target) : target(target) {\\n        ct[0] = 1;\\n    }\\n    \\n    inline void add(const T& val) {\\n        cum += val;\\n        auto const &complement = cum - target;\\n        if(auto it = ct.find(complement); it != ct.end())\\n            res += it->second;\\n        ct[cum]++;\\n    }\\n    \\n    inline size_t count() const {\\n        return res;\\n    }\\n    \\n    void reset() {\\n        ct.clear();\\n        cum = 0;\\n        res = 0;\\n        \\n        ct[0] = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n        \\n        // row-wise prefix sums\\n        for(auto &row : matrix)\\n            partial_sum(begin(row), end(row), begin(row));\\n        \\n        int res {0};\\n\\t\\t// [CHOICE-A]: Single `SubarraySumCount` object during this function\\'s lifetime that is `reset()`\\n\\t\\t// multiple times\\n        SubarraySumCount s {target};\\n        \\n        for(int lo = 0; lo < cols; lo++) {\\n            for(int hi = lo; hi < cols; hi++) {\\n\\t\\t\\t    // [CHOICE-B]: Multiple `SubarraySumCount` objects during function\\'s lifetime\\n\\t\\t\\t\\t// Once per pair of column indices that is destroyed rather than being `reset`.\\n\\t\\t\\t\\t// SubarraySumCount s {target};\\n                for(int r = 0; r < rows; r++)\\n                    s.add(matrix[r][hi] - (lo > 0 ? matrix[r][lo-1] : 0));\\n                res += s.count();\\n                // [CHOICE-A]\\n\\t\\t\\t\\ts.reset();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime-Complexity: `O(cols * cols * rows)`\\nSpace-Complexity: Ignoring the in-place use of the input `matrix`\\n- Choice **A**: `O(cols * cols * rows)` in worst case (Is the time better though? IDK.)\\n- Choice **B**: `O(rows)` in worst case.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n// Usage:\\n    SubarraySumCount s {target};\\n    for(auto const &v : values)\\n        s.add(v);\\n    auto res = s.count();\\n// `res` holds the count of all non-empty subarrays from `values`\\n// that have a sum equal to `target`\\n\\n*/\\n\\ntemplate <typename T>\\nclass SubarraySumCount {\\n    static_assert(is_integral_v<T>, \"Must specify an Integral Type\");\\n    \\n    unordered_map<T, size_t> ct;\\n    T target;\\n    T cum {0};\\n    size_t res {0};\\npublic:\\n    SubarraySumCount(const T &target) : target(target) {\\n        ct[0] = 1;\\n    }\\n    \\n    inline void add(const T& val) {\\n        cum += val;\\n        auto const &complement = cum - target;\\n        if(auto it = ct.find(complement); it != ct.end())\\n            res += it->second;\\n        ct[cum]++;\\n    }\\n    \\n    inline size_t count() const {\\n        return res;\\n    }\\n    \\n    void reset() {\\n        ct.clear();\\n        cum = 0;\\n        res = 0;\\n        \\n        ct[0] = 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n        \\n        // row-wise prefix sums\\n        for(auto &row : matrix)\\n            partial_sum(begin(row), end(row), begin(row));\\n        \\n        int res {0};\\n\\t\\t// [CHOICE-A]: Single `SubarraySumCount` object during this function\\'s lifetime that is `reset()`\\n\\t\\t// multiple times\\n        SubarraySumCount s {target};\\n        \\n        for(int lo = 0; lo < cols; lo++) {\\n            for(int hi = lo; hi < cols; hi++) {\\n\\t\\t\\t    // [CHOICE-B]: Multiple `SubarraySumCount` objects during function\\'s lifetime\\n\\t\\t\\t\\t// Once per pair of column indices that is destroyed rather than being `reset`.\\n\\t\\t\\t\\t// SubarraySumCount s {target};\\n                for(int r = 0; r < rows; r++)\\n                    s.add(matrix[r][hi] - (lo > 0 ? matrix[r][lo-1] : 0));\\n                res += s.count();\\n                // [CHOICE-A]\\n\\t\\t\\t\\ts.reset();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300092,
                "title": "c-prefix-sum",
                "content": "***Comment down your queries***\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        //calculate the prefix sum\\n         for(int r = 0;r<matrix.size();r++)\\n         {\\n             for(int c = 1;c<matrix[0].size();c++)\\n             {\\n                 matrix[r][c] += matrix[r][c-1];\\n             }\\n         }\\n        //Here the magic begin\\n        int res = 0;\\n        for(int fixColumn = 0;fixColumn < matrix[0].size();fixColumn++)\\n        {\\n            for(int subMatrixCol = fixColumn;subMatrixCol < matrix[0].size();subMatrixCol++)\\n            {\\n                unordered_map<int,int>mp;\\n                mp[0] = 1;\\n                int sum = 0;//sum of current sub-matrix\\n                for(int currentRow = 0;currentRow<matrix.size();currentRow++)\\n                {\\n                    //when fixed point is 2nd col and onward, we have to subtract previous cols\\n                    if(fixColumn>0) matrix[currentRow][subMatrixCol] -=  matrix[currentRow][fixColumn-1];\\n                    sum+=(matrix[currentRow][subMatrixCol]); // calculating the sum w.r.t column\\n                    if(mp[sum-target]) res+=mp[sum-target];\\n                    mp[sum]++; // you can get this idea by solving, sub-array target problem\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        //calculate the prefix sum\\n         for(int r = 0;r<matrix.size();r++)\\n         {\\n             for(int c = 1;c<matrix[0].size();c++)\\n             {\\n                 matrix[r][c] += matrix[r][c-1];\\n             }\\n         }\\n        //Here the magic begin\\n        int res = 0;\\n        for(int fixColumn = 0;fixColumn < matrix[0].size();fixColumn++)\\n        {\\n            for(int subMatrixCol = fixColumn;subMatrixCol < matrix[0].size();subMatrixCol++)\\n            {\\n                unordered_map<int,int>mp;\\n                mp[0] = 1;\\n                int sum = 0;//sum of current sub-matrix\\n                for(int currentRow = 0;currentRow<matrix.size();currentRow++)\\n                {\\n                    //when fixed point is 2nd col and onward, we have to subtract previous cols\\n                    if(fixColumn>0) matrix[currentRow][subMatrixCol] -=  matrix[currentRow][fixColumn-1];\\n                    sum+=(matrix[currentRow][subMatrixCol]); // calculating the sum w.r.t column\\n                    if(mp[sum-target]) res+=mp[sum-target];\\n                    mp[sum]++; // you can get this idea by solving, sub-array target problem\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299773,
                "title": "c-solution-faster-than-96-less-than-98",
                "content": "The idea:\\n\\n1. Create a prefix array of top row and leftmost column. \\ne.g. if top row = 1 2 3, then prefix row = 1 3 6, same for leftmost column from top to bottom\\n2. Create a 2D prefix array. Sum at a position [i, j], such that both i, j > 0 = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\\n\\n```\\n    --------------------\\n    [i-1,j-1]|[i-1,j]\\n    --------------------\\n    [i,j-1]  |[i,j]\\n    --------------------\\n```\\n\\n[i-1,j-1] is the overlapped region, that\\'s why you cancel that out.\\n\\nThat\\'s it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const static int MAX = 120;\\n    int rec[MAX][MAX];\\n    int R, C;\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        rec[0][0] = matrix[0][0];\\n        int res_cnt = 0;\\n        if (rec[0][0] == target)\\n            res_cnt++;\\n        R = matrix.size();\\n        C = matrix[0].size();\\n        for (int i = 1; i < R; i++) {\\n            rec[i][0] = rec[i - 1][0] + matrix[i][0];\\n            if (rec[i][0] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < C; i++) {\\n            rec[0][i] = rec[0][i - 1] + matrix[0][i];\\n            if (rec[0][i] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                rec[i][j] = matrix[i][j] + rec[i][j - 1] + rec[i - 1][j] - rec[i - 1][j - 1];\\n            }\\n        }\\n        // top row\\n        for (int j = 1; j < C; j++) {\\n            for (int k = 0; k < j; k++) {\\n                if (rec[0][j] - rec[0][k] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        // top col\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (rec[i][0] - rec[j][0] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                // init case\\n                if (rec[i][j] == target) {\\n                    res_cnt++;\\n                }\\n                // row case\\n                for (int k = 0; k < i; k++) {\\n                    if (rec[i][j] - rec[k][j] == target)\\n                        res_cnt++;\\n                }\\n                // col case\\n                for (int l = 0; l < j; l++) {\\n                    if (rec[i][j] - rec[i][l] == target) {\\n                        res_cnt++;\\n                    }\\n                }\\n                // wow case\\n                for (int k = 0; k < i; k++) {\\n                    for (int l = 0; l < j; l++) {\\n                        if (rec[i][j] - rec[k][j] - rec[i][l] + rec[k][l] == target)\\n                            res_cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return res_cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    --------------------\\n    [i-1,j-1]|[i-1,j]\\n    --------------------\\n    [i,j-1]  |[i,j]\\n    --------------------\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const static int MAX = 120;\\n    int rec[MAX][MAX];\\n    int R, C;\\n    \\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        rec[0][0] = matrix[0][0];\\n        int res_cnt = 0;\\n        if (rec[0][0] == target)\\n            res_cnt++;\\n        R = matrix.size();\\n        C = matrix[0].size();\\n        for (int i = 1; i < R; i++) {\\n            rec[i][0] = rec[i - 1][0] + matrix[i][0];\\n            if (rec[i][0] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < C; i++) {\\n            rec[0][i] = rec[0][i - 1] + matrix[0][i];\\n            if (rec[0][i] == target)\\n                res_cnt++;\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                rec[i][j] = matrix[i][j] + rec[i][j - 1] + rec[i - 1][j] - rec[i - 1][j - 1];\\n            }\\n        }\\n        // top row\\n        for (int j = 1; j < C; j++) {\\n            for (int k = 0; k < j; k++) {\\n                if (rec[0][j] - rec[0][k] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        // top col\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (rec[i][0] - rec[j][0] == target)\\n                    res_cnt++;\\n            }\\n        }\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                // init case\\n                if (rec[i][j] == target) {\\n                    res_cnt++;\\n                }\\n                // row case\\n                for (int k = 0; k < i; k++) {\\n                    if (rec[i][j] - rec[k][j] == target)\\n                        res_cnt++;\\n                }\\n                // col case\\n                for (int l = 0; l < j; l++) {\\n                    if (rec[i][j] - rec[i][l] == target) {\\n                        res_cnt++;\\n                    }\\n                }\\n                // wow case\\n                for (int k = 0; k < i; k++) {\\n                    for (int l = 0; l < j; l++) {\\n                        if (rec[i][j] - rec[k][j] - rec[i][l] + rec[k][l] == target)\\n                            res_cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return res_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299708,
                "title": "simple-python-solution-using-prefix-sum",
                "content": "```from typing import List\\n\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        ans = 0\\n\\n        for start in range(n):\\n            tempSum = [0] * m\\n            for i in range(start, n):\\n                for j in range(m):\\n                    tempSum[j] += matrix[i][j]\\n                ans += self.subSetSum(tempSum, target)\\n        return ans\\n\\n    def subSetSum(self, arr, k):\\n        res = 0\\n        currSum = 0\\n        prefixSum = {0: 1}\\n        for n in arr:\\n            currSum += n\\n            diff = currSum - k\\n            res += prefixSum.get(diff, 0)\\n            prefixSum[currSum] = 1 + prefixSum.get(currSum, 0)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```from typing import List\\n\\n\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        ans = 0\\n\\n        for start in range(n):\\n            tempSum = [0] * m\\n            for i in range(start, n):\\n                for j in range(m):\\n                    tempSum[j] += matrix[i][j]\\n                ans += self.subSetSum(tempSum, target)\\n        return ans\\n\\n    def subSetSum(self, arr, k):\\n        res = 0\\n        currSum = 0\\n        prefixSum = {0: 1}\\n        for n in arr:\\n            currSum += n\\n            diff = currSum - k\\n            res += prefixSum.get(diff, 0)\\n            prefixSum[currSum] = 1 + prefixSum.get(currSum, 0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299321,
                "title": "python-98-faster",
                "content": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        for row in matrix:\\n            for i in range(1,len(row)):\\n                row[i] += row[i-1]\\n        res = 0\\n        for i in range(len(matrix)):\\n            tmp = [0 for val in matrix[i]]\\n            for j in range(i,len(matrix)):\\n                need = collections.defaultdict(int)\\n                need[target] = 1\\n                for k in range(len(matrix[0])):\\n                    tmp[k] += matrix[j][k]\\n                    if tmp[k] in need:\\n                        res += need[tmp[k]]\\n                    need[tmp[k]+target] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        for row in matrix:\\n            for i in range(1,len(row)):\\n                row[i] += row[i-1]\\n        res = 0\\n        for i in range(len(matrix)):\\n            tmp = [0 for val in matrix[i]]\\n            for j in range(i,len(matrix)):\\n                need = collections.defaultdict(int)\\n                need[target] = 1\\n                for k in range(len(matrix[0])):\\n                    tmp[k] += matrix[j][k]\\n                    if tmp[k] in need:\\n                        res += need[tmp[k]]\\n                    need[tmp[k]+target] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299303,
                "title": "java-solution",
                "content": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        \\n        int dp[][]=new int[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix[0].length;i++)\\n        {\\n            int sum=0;\\n            for(int j=matrix.length-1;j>=0;j--)\\n            {\\n                sum+=matrix[j][i];\\n                dp[j][i]=sum;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n               for(int p=i;p>=0;p--)\\n               {\\n                  int sum=0; \\n                  for(int k=j;k>=0;k--)\\n                  {\\n                     if(i==dp.length-1)\\n                     {\\n                         sum+=dp[p][k];\\n                     }\\n                     else\\n                         sum+=dp[p][k]-dp[i+1][k];\\n                     if(sum==target)\\n                     {\\n                         ans++;\\n                     }\\n                  }\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        \\n        int dp[][]=new int[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix[0].length;i++)\\n        {\\n            int sum=0;\\n            for(int j=matrix.length-1;j>=0;j--)\\n            {\\n                sum+=matrix[j][i];\\n                dp[j][i]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2299086,
                "title": "java-approach-and-code-detailed-explaination",
                "content": "Approach :\\n\\nThis problem is essentially a 2-dimensional version Subarray Sum Equals K (S.S.E.K). By using a prefix sum on each row or each column, we can compress this problem down to either N^2 iterations of the O(M) SSEK, or M^2 iterations of the O(N) SSEK.\\n\\nIn the SSEK solution, we can find the number of subarrays with the target sum by utilizing a result map (res) to store the different values found as we iterate through the array while keeping a running sum (csum). Just as in the case with a prefix sum array, the sum of a subarray between i and j is equal to the sum of the subarray from 0 to j minus the sum of the subarray from 0 to i-1.\\n\\nRather than iteratively checking if sum[0,j] - sum[0,i-1] = T for every pair of i, j values, we can flip it around to sum[0,j] - T = sum[0,i-1] and since every earlier sum value has been stored in res, we can simply perform a lookup on sum[0,j] - T to see if there are any matches.\\n\\nWhen extrapolating this solution to our 2-dimensional matrix (M), we will need to first prefix sum the rows or columns, (which we can do in-place to avoid extra space, as we will not need the original values again). Then we should iterate through M again in the opposite order of rows/columns where the prefix sums will allow us to treat a group of columns or rows as if it were a 1-dimensional array and apply the SSEK algorithm.\\n\\nCode:\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int xlen = matrix[0].length, ylen = matrix.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : matrix)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - target, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }\\n            }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int xlen = matrix[0].length, ylen = matrix.length, ans = 0;\\n        Map<Integer, Integer> res = new HashMap<>();\\n        for (int[] r : matrix)\\n            for (int j = 1; j < xlen; j++)\\n                r[j] += r[j-1];\\n        for (int j = 0; j < xlen; j++)\\n            for (int k = j; k < xlen; k++) {\\n                res.clear();\\n                res.put(0,1);\\n                int csum = 0;\\n                for (int i = 0; i < ylen; i++) {\\n                    csum += matrix[i][k] - (j > 0 ? matrix[i][j-1] : 0);\\n                    ans += res.getOrDefault(csum - target, 0);\\n                    res.put(csum, res.getOrDefault(csum, 0) + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2299058,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++)\\n            {\\n                map<int,int>m1;\\n                m1[0]++;\\n                int sum=0;\\n                for(int k=0;k<m;k++)\\n                {\\n                    sum+=matrix[k][j]-(i>0 ? matrix[k][i-1] : 0);\\n                    if(m1[sum-target])\\n                        ans+=m1[sum-target];\\n                    m1[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++)\\n            {\\n                map<int,int>m1;\\n                m1[0]++;\\n                int sum=0;\\n                for(int k=0;k<m;k++)\\n                {\\n                    sum+=matrix[k][j]-(i>0 ? matrix[k][i-1] : 0);\\n                    if(m1[sum-target])\\n                        ans+=m1[sum-target];\\n                    m1[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298739,
                "title": "java-easy-subarray-with-target-sum-based-approach",
                "content": "class Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix.length==0){\\n            return 0;\\n        }\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int count = 0;\\n        for(int i = 0; i<row; i++){\\n            for(int j = 1; j<col; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int startCol = 0; startCol<col; startCol++){\\n            for(int currCol = startCol; currCol<col; currCol++){\\n                map.clear();\\n                map.put(0,1);\\n                int sum = 0;\\n                for(int i = 0; i<row; i++){\\n                    sum += matrix[i][currCol] - (startCol>0 ? matrix[i][startCol-1]:0);\\n                    if(map.containsKey(sum-target)){\\n                        count+=map.get(sum-target);\\n                    }\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if(matrix.length==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298693,
                "title": "c-prefix-sum-hashmap",
                "content": "**Explantion:**\\n![image](https://assets.leetcode.com/users/images/adbe68e4-aab2-4e88-af67-a714a7b8ccee_1658133221.2636046.png)\\n\\n\\n**Implementation:**\\n```\\nclass Solution {\\npublic:\\n    // TC-> O(n*m^2)\\n    // SC-> O(n)\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // forming prefix -sum\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        // For each pair of columns, calculate the accumulated sum of rows.\\n        // Now this problem is same as, \"Subarray sum with given Target Sum\".\\n        for(int c1 = 0; c1 < m; c1++){\\n            for(int c2 = c1; c2 < m; c2++){\\n                unordered_map<int, int> mp; // sum->freq\\n                mp[0] = 1;\\n                // cout<<\"c1=\"<<c1<<\" \"<<\"c2=\"<<c2<<\" \";\\n                int sum = 0;\\n                for(int r = 0; r < n; r++){\\n                    sum += matrix[r][c2] - (c1 > 0? matrix[r][c1-1]: 0);\\n                    // cout<<\"r=\"<<r<<\" \"<<\"sum=\"<<sum<<\" \";\\n                    // there exist contiguous sum equal to target\\n                    if(mp.count(sum-target))\\n                        count += mp[sum-target];\\n                    // cout<<\"count=\"<<count<<\" \";\\n                    // add the sum obtained in the map\\n                    mp[sum]++;\\n                }\\n                // cout<<endl;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // TC-> O(n*m^2)\\n    // SC-> O(n)\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        // forming prefix -sum\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        int count = 0;\\n        // For each pair of columns, calculate the accumulated sum of rows.\\n        // Now this problem is same as, \"Subarray sum with given Target Sum\".\\n        for(int c1 = 0; c1 < m; c1++){\\n            for(int c2 = c1; c2 < m; c2++){\\n                unordered_map<int, int> mp; // sum->freq\\n                mp[0] = 1;\\n                // cout<<\"c1=\"<<c1<<\" \"<<\"c2=\"<<c2<<\" \";\\n                int sum = 0;\\n                for(int r = 0; r < n; r++){\\n                    sum += matrix[r][c2] - (c1 > 0? matrix[r][c1-1]: 0);\\n                    // cout<<\"r=\"<<r<<\" \"<<\"sum=\"<<sum<<\" \";\\n                    // there exist contiguous sum equal to target\\n                    if(mp.count(sum-target))\\n                        count += mp[sum-target];\\n                    // cout<<\"count=\"<<count<<\" \";\\n                    // add the sum obtained in the map\\n                    mp[sum]++;\\n                }\\n                // cout<<endl;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2298477,
                "title": "c-approach-straightforward-no-hashmap-beats-99-5",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int numSubArraywTarget(vector<int>& make, int target)\\n    {\\n        int n= make.size();\\n        //find the number of contiguous sub-arrays with sum target\\n        \\n        \\n        int sum=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum=0; \\n            for(int j=i;j<n;j++)\\n            {\\n                sum+= make[j];\\n            \\n                if(sum==target)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> make(m, 0);\\n            \\n            for(int row=i;row<n;row++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    make[j]+= matrix[row][j];        \\n                }\\n                ans+= numSubArraywTarget(make, target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numSubArraywTarget(vector<int>& make, int target)\\n    {\\n        int n= make.size();\\n        //find the number of contiguous sub-arrays with sum target\\n        \\n        \\n        int sum=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum=0; \\n            for(int j=i;j<n;j++)\\n            {\\n                sum+= make[j];\\n            \\n                if(sum==target)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> make(m, 0);\\n            \\n            for(int row=i;row<n;row++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    make[j]+= matrix[row][j];        \\n                }\\n                ans+= numSubArraywTarget(make, target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298443,
                "title": "simple-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n    int m=matrix[0].size();\\n        map<int,int>mp;\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int c1=0; c1<m; c1++){\\n            for(int c2=c1; c2<m; c2++){\\n                mp.clear();\\n                mp[0]=1;\\n                int sum=0;\\n                for(int i=0; i<n; i++){\\n                    sum=sum+matrix[i][c2]-(c1>0?matrix[i][c1-1]: 0);\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        ans=ans+mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n    int m=matrix[0].size();\\n        map<int,int>mp;\\n        for(int i=0; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int ans=0;\\n        for(int c1=0; c1<m; c1++){\\n            for(int c2=c1; c2<m; c2++){\\n                mp.clear();\\n                mp[0]=1;\\n                int sum=0;\\n                for(int i=0; i<n; i++){\\n                    sum=sum+matrix[i][c2]-(c1>0?matrix[i][c1-1]: 0);\\n                    if(mp.find(sum-target)!=mp.end()){\\n                        ans=ans+mp[sum-target];\\n                    }\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298401,
                "title": "java-solution-with-comments-easy-to-understand-t-c-is-o-cols-cols-rows",
                "content": "Please go through the comments to understand the code. Anyone can solve it after getting the intuition. \\n```java\\nclass Solution {\\n    //Approach - we are fixing two columns. Then for it we are iterating row from 0 to rows. For the region\\n    //between the two columns and the row, we are storing this sum in a hashMap with frequencies.\\n    //If sum-target exists then we will increase the count.\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] prefix = new int[rows+1][cols+1];\\n        for(int row = 0; row<rows; ++row){\\n            for(int col = 0; col<cols; ++col){\\n                prefix[row+1][col+1] = matrix[row][col] + prefix[row][col+1] + prefix[row+1][col] - prefix[row][col];\\n            }\\n        }\\n        // for(int i = 0; i<prefix.length; ++i){\\n        //     System.out.println(Arrays.toString(prefix[i]));\\n        // }\\n        int count = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        //fixing two columns\\n        for(int col1 = 0; col1<cols; ++col1){\\n            for(int col2 = col1; col2<cols; ++col2){\\n                map.clear();\\n                //to handle the cases when sum is equal to target.\\n                map.put(0,1);\\n                int sum = 0;\\n                // System.out.printf(\"Col1 :%d , Col2 :%d \\\\n\",col1,col2);\\n                for(int row = 0; row<rows; ++row){\\n                    sum = prefix[row+1][col2+1] - prefix[row+1][col1];\\n                    Integer key = map.get(sum-target);\\n                    if(key != null){\\n                        count += key;\\n                    }\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    // System.out.printf(\"Row : %d , sum = %d \\\\n\",row,sum);\\n                }\\n                // System.out.println();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nWith same approach we can solve it using T.C of O(rows*rows*cols) by fixing two rows and iterating each column for it.\\n",
                "solutionTags": [
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    //Approach - we are fixing two columns. Then for it we are iterating row from 0 to rows. For the region\\n    //between the two columns and the row, we are storing this sum in a hashMap with frequencies.\\n    //If sum-target exists then we will increase the count.\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int[][] prefix = new int[rows+1][cols+1];\\n        for(int row = 0; row<rows; ++row){\\n            for(int col = 0; col<cols; ++col){\\n                prefix[row+1][col+1] = matrix[row][col] + prefix[row][col+1] + prefix[row+1][col] - prefix[row][col];\\n            }\\n        }\\n        // for(int i = 0; i<prefix.length; ++i){\\n        //     System.out.println(Arrays.toString(prefix[i]));\\n        // }\\n        int count = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        //fixing two columns\\n        for(int col1 = 0; col1<cols; ++col1){\\n            for(int col2 = col1; col2<cols; ++col2){\\n                map.clear();\\n                //to handle the cases when sum is equal to target.\\n                map.put(0,1);\\n                int sum = 0;\\n                // System.out.printf(\"Col1 :%d , Col2 :%d \\\\n\",col1,col2);\\n                for(int row = 0; row<rows; ++row){\\n                    sum = prefix[row+1][col2+1] - prefix[row+1][col1];\\n                    Integer key = map.get(sum-target);\\n                    if(key != null){\\n                        count += key;\\n                    }\\n                    map.put(sum,map.getOrDefault(sum,0)+1);\\n                    // System.out.printf(\"Row : %d , sum = %d \\\\n\",row,sum);\\n                }\\n                // System.out.println();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298370,
                "title": "unorder-map-prefix-sum-easy-matrix-hash-map-cpp",
                "content": "\\n\\n## C++ code Easy to Understand ##\\n```\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans=0;\\n        unordered_map<int, int> ump;\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tump = {{0,1}};\\n\\t\\t\\t\\tint curr = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  curr += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\t  ans += ump.find(curr - target) != ump.end() ? ump[curr - target] : 0;\\n\\t\\t\\t\\t  ump[curr]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\\n## Please upvotes if you understood the solution ##",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int ans=0;\\n        unordered_map<int, int> ump;\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\t\\tmatrix[i][j] += matrix[i][j - 1];\\n\\n\\t\\t\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tump = {{0,1}};\\n\\t\\t\\t\\tint curr = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\n\\t\\t\\t\\t  curr += matrix[k][j] - (i > 0 ? matrix[k][i - 1] : 0);\\n\\t\\t\\t\\t  ans += ump.find(curr - target) != ump.end() ? ump[curr - target] : 0;\\n\\t\\t\\t\\t  ump[curr]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298351,
                "title": "c-hashmap-simple-and-easy-to-understand",
                "content": "****please upvote if you like****\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int>mp;\\n                mp[0]=1;\\n                int sum=0;\\n                for(int k=0;k<n;k++){\\n                    sum+=matrix[k][j]-(i==0 ? 0 : matrix[k][i-1]);\\n                    count+=mp[sum-target];\\n                    mp[sum]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n****if you have any trouble to understand you can comment and I will  reply very soon****",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                matrix[i][j]+=matrix[i][j-1];\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=i;j<m;j++){\\n                unordered_map<int,int>mp;\\n                mp[0]=1;\\n                int sum=0;\\n                for(int k=0;k<n;k++){\\n                    sum+=matrix[k][j]-(i==0 ? 0 : matrix[k][i-1]);\\n                    count+=mp[sum-target];\\n                    mp[sum]+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298305,
                "title": "c-prefixsum-hashing",
                "content": "This question is advancement of the question \"finding the count of subarrays with a given sum\"\\nThere we used to find the subarray sum in horizontal array but here we will consider vertical array\\nWe will check for every combination of coloums that 0 0, 0 1, 0 2, etc then 1 1, 1 2, 1 3 etc similarly other also\\nThe elements in our considered array will be sum of element from col1 to col2 of that particular row\\nFor that we will precompute the sum of a particular row (we will change our original row with the presum row)i.e each element in a particular row will chaged to the prefix sum upto it (this will help us to get the sum between col2 and col1 in O(1) time\\nNow when we have our elements we will do the same thing we do for finding the subarray with a given sum\\n\\n```\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int row = 0; row<m; row++) \\n        {\\n            for(int col = 1; col<n; col++)\\n            {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        int count = 0; \\n        for(int col1 = 0; col1<n; col1++) \\n        {\\n            for(int col2 = col1; col2<n; col2++)\\n            {\\n                int sum = 0; // now the same thing which we do to find subarray problem\\n                unordered_map<int, int>um;\\n                for(int row = 0; row<m; row++) // to get all the elements from top to down\\n                {\\n                    int val = matrix[row][col2] - (col1>0?matrix[row][col1-1]:0); \\n                    sum += val; \\n                    if(sum == target) // this is to check if our prefix is itself equal to given target so we have to compute it independentally\\n                    {\\n                        count++;\\n                    }\\n                    if(um.find(sum-target) != um.end())\\n                    {\\n                        count += um[sum-target];\\n                    }\\n                    um[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\nUpvote if found usefull",
                "solutionTags": [],
                "code": "```\\n   int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int row = 0; row<m; row++) \\n        {\\n            for(int col = 1; col<n; col++)\\n            {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        int count = 0; \\n        for(int col1 = 0; col1<n; col1++) \\n        {\\n            for(int col2 = col1; col2<n; col2++)\\n            {\\n                int sum = 0; // now the same thing which we do to find subarray problem\\n                unordered_map<int, int>um;\\n                for(int row = 0; row<m; row++) // to get all the elements from top to down\\n                {\\n                    int val = matrix[row][col2] - (col1>0?matrix[row][col1-1]:0); \\n                    sum += val; \\n                    if(sum == target) // this is to check if our prefix is itself equal to given target so we have to compute it independentally\\n                    {\\n                        count++;\\n                    }\\n                    if(um.find(sum-target) != um.end())\\n                    {\\n                        count += um[sum-target];\\n                    }\\n                    um[sum]++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298179,
                "title": "c-solution",
                "content": "Based on  [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0;\\n        for(int i = 0; i < matrix.Length; i++){\\n            int[] nums = new int[matrix[0].Length];\\n            for(int j = i; j < matrix.Length; j++){\\n                for(int c = 0; c < matrix[0].Length; c++){\\n                    nums[c] += matrix[j][c];\\n                }\\n                res += getNumOfSubarrays(nums, target);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    private int getNumOfSubarrays(int[] nums, int k){\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        map.Add(0,1);\\n        int res = 0, sum = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            sum += nums[i];\\n            if(map.ContainsKey(sum-k)){\\n                res += map[sum-k];\\n            }\\n            if(map.ContainsKey(sum))\\n                map[sum]++;\\n            else\\n                map.Add(sum,1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        int res = 0;\\n        for(int i = 0; i < matrix.Length; i++){\\n            int[] nums = new int[matrix[0].Length];\\n            for(int j = i; j < matrix.Length; j++){\\n                for(int c = 0; c < matrix[0].Length; c++){\\n                    nums[c] += matrix[j][c];\\n                }\\n                res += getNumOfSubarrays(nums, target);\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n    private int getNumOfSubarrays(int[] nums, int k){\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        map.Add(0,1);\\n        int res = 0, sum = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            sum += nums[i];\\n            if(map.ContainsKey(sum-k)){\\n                res += map[sum-k];\\n            }\\n            if(map.ContainsKey(sum))\\n                map[sum]++;\\n            else\\n                map.Add(sum,1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298127,
                "title": "python-code-with-itertools",
                "content": "```\\nclass Solution:\\n  def numSubmatrixSumTarget(self, M: List[List[int]], t: int) -> int:\\n    res,rs = 0,[list(accumulate(r,operator.add))+[0] for r in M]\\n    for y1,y2 in combinations(range(-1,len(M[0])),2):\\n      su,d = 0,{0:1}\\n      for r in rs:\\n        su += r[y2] - r[y1]\\n        res += d.get(su-t,0)\\n        d[su] = d.get(su,0) + 1\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def numSubmatrixSumTarget(self, M: List[List[int]], t: int) -> int:\\n    res,rs = 0,[list(accumulate(r,operator.add))+[0] for r in M]\\n    for y1,y2 in combinations(range(-1,len(M[0])),2):\\n      su,d = 0,{0:1}\\n      for r in rs:\\n        su += r[y2] - r[y1]\\n        res += d.get(su-t,0)\\n        d[su] = d.get(su,0) + 1\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298022,
                "title": "easy-understanding",
                "content": "def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        xlen, ylen, ans, res = len(matrix[0]), len(matrix), 0, defaultdict(int)\\n        for r in matrix:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res.clear()\\n                res[0], csum = 1, 0\\n                for i in range(ylen):\\n                    csum += matrix[i][k] - (matrix[i][j-1] if j else 0)\\n                    ans += res[csum - target]\\n                    res[csum] += 1\\n        return ans\\n\\t\\t\\n\\t\\t##just lemme know if you have any doubt\\n\\t\\t##Happy Coding Guys",
                "solutionTags": [
                    "Python"
                ],
                "code": "def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        xlen, ylen, ans, res = len(matrix[0]), len(matrix), 0, defaultdict(int)\\n        for r in matrix:\\n            for j in range(1, xlen):\\n                r[j] += r[j-1]\\n        for j in range(xlen):\\n            for k in range(j, xlen):\\n                res.clear()\\n                res[0], csum = 1, 0\\n                for i in range(ylen):\\n                    csum += matrix[i][k] - (matrix[i][j-1] if j else 0)\\n                    ans += res[csum - target]\\n                    res[csum] += 1\\n        return ans\\n\\t\\t\\n\\t\\t##just lemme know if you have any doubt\\n\\t\\t##Happy Coding Guys",
                "codeTag": "Python3"
            },
            {
                "id": 2297606,
                "title": "rust-prefix-sum-dp-hashmap-for-o-m-n-n",
                "content": "Firstly make a basic prefix sum DP solution for O(m * m * n * n) time.\\n```rust\\npub fn num_submatrix_sum_target_old(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for x in 0..i + 1 {\\n                for y in 0..j + 1 {\\n                    if dp[i + 1][j + 1] - dp[i + 1][y] - (dp[x][j + 1] - dp[x][y]) == target {\\n                        ans += 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\\nThen we can find that the count of previous results of `dp[x][j + 1] - dp[x][y]` can be grouped up with a HashMap. Simple modification but having a O(m * n * n) space HashMap.\\n```rust\\npub fn num_submatrix_sum_target_hash(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    let mut hash: HashMap<(usize, usize, i32), i32> = HashMap::new();\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            hash.insert((y, j + 1, 0), 1);\\n        }\\n    }\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for y in 0..j + 1 {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(y, j + 1, diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry((y, j + 1, diff)).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\\nThen optimize the HashMap space usage by eliminating the `(y, j + 1)` part, making it O(n) space.\\n```rust\\npub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n        }\\n    }\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            let mut hash: HashMap<i32, i32> = HashMap::new();\\n            hash.insert(0, 1);\\n            for i in 0..matrix.len() {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry(diff).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```rust\\npub fn num_submatrix_sum_target_old(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for x in 0..i + 1 {\\n                for y in 0..j + 1 {\\n                    if dp[i + 1][j + 1] - dp[i + 1][y] - (dp[x][j + 1] - dp[x][y]) == target {\\n                        ans += 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\n```rust\\npub fn num_submatrix_sum_target_hash(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;        \\n    let mut hash: HashMap<(usize, usize, i32), i32> = HashMap::new();\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            hash.insert((y, j + 1, 0), 1);\\n        }\\n    }\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            for y in 0..j + 1 {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(y, j + 1, diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry((y, j + 1, diff)).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```\n```rust\\npub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n    let mut dp = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];\\n    let mut ans = 0;\\n    for i in 0..matrix.len() {\\n        for j in 0..matrix[0].len() {\\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n        }\\n    }\\n    for j in 0..matrix[0].len() {\\n        for y in 0..j + 1 {\\n            let mut hash: HashMap<i32, i32> = HashMap::new();\\n            hash.insert(0, 1);\\n            for i in 0..matrix.len() {\\n                let diff = dp[i + 1][j + 1] - dp[i + 1][y];\\n                if let Some(c) = hash.get(&(diff - target)) {\\n                    ans += c;\\n                }\\n                *hash.entry(diff).or_insert(0) += 1;\\n            }\\n        }\\n    }\\n    ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297328,
                "title": "easy-to-understand-python-solution",
                "content": "Time Complexity -  O(m*n*n)\\nSpace Complexity - O(m*n)\\n\\nm,n - no. of rows, cols of matrix\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m,n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(1,n):\\n                matrix[i][j] += matrix[i][j-1]\\n        \\n        # print(matrix)\\n        ans = 0\\n        #submatrix column division for each pair of columns\\n        for sc1 in range(n):\\n            for sc2 in range(sc1,n):\\n                d = collections.defaultdict(int)\\n                ## sum 0\\n                d[0] = 1\\n                #submatrix sum\\n                s = 0\\n                for i in range(m):\\n                    s += matrix[i][sc2]\\n                    #remove previous column sums\\n                    if sc1:\\n                        s -= matrix[i][sc1-1]\\n                    ans += d[s-target]\\n                    d[s] += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m,n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(1,n):\\n                matrix[i][j] += matrix[i][j-1]\\n        \\n        # print(matrix)\\n        ans = 0\\n        #submatrix column division for each pair of columns\\n        for sc1 in range(n):\\n            for sc2 in range(sc1,n):\\n                d = collections.defaultdict(int)\\n                ## sum 0\\n                d[0] = 1\\n                #submatrix sum\\n                s = 0\\n                for i in range(m):\\n                    s += matrix[i][sc2]\\n                    #remove previous column sums\\n                    if sc1:\\n                        s -= matrix[i][sc1-1]\\n                    ans += d[s-target]\\n                    d[s] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215262,
                "title": "c-using-prefix-matrix",
                "content": "```\\n/**\\n   @brief   First thing about this problem. its constraints demand O(m*n*n) solution. So dont waste your time thinking of something better.\\n            Now, you must have noted the fact that in problems where we have to store the data of a submatrix or something like that, we go\\n            with prefix matrix. Like in the question, Largest Area of Rectangle, we did the same. Here too, we do the same. We make a prefix\\n            matrix, storing the sum of all the elements in a coloumn upto current cell. Now, we use this prefix matrix to compute our answer.\\n            So, as i said, this question demands a O(n^3), the third loop is actually to set a region of rows to be processed at a time. So\\n            we move down, row wise, and at each row, we proces all the submatrices, that could be formed between any row above it and current \\n            row. Therefore, we run another loop, r, which starts from 0 to i, and using this loop, we update the current prefix row, by subtracting\\n            the values on that row, so that to eliminate all the subarrays above row r. Then, we will have a single array, the current row with \\n            updated values, and we compute our answer with that. Doing so for all the row pairs will give our final answer. \\n\\n */\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> prefix(m,vector<int>(n,0));\\n        for(int j = 0; j<n; j++){\\n            int sum = 0;\\n            for(int i = 0; i<m; i++){\\n                sum += matrix[i][j];\\n                prefix[i][j] = sum;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<m; i++){\\n            for(int r = 0; r<=i; r++){\\n                vector <int> arr = prefix[i];\\n                if(r==i) ans += fun(arr,target);\\n                else{\\n                    for(int j = 0; j<n; j++) arr[j] -= prefix[r][j];\\n                    ans += fun(arr,target);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int fun(vector<int>&arr, int target){\\n        unordered_map <int,int> mp;\\n        int sum = 0, ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            sum += arr[i];\\n            if(sum == target) ans++;\\n            if(mp.find(sum-target)!=mp.end()) ans += mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n   @brief   First thing about this problem. its constraints demand O(m*n*n) solution. So dont waste your time thinking of something better.\\n            Now, you must have noted the fact that in problems where we have to store the data of a submatrix or something like that, we go\\n            with prefix matrix. Like in the question, Largest Area of Rectangle, we did the same. Here too, we do the same. We make a prefix\\n            matrix, storing the sum of all the elements in a coloumn upto current cell. Now, we use this prefix matrix to compute our answer.\\n            So, as i said, this question demands a O(n^3), the third loop is actually to set a region of rows to be processed at a time. So\\n            we move down, row wise, and at each row, we proces all the submatrices, that could be formed between any row above it and current \\n            row. Therefore, we run another loop, r, which starts from 0 to i, and using this loop, we update the current prefix row, by subtracting\\n            the values on that row, so that to eliminate all the subarrays above row r. Then, we will have a single array, the current row with \\n            updated values, and we compute our answer with that. Doing so for all the row pairs will give our final answer. \\n\\n */\\n\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<vector<int>> prefix(m,vector<int>(n,0));\\n        for(int j = 0; j<n; j++){\\n            int sum = 0;\\n            for(int i = 0; i<m; i++){\\n                sum += matrix[i][j];\\n                prefix[i][j] = sum;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<m; i++){\\n            for(int r = 0; r<=i; r++){\\n                vector <int> arr = prefix[i];\\n                if(r==i) ans += fun(arr,target);\\n                else{\\n                    for(int j = 0; j<n; j++) arr[j] -= prefix[r][j];\\n                    ans += fun(arr,target);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int fun(vector<int>&arr, int target){\\n        unordered_map <int,int> mp;\\n        int sum = 0, ans = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            sum += arr[i];\\n            if(sum == target) ans++;\\n            if(mp.find(sum-target)!=mp.end()) ans += mp[sum-target];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190325,
                "title": "c-brute-force-o-m-m-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>pref;\\n    int getVal(int i,int j){\\n        if(i < 0 || j < 0 || i>=pref.size() || j>=pref[0].size())\\n            return 0;\\n        return pref[i][j];\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        pref.assign(m,vector<int>(n,0));\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                pref[i][j] = matrix[i][j] + getVal(i-1,j) + getVal(i,j-1) - getVal(i-1,j-1);\\n            }\\n        }\\n        int ans = 0;\\n        for(int r1 = 0;r1<m;r1++){\\n            for(int r2 = r1;r2<m;r2++){\\n                for(int c1 = 0;c1<n;c1++){\\n                    for(int c2 = c1;c2<n;c2++){\\n                        int sum = pref[r2][c2] - getVal(r2,c1-1) - getVal(r1-1,c2) + getVal(r1-1,c1-1);\\n                        if(sum == target)\\n                            ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>pref;\\n    int getVal(int i,int j){\\n        if(i < 0 || j < 0 || i>=pref.size() || j>=pref[0].size())\\n            return 0;\\n        return pref[i][j];\\n    }\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        pref.assign(m,vector<int>(n,0));\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                pref[i][j] = matrix[i][j] + getVal(i-1,j) + getVal(i,j-1) - getVal(i-1,j-1);\\n            }\\n        }\\n        int ans = 0;\\n        for(int r1 = 0;r1<m;r1++){\\n            for(int r2 = r1;r2<m;r2++){\\n                for(int c1 = 0;c1<n;c1++){\\n                    for(int c2 = c1;c2<n;c2++){\\n                        int sum = pref[r2][c2] - getVal(r2,c1-1) - getVal(r1-1,c2) + getVal(r1-1,c1-1);\\n                        if(sum == target)\\n                            ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146393,
                "title": "easy-accepted-c-code-with-explanation-and-analysis-of-analogy-with-1d-array-question",
                "content": "Question :- To find number of subarrays with sum = target. \\n\\nConcept :- We have total 3 ways to do :- One is sliding window, second is niave by taking all possible subarrays and third is O(n) approach using prefix sum and map which stores all occured prefix sums till current index.\\n\\nSo, first two approaches are straightforward, lets discuss third approach :-\\n\\nCrux :- We iterate from left to right and continuously calculate prefix sum at each index and also storing them in a map and also at current index, we apply map.find(prefix sum - target), if found then we increment our answer or count by map[prefix sum - target] means frequency of compliment (prefix sum - target) already occured.\\n\\nWhat it indicates :- Suppose we have an array and we are at current index 5, means we have already stored all previous prefix sums in map. So, current prefix sum - target = value and if this value exists in map, means the subarray from the index after that found previous sum till current index has a sum = target.\\n\\nSo, if this value has occured for suppose 3 times, means there are 3 subarays which are ending at current index with sum = target and starting after the index till which previous found value has occured.\\n\\nSo, in this way we can calculate all the subarrays with sum = target.\\n\\n\\n\\nNow, we have to just use this concept to solve it for a matrix :-\\n\\nSuppose we have a matrix of size (n * m) , means each row has m elements. \\nThink matrix as a 1d array, BUT we have to find what elements actually matching the analogy with 1d array elements which we discussed above then only we can solve it for matrix.\\n\\nSo, if we think, we can use each row with total m^2 ranges from any left column till any right column, so for this we use all pairs of columns as extremes and consider the range of all rows between current pair of columns inclusive both.\\n\\nSo, the sum of each row elements in the given current range will be considered as the analogy elements of a 1d array.\\n\\nSo for any current range, we have n (number of rows of matrix) elements which are actually the sum of elements in this range for each ith row.\\n\\nNow apply same concept as we did in 1d array case, the only difference is that there we had only 1 occurence of working, here we have m^2 occurences of working, for each possible range of row.\\n\\nNOTE :- Why we are considering all possible ranges in each row? \\n\\nSuppose we have 5 columns or 5 elements in each row then we can select any possible range of continuous elements to form a submatrix whose column length will be this range\\'s length.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> prefix_row(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    prefix_row[i][j] = matrix[i][j];\\n                }\\n                else\\n                {\\n                    prefix_row[i][j] = prefix_row[i][j-1] + matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int lc=0;lc<m;lc++)\\n        {\\n            for(int rc=lc;rc<m;rc++)\\n            {\\n                map<int,int> m;\\n                int prefix = 0;\\n                \\n                m[0] = 1;\\n                \\n                for(int i=0;i<n;i++)\\n                {\\n                    if(lc == 0)\\n                    {\\n                        prefix += prefix_row[i][rc];\\n                    }\\n                    else\\n                    {\\n                        prefix += prefix_row[i][rc] - prefix_row[i][lc - 1];\\n                    }\\n                    \\n                    if(m.find(prefix - target) != m.end())\\n                    {\\n                        res += m[prefix - target];\\n                    }\\n                    \\n                    m[prefix]++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> prefix_row(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    prefix_row[i][j] = matrix[i][j];\\n                }\\n                else\\n                {\\n                    prefix_row[i][j] = prefix_row[i][j-1] + matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        for(int lc=0;lc<m;lc++)\\n        {\\n            for(int rc=lc;rc<m;rc++)\\n            {\\n                map<int,int> m;\\n                int prefix = 0;\\n                \\n                m[0] = 1;\\n                \\n                for(int i=0;i<n;i++)\\n                {\\n                    if(lc == 0)\\n                    {\\n                        prefix += prefix_row[i][rc];\\n                    }\\n                    else\\n                    {\\n                        prefix += prefix_row[i][rc] - prefix_row[i][lc - 1];\\n                    }\\n                    \\n                    if(m.find(prefix - target) != m.end())\\n                    {\\n                        res += m[prefix - target];\\n                    }\\n                    \\n                    m[prefix]++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108120,
                "title": "c-2d-prefix-sum",
                "content": "```\\n// Time complexity = O(M*N*N) where M = number of rows in matrix, N = number of columns in matrix\\nclass Solution {\\nprivate:\\n    int get2dSum(vector<vector<int>> &ps, int c1, int c2, int r) {\\n        return ps[r + 1][c2 + 1] - ps[r + 1][c1];\\n    }\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rSize = matrix.size();\\n        int cSize = matrix[0].size();\\n        vector<vector<int>> ps(rSize + 1, vector<int>(cSize + 1, 0));\\n        \\n        for (int r = 1; r <= rSize; r++) {\\n            for (int c = 1; c <= cSize; c++) {\\n                ps[r][c] = ps[r - 1][c] + ps[r][c - 1] - ps[r - 1][c - 1] + matrix[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        unordered_map<int, int> prevSum;\\n        for (int c1 = 0; c1 < cSize; c1++) {\\n            for (int c2 = c1; c2 < cSize; c2++) {\\n                prevSum[0] = 1;\\n                for (int r = 0; r < rSize; r++) {\\n                    int currSum = get2dSum(ps, c1, c2, r);\\n                    if (prevSum.count(currSum - target)) {\\n                        res += prevSum[currSum -target];\\n                    }\\n                    prevSum[currSum]++;\\n                }\\n                prevSum.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n// Time complexity = O(M*N*N) where M = number of rows in matrix, N = number of columns in matrix\\nclass Solution {\\nprivate:\\n    int get2dSum(vector<vector<int>> &ps, int c1, int c2, int r) {\\n        return ps[r + 1][c2 + 1] - ps[r + 1][c1];\\n    }\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rSize = matrix.size();\\n        int cSize = matrix[0].size();\\n        vector<vector<int>> ps(rSize + 1, vector<int>(cSize + 1, 0));\\n        \\n        for (int r = 1; r <= rSize; r++) {\\n            for (int c = 1; c <= cSize; c++) {\\n                ps[r][c] = ps[r - 1][c] + ps[r][c - 1] - ps[r - 1][c - 1] + matrix[r - 1][c - 1];\\n            }\\n        }\\n        \\n        int res = 0;\\n        \\n        unordered_map<int, int> prevSum;\\n        for (int c1 = 0; c1 < cSize; c1++) {\\n            for (int c2 = c1; c2 < cSize; c2++) {\\n                prevSum[0] = 1;\\n                for (int r = 0; r < rSize; r++) {\\n                    int currSum = get2dSum(ps, c1, c2, r);\\n                    if (prevSum.count(currSum - target)) {\\n                        res += prevSum[currSum -target];\\n                    }\\n                    prevSum[currSum]++;\\n                }\\n                prevSum.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039528,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int res = 0;\\n        \\n        // traverse upper boundary\\n        for (int top = 0; top < m; top++) {\\n            \\n            // for each upper boundary, we have a prefix sum array\\n            int[] sum = new int[n];\\n            \\n            // traverse lower boundary\\n            for (int bottom = top; bottom < m; bottom++) {\\n                \\n                // count the prefix sum for each column\\n                for (int col = 0; col < n; col++) {\\n                    sum[col] += matrix[bottom][col];\\n                }\\n          \\n                // traverse left and right boundary\\n                for (int left = 0; left < n; left++) {\\n                    int cnt = 0;\\n                    for (int right = left; right < n; right++) {\\n                        cnt += sum[right];\\n                        if (cnt == target) res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int res = 0;\\n        \\n        // traverse upper boundary\\n        for (int top = 0; top < m; top++) {\\n            \\n            // for each upper boundary, we have a prefix sum array\\n            int[] sum = new int[n];\\n            \\n            // traverse lower boundary\\n            for (int bottom = top; bottom < m; bottom++) {\\n                \\n                // count the prefix sum for each column\\n                for (int col = 0; col < n; col++) {\\n                    sum[col] += matrix[bottom][col];\\n                }\\n          \\n                // traverse left and right boundary\\n                for (int left = 0; left < n; left++) {\\n                    int cnt = 0;\\n                    for (int right = left; right < n; right++) {\\n                        cnt += sum[right];\\n                        if (cnt == target) res++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873139,
                "title": "java-solution-easy-to-understand-tc-o-mnn-space-o-m",
                "content": "Preaquis: 560. Subarray Sum Equals K\\n\\nExplanation\\n* For each row, calculate the prefix sum.\\n* For each pair of columns,\\n* calculate the accumulated sum of rows.\\n* Now this problem is same to, \"Find the Subarray with Target Sum\".\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nCredit: https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/discuss/803353/Java-Solution-with-Detailed-Explanation",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int res = 0;\\n        //int[][] sum = new int[row][col];\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                //sum[i][j] =sum[i][j-1] + matrix[i][j-1];\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        \\n        for(int start = 0; start < col; start++){\\n            for(int end = start; end < col; end++){\\n                int subMatrixSum = 0;\\n                \\n                Map<Integer, Integer> countElm = new HashMap<Integer, Integer>();\\n                countElm.put(0,1);\\n                \\n                for(int k = 0; k < row; k++){\\n                    //subMatrixSum += sum[k][end] - sum[k][start];\\n                    int prefixSum = start == 0 ? 0:matrix[k][start-1];\\n                    subMatrixSum += matrix[k][end] - prefixSum;\\n                    \\n                    if(countElm.containsKey(subMatrixSum - target))\\n                        res += countElm.get(subMatrixSum - target);\\n                    \\n                    int r = countElm.getOrDefault(subMatrixSum, 0);\\n                    countElm.put(subMatrixSum, r+1);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596840,
                "title": "c-o-n-3-cumulative-sum-compress-rows",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n\\n        int ans = 0;\\n\\n        for(int topBoundary = 0; topBoundary<R; topBoundary++){\\n\\n            vector<int> nums(C,0);\\n\\n            for(int bottomBoundary = topBoundary; bottomBoundary<R; bottomBoundary++){\\n                \\n                for(int j=0;j<C;j++)    nums[j] += matrix[bottomBoundary][j];\\n\\n                // Now do exactly this: https://leetcode.com/problems/subarray-sum-equals-k/\\n                unordered_map<int,int> mp; // <cumulative sum , number of such subarrays>\\n                mp[0] = +1;\\n\\n                int cumuSum = 0;\\n                for(int i=0;i<C;i++){\\n                    \\n                    cumuSum += nums[i];\\n                    ans += (mp.count(cumuSum - target) > 0 ? mp[cumuSum - target] : 0);\\n                    mp[cumuSum] ++;\\n\\n                }\\n                //---------------------------------------------------------------------------\\n            }\\n\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n\\n        int ans = 0;\\n\\n        for(int topBoundary = 0; topBoundary<R; topBoundary++){\\n\\n            vector<int> nums(C,0);\\n\\n            for(int bottomBoundary = topBoundary; bottomBoundary<R; bottomBoundary++){\\n                \\n                for(int j=0;j<C;j++)    nums[j] += matrix[bottomBoundary][j];\\n\\n                // Now do exactly this: https://leetcode.com/problems/subarray-sum-equals-k/\\n                unordered_map<int,int> mp; // <cumulative sum , number of such subarrays>\\n                mp[0] = +1;\\n\\n                int cumuSum = 0;\\n                for(int i=0;i<C;i++){\\n                    \\n                    cumuSum += nums[i];\\n                    ans += (mp.count(cumuSum - target) > 0 ? mp[cumuSum - target] : 0);\\n                    mp[cumuSum] ++;\\n\\n                }\\n                //---------------------------------------------------------------------------\\n            }\\n\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579357,
                "title": "c-explained-with-stepwise-algorithm-prefix-sum-hash-table",
                "content": "**Algorithm**\\n1.  find prefix sum of matrix\\n2.  take a pair of rows(r1 and r2) and traverse along row.\\n3.  while traversing along the row for each column, find submatrix Sum between r1 and r2 using prefix sum in O(1) time.\\n4.  check if the sum - target is already present in map (i.e sumatrix with sum = sum - target is present) and increase the count accordingly\\n5.  now put the sum in map and increase its count.\\n\\n**Note-**\\nfor r1 = 0, there is no *sub*matrix so take sum of submatrix for r2 only\\n**Upvote Please!**\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int target) {\\n        \\n        int r = m.size(), c = m[0].size();\\n        int res = 0;\\n        for(int i = 1;i < c; i++)\\n            m[0][i] += m[0][i-1];\\n        for(int i = 1; i < r; i++)\\n            m[i][0] += m[i-1][0];\\n        for(int i = 1; i < r; i++)\\n            for(int j = 1; j < c; j++)\\n                m[i][j] += m[i-1][j] + m[i][j-1] - m[i-1][j-1];\\n        \\n        for(int r1 = 0; r1 < r; r1++)\\n        {\\n            for(int r2 = r1; r2 < r; r2++)\\n            {\\n                unordered_map<int, int> map;\\n                map[0]++;\\n                for(int y = 0; y < c; y++)\\n                {\\n                    int sum = m[r2][y];\\n                    if(r1 != 0)sum -= m[r1-1][y];\\n                    if(map.find(sum-target) != map.end())res+= map[sum-target];\\n                    map[sum]++;\\n                }\\n            }\\n        }\\n        return res;                \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int target) {\\n        \\n        int r = m.size(), c = m[0].size();\\n        int res = 0;\\n        for(int i = 1;i < c; i++)\\n            m[0][i] += m[0][i-1];\\n        for(int i = 1; i < r; i++)\\n            m[i][0] += m[i-1][0];\\n        for(int i = 1; i < r; i++)\\n            for(int j = 1; j < c; j++)\\n                m[i][j] += m[i-1][j] + m[i][j-1] - m[i-1][j-1];\\n        \\n        for(int r1 = 0; r1 < r; r1++)\\n        {\\n            for(int r2 = r1; r2 < r; r2++)\\n            {\\n                unordered_map<int, int> map;\\n                map[0]++;\\n                for(int y = 0; y < c; y++)\\n                {\\n                    int sum = m[r2][y];\\n                    if(r1 != 0)sum -= m[r1-1][y];\\n                    if(map.find(sum-target) != map.end())res+= map[sum-target];\\n                    map[sum]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1526961,
                "title": "python-solution-with-600ms",
                "content": "```\\nimport numpy as np\\nimport copy\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        xs, ys = len(matrix), len(matrix[0])\\n        res = []\\n        for x1 in range(xs):\\n            #x2 = x1\\n            line = []\\n            for y1 in range(ys):\\n                prev = 0\\n                for y2 in range(y1, ys):\\n                    prev += matrix[x1][y2]\\n                    line += [prev]\\n            res += [line]\\n        res = np.array(res)\\n        tmp = copy.deepcopy(res)\\n        tot = np.sum(tmp == target)\\n        for step in range(1, xs):\\n            tmp = tmp[:-1] + res[step:]\\n            tot += np.sum(tmp == target)\\n        return tot\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nimport copy\\nclass Solution(object):\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        xs, ys = len(matrix), len(matrix[0])\\n        res = []\\n        for x1 in range(xs):\\n            #x2 = x1\\n            line = []\\n            for y1 in range(ys):\\n                prev = 0\\n                for y2 in range(y1, ys):\\n                    prev += matrix[x1][y2]\\n                    line += [prev]\\n            res += [line]\\n        res = np.array(res)\\n        tmp = copy.deepcopy(res)\\n        tot = np.sum(tmp == target)\\n        for step in range(1, xs):\\n            tmp = tmp[:-1] + res[step:]\\n            tot += np.sum(tmp == target)\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435108,
                "title": "c-easy-peasy-solution",
                "content": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=1;j<n;j++){\\n                \\n                matrix[i][j]+=matrix[i][j-1];\\n                \\n            }\\n            \\n        }\\n        \\n        for(int c1=0;c1<n;c1++){\\n            \\n            for(int c2=c1;c2<n;c2++){\\n                \\n                map<int,int>mp;\\n                mp[0]=1;\\n                int sum=0;\\n                \\n                for(int row=0;row<m;row++){\\n                    \\n                    sum+=matrix[row][c2]-(c1>0?matrix[row][c1-1]:0);\\n                    \\n                    count+=mp[sum-target];\\n                    \\n                    mp[sum]++;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        \\n        int count=0;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=1;j<n;j++){\\n                \\n                matrix[i][j]+=matrix[i][j-1];\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1434544,
                "title": "o-n-3-converting-to-1d-then-applying-kadane",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans=0;\\n        int dp[m];\\n        for(int i=0;i<n;i++){\\n            memset(dp,0,sizeof(dp));\\n            for(int j=i;j<n;j++){\\n                int cs=0;\\n                unordered_map<int,int>maps;\\n                maps[0]=1;\\n                for(int k=0;k<m;k++){\\n                    dp[k]+=mat[j][k];\\n                    cs+=dp[k];\\n                    if(maps.find(cs-target)!=maps.end()){\\n                        ans+=maps[cs-target];\\n                    }\\n                    maps[cs]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int ans=0;\\n        int dp[m];\\n        for(int i=0;i<n;i++){\\n            memset(dp,0,sizeof(dp));\\n            for(int j=i;j<n;j++){\\n                int cs=0;\\n                unordered_map<int,int>maps;\\n                maps[0]=1;\\n                for(int k=0;k<m;k++){\\n                    dp[k]+=mat[j][k];\\n                    cs+=dp[k];\\n                    if(maps.find(cs-target)!=maps.end()){\\n                        ans+=maps[cs-target];\\n                    }\\n                    maps[cs]++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287019,
                "title": "c-prefix-sum-solution",
                "content": "**Intuition**\\n![image](https://assets.leetcode.com/users/images/95b29370-2238-46b5-a12b-5146389b9037_1624256582.071004.png)\\n\\n**complexity**\\n- time: O(M^2 * N) where M is the number of rows of matrix, N is the number of columns of matrix\\n- space: O(MN)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return 0;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n            \\n        // Key: rangeSum, Value: count\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        int cnt = 0;\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {\\n                dic.Clear();\\n                // count of range sum starting with 0-th element\\n                dic.Add(0,1);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    // fix r1, then move r2 to enlarge the range\\n                    // prefixSum[r1 - 1,col] dentoes the sum of r1-th row\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1 - 1,col];\\n                    \\n                    // rangeSum - need = target\\n                    int need = rangeSum - target;\\n                    if(dic.ContainsKey(need))\\n                        cnt += dic[need];\\n                    \\n                    if(dic.ContainsKey(rangeSum))\\n                        dic[rangeSum]++;\\n                    else\\n                        dic.Add(rangeSum,1);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        if(matrix == null || matrix.Length == 0)\\n            return 0;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] prefixSum = new int[m + 1, n + 1];\\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)      \\n            {\\n                // prefixSum[i,j] denotes the sum of elements between matrix[0][0] ~ matrix[i-1][j-1]\\n                prefixSum[i,j] = prefixSum[i-1,j] + prefixSum[i,j-1] - prefixSum[i-1,j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n            \\n        // Key: rangeSum, Value: count\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        int cnt = 0;\\n        for(int r1 = 1; r1 <= m; r1++)\\n        {\\n            for(int r2 = r1; r2 <= m; r2++)\\n            {\\n                dic.Clear();\\n                // count of range sum starting with 0-th element\\n                dic.Add(0,1);\\n                \\n                for(int col = 1; col <= n; col++)\\n                {\\n                    // fix r1, then move r2 to enlarge the range\\n                    // prefixSum[r1 - 1,col] dentoes the sum of r1-th row\\n                    int rangeSum = prefixSum[r2,col] - prefixSum[r1 - 1,col];\\n                    \\n                    // rangeSum - need = target\\n                    int need = rangeSum - target;\\n                    if(dic.ContainsKey(need))\\n                        cnt += dic[need];\\n                    \\n                    if(dic.ContainsKey(rangeSum))\\n                        dic[rangeSum]++;\\n                    else\\n                        dic.Add(rangeSum,1);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250673,
                "title": "java-vs-python3-brute-force-with-prefixes-java-succeeds-python-fails",
                "content": "Trying brute-force with prefixes in different languages, i.e., caclulating 2D prefix sums and iterating over every submatrice. \\nThis is a great example to see how Python execution time suffers when using plain `for` loops.\\nDoing this in Java, it succeeds all tests after 250 ms. Doing the same in Python3 fails with `Time Limit Exceeded`, i.e., >10s. \\n\\n**Java 250 ms**\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] prefixes = calculatePrefixes(matrix);\\n        int ans = 0;\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                for(int a=i; a<=m; a++) {\\n                    for(int b=j; b<=n; b++) {\\n                        if(prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target) {\\n                            ans += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int[][] calculatePrefixes(int[][] matrix) {\\n        int[][] prefixes = new int[matrix.length + 1][matrix[0].length + 1];\\n        prefixes[0] = new int[matrix[0].length + 1];\\n        for(int i=0; i<=matrix[0].length; i++) {\\n            prefixes[0][i] = 0;\\n        }\\n\\n        for(int i=1; i<=matrix.length; i++) {\\n            prefixes[i][0] = 0;\\n            for(int j=1; j<=matrix[0].length; j++) {\\n                prefixes[i][j] = prefixes[i][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n\\n        for(int j=1; j<=matrix[0].length; j++) {\\n            for(int i=1; i<=matrix.length; i++) {\\n                prefixes[i][j] += prefixes[i-1][j];\\n            }\\n        }\\n\\n        return prefixes;\\n    }\\n}\\n```\\n\\n**Python3 - Time Limit Exceeded**\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # 2d prefix sums with [0] prefix:\\n        # accumulate rows -> transpose -> accumulate rows -> transpose\\n\\t\\t# calculating the 2D prefixes takes around 10-20 ms\\n        acc_rows = [list(accumulate(row)) for row in matrix]\\n        transposed = [list(tup) for tup in zip(*acc_rows)]\\n        acc_rows = [[0]*m] + [list(accumulate(row)) for row in transposed]\\n        prefixes = [[0]*(n+1)] + [list(tup) for tup in zip(*acc_rows)]\\n        \\n\\t\\t# access to local variables is much faster than to global\\n\\t\\tr = range\\n\\t\\t\\n        # Iterate over all submatrices\\n        for i in r(1, m+1):\\n            for j in r(1, n+1):\\n                for a in r(i, m+1):\\n                    for b in r(j, n+1):\\n                        if prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target:\\n                            ans += 1\\n        return ans\\n```\\n\\nCalculating the 2D prefixes takes up to 20 ms, so that is not the core problem here. In general Python3 execution time suffers heavily from accessing attributes or making function calls. Further, plain `for` loops are pretty slow too compared to built-in functions and list comprehension. Best performance boost can be gained by using numpy arrays, but that is also more complex than using plain built-in `for` loops.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] prefixes = calculatePrefixes(matrix);\\n        int ans = 0;\\n        for(int i=1; i<=m; i++) {\\n            for(int j=1; j<=n; j++) {\\n                for(int a=i; a<=m; a++) {\\n                    for(int b=j; b<=n; b++) {\\n                        if(prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target) {\\n                            ans += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int[][] calculatePrefixes(int[][] matrix) {\\n        int[][] prefixes = new int[matrix.length + 1][matrix[0].length + 1];\\n        prefixes[0] = new int[matrix[0].length + 1];\\n        for(int i=0; i<=matrix[0].length; i++) {\\n            prefixes[0][i] = 0;\\n        }\\n\\n        for(int i=1; i<=matrix.length; i++) {\\n            prefixes[i][0] = 0;\\n            for(int j=1; j<=matrix[0].length; j++) {\\n                prefixes[i][j] = prefixes[i][j-1] + matrix[i-1][j-1];\\n            }\\n        }\\n\\n        for(int j=1; j<=matrix[0].length; j++) {\\n            for(int i=1; i<=matrix.length; i++) {\\n                prefixes[i][j] += prefixes[i-1][j];\\n            }\\n        }\\n\\n        return prefixes;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        ans = 0\\n        \\n        # 2d prefix sums with [0] prefix:\\n        # accumulate rows -> transpose -> accumulate rows -> transpose\\n\\t\\t# calculating the 2D prefixes takes around 10-20 ms\\n        acc_rows = [list(accumulate(row)) for row in matrix]\\n        transposed = [list(tup) for tup in zip(*acc_rows)]\\n        acc_rows = [[0]*m] + [list(accumulate(row)) for row in transposed]\\n        prefixes = [[0]*(n+1)] + [list(tup) for tup in zip(*acc_rows)]\\n        \\n\\t\\t# access to local variables is much faster than to global\\n\\t\\tr = range\\n\\t\\t\\n        # Iterate over all submatrices\\n        for i in r(1, m+1):\\n            for j in r(1, n+1):\\n                for a in r(i, m+1):\\n                    for b in r(j, n+1):\\n                        if prefixes[a][b] - prefixes[i-1][b] - prefixes[a][j-1] + prefixes[i-1][j-1] == target:\\n                            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248486,
                "title": "please-help-with-this-error",
                "content": "**My code is all correct but getting this error**\\nEdit : problem is solved.\\n\\nIn the innermost loop\\n```\\nfor{int k=0;k<matrix.size();k++)\\n                {\\n                    sum+=matrix[k][j];\\n```\\nBy mistake i wrote { instead of (  in \"for{int k=0;k<matrix.size();k++)\".\\nThat was the error.\\n\\nx---------------x-----------------x--------------------x----------------x\\n\\nLine 86: Char 28: error: expected \\'}\\'\\n#pragma GCC optimize (\"O2\")\\n                           ^\\nLine 1: Char 16: note: to match this \\'{\\'\\nclass Solution {\\n               ^\\n\\t\\t\\t   **CODE**\\n```cpp\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n            for(int j=1;j<matrix[0].size();j++)\\n                matrix[i][j]+=matrix[i][j-1];\\n        \\n        int ans=0;\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            for(int j=i;j<matrix[0].size();j++)\\n            {\\n                unordered_map <int,int> mp;\\n                mp[0]=1;\\n                int sum=0;\\n                for{int k=0;k<matrix.size();k++)\\n                {\\n                    sum+=matrix[k][j];\\n                    if(i>0) sum-=matrix[k][i-1];\\n                    if(mp.find(sum-target)!=mp.end()) \\n                    ans+=mp[sum-target];\\n                    mp[sum]++;\\n                }\\n            }\\n        }\\n        return ans;\\n     }\\n\\t };\\n\\t",
                "solutionTags": [],
                "code": "```\\nfor{int k=0;k<matrix.size();k++)\\n                {\\n                    sum+=matrix[k][j];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222975,
                "title": "java-easy-solution",
                "content": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n   // by max summ rectangle logic\\'\\n       int n = matrix.length; int m = matrix[0].length; \\n       HashMap<Integer,Integer> map = new HashMap<>();\\n       int count=0;\\n        for(int fixedR = 0;fixedR<n;fixedR++){\\n         int[] prefixCol = new int[m];   \\n           for(int row = fixedR ; row< n;row++){\\n              for(int col = 0;col<m;col++)\\n                 prefixCol[col] += matrix[row][col];\\n               \\n               count += countSubarraysGivenTarget(prefixCol,target);\\n             \\n           }\\n            \\n       }\\n        \\n     return count;   \\n    }\\n        public static int countSubarraysGivenTarget(int[] arr , int tar){\\n            HashMap<Integer,Integer> map = new HashMap<>();\\n            map.put(0,1);\\n            int count = 0;\\n            int sum=0;\\n            for(int ele : arr){\\n                sum+=ele;\\n                count+=map.getOrDefault(sum - tar,0);\\n                \\n                map.put(sum,map.getOrDefault(sum,0)+1);\\n                \\n            }\\n            return count;\\n        }\\n    \\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSubmatrixSumTarget(int[][] matrix, int target) {\\n   // by max summ rectangle logic\\'\\n       int n = matrix.length; int m = matrix[0].length; \\n       HashMap<Integer,Integer> map = new HashMap<>();\\n       int count=0;\\n        for(int fixedR = 0;fixedR<n;fixedR++){\\n         int[] prefixCol = new int[m];   \\n           for(int row = fixedR ; row< n;row++){\\n              for(int col = 0;col<m;col++)\\n                 prefixCol[col] += matrix[row][col];\\n               \\n               count += countSubarraysGivenTarget(prefixCol,target);\\n             \\n           }\\n            \\n       }\\n        \\n     return count;   \\n    }\\n        public static int countSubarraysGivenTarget(int[] arr , int tar){\\n            HashMap<Integer,Integer> map = new HashMap<>();\\n            map.put(0,1);\\n            int count = 0;\\n            int sum=0;\\n            for(int ele : arr){\\n                sum+=ele;\\n                count+=map.getOrDefault(sum - tar,0);\\n                \\n                map.put(sum,map.getOrDefault(sum,0)+1);\\n                \\n            }\\n            return count;\\n        }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218138,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < m; j++) {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = 0;\\n        map<int, int> god;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = i; j < m; j++) {\\n                god.clear();\\n                god[0] = 1;\\n                int sum = 0;\\n                for(int row = 0; row < n; row++) {\\n                    sum += matrix[row][j] - (i>0 ? matrix[row][i-1]: 0);\\n                    if(god.find(sum-target) != god.end()) {\\n                        ans += god[sum - target];\\n                    }\\n                    god[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < m; j++) {\\n                matrix[i][j] += matrix[i][j-1];\\n            }\\n        }\\n        int ans = 0;\\n        map<int, int> god;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = i; j < m; j++) {\\n                god.clear();\\n                god[0] = 1;\\n                int sum = 0;\\n                for(int row = 0; row < n; row++) {\\n                    sum += matrix[row][j] - (i>0 ? matrix[row][i-1]: 0);\\n                    if(god.find(sum-target) != god.end()) {\\n                        ans += god[sum - target];\\n                    }\\n                    god[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169444,
                "title": "c-easy-solution",
                "content": "Remebr this from your high school Maths class ?\\n**n(A\\u222AB) = n(A) + n(B) - n(A\\u2229B)** \\nI have tried to use concept of *prefix sum matrix* here(which was the solution for similar problem in 1D array) and *basic concept of set theory (stated above)* to solve a problem which was to efficiently calculate prefix sum matrix.\\nAfter that for every possible submatrix we check wether it\\'s sum is equal to target or not and collect our required answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        // Make the Plan\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        vector<vector<int> > preSum(n+1,vector<int>(m+1));\\n        \\n        // Execute The Plan\\n        for ( int i = 0 ; i < n ; ++i ) \\n            for ( int j = 0 ; j < m ; ++j ) \\n                preSum[i+1][j+1] = matrix[i][j] + preSum[i][j+1] + preSum[i+1][j] - preSum[i][j];\\n        \\n        // Expect the plan to go off the rails\\n        for ( int x1 = 1 ; x1 < n+1 ; ++x1 )\\n            for ( int y1 = 1 ; y1 < m+1 ; ++y1 )\\n                for ( int x2 = x1 ; x2 < n+1 ; ++x2 )\\n                    for ( int y2 = y1 ; y2 < m+1 ; ++y2 ) \\n                        ans += ( preSum[x2][y2] - preSum[x1-1][y2] - preSum[x2][y1-1] + preSum[x1-1][y1-1]==target );\\n        \\n        // Throw the plan\\n        return ans;\\n    }\\n};\\n```\\n**PS: Hail Leo Snart!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        \\n        // Make the Plan\\n        int n = matrix.size(), m = matrix[0].size(), ans = 0;\\n        vector<vector<int> > preSum(n+1,vector<int>(m+1));\\n        \\n        // Execute The Plan\\n        for ( int i = 0 ; i < n ; ++i ) \\n            for ( int j = 0 ; j < m ; ++j ) \\n                preSum[i+1][j+1] = matrix[i][j] + preSum[i][j+1] + preSum[i+1][j] - preSum[i][j];\\n        \\n        // Expect the plan to go off the rails\\n        for ( int x1 = 1 ; x1 < n+1 ; ++x1 )\\n            for ( int y1 = 1 ; y1 < m+1 ; ++y1 )\\n                for ( int x2 = x1 ; x2 < n+1 ; ++x2 )\\n                    for ( int y2 = y1 ; y2 < m+1 ; ++y2 ) \\n                        ans += ( preSum[x2][y2] - preSum[x1-1][y2] - preSum[x2][y1-1] + preSum[x1-1][y1-1]==target );\\n        \\n        // Throw the plan\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165850,
                "title": "python3-prefix-sum",
                "content": "\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = 0 \\n        freq = defaultdict(int)\\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                for jj in range(-1, j): \\n                    diff = prefix[i+1][j+1] - prefix[i+1][jj+1] \\n                    ans += freq[jj, j, diff - target]\\n                    if diff == target: ans += 1\\n                    freq[jj, j, diff] += 1\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        ans = 0 \\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        \\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                \\n            for ii in range(i+1):\\n                freq = {0: 1}\\n                for j in range(n): \\n                    diff = prefix[i+1][j+1] - prefix[ii][j+1] \\n                    ans += freq.get(diff - target, 0)\\n                    freq[diff] = 1 + freq.get(diff, 0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = 0 \\n        freq = defaultdict(int)\\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                for jj in range(-1, j): \\n                    diff = prefix[i+1][j+1] - prefix[i+1][jj+1] \\n                    ans += freq[jj, j, diff - target]\\n                    if diff == target: ans += 1\\n                    freq[jj, j, diff] += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        ans = 0 \\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        \\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = matrix[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                \\n            for ii in range(i+1):\\n                freq = {0: 1}\\n                for j in range(n): \\n                    diff = prefix[i+1][j+1] - prefix[ii][j+1] \\n                    ans += freq.get(diff - target, 0)\\n                    freq[diff] = 1 + freq.get(diff, 0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164993,
                "title": "easy-to-understand-prefix-sum-o-n-n-m",
                "content": "All solution are a bit confusion. So writing this.\\n\\nPlease solve [this](https://leetcode.com/problems/subarray-sum-equals-k/solution/) before reading below explanation.\\n\\n1. Create a prefix sum for every row.\\n2. Create start and end using colums length such that 0 <= start <= end < len(array)\\n```\\nfor start in range(len(matrix[0)):\\n\\tfor end in range(start, len(matrix[0)):\\n```\\nApply [this](https://leetcode.com/problems/subarray-sum-equals-k/discuss/1164884/Easy-to-Understand-O(n)) within the inner loop in terms of rows.\\n\\nplease go through the comment for clear understanding.\\n\\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, ma: List[List[int]], t: int) -> int:\\n\\t\\t# row - m, column - n\\n        m, n = len(ma), len(ma[0])\\n\\t\\t# building prefix Sum on rows\\n        for i in range(m):\\n            for j in range(1,n):\\n                ma[i][j]+=ma[i][j-1]\\n        print(ma)\\n\\t\\t# result that we want to emit\\n        res = 0\\n\\t\\t# creating combination of i, j where 0 <= i <= j <= len(martix[0])\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\t# creating map for storing previous sums\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n\\t\\t\\t\\t# iterating 0 to rowlength\\n\\t\\t\\t\\t# for k  = 0 \\n\\t\\t\\t\\t# only row 0\\n\\t\\t\\t\\t# for k = 1\\n\\t\\t\\t\\t# row row 0 + row 1\\n\\t\\t\\t\\t# and so on\\n                for k in range(m):\\n\\t\\t\\t\\t\\t# Calculating sum of elements in range i to j indexes of columns using prefix sum\\n                    cur += ma[k][j] - (ma[k][i - 1] if i > 0 else 0)\\n\\t\\t\\t\\t\\t# checking if sum - target is present previously or not\\n                    res += c[cur - t]\\n                    c[cur] += 1\\n        return res\\n```\\n\\nTime complexity: O(n*n*m)\\nspace complexity: O(m)\\nPlease Upvote! if it is helpful.\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nfor start in range(len(matrix[0)):\\n\\tfor end in range(start, len(matrix[0)):\\n```\n```\\nclass Solution:\\n    def numSubmatrixSumTarget(self, ma: List[List[int]], t: int) -> int:\\n\\t\\t# row - m, column - n\\n        m, n = len(ma), len(ma[0])\\n\\t\\t# building prefix Sum on rows\\n        for i in range(m):\\n            for j in range(1,n):\\n                ma[i][j]+=ma[i][j-1]\\n        print(ma)\\n\\t\\t# result that we want to emit\\n        res = 0\\n\\t\\t# creating combination of i, j where 0 <= i <= j <= len(martix[0])\\n        for i in range(n):\\n            for j in range(i,n):\\n\\t\\t\\t\\t# creating map for storing previous sums\\n                c = collections.defaultdict(int)\\n                cur, c[0] = 0, 1\\n\\t\\t\\t\\t# iterating 0 to rowlength\\n\\t\\t\\t\\t# for k  = 0 \\n\\t\\t\\t\\t# only row 0\\n\\t\\t\\t\\t# for k = 1\\n\\t\\t\\t\\t# row row 0 + row 1\\n\\t\\t\\t\\t# and so on\\n                for k in range(m):\\n\\t\\t\\t\\t\\t# Calculating sum of elements in range i to j indexes of columns using prefix sum\\n                    cur += ma[k][j] - (ma[k][i - 1] if i > 0 else 0)\\n\\t\\t\\t\\t\\t# checking if sum - target is present previously or not\\n                    res += c[cur - t]\\n                    c[cur] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164702,
                "title": "prefix-sum-find-subarray-with-target-sum",
                "content": "### Prefix Sum + Subarray Target Sum\\nIt\\'s apparent that we should calculate the sum of submatrix using 2D prefix sum array, where `prefix[i][j] = prefix[i][j-1] + prefix[i-1][j] - prefix[i -1][j-1]`. Note the reason that we have to remove *prefix[i-1][j-1]* is that we add that part twice. For the sake of easy implementation, we need add one blank row on the top and one blank column on the most left side.\\nMy first idea is for each *(i, j)*, we check each cell *(x, y)* where `x <= i and y <= j` for possible submatix to get the sum to see if it equals to *target*. It denote *O(m^2n^2)* time complexity. Is there any better solution?\\nThe intuition tells me that there must be a better approach using hashtable, because it\\'s similar with two sum problem. What\\'s more, it\\'s similar with sum of subarray problem that is resolved using hashtable.\\nSo we can specifiy the length of rows each submatrix covers, then we can convert the problem to find the sum of subarray that equals to *target*. You have to treate the multiple rows to one element. \\nThen we need check each pair of rows *(r1, r2)*, which reduces complexity to *O(m^2n)*. \\n\\nalternatively, if we have much smaller *n*, then we can do same trick on columns instead of rows, which takes *O(n^2m)* time complexity.\\n```python\\n   def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):   \\n                prefix[i][j] = matrix[i - 1][j - 1] + prefix[i][j - 1] + prefix[i- 1][j] - prefix[i - 1][j -1]\\n \\n        count = 0\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                counter = defaultdict(int)\\n                for k in range(n + 1):\\n                    current_sum = prefix[j][k] - prefix[i - 1][k]\\n                    count += counter[current_sum - target]\\n                    counter[current_sum] += 1\\n                    \\n        return count\\n```\\n\\n*Time Complexity*= **O(m^2n)**\\n*Space Complexity*= **O(mn)**\\n",
                "solutionTags": [],
                "code": "```python\\n   def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):   \\n                prefix[i][j] = matrix[i - 1][j - 1] + prefix[i][j - 1] + prefix[i- 1][j] - prefix[i - 1][j -1]\\n \\n        count = 0\\n        for i in range(1, m + 1):\\n            for j in range(i, m + 1):\\n                counter = defaultdict(int)\\n                for k in range(n + 1):\\n                    current_sum = prefix[j][k] - prefix[i - 1][k]\\n                    count += counter[current_sum - target]\\n                    counter[current_sum] += 1\\n                    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1163320,
                "title": "c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = i; j < m; j++)\\n            {\\n                mp.clear();\\n                mp[0]++;\\n                int sum = 0;\\n                for(int k = 0; k < n; k++)\\n                {\\n                    int curr = matrix[k][j];\\n                    if(i > 0)\\n                        curr -= matrix[k][i-1];\\n                    sum+= curr;\\n                    ans += mp[sum - target];\\n                    mp[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 1; j < m; j++)\\n                matrix[i][j] += matrix[i][j-1];\\n        \\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = i; j < m; j++)\\n            {\\n                mp.clear();\\n                mp[0]++;\\n                int sum = 0;\\n                for(int k = 0; k < n; k++)\\n                {\\n                    int curr = matrix[k][j];\\n                    if(i > 0)\\n                        curr -= matrix[k][i-1];\\n                    sum+= curr;\\n                    ans += mp[sum - target];\\n                    mp[sum]++;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163230,
                "title": "swift-find-subarray-with-target-sum",
                "content": "```swift\\n    func numSubmatrixSumTarget(_ matrix: [[Int]], _ target: Int) -> Int {\\n        let rows = matrix.endIndex\\n        let cols = matrix[0].endIndex\\n        var matrix = matrix\\n        var res = 0\\n        for i in 0..<rows {\\n            for j in 1..<cols {\\n                matrix[i][j] += matrix[i][j-1]\\n            }\\n        }\\n        for i in 0..<cols {\\n            for j in i..<cols {\\n                var dict = [0:1]\\n                var sum = 0\\n                for row in 0..<rows {\\n                    sum += matrix[row][j] - (i > 0 ? matrix[row][i-1] : 0)\\n                    res += dict[sum-target, default:0]\\n                    dict[sum, default: 0]+=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [],
                "code": "```swift\\n    func numSubmatrixSumTarget(_ matrix: [[Int]], _ target: Int) -> Int {\\n        let rows = matrix.endIndex\\n        let cols = matrix[0].endIndex\\n        var matrix = matrix\\n        var res = 0\\n        for i in 0..<rows {\\n            for j in 1..<cols {\\n                matrix[i][j] += matrix[i][j-1]\\n            }\\n        }\\n        for i in 0..<cols {\\n            for j in i..<cols {\\n                var dict = [0:1]\\n                var sum = 0\\n                for row in 0..<rows {\\n                    sum += matrix[row][j] - (i > 0 ? matrix[row][i-1] : 0)\\n                    res += dict[sum-target, default:0]\\n                    dict[sum, default: 0]+=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163043,
                "title": "c-comments-easy-to-read-and-understand-variables",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        if(rows == 0)\\n            return 0;\\n        int cols = matrix[0].size();\\n        \\n        //First take the cumulative sum row-wise\\n        for(int row = 0; row<rows; row++) {\\n            for(int col = 1; col<cols; col++) {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        \\n        //Now, you need to find the \"No. of subarrays with sum k\" in downward direction\\n\\t\\t//which is a prerequisite to this question : Please solve that first and then come to this question : Leetcode-560\\n        int result = 0;\\n        for(int startCol = 0; startCol<cols; startCol++) {\\n            \\n            for(int currCol = startCol; currCol<cols; currCol++) {\\n                //We need to find all sub matrices sum\\n                \\n                //Now comes the concept of \"No. of subarrays with sum k\"\\n                unordered_map<int, int> mp;\\n                mp[0] = 1;\\n                int sum = 0;\\n                //Go downwards row wise\\n                for(int row = 0; row<rows; row++) {\\n                    sum += matrix[row][currCol] - (startCol > 0 ? matrix[row][startCol-1] : 0);\\n                    \\n                    if(mp.count(sum-target)) {\\n                        result += mp[sum-target];\\n                    }\\n                    \\n                    mp[sum]++;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        if(rows == 0)\\n            return 0;\\n        int cols = matrix[0].size();\\n        \\n        //First take the cumulative sum row-wise\\n        for(int row = 0; row<rows; row++) {\\n            for(int col = 1; col<cols; col++) {\\n                matrix[row][col] += matrix[row][col-1];\\n            }\\n        }\\n        \\n        //Now, you need to find the \"No. of subarrays with sum k\" in downward direction\\n\\t\\t//which is a prerequisite to this question : Please solve that first and then come to this question : Leetcode-560\\n        int result = 0;\\n        for(int startCol = 0; startCol<cols; startCol++) {\\n            \\n            for(int currCol = startCol; currCol<cols; currCol++) {\\n                //We need to find all sub matrices sum\\n                \\n                //Now comes the concept of \"No. of subarrays with sum k\"\\n                unordered_map<int, int> mp;\\n                mp[0] = 1;\\n                int sum = 0;\\n                //Go downwards row wise\\n                for(int row = 0; row<rows; row++) {\\n                    sum += matrix[row][currCol] - (startCol > 0 ? matrix[row][startCol-1] : 0);\\n                    \\n                    if(mp.count(sum-target)) {\\n                        result += mp[sum-target];\\n                    }\\n                    \\n                    mp[sum]++;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162957,
                "title": "rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let sums = matrix\\n            .iter()\\n            .map(|row| {\\n                row.iter()\\n                    .scan(0, |sum, &x| {\\n                        *sum += x;\\n                        Some(*sum)\\n                    })\\n                    .collect::<Vec<_>>()\\n            })\\n            .collect::<Vec<_>>();\\n        let len = matrix[0].len();\\n        let mut answer = 0;\\n        let mut hm = HashMap::new();\\n        for i in 0..len {\\n            for j in i..len {\\n                hm.clear();\\n                hm.insert(0, 1);\\n                let mut sum = 0;\\n                for row in &sums {\\n                    sum += row[j] - if i > 0 { row[i - 1] } else { 0 };\\n                    if let Some(&count) = hm.get(&(sum - target)) {\\n                        answer += count;\\n                    }\\n                    *hm.entry(sum).or_default() += 1;\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let sums = matrix\\n            .iter()\\n            .map(|row| {\\n                row.iter()\\n                    .scan(0, |sum, &x| {\\n                        *sum += x;\\n                        Some(*sum)\\n                    })\\n                    .collect::<Vec<_>>()\\n            })\\n            .collect::<Vec<_>>();\\n        let len = matrix[0].len();\\n        let mut answer = 0;\\n        let mut hm = HashMap::new();\\n        for i in 0..len {\\n            for j in i..len {\\n                hm.clear();\\n                hm.insert(0, 1);\\n                let mut sum = 0;\\n                for row in &sums {\\n                    sum += row[j] - if i > 0 { row[i - 1] } else { 0 };\\n                    if let Some(&count) = hm.get(&(sum - target)) {\\n                        answer += count;\\n                    }\\n                    *hm.entry(sum).or_default() += 1;\\n                }\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162684,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return 0;\\n        }\\n    \\n        int rows = matrix.length;\\n        int columns = matrix[0].length;\\n        int[][] prefixSum = new int[rows+1][columns];\\n        \\n        for (int i=0; i<columns; i++) {\\n            for (int j=0; j<rows; j++) {\\n                prefixSum[j+1][i] = prefixSum[j][i] + matrix[j][i];\\n            }\\n        }\\n        \\n        int result= 0;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        \\n        for (int i=0; i<rows; i++) {\\n            for (int j=i; j<rows; j++) {\\n                map.clear();\\n                int sum = 0;\\n                for (int k=0; k<columns; k++) {\\n                    sum += prefixSum[j+1][k] - prefixSum[i][k];\\n                    \\n                    if (sum == target) {\\n                        result++;\\n                    }\\n                    \\n                    int difference = sum - target;\\n                    if (map.containsKey(difference)) {\\n                        result+= map.get(difference);\\n                    }\\n                    \\n                    if (map.containsKey(sum)) {\\n                        map.put(sum, map.get(sum) + 1);\\n                    } else {\\n                        map.put(sum, 1);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1162626,
                "title": "number-of-submatrices-that-sum-to-target",
                "content": "The approach for the problem is that we will look for all the submatrices which are possible for a given matrix and find the sum of all the elements if it will be equal to target then we will consider it for answer and increment one to our answer.\\nwe will iterate to each cell of the given matrix and check all the possible submatrices which will start from that cell.\\nExample if we are given 2X2 matrix then all submatrices which will be passing through all four cells are:\\n(i)(0,0)->{((0,0)->(0,0)),((0,0)->(0,1)),((0,0)->(1,0)),((0,0)->(1,1))}\\n(ii)(0,1)->{((0,1)->(0,1)),((0,1)->(1,1))}\\n(iii)(1,0)->{((1,0)->(1,0)),((1,0)->(1,1))}\\n(iv)(1,1)->{((1,1)->(1,1))}\\nThe given constraints are only upto 100 so this approach will not give any TLE error. \\n\\n\\n\\n```\\nint R,C,Ans,Ans1,Ans2=0,i,j,k,l,S;\\n        vector<vector<int>> E;\\n        R=matrix.size();\\n        C=matrix[0].size();\\n        for(i=0;i<R;i++)\\n        {\\n            vector<int> F;\\n            S=0;\\n            for(j=0;j<C;j++)\\n            {\\n                S+=matrix[i][j];\\n                F.push_back(S);\\n            }\\n            E.push_back(F);\\n        }\\n        for(i=0;i<R;i++)\\n        {\\n            for(j=0;j<C;j++)\\n            {\\n                S=0;\\n                for(k=j;k<C;k++)\\n                {\\n                    if(j==0)\\n                    Ans=E[i][k];\\n                    else\\n                    Ans=E[i][k]-E[i][j-1];\\n                    if(k==(C-1))\\n                    S+=Ans; \\n                    Ans1=Ans;\\n                    for(l=i;l<R;l++)\\n                    {\\n                        if(l!=i)\\n                        {\\n                            if(j==0)\\n                            Ans1+=E[l][k];\\n                            else\\n                            Ans1+=(E[l][k]-E[l][j-1]);    \\n                        }\\n                        if(Ans1==target)\\n                            ++Ans2;\\n                    }\\n                }\\n            }\\n        }\\n        return Ans2;\\n\\t\\t",
                "solutionTags": [],
                "code": "The approach for the problem is that we will look for all the submatrices which are possible for a given matrix and find the sum of all the elements if it will be equal to target then we will consider it for answer and increment one to our answer.\\nwe will iterate to each cell of the given matrix and check all the possible submatrices which will start from that cell.\\nExample if we are given 2X2 matrix then all submatrices which will be passing through all four cells are:\\n(i)(0,0)->{((0,0)->(0,0)),((0,0)->(0,1)),((0,0)->(1,0)),((0,0)->(1,1))}\\n(ii)(0,1)->{((0,1)->(0,1)),((0,1)->(1,1))}\\n(iii)(1,0)->{((1,0)->(1,0)),((1,0)->(1,1))}\\n(iv)(1,1)->{((1,1)->(1,1))}\\nThe given constraints are only upto 100 so this approach will not give any TLE error. \\n\\n\\n\\n```\\nint R,C,Ans,Ans1,Ans2=0,i,j,k,l,S;\\n        vector<vector<int>> E;\\n        R=matrix.size();\\n        C=matrix[0].size();\\n        for(i=0;i<R;i++)\\n        {\\n            vector<int> F;\\n            S=0;\\n            for(j=0;j<C;j++)\\n            {\\n                S+=matrix[i][j];\\n                F.push_back(S);\\n            }\\n            E.push_back(F);\\n        }\\n        for(i=0;i<R;i++)\\n        {\\n            for(j=0;j<C;j++)\\n            {\\n                S=0;\\n                for(k=j;k<C;k++)\\n                {\\n                    if(j==0)\\n                    Ans=E[i][k];\\n                    else\\n                    Ans=E[i][k]-E[i][j-1];\\n                    if(k==(C-1))\\n                    S+=Ans; \\n                    Ans1=Ans;\\n                    for(l=i;l<R;l++)\\n                    {\\n                        if(l!=i)\\n                        {\\n                            if(j==0)\\n                            Ans1+=E[l][k];\\n                            else\\n                            Ans1+=(E[l][k]-E[l][j-1]);    \\n                        }\\n                        if(Ans1==target)\\n                            ++Ans2;\\n                    }\\n                }\\n            }\\n        }\\n        return Ans2;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1162495,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int t) \\n    {\\n        \\n        int i,n,m;\\n        n=A.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        m=A[0].size();\\n        if(m==0)\\n        {\\n            return 0;\\n        }\\n        \\n        int j;\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=1;j<m;j++)\\n            {\\n                A[i][j]+=A[i][j-1];\\n            }\\n        }\\n        \\n        int ans=0;\\n        map<int,int>ma;\\n        \\n        for(int sc=0;sc<m;sc++)\\n        {\\n            for(int cc=sc;cc<m;cc++)\\n            {\\n                ma.clear();\\n                ma[0]=1;\\n                int sum=0;\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=A[i][cc]-(sc>0?A[i][sc-1]:0);\\n                    ans+=ma[sum-t];        \\n                    ma[sum]++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& A, int t) \\n    {\\n        \\n        int i,n,m;\\n        n=A.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1103444,
                "title": "using-dp-java",
                "content": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] sum = new int[m][n];\\n        int sumSoFar = 0;\\n        for(int i=0;i<m;i++) {\\n            sumSoFar+=matrix[i][0];\\n            sum[i][0] = sumSoFar;\\n        }\\n        sumSoFar = 0;\\n        for(int i=0;i<n;i++) {\\n            sumSoFar+=matrix[0][i];\\n            sum[0][i] = sumSoFar;\\n        }\\n        \\n        for(int i=1; i< m;i++) {\\n            for(int j=1;j < n; j++) {\\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + matrix[i][j];\\n            }\\n        }\\n        int count =0;\\n        \\n        for(int i=0;i<m;i++) {\\n            for (int j=0;j<n;j++) {\\n                for(int k=i;k<m;k++) {\\n                    for (int l=j; l<n;l++) {\\n                        int tempSum = sum[k][l];\\n                        if(i>0) {\\n                            tempSum -= sum[i-1][l];\\n                        }\\n                        if(j>0) {\\n                            tempSum -= sum[k][j-1];\\n                        }\\n                        if(i>0 && j>0) {\\n                            tempSum += sum[i-1][j-1];\\n                        }\\n                        if(tempSum == target) {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        \\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        \\n        int[][] sum = new int[m][n];\\n        int sumSoFar = 0;\\n        for(int i=0;i<m;i++) {\\n            sumSoFar+=matrix[i][0];\\n            sum[i][0] = sumSoFar;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 972074,
                "title": "java-easiest",
                "content": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int k) {\\n        int m = matrix[0].length, n = matrix.length;\\n        for(int i = 1; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                matrix[i][j] += matrix[i-1][j];\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int base = 0; base <n ; base++){\\n            \\n            for(int row = base; row<n; row++){\\n                \\n                HashMap<Integer,Integer> map = new HashMap<>();\\n                map.put(0,1);\\n                int prefixsum = 0;\\n                \\n                for(int j = 0; j<m ; j++){\\n                    \\n                    prefixsum += matrix[row][j] - (base != 0 ? matrix[base - 1][j] : 0);\\n                    count += map.getOrDefault(prefixsum - k, 0);\\n                    map.put(prefixsum, map.getOrDefault(prefixsum,0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int k) {\\n        int m = matrix[0].length, n = matrix.length;\\n        for(int i = 1; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                matrix[i][j] += matrix[i-1][j];\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int base = 0; base <n ; base++){\\n            \\n            for(int row = base; row<n; row++){\\n                \\n                HashMap<Integer,Integer> map = new HashMap<>();\\n                map.put(0,1);\\n                int prefixsum = 0;\\n                \\n                for(int j = 0; j<m ; j++){\\n                    \\n                    prefixsum += matrix[row][j] - (base != 0 ? matrix[base - 1][j] : 0);\\n                    count += map.getOrDefault(prefixsum - k, 0);\\n                    map.put(prefixsum, map.getOrDefault(prefixsum,0) + 1);\\n                    \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890948,
                "title": "python-o-r-2-c-solution-beats-98-57",
                "content": "```\\nclass Solution:\\n    \\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        rows, cols = len(matrix)+1, len(matrix[0])+1\\n        psum = [[0]*cols for _ in range(rows)]\\n        \\n        for r in range(1, rows):\\n            t = 0\\n            for c in range(1, cols):\\n                t += matrix[r-1][c-1]\\n                psum[r][c] = psum[r-1][c] + t\\n        \\n        ans = 0\\n        for r1 in range(rows-1):\\n            for r2 in range(r1+1, rows):\\n                d = {target: 1}\\n                for c in range(1, cols):\\n                    x = psum[r2][c] - psum[r1][c]\\n                    if x in d: \\n                        ans += d[x]\\n                    x += target\\n                    d[x] = d.get(x, 0) + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        rows, cols = len(matrix)+1, len(matrix[0])+1\\n        psum = [[0]*cols for _ in range(rows)]\\n        \\n        for r in range(1, rows):\\n            t = 0\\n            for c in range(1, cols):\\n                t += matrix[r-1][c-1]\\n                psum[r][c] = psum[r-1][c] + t\\n        \\n        ans = 0\\n        for r1 in range(rows-1):\\n            for r2 in range(r1+1, rows):\\n                d = {target: 1}\\n                for c in range(1, cols):\\n                    x = psum[r2][c] - psum[r1][c]\\n                    if x in d: \\n                        ans += d[x]\\n                    x += target\\n                    d[x] = d.get(x, 0) + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864371,
                "title": "java-noob-friendly-o-n-4-solution-accepted-beats-82-7",
                "content": "Claculates Prefix sum for all co-ordinates then goes for N^4 loop to serach for target sum.\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int[][] sum = new int[matrix.length][matrix[0].length];\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        sum[0][0] = matrix[0][0];\\n        for(int i=1;i<row;i++){\\n            sum[i][0] = sum[i-1][0] + matrix[i][0];\\n        }\\n        \\n        for(int j=1; j<col;j++){\\n            sum[0][j] = sum[0][j-1]+matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                sum[i][j] = sum[i-1][j]+sum[i][j-1]+matrix[i][j]-sum[i-1][j-1];\\n            }\\n        }\\n        \\n\\n        int res = 0;\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int tempSum = 0;\\n                \\n                for(int m=i;m<row;m++){\\n                    for(int n=j;n<col;n++){\\n                        tempSum = sum[m][n];\\n                        if(i>0){\\n                            tempSum -= sum[i-1][n];\\n                        }\\n                        if(j>0){\\n                            tempSum -= sum[m][j-1];\\n                        }\\n                        if(i>0 && j>0){\\n                            tempSum += sum[i-1][j-1];\\n                        }\\n                        \\n                        if(tempSum == target){\\n                            res++;        \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int[][] sum = new int[matrix.length][matrix[0].length];\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        sum[0][0] = matrix[0][0];\\n        for(int i=1;i<row;i++){\\n            sum[i][0] = sum[i-1][0] + matrix[i][0];\\n        }\\n        \\n        for(int j=1; j<col;j++){\\n            sum[0][j] = sum[0][j-1]+matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<row;i++){\\n            for(int j=1;j<col;j++){\\n                sum[i][j] = sum[i-1][j]+sum[i][j-1]+matrix[i][j]-sum[i-1][j-1];\\n            }\\n        }\\n        \\n\\n        int res = 0;\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int tempSum = 0;\\n                \\n                for(int m=i;m<row;m++){\\n                    for(int n=j;n<col;n++){\\n                        tempSum = sum[m][n];\\n                        if(i>0){\\n                            tempSum -= sum[i-1][n];\\n                        }\\n                        if(j>0){\\n                            tempSum -= sum[m][j-1];\\n                        }\\n                        if(i>0 && j>0){\\n                            tempSum += sum[i-1][j-1];\\n                        }\\n                        \\n                        if(tempSum == target){\\n                            res++;        \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788134,
                "title": "javascript-clean-easy-fast",
                "content": "```\\n//this question is very similar to \"Subarray Sum Equals k.\" \\n//https://leetcode.com/problems/subarray-sum-equals-k/\\n//it\\'s a 2D array variation of the original 1D problem\\nvar numSubmatrixSumTarget = function(matrix, target) {    \\n    let rlen = matrix.length\\n    let clen = matrix[0].length\\n\\t//pfsum is a 2D array that will be used to store the sum from [0][0] to [r][c] (inclusive)\\n\\t//eg pfsum[1][1] will be sum of (matrix[0][0],matrix[0][1],matrix[1][0],matrix[1][1])\\n    let pfsum = []\\n    for(let i = 0;i<rlen;i++){\\n        let t = Array(clen).fill(0)\\n        pfsum.push(t)\\n    }\\n    for(let i = 0;i<rlen;i++){\\n        let rowsum = 0\\n        for(let j=0;j<clen;j++){\\n            rowsum+=matrix[i][j]\\n            pfsum[i][j] = rowsum\\n            if(i===0)\\n                continue\\n            pfsum[i][j] += pfsum[i-1][j] \\n        }\\n    }\\n    let count = 0\\n    //prefix sum\\n    for(let jlen = 0;jlen<clen;jlen++){\\n        for(let j = 0;j+jlen<clen;j++){\\n            let pf = new Map()\\n            pf.set(0,1)\\n            for(let i = 0;i<rlen;i++){\\n                let left = 0\\n                if((j-1)>=0)\\n                    left = pfsum[i][j-1]\\n                \\n                let sum = pfsum[i][j+jlen] - left\\n                \\n                if(pf.has(sum-target))\\n                    count+=pf.get(sum-target)\\n                \\n                if(!pf.has(sum))\\n                    pf.set(sum,1)\\n                else\\n                    pf.set(sum,pf.get(sum)+1)\\n            }\\n        }\\n    }  \\n    return count\\n```",
                "solutionTags": [],
                "code": "```\\n//this question is very similar to \"Subarray Sum Equals k.\" \\n//https://leetcode.com/problems/subarray-sum-equals-k/\\n//it\\'s a 2D array variation of the original 1D problem\\nvar numSubmatrixSumTarget = function(matrix, target) {    \\n    let rlen = matrix.length\\n    let clen = matrix[0].length\\n\\t//pfsum is a 2D array that will be used to store the sum from [0][0] to [r][c] (inclusive)\\n\\t//eg pfsum[1][1] will be sum of (matrix[0][0],matrix[0][1],matrix[1][0],matrix[1][1])\\n    let pfsum = []\\n    for(let i = 0;i<rlen;i++){\\n        let t = Array(clen).fill(0)\\n        pfsum.push(t)\\n    }\\n    for(let i = 0;i<rlen;i++){\\n        let rowsum = 0\\n        for(let j=0;j<clen;j++){\\n            rowsum+=matrix[i][j]\\n            pfsum[i][j] = rowsum\\n            if(i===0)\\n                continue\\n            pfsum[i][j] += pfsum[i-1][j] \\n        }\\n    }\\n    let count = 0\\n    //prefix sum\\n    for(let jlen = 0;jlen<clen;jlen++){\\n        for(let j = 0;j+jlen<clen;j++){\\n            let pf = new Map()\\n            pf.set(0,1)\\n            for(let i = 0;i<rlen;i++){\\n                let left = 0\\n                if((j-1)>=0)\\n                    left = pfsum[i][j-1]\\n                \\n                let sum = pfsum[i][j+jlen] - left\\n                \\n                if(pf.has(sum-target))\\n                    count+=pf.get(sum-target)\\n                \\n                if(!pf.has(sum))\\n                    pf.set(sum,1)\\n                else\\n                    pf.set(sum,pf.get(sum)+1)\\n            }\\n        }\\n    }  \\n    return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744453,
                "title": "clear-java-solution",
                "content": "2 steps\\n1. compress the matrix to array \\n2. same as solve problem 560\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int cnt = 0;\\n\\t\\t//step1: compress the matrix to array for by row. \\n        for (int i = 0; i < m; i++){\\n            int[] tmp = new int[n];\\n            for (int j = i; j < m; j++){\\n                for (int l = 0; l < n; l++){\\n                    tmp[l] += matrix[j][l];\\n                }\\n                cnt += helper(tmp, target);\\n            }\\n        }\\n        return cnt;\\n    }\\n\\t\\n    //this is same as solution for problem 560\\n    private int helper(int[] nums, int k){\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] preSum = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++){\\n            preSum[i + 1] = preSum[i] + nums[i];\\n        }\\n        int cnt = 0;\\n        for (int n : preSum){\\n            if (map.containsKey(n)){\\n                cnt += map.get(n);\\n            }\\n            map.put(n + k, map.getOrDefault(n + k, 0) + 1);\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int cnt = 0;\\n\\t\\t//step1: compress the matrix to array for by row. \\n        for (int i = 0; i < m; i++){\\n            int[] tmp = new int[n];\\n            for (int j = i; j < m; j++){\\n                for (int l = 0; l < n; l++){\\n                    tmp[l] += matrix[j][l];\\n                }\\n                cnt += helper(tmp, target);\\n            }\\n        }\\n        return cnt;\\n    }\\n\\t\\n    //this is same as solution for problem 560\\n    private int helper(int[] nums, int k){\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] preSum = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++){\\n            preSum[i + 1] = preSum[i] + nums[i];\\n        }\\n        int cnt = 0;\\n        for (int n : preSum){\\n            if (map.containsKey(n)){\\n                cnt += map.get(n);\\n            }\\n            map.put(n + k, map.getOrDefault(n + k, 0) + 1);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738572,
                "title": "too-strict-threshold-for-c-submission",
                "content": "I have first tried to slove the problem in c++. The time complexity of my code is O(|R|^2*|C|), but I got \"\\tTime Limit Exceeded\" error. \\nI then translated my c++ code to java code word by word, they are exactly the same. But this time my java code pass the OJ. \\nI think the threshold for c++ submission is too strict. It\\'s unfair. \\n# My c++ code:\\n```\\nstatic int _ = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int dp[300] = {0};\\n        int ret = 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0;i<matrix.size();i++){\\n            for(int j = i;j<matrix.size();j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].size();k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m[sum-target];\\n                    m[sum]++;\\n                }\\n            }\\n            memset(dp,0,sizeof(dp));\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n# My java code: \\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int []dp = new int[300];\\n        HashMap<Integer,Integer> m = new HashMap();\\n        int ret = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = i;j<matrix.length;j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].length;k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m.getOrDefault(sum-target,0);\\n                    m.merge(sum,1,Integer::sum);\\n                }\\n            }\\n            dp = new int[300];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int _ = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        int dp[300] = {0};\\n        int ret = 0;\\n        unordered_map<int,int> m;\\n        for(int i = 0;i<matrix.size();i++){\\n            for(int j = i;j<matrix.size();j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].size();k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m[sum-target];\\n                    m[sum]++;\\n                }\\n            }\\n            memset(dp,0,sizeof(dp));\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int []dp = new int[300];\\n        HashMap<Integer,Integer> m = new HashMap();\\n        int ret = 0;\\n        for(int i = 0;i<matrix.length;i++){\\n            for(int j = i;j<matrix.length;j++){\\n                int sum = 0;\\n                m.clear();\\n                for(int k = 0;k<matrix[0].length;k++) {\\n                    dp[k] += matrix[j][k];\\n                    sum += dp[k];\\n                    if(sum == target) {\\n                        ret++;\\n                    }\\n                    ret += m.getOrDefault(sum-target,0);\\n                    m.merge(sum,1,Integer::sum);\\n                }\\n            }\\n            dp = new int[300];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 633989,
                "title": "python-dict-92-vs-defaultdict-51",
                "content": "I was playing with python `dict` and `defaultdict`. It apears that `dict` is lot faster than `defaultdict` when the size of the dictionary is relatively small. But over a large dictionary `defaultdict` beats `dict`. In this particular problem the datasize favors `dict`.\\n1. Below is the `defaultdict` solution. It looks cleaner. Beats 51%.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = defaultdict(int)\\n                dp[0]=1\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp[val-target]\\n                    dp[val] += 1\\n        return ans\\n```\\n2. Then below is the `dict` based solution that beats 92%.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = {0:1}\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp.get(val-target,0)\\n                    \\n                    if val in dp:\\n                        dp[val] += 1\\n                    else:\\n                        dp[val]=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = defaultdict(int)\\n                dp[0]=1\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp[val-target]\\n                    dp[val] += 1\\n        return ans\\n```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix, target):\\n        r, c = len(matrix), len(matrix[0])\\n        ans, bsum = 0, [ [0 for j in range(c+1)] for i in range(r+1)]\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                bsum[i+1][j+1] = bsum[i+1][j] + bsum[i][j+1] - bsum[i][j] + matrix[i][j]\\n\\n        for i in range(c):\\n            for j in range(i+1,c+1):\\n                dp = {0:1}\\n                for k in range(1,r+1):\\n                    val = bsum[k][j] - bsum[k][i]\\n                    ans += dp.get(val-target,0)\\n                    \\n                    if val in dp:\\n                        dp[val] += 1\\n                    else:\\n                        dp[val]=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560881,
                "title": "java-accepted-simple-but-slow",
                "content": "The idea is to flatten one dimension of the array, by obtaining sums of all numbers between each set of two columns.\\n\\nWe can then iterate over every possible range of these sums, to find the target sum.\\n\\n```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        \\n        int rows = matrix.length;\\n        if (rows == 0) return 0;\\n        \\n        int cols = matrix[0].length;\\n        if (cols == 0) return 0;\\n        \\n        for (int ileft = 0; ileft < cols; ileft++) {\\n            // Contains sum of numbers between ileft and iright\\n            int[] rowSums = new int[rows];\\n                \\n            for (int iright = ileft; iright < cols; iright++) {\\n                \\n                for (int row = 0; row < rows; row++) {\\n                    rowSums[row] += matrix[row][iright];\\n                }\\n                \\n                // Brute force: find all ranges in rowSums that add up to target\\n                for (int isum = 0; isum < rowSums.length; isum++) {\\n                \\n                    int curSum = 0; \\n                    for (int jsum = isum; jsum < rowSums.length; jsum++) {\\n                        curSum += rowSums[jsum];\\n                        \\n                        if (curSum == target) {\\n                            result++;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSubmatrixSumTarget(int[][] matrix, int target) {\\n        int result = 0;\\n        \\n        int rows = matrix.length;\\n        if (rows == 0) return 0;\\n        \\n        int cols = matrix[0].length;\\n        if (cols == 0) return 0;\\n        \\n        for (int ileft = 0; ileft < cols; ileft++) {\\n            // Contains sum of numbers between ileft and iright\\n            int[] rowSums = new int[rows];\\n                \\n            for (int iright = ileft; iright < cols; iright++) {\\n                \\n                for (int row = 0; row < rows; row++) {\\n                    rowSums[row] += matrix[row][iright];\\n                }\\n                \\n                // Brute force: find all ranges in rowSums that add up to target\\n                for (int isum = 0; isum < rowSums.length; isum++) {\\n                \\n                    int curSum = 0; \\n                    for (int jsum = isum; jsum < rowSums.length; jsum++) {\\n                        curSum += rowSums[jsum];\\n                        \\n                        if (curSum == target) {\\n                            result++;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539506,
                "title": "python3-kadane-algorithm-time-o-row-2-c-space-o-c-kind-of-similar-to-problem363",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # Kind of similar to 363\\n        # kadane algorithm: find all possible sum in a matrix/rectangle\\n        # Time: O(row^2*c). Space: O(c)\\n        res = 0\\n        for l in range(len(matrix[0])):\\n            col = [0] * len(matrix)\\n            for r in range(l, len(matrix[0])):\\n                for i in range(len(matrix)):\\n                    col[i] += matrix[i][r]\\n                cumu_sum = defaultdict(int) # Need to memorize the number.\\n                sums = 0\\n                for i, n in enumerate(col):\\n                    sums += n\\n                    if sums == target: # If itself is target\\n                        res += 1\\n                    if sums - target in cumu_sum: # Range sum is target\\n                        res += cumu_sum[sums - target] # Here add up the number\\n                    cumu_sum[sums] += 1 # Update after two \\'if\\'\\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\\n        # Kind of similar to 363\\n        # kadane algorithm: find all possible sum in a matrix/rectangle\\n        # Time: O(row^2*c). Space: O(c)\\n        res = 0\\n        for l in range(len(matrix[0])):\\n            col = [0] * len(matrix)\\n            for r in range(l, len(matrix[0])):\\n                for i in range(len(matrix)):\\n                    col[i] += matrix[i][r]\\n                cumu_sum = defaultdict(int) # Need to memorize the number.\\n                sums = 0\\n                for i, n in enumerate(col):\\n                    sums += n\\n                    if sums == target: # If itself is target\\n                        res += 1\\n                    if sums - target in cumu_sum: # Range sum is target\\n                        res += cumu_sum[sums - target] # Here add up the number\\n                    cumu_sum[sums] += 1 # Update after two \\'if\\'\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 519657,
                "title": "c-3-2s-99-solution-using-prefix-sum",
                "content": "This solution is based on calculating contiguous array with `sum = k` for an array with possible negative numbers in `O(n)` time. This is problem 560 on LC. \\n\\nOnce you solve that problem, this one is straight forward. We iterate through all possible `x` and `x\\'`, using cumulative sum, and apply the algorithm from problem 560 to get all subarrays `y`, `y\\'` in `O(n)` time, which leads to a total run-time of `O(R*R*C)`, which is `O(N^3)`.  \\n\\nOnly 1 array is needed, since we only need the cumulative sum, so after calculating all submatrices of dimensions `{x, x\\', *, *}`, we can get cumulative sum for `{x, x\\'+1, *, *}` by just adding `matrix[x\\'+1]` onto the previous cumulative matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t R = matrix.size(), C = matrix[0].size();\\n        \\n        vector<int> rowAcc;\\n        unordered_map<int, int> m;\\n        int sum = 0, count = 0;\\n        for(int r = 0; r < R; ++r) {\\n            rowAcc = matrix[r];\\n            for(int i = r; i < R; ++i) {\\n                m.clear();\\n                m[0] = 1;\\n                sum = 0;\\n                for(int j = 0; j < C; ++j) {\\n                    sum += rowAcc[j];\\n                    if(m.count(sum - target)) count += m[sum-target];\\n                    ++m[sum];\\n                    if(i < R-1) rowAcc[j] += matrix[i+1][j];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n        size_t R = matrix.size(), C = matrix[0].size();\\n        \\n        vector<int> rowAcc;\\n        unordered_map<int, int> m;\\n        int sum = 0, count = 0;\\n        for(int r = 0; r < R; ++r) {\\n            rowAcc = matrix[r];\\n            for(int i = r; i < R; ++i) {\\n                m.clear();\\n                m[0] = 1;\\n                sum = 0;\\n                for(int j = 0; j < C; ++j) {\\n                    sum += rowAcc[j];\\n                    if(m.count(sum - target)) count += m[sum-target];\\n                    ++m[sum];\\n                    if(i < R-1) rowAcc[j] += matrix[i+1][j];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 505938,
                "title": "c-solution",
                "content": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int t) {\\n        for(auto & r : m) for(int i = 1; i < m[0].size(); i++) r[i] += r[i-1];\\n        \\n        int res = 0;\\n        for(int c1 = 0; c1 < m[0].size(); c1++) {\\n            for(int c2 = c1; c2 < m[0].size(); c2++) {\\n                unordered_map<int, int> map;\\n                map[0] = 1;\\n                int preSum = 0;\\n                for(int k = 0; k < m.size(); k++) {\\n                    int v = m[k][c2] - (c1 == 0 ? 0 : m[k][c1-1]);\\n                    preSum += v;\\n                    res += map[preSum-t];\\n                    map[preSum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numSubmatrixSumTarget(vector<vector<int>>& m, int t) {\\n        for(auto & r : m) for(int i = 1; i < m[0].size(); i++) r[i] += r[i-1];\\n        \\n        int res = 0;\\n        for(int c1 = 0; c1 < m[0].size(); c1++) {\\n            for(int c2 = c1; c2 < m[0].size(); c2++) {\\n                unordered_map<int, int> map;\\n                map[0] = 1;\\n                int preSum = 0;\\n                for(int k = 0; k < m.size(); k++) {\\n                    int v = m[k][c2] - (c1 == 0 ? 0 : m[k][c1-1]);\\n                    preSum += v;\\n                    res += map[preSum-t];\\n                    map[preSum]++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502796,
                "title": "c-matrix-compression-3992ms-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint helper(vector<int>& temp,int target){\\n\\t\\t\\tint n=temp.size();\\n\\t\\t\\tunordered_map<int,int> m;\\n\\t\\t\\tm[0]=1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint prefixSum=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tprefixSum+=temp[i];\\n\\t\\t\\t\\tif(m.count(prefixSum-target)){\\n\\t\\t\\t\\t\\tans+=m[prefixSum-target];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tm[prefixSum]+=1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tint numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint m=matrix.size();\\n\\t\\t\\tint n=matrix[0].size();\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tvector<int> temp(n,0);\\n\\t\\t\\t\\tfor(int j=i;j<m;j++){\\n\\t\\t\\t\\t\\tfor(int k=0;k<n;k++){\\n\\t\\t\\t\\t\\t\\ttemp[k]+=matrix[j][k];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t res+=helper(temp,target);\\n\\t\\t\\t\\t}    \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint helper(vector<int>& temp,int target){\\n\\t\\t\\tint n=temp.size();\\n\\t\\t\\tunordered_map<int,int> m;\\n\\t\\t\\tm[0]=1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint prefixSum=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tprefixSum+=temp[i];\\n\\t\\t\\t\\tif(m.count(prefixSum-target)){\\n\\t\\t\\t\\t\\tans+=m[prefixSum-target];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565291,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1575831,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1570428,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1572723,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 1971276,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            },
            {
                "id": 2050719,
                "content": [
                    {
                        "username": "mhelvens",
                        "content": "![image](https://assets.leetcode.com/users/mhelvens/image_1563627416.png)\\n"
                    },
                    {
                        "username": "crutch_user",
                        "content": "Generalize the this problem to K dimensions.\\n- 1-D: Given an array length n and number T. Count number of subarrays with sum T.\\nSolve by hash table and prefix sums with O(n) time complexity.\\n- 2-D: Given an square matrix (nxn) and number T.  Count number of submatrixes with sum T.\\nCompute prefix sums for all rows - `O(n^2)`. For all columns i and j (i <= j): translate (compress) submatrix  between this columns (inclusive) to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n)`. Now this is 1D case. Solve by `O(n)` for all (i, j).\\nTotal time complexity: `O(n^2 + n^2 * n) = O(n^3)`.\\n- 3-D: Given an cube (nxnxn) and number T. Count number of subcubes with sum T. \\nSuggest a solution: Cube is array of layers (matrixes). Compute prefix sums for all rows in layers  - `O(n^3)`. For all axes i and j (i <= j): given subcube between this axes (inclusive). Translate (compress) layer of this subcube to array (all elements is sum of row this submatrix) with length n by prefix sums - `O(n^2)`. This arrays form a matrix. Now this is 2D case. Solve by `O(n^3)` for all (i, j).\\nTotal time complexity: `O(n^3 + n^2 * n^3) = O(n^5)`.\\n- K-D: Given an hypercube with k dimensions (nxnxn...xn) and number T. Count number of subhypercubes with sum T.\\nSuggest a solution: use decreasing dimension. Like in cases above we slice hypercube by two axes and compress subhypercube beetween this axes (inclusive) two hypercube with dimension less by one. Use slice\\\\compress while we not giving a 1-D case. Proof this by mathematical induction?\\nTotal time complexity: `O(n^k + n^(1+2*(k-1))) = O(n^(1+2*(k-1)))`.\\n\\nWhat do you think about reasoning above? I would like to see this problem on hypercubes on LeetCode."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "Please never add this thx <3 ;P"
                    },
                    {
                        "username": "Maristie",
                        "content": "I\\'ll just give several possible variants of this problem if you\\'re interested.\\n1. Decide whether there\\'s a submatrix summing to a target\\n2. Count submatrices summing to a target (exactly this one)\\n3. Decide whether there\\'s a submatrix whose sum is no larger than K\\n4. Count submatrices whose sum is no larger than K\\n5. Count submatrices whose sum is between `[k1, k2]`\\n6. Decide the maximum submatrix sum which is no larger than K ([363. Max Sum of Rectangle No Larger Than K](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/))\\n7. Decide the maximum number of elements in a submatrix whose sum is no larger than K"
                    },
                    {
                        "username": "NEU20133823",
                        "content": "![image](https://assets.leetcode.com/users/neu20133823/image_1559448784.png)\\nThe custom testcase was given from my failed submission before. I spent more than 30 minutes debugging it and still could not pass. Then I submitted near the final second of the contest and got AC??? Why?\\nMy solution is O(N^3)."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Asked in interview of MediaNet."
                    },
                    {
                        "username": "CodeMore19",
                        "content": "which college? for intern or placement??"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Any similar easy problem to solve before this? I\\'m kind of not able to solve this."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "https://leetcode.com/problems/subarray-sum-equals-k/"
                    }
                ]
            }
        ]
    }
]