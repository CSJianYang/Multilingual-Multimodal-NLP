[
    {
        "title": "Maximum Value of K Coins From Piles",
        "question_content": "There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.\nIn one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.\nGiven a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.\n&nbsp;\nExample 1:\n\nInput: piles = [[1,100,3],[7,8,9]], k = 2\nOutput: 101\nExplanation:\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\nExample 2:\n\nInput: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\nOutput: 706\nExplanation:\nThe maximum total can be obtained if we choose all coins from the last pile.\n\n&nbsp;\nConstraints:\n\n\tn == piles.length\n\t1 <= n <= 1000\n\t1 <= piles[i][j] <= 105\n\t1 <= k <= sum(piles[i].length) <= 2000",
        "solutions": [
            {
                "id": 1887010,
                "title": "java-c-python-top-down-dp-solution",
                "content": "# **Intuition**\\nTop down dynamic programming.\\nAlso noticed that some people already get accepted, a dp program.\\n<br>\\n\\n# **Explanation**\\n`dp[i,k]` means picking `k` elements from `pile[i]` to `pile[n-1]`.\\nWe can pick 0,1,2,3... elements from the current `pile[i]` one by one.\\nIt asks for the maximum total value of coins we can have,\\nso we need to return `max` of all the options.\\n<br>\\n\\n# **Complexity**\\nTime `O(nm)`\\nSpace `O(nk)`\\nwhere `m = sum(piles[i].length) <= 2000`\\n<br>\\n\\n**Java**\\nFrom @ssmegentle\\n```java\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        Integer[][] memo = new Integer[piles.size() + 1][k + 1];\\n\\n        return dp(piles, memo, 0, k);\\n    }\\n    public int dp(List<List<Integer>> piles, Integer[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.size()) return 0;\\n        if (memo[i][k] != null) return memo[i][k];\\n\\n        int res = dp(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, cur + dp(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n```\\n**Python**\\n```py\\n    def maxValueOfCoins(self, A, K):\\n        \\n        @functools.lru_cache(None)\\n        def dp(i, k):\\n            if k == 0 or i == len(A): return 0\\n            res, cur = dp(i + 1, k), 0\\n            for j in range(min(len(A[i]), k)):\\n                cur += A[i][j]\\n                res = max(res, cur + dp(i+1, k-j-1))\\n            return res\\n        \\n        return dp(0, K)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        Integer[][] memo = new Integer[piles.size() + 1][k + 1];\\n\\n        return dp(piles, memo, 0, k);\\n    }\\n    public int dp(List<List<Integer>> piles, Integer[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.size()) return 0;\\n        if (memo[i][k] != null) return memo[i][k];\\n\\n        int res = dp(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, cur + dp(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n```\n```cpp\\n    int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n```\n```py\\n    def maxValueOfCoins(self, A, K):\\n        \\n        @functools.lru_cache(None)\\n        def dp(i, k):\\n            if k == 0 or i == len(A): return 0\\n            res, cur = dp(i + 1, k), 0\\n            for j in range(min(len(A[i]), k)):\\n                cur += A[i][j]\\n                res = max(res, cur + dp(i+1, k-j-1))\\n            return res\\n        \\n        return dp(0, K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3417959,
                "title": "image-explanation-top-down-dp-easy-concise-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Maximum Value of K Coins From Piles` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/9eaa66d1-03e7-4394-93c0-4875df24d5d7_1681526852.9686515.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/91939f49-936e-4f8b-97d7-3d48ebd5355f_1681522506.1156633.png)\\n![image.png](https://assets.leetcode.com/users/images/b1342805-93ea-4693-948d-8c1b0702a36a_1681522520.1675975.png)\\n![image.png](https://assets.leetcode.com/users/images/61d2fbf7-ce76-4475-8495-c2697471c49c_1681522531.6415837.png)\\n![image.png](https://assets.leetcode.com/users/images/5aab26d9-86f1-4b11-af58-776da724f822_1681522548.880134.png)\\n![image.png](https://assets.leetcode.com/users/images/af325b84-0f8b-4825-b3ef-3d2239aed68b_1681522557.3164456.png)\\n![image.png](https://assets.leetcode.com/users/images/3af07571-8d76-486f-96df-540499f3110e_1681522565.693431.png)\\n![image.png](https://assets.leetcode.com/users/images/319fcde5-983d-4ed5-bba1-29c5ee4eed9a_1681522573.987136.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int func(int i, int k, vector<vector<int>>& piles, vector<vector<int>>& dp){\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n            cur += piles[i][j];\\n            res = max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int K) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(K + 1, 0));\\n        return func(0, K, piles, dp);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int func(int i, int k, List<List<Integer>> piles, int[][] dp) {\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles.get(i).size() && j < k; ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n + 1][K + 1];\\n        return func(0, K, piles, dp);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def _search(rest_k: int, pile_pos: int) -> int:\\n            \"\"\"Searches for best accumulated coin value starting from pile at position `pile_pos`.\\n            \\n            Args:\\n              - rest_k: The rest of coins we could pick.\\n              - pile_pos: The starting position of pile we are working on.\\n            \"\"\"\\n            if rest_k == 0 or pile_pos == len(piles): return 0\\n\\n            # Ignore the current pile and moving to next pile\\n            current_mv_found = _search(rest_k, pile_pos+1)\\n\\n            # Start looking solution with current pile being involved\\n            current_pile = piles[pile_pos]\\n            accum_coin_value = 0\\n            for i in range(min(rest_k, len(current_pile))):\\n                # Accumulate the coins\\n                accum_coin_value += current_pile[i]\\n\\n                # Moving to next pile with accumulated coin value in current pile\\n                current_mv_found = max(\\n                    current_mv_found, \\n                    accum_coin_value + _search(rest_k-i-1, pile_pos+1))\\n\\n            # Return the maximum accumulated coin value found from current pile.\\n            return current_mv_found\\n\\n        # Start searching with initial `k` and first pile\\n        return _search(k, 0)\\n```\\nCredits: Python Solution commented beautifully by @puremonkey2001\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int func(int i, int k, vector<vector<int>>& piles, vector<vector<int>>& dp){\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n            cur += piles[i][j];\\n            res = max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int K) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(K + 1, 0));\\n        return func(0, K, piles, dp);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int func(int i, int k, List<List<Integer>> piles, int[][] dp) {\\n        if (dp[i][k] > 0) return dp[i][k];\\n        if (i == piles.size() || k == 0) return 0;\\n        int res = func(i + 1, k, piles, dp), cur = 0;\\n        for (int j = 0; j < piles.get(i).size() && j < k; ++j) {\\n            cur += piles.get(i).get(j);\\n            res = Math.max(res, func(i + 1, k - j - 1, piles, dp) + cur);\\n        }\\n        dp[i][k] = res;\\n        return res;\\n    }\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n + 1][K + 1];\\n        return func(0, K, piles, dp);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def _search(rest_k: int, pile_pos: int) -> int:\\n            \"\"\"Searches for best accumulated coin value starting from pile at position `pile_pos`.\\n            \\n            Args:\\n              - rest_k: The rest of coins we could pick.\\n              - pile_pos: The starting position of pile we are working on.\\n            \"\"\"\\n            if rest_k == 0 or pile_pos == len(piles): return 0\\n\\n            # Ignore the current pile and moving to next pile\\n            current_mv_found = _search(rest_k, pile_pos+1)\\n\\n            # Start looking solution with current pile being involved\\n            current_pile = piles[pile_pos]\\n            accum_coin_value = 0\\n            for i in range(min(rest_k, len(current_pile))):\\n                # Accumulate the coins\\n                accum_coin_value += current_pile[i]\\n\\n                # Moving to next pile with accumulated coin value in current pile\\n                current_mv_found = max(\\n                    current_mv_found, \\n                    accum_coin_value + _search(rest_k-i-1, pile_pos+1))\\n\\n            # Return the maximum accumulated coin value found from current pile.\\n            return current_mv_found\\n\\n        # Start searching with initial `k` and first pile\\n        return _search(k, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418129,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be approached using dynamic programming by breaking it down into subproblems. We can create a 2D array dp[i][j] to store the maximum value of coins for choosing j coins from the first i piles. Then, we can iterate through the array and compute the maximum value of coins for each subproblem by trying all possible choices for the current pile and updating the maximum result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a 2D array dp[i][j] to store the maximum value of coins for choosing j coins from the first i piles.\\n2. Fill the first row and column of the array with zeros.\\n3. Iterate through the array and compute the maximum value of coins for each subproblem by trying all possible choices for the current pile and updating the maximum result.\\n4. If not choosing any coin from the current pile gives a better result, use that instead.\\n5. The last element of the array is the maximum value of coins for choosing k coins from all the piles.\\n\\n  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3), where n is the maximum number of coins in a pile. The outer loop runs n times, the inner loop runs k times, and the innermost loop runs n times in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nk), since we are using a 2D array of size (n+1) x (k+1) to store the results.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        // create a 2D array to store the maximum value of coins for choosing j coins from the first i piles\\n        int[][] dp = new int[piles.size() + 1][k + 1];\\n        // fill the first row of the array with zeros\\n        Arrays.fill(dp[0], 0);\\n        // fill the first column of the array with zeros\\n        for (int i = 1; i <= piles.size(); i++) {\\n            dp[i][0] = 0;\\n        }\\n        // iterate through the array and compute the maximum value of coins for each subproblem\\n        for (int i = 1; i <= piles.size(); i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                // try all possible choices for the current pile and update the maximum result\\n                for (int x = 0; x < Math.min(piles.get(i - 1).size(), j); x++) {\\n                    cur += piles.get(i - 1).get(x);\\n                    dp[i][j] = Math.max(dp[i][j], cur + dp[i - 1][j - x - 1]);\\n                }\\n                // if not choosing any coin from the current pile gives a better result, use that instead\\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n            }\\n        }\\n        // the last element of the array is the maximum value of coins for choosing k coins from all the piles\\n        return dp[piles.size()][k];\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * @param {number[][]} piles\\n * @param {number} k\\n * @return {number}\\n */\\n \\nvar maxValueOfCoins = function(piles, k) {\\n    // Initialize a 2D array dp with dimensions (n+1) x (k+1) to store the maximum value of coins\\n    // for choosing j coins from the first i piles\\n    const n = piles.length;\\n    const dp = Array(n + 1).fill().map(() => Array(k + 1).fill(0));\\n    \\n    // Iterate through the rows of dp and compute the maximum value of coins for each subproblem\\n    for (let i = 1; i <= n; i++) {\\n        // Iterate through the columns of dp and compute the maximum value of coins for each subproblem\\n        for (let j = 1; j <= k; j++) {\\n            let cur = 0;\\n            // Iterate through the first j coins of the ith pile and compute the maximum value of coins\\n            // for choosing x coins from the ith pile and (j-x) coins from the first (i-1) piles\\n            for (let x = 0; x < Math.min(j, piles[i-1].length); x++) {\\n                cur += piles[i-1][x];\\n                dp[i][j] = Math.max(dp[i][j], cur + dp[i-1][j-x-1]);\\n            }\\n            // Take the maximum value of coins for choosing j coins from the first (i-1) piles\\n            dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n        }\\n    }\\n    // Return the maximum value of coins for choosing k coins from all the piles\\n    return dp[n][k];\\n};\\n\\n```\\n```python []\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0] * (k + 1) for _ in range(len(piles) + 1)]\\n        for i in range(1, len(piles) + 1):\\n            for j in range(1, k + 1):\\n                cur = 0\\n                for x in range(min(len(piles[i - 1]), j)):\\n                    cur += piles[i - 1][x]\\n                    dp[i][j] = max(dp[i][j], cur + dp[i - 1][j - x - 1])\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\\n        return dp[len(piles)][k]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                for (int x = 0; x < min(j, (int)piles[i-1].size()); x++) {\\n                    cur += piles[i-1][x];\\n                    dp[i][j] = max(dp[i][j], cur + dp[i-1][j-x-1]);\\n                }\\n                dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        // create a 2D array to store the maximum value of coins for choosing j coins from the first i piles\\n        int[][] dp = new int[piles.size() + 1][k + 1];\\n        // fill the first row of the array with zeros\\n        Arrays.fill(dp[0], 0);\\n        // fill the first column of the array with zeros\\n        for (int i = 1; i <= piles.size(); i++) {\\n            dp[i][0] = 0;\\n        }\\n        // iterate through the array and compute the maximum value of coins for each subproblem\\n        for (int i = 1; i <= piles.size(); i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                // try all possible choices for the current pile and update the maximum result\\n                for (int x = 0; x < Math.min(piles.get(i - 1).size(), j); x++) {\\n                    cur += piles.get(i - 1).get(x);\\n                    dp[i][j] = Math.max(dp[i][j], cur + dp[i - 1][j - x - 1]);\\n                }\\n                // if not choosing any coin from the current pile gives a better result, use that instead\\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n            }\\n        }\\n        // the last element of the array is the maximum value of coins for choosing k coins from all the piles\\n        return dp[piles.size()][k];\\n    }\\n}\\n```\n```javascript []\\n/**\\n * @param {number[][]} piles\\n * @param {number} k\\n * @return {number}\\n */\\n \\nvar maxValueOfCoins = function(piles, k) {\\n    // Initialize a 2D array dp with dimensions (n+1) x (k+1) to store the maximum value of coins\\n    // for choosing j coins from the first i piles\\n    const n = piles.length;\\n    const dp = Array(n + 1).fill().map(() => Array(k + 1).fill(0));\\n    \\n    // Iterate through the rows of dp and compute the maximum value of coins for each subproblem\\n    for (let i = 1; i <= n; i++) {\\n        // Iterate through the columns of dp and compute the maximum value of coins for each subproblem\\n        for (let j = 1; j <= k; j++) {\\n            let cur = 0;\\n            // Iterate through the first j coins of the ith pile and compute the maximum value of coins\\n            // for choosing x coins from the ith pile and (j-x) coins from the first (i-1) piles\\n            for (let x = 0; x < Math.min(j, piles[i-1].length); x++) {\\n                cur += piles[i-1][x];\\n                dp[i][j] = Math.max(dp[i][j], cur + dp[i-1][j-x-1]);\\n            }\\n            // Take the maximum value of coins for choosing j coins from the first (i-1) piles\\n            dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n        }\\n    }\\n    // Return the maximum value of coins for choosing k coins from all the piles\\n    return dp[n][k];\\n};\\n\\n```\n```python []\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0] * (k + 1) for _ in range(len(piles) + 1)]\\n        for i in range(1, len(piles) + 1):\\n            for j in range(1, k + 1):\\n                cur = 0\\n                for x in range(min(len(piles[i - 1]), j)):\\n                    cur += piles[i - 1][x]\\n                    dp[i][j] = max(dp[i][j], cur + dp[i - 1][j - x - 1])\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\\n        return dp[len(piles)][k]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                int cur = 0;\\n                for (int x = 0; x < min(j, (int)piles[i-1].size()); x++) {\\n                    cur += piles[i-1][x];\\n                    dp[i][j] = max(dp[i][j], cur + dp[i-1][j-x-1]);\\n                }\\n                dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886905,
                "title": "python-dp-solution-complexity-updated-explained",
                "content": "Let use dp with states `dp(n, k)`, where it is `(current index of pile, nubmer of elements we still need to take)`. Then on each state we can try to take `0, ..., min(k, len(piles[m]))` elements from pile `m`. Also if `n == N`, that is we reached the last pile and `k == 0`, we are happy, return `0`. If `k > 0`, it means that we reached the last pile and did not take `k` elements, we are not happy, return `-inf`.\\n\\n#### Complexity\\nImagine, that piles have `x1, ..., xn` elements in them. Then for state `(1, k)` we have `x1` possible transactions, for state `(2, k)` we have `x2` possible transactions and so on. In total we have `x1 + ... + xn` transactions for every value of `k`. So, in total we have time complexity `O(M * K)`, where `M = x1 + ... + xn`. Space is `O(n * K)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles, K):\\n        N = len(piles)\\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == N:\\n                if k == 0: return 0\\n                if k > 0: return -float(\"inf\")\\n            ans = dp(n + 1, k)\\n            sm = 0\\n            for i in range(min(k, len(piles[n]))):\\n                sm += piles[n][i]\\n                ans = max(ans, dp(n + 1, k - i - 1) + sm)\\n            return ans\\n\\n        return dp(0, K)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles, K):\\n        N = len(piles)\\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == N:\\n                if k == 0: return 0\\n                if k > 0: return -float(\"inf\")\\n            ans = dp(n + 1, k)\\n            sm = 0\\n            for i in range(min(k, len(piles[n]))):\\n                sm += piles[n][i]\\n                ans = max(ans, dp(n + 1, k - i - 1) + sm)\\n            return ans\\n\\n        return dp(0, K)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886912,
                "title": "again-knapsack-variation-easy-to-understand",
                "content": "TC - O(N*M) n=size of piles, m=size of piles[i]\\n**JAVA**\\n```\\nclass Solution {\\n    Integer dp[][];\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.dp = new Integer[piles.size() + 1][k + 1];\\n        return solve(0, piles, k);\\n    }\\n\\n    private int solve(int index, List<List<Integer>> p, int k) {\\n        if (index >= p.size()) return 0;\\n        int max = 0, sum = 0;\\n        if (dp[index][k] != null) return dp[index][k];\\n        //either dont take from that pile\\n        max = Math.max(max, solve(index + 1, p, k));\\n        for (int i = 0; i < p.get(index).size(); i++) {\\n            sum += p.get(index).get(i);\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) max = Math.max(max, sum + solve(index + 1, p, k - (i + 1)));\\n        }\\n        return dp[index][k] = max; // return max\\n    }\\n}\\n```\\n**CPP**\\n```\\nclass Solution {\\n    public:\\n        int dp[2001][2001] = { 0 };\\n    int maxValueOfCoins(vector < vector < int >> & piles, int k) {\\n        return solve(0, piles, k);\\n    }\\n    int solve(int index, vector < vector < int >> & piles, int k) {\\n        if (index >= piles.size()) return 0;\\n        if (dp[index][k] != 0) return dp[index][k];\\n        int maxi = 0, sum = 0;\\n        //either dont take from that pile\\n        maxi = max(maxi, solve(index + 1, piles, k));\\n        for (int i = 0; i < piles[index].size(); i++) {\\n            sum += piles[index][i];\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) maxi = max(maxi, sum + solve(index + 1, piles, k - (i + 1)));\\n        }\\n        return dp[index][k] = maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.dp = new Integer[piles.size() + 1][k + 1];\\n        return solve(0, piles, k);\\n    }\\n\\n    private int solve(int index, List<List<Integer>> p, int k) {\\n        if (index >= p.size()) return 0;\\n        int max = 0, sum = 0;\\n        if (dp[index][k] != null) return dp[index][k];\\n        //either dont take from that pile\\n        max = Math.max(max, solve(index + 1, p, k));\\n        for (int i = 0; i < p.get(index).size(); i++) {\\n            sum += p.get(index).get(i);\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) max = Math.max(max, sum + solve(index + 1, p, k - (i + 1)));\\n        }\\n        return dp[index][k] = max; // return max\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public:\\n        int dp[2001][2001] = { 0 };\\n    int maxValueOfCoins(vector < vector < int >> & piles, int k) {\\n        return solve(0, piles, k);\\n    }\\n    int solve(int index, vector < vector < int >> & piles, int k) {\\n        if (index >= piles.size()) return 0;\\n        if (dp[index][k] != 0) return dp[index][k];\\n        int maxi = 0, sum = 0;\\n        //either dont take from that pile\\n        maxi = max(maxi, solve(index + 1, piles, k));\\n        for (int i = 0; i < piles[index].size(); i++) {\\n            sum += piles[index][i];\\n            //or take some certain prefix from that pile, if we can take that much elements.\\n            if (k - (i + 1) >= 0) maxi = max(maxi, sum + solve(index + 1, piles, k - (i + 1)));\\n        }\\n        return dp[index][k] = maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887130,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int maxValueOfCoins(vector<vector < int>> &p, int k)\\n        {\\n            int n = p.size();\\n            vector<vector < int>> dp(n + 1, vector<int> (k + 1, -1));\\n            return solve(0, dp, p, k);\\n        }\\n        int solve(int index, vector<vector < int>> &dp, vector< vector< int>> &p, int k)\\n        {\\n            if (index >= p.size())\\n                return 0;\\n\\n            int maxi = 0, sum = 0;\\n\\n            if (dp[index][k] != -1)\\n                return dp[index][k];\\n            \\n            //dont take from that pile\\n            maxi = max(maxi, solve(index + 1, dp, p, k));\\n\\n            for (int i = 0; i < p[index].size(); i++)\\n            {\\n                sum += p[index][i];\\n                \\n                //take some certain prefix from that pile, if we can take that much elements.\\n                if (k - (i + 1) >= 0)\\n                    maxi = max(maxi, sum + solve(index + 1, dp, p, k - (i + 1)));\\n            }\\n            return dp[index][k] = maxi;\\t// return max\\n        }\\n};\\n```\\n\\nC++ version of @x21svage \\'s code",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxValueOfCoins(vector<vector < int>> &p, int k)\\n        {\\n            int n = p.size();\\n            vector<vector < int>> dp(n + 1, vector<int> (k + 1, -1));\\n            return solve(0, dp, p, k);\\n        }\\n        int solve(int index, vector<vector < int>> &dp, vector< vector< int>> &p, int k)\\n        {\\n            if (index >= p.size())\\n                return 0;\\n\\n            int maxi = 0, sum = 0;\\n\\n            if (dp[index][k] != -1)\\n                return dp[index][k];\\n            \\n            //dont take from that pile\\n            maxi = max(maxi, solve(index + 1, dp, p, k));\\n\\n            for (int i = 0; i < p[index].size(); i++)\\n            {\\n                sum += p[index][i];\\n                \\n                //take some certain prefix from that pile, if we can take that much elements.\\n                if (k - (i + 1) >= 0)\\n                    maxi = max(maxi, sum + solve(index + 1, dp, p, k - (i + 1)));\\n            }\\n            return dp[index][k] = maxi;\\t// return max\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418438,
                "title": "easy-dp-solution-approach-explained-beginner-friendly",
                "content": "# Intuition\\nThe intuition here is to understand that when we are on any currentPile we have two choices\\n- either to exclude that pile and move on to next one or\\n- pick from currentPile one or two or three coins and so on till <= K(coinsLeft to pick) and currentPile is not exhausted of coins and then move on to new pile if coins are left\\n\\nNow when we try to solve with above approach, we see that there are repeating sub problems so we will go ahead and store results of repeating subproblems in a 2D DP array.\\n\\nDP[i][j] represent the max-value of coins(or sum) from j coins, when we are on ith pile.\\n\\n---\\n\\n\\n# Approach\\n1) We declare dp[n+1][k+1], we need to intialise DP with some variable so that we know if we have solved that subproblem so either intialise all elements *by -1* or i have made *dp = new Integer[][]* so that by default it is intialised *to null values*.\\n\\n2) Following top down approach we start iterating from last pile\\n- check base conditions\\n- return if we have already solved for that case already\\n\\n3) If above coditions don\\'t pass then we calcualte what is coinPickLimit\\n```\\nint coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n```\\nminmium we are taking since the each piles coins can get exhausted if we plan to take multiple coins from it.\\n\\n4) for currentPile either we \\n- exclude it and move on to next pile \\n```\\nint excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n```\\n- or we include the currentPile and take 1 or 2 or .. coins from it(so for loop), we calculate sum and move onto next pile. Each time we pick a coin from curretPile we add to sum and move on to next pile get the result, we can repeat this till cointsLeftLimit.\\n\\nSo we calculate all possiblities of currentPile if we take one coint move on to next pile, then if we took 2 coins from currentPile and moved on to next pile and so on\\n\\nNow we have both result from excludeCurrentPile, includeCurentPile we do\\n```\\nMath.max(includeCurentPile, excludeCurrentPile)\\n```\\nand set it to dp[currentPile][coinsLeft]\\n\\nTry dry the code with 3 piles you will get the idea and why dp is imp as we are reusing our results.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\nO(n*k) where n is the total number of coins in all the piles\\n\\n---\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n----\\n\\n# Code\\n```\\nclass Solution {\\n    private Integer dp[][];\\n    private int helper(List<List<Integer>> piles, int currentPile, int coinsLeft){\\n        if(currentPile<0 || coinsLeft == 0)\\n            return 0;\\n        if(dp[currentPile][coinsLeft]!=null)\\n            return dp[currentPile][coinsLeft];\\n\\n        int coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n\\n        //not including that currentPile, so coinsLeft remain same\\n        int excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n        \\n        int includeCurentPile=0;\\n        for(int j=0, sum=0; j<coinsPickLimit ; j++){\\n            sum+= piles.get(currentPile).get(j);\\n            //doing coinsLeft-(j+1) as we are starting from index 0 and coin picked cannot pe 0 if we pick it is > 0\\n            includeCurentPile = Math.max(sum + helper(piles, currentPile-1, coinsLeft-(j+1)), includeCurentPile);\\n        }\\n        \\n        int res = Math.max(includeCurentPile, excludeCurrentPile);\\n        dp[currentPile][coinsLeft] = res;\\n        return res;\\n\\n    } \\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        dp = new Integer[n + 1][K + 1];\\n        return helper(piles, n-1, K);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n```\n```\\nint excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n```\n```\\nMath.max(includeCurentPile, excludeCurrentPile)\\n```\n```\\nclass Solution {\\n    private Integer dp[][];\\n    private int helper(List<List<Integer>> piles, int currentPile, int coinsLeft){\\n        if(currentPile<0 || coinsLeft == 0)\\n            return 0;\\n        if(dp[currentPile][coinsLeft]!=null)\\n            return dp[currentPile][coinsLeft];\\n\\n        int coinsPickLimit = Math.min(coinsLeft, piles.get(currentPile).size());\\n\\n        //not including that currentPile, so coinsLeft remain same\\n        int excludeCurrentPile = helper(piles, currentPile-1, coinsLeft);\\n        \\n        int includeCurentPile=0;\\n        for(int j=0, sum=0; j<coinsPickLimit ; j++){\\n            sum+= piles.get(currentPile).get(j);\\n            //doing coinsLeft-(j+1) as we are starting from index 0 and coin picked cannot pe 0 if we pick it is > 0\\n            includeCurentPile = Math.max(sum + helper(piles, currentPile-1, coinsLeft-(j+1)), includeCurentPile);\\n        }\\n        \\n        int res = Math.max(includeCurentPile, excludeCurrentPile);\\n        dp[currentPile][coinsLeft] = res;\\n        return res;\\n\\n    } \\n\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        dp = new Integer[n + 1][K + 1];\\n        return helper(piles, n-1, K);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417927,
                "title": "recursion-top-down-bottom-up-easy-to-understand-code",
                "content": "### RECURSION, TLE\\n```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        int ans = solve(piles, n - 1, k);\\n        return ans;\\n        \\n    }\\n};\\n```\\n//====================================================================================================================\\n\\n### TOP DOWN [Memoization], Accepted\\n```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, vector<vector<int>>&dp, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        if (dp[endPileIdx][k] != -1) return dp[endPileIdx][k];\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, dp, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, dp, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return dp[endPileIdx][k] = maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int ans = solve(piles, dp, n - 1, k);\\n        return ans;\\n    }\\n};\\n```\\n//================================================================================================================================\\n\\n### BOTTOM UP, Accepted\\n\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, 0)); \\n        //for considering [number of piles = n]\\n        //we must already have answers for [number of piles = (n - 1)]\\n        //thus we need to go bottom up\\n        //we need to go from [no. of piles under consideration = 1 to n]\\n        \\n        //consider only (endPileIdx + 1) number of piles at a time\\n        for (int endPileIdx = 0; endPileIdx < n; endPileIdx++) //count of piles = endPileIdx + 1\\n        {\\n            int currPileSize = piles[endPileIdx].size();\\n            for (int coinsToPick = 1; coinsToPick <= k; coinsToPick++)\\n            {\\n                //=============================================================================\\n                //DON\\'T PICK ANY COIN FROM CURR PILE\\n                int maxSum = (endPileIdx - 1 < 0)? 0 : dp[endPileIdx - 1][coinsToPick];  \\n                \\n                int maxCanPick = min(coinsToPick, currPileSize);\\n                int pickedSum = 0;\\n                //now consider picking some coins\\n                for (int i = 0; i < maxCanPick; i++)\\n                {\\n                    int coinValue = piles[endPileIdx][i];\\n                    pickedSum += coinValue;\\n                    \\n                    int nextMaxSum = 0;\\n                    if (endPileIdx > 0) \\n                        nextMaxSum = dp[endPileIdx - 1][coinsToPick - i - 1];\\n                    maxSum = max(maxSum, pickedSum + nextMaxSum);\\n                }\\n                //=======================================================================================\\n                dp[endPileIdx][coinsToPick] = maxSum;\\n            }\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n````\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        int ans = solve(piles, n - 1, k);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //startPileIdx is always 0\\n    //piles under consideration for each call ==> [pileIdx = 0 to pileIdx = endPileIdx]\\n    int solve(vector<vector<int>>&piles, vector<vector<int>>&dp, int endPileIdx, int k)\\n    {\\n        if (endPileIdx < 0 || k == 0) return 0;\\n        if (dp[endPileIdx][k] != -1) return dp[endPileIdx][k];\\n        \\n        int currPileSize = piles[endPileIdx].size(); \\n        int maxCanPick = min(k, currPileSize);\\n        \\n        //consider \\'not picking\\' any coin\\n        int maxSum = solve(piles, dp, endPileIdx - 1, k);  //DON\\'T PICK ANY COIN FROM CURR PILE\\n        int pickedSum = 0;\\n        //===============================================================================\\n        //now consider picking some coins\\n        for (int i = 0; i < maxCanPick; i++)\\n        {\\n            int coinValue = piles[endPileIdx][i];\\n            pickedSum += coinValue;\\n            \\n            int nextMaxSum = solve(piles, dp, endPileIdx - 1, k - i - 1); \\n            maxSum = max(maxSum, pickedSum + nextMaxSum);\\n        }\\n        //=================================================================================\\n        return dp[endPileIdx][k] = maxSum;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int ans = solve(piles, dp, n - 1, k);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) \\n    {\\n        int n = piles.size();\\n        vector<vector<int>>dp(n, vector<int>(k + 1, 0)); \\n        //for considering [number of piles = n]\\n        //we must already have answers for [number of piles = (n - 1)]\\n        //thus we need to go bottom up\\n        //we need to go from [no. of piles under consideration = 1 to n]\\n        \\n        //consider only (endPileIdx + 1) number of piles at a time\\n        for (int endPileIdx = 0; endPileIdx < n; endPileIdx++) //count of piles = endPileIdx + 1\\n        {\\n            int currPileSize = piles[endPileIdx].size();\\n            for (int coinsToPick = 1; coinsToPick <= k; coinsToPick++)\\n            {\\n                //=============================================================================\\n                //DON\\'T PICK ANY COIN FROM CURR PILE\\n                int maxSum = (endPileIdx - 1 < 0)? 0 : dp[endPileIdx - 1][coinsToPick];  \\n                \\n                int maxCanPick = min(coinsToPick, currPileSize);\\n                int pickedSum = 0;\\n                //now consider picking some coins\\n                for (int i = 0; i < maxCanPick; i++)\\n                {\\n                    int coinValue = piles[endPileIdx][i];\\n                    pickedSum += coinValue;\\n                    \\n                    int nextMaxSum = 0;\\n                    if (endPileIdx > 0) \\n                        nextMaxSum = dp[endPileIdx - 1][coinsToPick - i - 1];\\n                    maxSum = max(maxSum, pickedSum + nextMaxSum);\\n                }\\n                //=======================================================================================\\n                dp[endPileIdx][coinsToPick] = maxSum;\\n            }\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886987,
                "title": "java-bottom-up-dp-with-clear-explanation-and-code",
                "content": "Either pick all k from previous piles, or choose j from current pile and pick k-j from previous piles\\n**Recurrence relation**:\\n`f(n,k)` represents the max sum of coins collected from first `n` piles and choosing `k` top coins.\\n```\\nf(n,k) = max(\\n\\t\\t\\tf(n-1,k) // pick k from previous n-1 piles\\n\\t\\t\\t,max(f(n-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[n-1].size())) // pick j+1 from current pile and k-j-1 from previous n-1 piles\\n\\t\\t)\\n```\\nif k = 0, i.e. you can\\'t pick any coin then ans = 0\\nif n = 0, i.e. you don\\'t have any piles then ans = 0\\n**Base cases** :\\n`f(0,k) = 0`\\n`f(n,0) = 0`\\n\\n```\\n/*\\nf(i,k) = max(f(i-1,k),max(f(i-1,k-j-1)+sum(j) for j = 0 to max(k,p[i-1].length)))\\nf(i,0) = 0\\nf(0,k) = 0\\n*/\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n+1][K+1];\\n        \\n        for(int i = 1; i <= n; i ++) {\\n            for(int k = 1; k <= K; k ++) {\\n                dp[i][k] = dp[i-1][k];\\n                int sum = 0;\\n                int picked = 1;\\n                for(int v: piles.get(i-1)) {\\n                    if(k-picked < 0) {\\n                        break;\\n                    }\\n                    sum += v;\\n                    dp[i][k] = Math.max(dp[i][k], dp[i-1][k-picked]+sum);\\n                    picked ++;\\n                }\\n            }\\n        }\\n        return dp[n][K];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nf(n,k) = max(\\n\\t\\t\\tf(n-1,k) // pick k from previous n-1 piles\\n\\t\\t\\t,max(f(n-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[n-1].size())) // pick j+1 from current pile and k-j-1 from previous n-1 piles\\n\\t\\t)\\n```\n```\\n/*\\nf(i,k) = max(f(i-1,k),max(f(i-1,k-j-1)+sum(j) for j = 0 to max(k,p[i-1].length)))\\nf(i,0) = 0\\nf(0,k) = 0\\n*/\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int K) {\\n        int n = piles.size();\\n        int[][] dp = new int[n+1][K+1];\\n        \\n        for(int i = 1; i <= n; i ++) {\\n            for(int k = 1; k <= K; k ++) {\\n                dp[i][k] = dp[i-1][k];\\n                int sum = 0;\\n                int picked = 1;\\n                for(int v: piles.get(i-1)) {\\n                    if(k-picked < 0) {\\n                        break;\\n                    }\\n                    sum += v;\\n                    dp[i][k] = Math.max(dp[i][k], dp[i-1][k-picked]+sum);\\n                    picked ++;\\n                }\\n            }\\n        }\\n        return dp[n][K];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888175,
                "title": "explained-solution-by-relating-it-to-coin-change-problem-memoisation-c",
                "content": "### **Intution and Relation with Coin Change**\\nLets try to recall what do we do in coin change , we go to every index and either pick or not pick the element.\\nSimilarly , in this question , we go to every index and because we can pick atmost k elements so , we try all the possibilities of picking elements from 0 to min(piles[idx].size() , k ) and we have to take max of all the possibilities \\nwe tried and return . As simple as that. For the memoisation part , the two parameters that are changing are memoised to reduce the \\n**Time complexity from O(K^n) to (O(k*n)**\\nIf you dont understand any part , try to recall coin change problem thoroughly or comment below. I would be happy to explain further.\\n\\n\\n```\\n    int fun(vector<vector<int>>& piles, vector<vector<int>>& dp , int idx , int k)\\n    {\\n        if(idx == piles.size() || k==0) return 0;\\n        \\n        if(dp[idx][k]!= -1) return dp[idx][k] ;\\n        \\n        int ans = fun(piles, dp , idx+1 , k ) ;\\n        int sum = 0;\\n        \\n        for(int i=0; i< min(int(piles[idx].size()) , k) ; i++)\\n        {\\n            sum+=piles[idx][i] ;\\n            ans = max(ans , sum + fun(piles , dp , idx+1 , k-i-1)) ;\\n        }\\n        \\n        return dp[idx][k] = ans ;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         \\n         int n = piles.size();\\n         vector<vector<int> > dp(n+1 , vector<int>(k+1 , -1)) ;\\n      \\n        return fun(piles , dp , 0 , k) ;\\n        \\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "### **Intution and Relation with Coin Change**\\nLets try to recall what do we do in coin change , we go to every index and either pick or not pick the element.\\nSimilarly , in this question , we go to every index and because we can pick atmost k elements so , we try all the possibilities of picking elements from 0 to min(piles[idx].size() , k ) and we have to take max of all the possibilities \\nwe tried and return . As simple as that. For the memoisation part , the two parameters that are changing are memoised to reduce the \\n**Time complexity from O(K^n) to (O(k*n)**\\nIf you dont understand any part , try to recall coin change problem thoroughly or comment below. I would be happy to explain further.\\n\\n\\n```\\n    int fun(vector<vector<int>>& piles, vector<vector<int>>& dp , int idx , int k)\\n    {\\n        if(idx == piles.size() || k==0) return 0;\\n        \\n        if(dp[idx][k]!= -1) return dp[idx][k] ;\\n        \\n        int ans = fun(piles, dp , idx+1 , k ) ;\\n        int sum = 0;\\n        \\n        for(int i=0; i< min(int(piles[idx].size()) , k) ; i++)\\n        {\\n            sum+=piles[idx][i] ;\\n            ans = max(ans , sum + fun(piles , dp , idx+1 , k-i-1)) ;\\n        }\\n        \\n        return dp[idx][k] = ans ;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         \\n         int n = piles.size();\\n         vector<vector<int> > dp(n+1 , vector<int>(k+1 , -1)) ;\\n      \\n        return fun(piles , dp , 0 , k) ;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1888833,
                "title": "c-top-down-memoization-with-explanation",
                "content": "**Approach:-**\\n-->This is the **DP Approach with Memoization.**\\n-->We have Choices for any i\\'th index Pile. :-\\n 1)Either We should not take any Coin from  i\\'th index pile.\\n 2)Either we take one top coin from it.\\n 3)Either we take 2 consecutive top coin from that pile.\\n And So ...on \\n -->And After that We call for (i+1)th index Pile.\\n ```\\nclass Solution {\\npublic:\\n    int dp[1001][2001]; //Dp array For Memoization.\\n    int solve(vector<vector<int>>&v,int index,int coin)\\n    {\\n        if(index>=v.size()||coin==0)  //Base Condition\\n            return 0;\\n        if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n            return dp[index][coin];\\n        \\n        \\n        /* Our 1st choice :- We not take any Coin from that pile*/\\n        int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n        \\n       \\n        /*Otherwise we can take Coins from that Pile.*/\\n        int loop=v[index].size()-1;\\n        int sum=0;\\n        \\n        for(int j=0;j<=min(coin-1,loop);j++) //\\n        {\\n            sum=sum+v[index][j];\\n            ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n            \\n            /*Above we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n        }\\n        \\n        return dp[index][coin]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,k);\\n    }\\n};\\n```\\n*If you find it Helpful .Please Upvote.*",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001]; //Dp array For Memoization.\\n    int solve(vector<vector<int>>&v,int index,int coin)\\n    {\\n        if(index>=v.size()||coin==0)  //Base Condition\\n            return 0;\\n        if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n            return dp[index][coin];\\n        \\n        \\n        /* Our 1st choice :- We not take any Coin from that pile*/\\n        int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n        \\n       \\n        /*Otherwise we can take Coins from that Pile.*/\\n        int loop=v[index].size()-1;\\n        int sum=0;\\n        \\n        for(int j=0;j<=min(coin-1,loop);j++) //\\n        {\\n            sum=sum+v[index][j];\\n            ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n            \\n            /*Above we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n        }\\n        \\n        return dp[index][coin]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886924,
                "title": "2d-dp",
                "content": "We search and memoize the maximum value for `k` coins and `i` piles. \\n\\n**C++**\\n```cpp\\nint dp[1001][2001] = {};\\nint maxValueOfCoins(vector<vector<int>>& piles, int k, int i = 0) {\\n    if (i == piles.size() || k == 0)\\n        return 0;\\n    if (dp[i][k] == 0)\\n        for (int j = 0, sum = 0; j <= piles[i].size() && k - j >= 0; ++j) {\\n            dp[i][k] = max(dp[i][k], sum + maxValueOfCoins(piles, k - j, i + 1));\\n            if (j < piles[i].size())\\n                sum += piles[i][j];\\n        }\\n    return dp[i][k];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[1001][2001] = {};\\nint maxValueOfCoins(vector<vector<int>>& piles, int k, int i = 0) {\\n    if (i == piles.size() || k == 0)\\n        return 0;\\n    if (dp[i][k] == 0)\\n        for (int j = 0, sum = 0; j <= piles[i].size() && k - j >= 0; ++j) {\\n            dp[i][k] = max(dp[i][k], sum + maxValueOfCoins(piles, k - j, i + 1));\\n            if (j < piles[i].size())\\n                sum += piles[i][j];\\n        }\\n    return dp[i][k];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418505,
                "title": "c-recursive-dp-memoization-prefix-sum-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n    int dp[1001][2001];\\n    int help(int idx, int k, vector<vector<int>> &piles)\\n    {\\n        // if no coins left then return 0\\n        if (k == 0)\\n            return 0;\\n\\n        // if we have processed all the piles\\n        if (idx == piles.size())\\n        {\\n            // if k is 0 then we have chosen all the coins so return 0\\n            if (k == 0)\\n                return 0;   \\n            // if k is not 0, then this is not valid so return -infinity\\n            return -inf;\\n        }\\n\\n        // if we have calculated the state before then return it\\n        if (dp[idx][k] != -1)\\n            return dp[idx][k];\\n            \\n        // for the current state initialize answer as 0\\n        int ans = -inf;\\n\\n        // case1: take coins from the current prices {we can choose maximum \\'min(k, current pile size)\\' coins from the current pile}\\n        for (int i = 0; i < min(k, (int)piles[idx].size()); i++)\\n            ans = max(ans, piles[idx][i] + help(idx + 1, k - (i + 1), piles));\\n\\n        // -----------------max(take,nottake)----------------\\n        return dp[idx][k] = max(ans, help(idx + 1, k, piles));\\n    }\\n    int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        int n = piles.size();\\n\\n        // storing pref in the piles itself\\n        for (int i = 0; i < n; i++)\\n            for (int j = 1; j < piles[i].size(); j++)\\n                piles[i][j] += piles[i][j - 1];\\n\\n        // answer\\n        return help(0, k, piles);\\n    }\\n};\\n```\\n\\n### Please UPVOTE if you liked.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int inf = 1e9;\\n    int dp[1001][2001];\\n    int help(int idx, int k, vector<vector<int>> &piles)\\n    {\\n        // if no coins left then return 0\\n        if (k == 0)\\n            return 0;\\n\\n        // if we have processed all the piles\\n        if (idx == piles.size())\\n        {\\n            // if k is 0 then we have chosen all the coins so return 0\\n            if (k == 0)\\n                return 0;   \\n            // if k is not 0, then this is not valid so return -infinity\\n            return -inf;\\n        }\\n\\n        // if we have calculated the state before then return it\\n        if (dp[idx][k] != -1)\\n            return dp[idx][k];\\n            \\n        // for the current state initialize answer as 0\\n        int ans = -inf;\\n\\n        // case1: take coins from the current prices {we can choose maximum \\'min(k, current pile size)\\' coins from the current pile}\\n        for (int i = 0; i < min(k, (int)piles[idx].size()); i++)\\n            ans = max(ans, piles[idx][i] + help(idx + 1, k - (i + 1), piles));\\n\\n        // -----------------max(take,nottake)----------------\\n        return dp[idx][k] = max(ans, help(idx + 1, k, piles));\\n    }\\n    int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        int n = piles.size();\\n\\n        // storing pref in the piles itself\\n        for (int i = 0; i < n; i++)\\n            for (int j = 1; j < piles[i].size(); j++)\\n                piles[i][j] += piles[i][j - 1];\\n\\n        // answer\\n        return help(0, k, piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417918,
                "title": "simple-dp-solution-go-c",
                "content": "Go\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n\\tmemo := make([][]int, len(piles)+1)\\n\\tfor i := range memo {\\n\\t\\tmemo[i] = make([]int, k+1)\\n\\t}\\n\\n\\treturn dp(piles, memo, 0, k)\\n}\\n\\nfunc dp(piles [][]int, memo [][]int, i int, k int) int {\\n\\tif k == 0 || i == len(piles) {\\n\\t\\treturn 0\\n\\t}\\n\\tif memo[i][k] != 0 {\\n\\t\\treturn memo[i][k]\\n\\t}\\n\\n\\tres := dp(piles, memo, i+1, k)\\n\\tcur := 0\\n\\n\\tfor j := 0; j < min(len(piles[i]), k); j++ {\\n\\t\\tcur += piles[i][j]\\n\\t\\tres = max(res, cur+dp(piles, memo, i+1, k-j-1))\\n\\t}\\n\\n\\tmemo[i][k] = res\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        int n = piles.Count;\\n        int[][] memo = new int[n + 1][];\\n        for (int i = 0; i <= n; i++) {\\n            memo[i] = new int[k + 1];\\n            Array.Fill(memo[i], -1);\\n        }\\n\\n        return DP(piles, memo, 0, k);\\n    }\\n\\n    public int DP(IList<IList<int>> piles, int[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.Count) return 0;\\n        if (memo[i][k] != -1) return memo[i][k];\\n\\n        int res = DP(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.Min(piles[i].Count, k); ++j) {\\n            cur += piles[i][j];\\n            res = Math.Max(res, cur + DP(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n\\tmemo := make([][]int, len(piles)+1)\\n\\tfor i := range memo {\\n\\t\\tmemo[i] = make([]int, k+1)\\n\\t}\\n\\n\\treturn dp(piles, memo, 0, k)\\n}\\n\\nfunc dp(piles [][]int, memo [][]int, i int, k int) int {\\n\\tif k == 0 || i == len(piles) {\\n\\t\\treturn 0\\n\\t}\\n\\tif memo[i][k] != 0 {\\n\\t\\treturn memo[i][k]\\n\\t}\\n\\n\\tres := dp(piles, memo, i+1, k)\\n\\tcur := 0\\n\\n\\tfor j := 0; j < min(len(piles[i]), k); j++ {\\n\\t\\tcur += piles[i][j]\\n\\t\\tres = max(res, cur+dp(piles, memo, i+1, k-j-1))\\n\\t}\\n\\n\\tmemo[i][k] = res\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        int n = piles.Count;\\n        int[][] memo = new int[n + 1][];\\n        for (int i = 0; i <= n; i++) {\\n            memo[i] = new int[k + 1];\\n            Array.Fill(memo[i], -1);\\n        }\\n\\n        return DP(piles, memo, 0, k);\\n    }\\n\\n    public int DP(IList<IList<int>> piles, int[][] memo, int i, int k) {\\n        if (k == 0 || i == piles.Count) return 0;\\n        if (memo[i][k] != -1) return memo[i][k];\\n\\n        int res = DP(piles, memo, i + 1, k);\\n        int cur = 0;\\n\\n        for (int j = 0; j < Math.Min(piles[i].Count, k); ++j) {\\n            cur += piles[i][j];\\n            res = Math.Max(res, cur + DP(piles, memo, i + 1, k - j - 1));\\n        }\\n        return memo[i][k] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889647,
                "title": "python-bottom-up-dp-solution",
                "content": "**Intuition**\\nBottom-up dynamic programming.\\n\\n\\n**Explanation**\\nTop-down DP solution is well-explained in @lee215\\'s [post](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/discuss/1887010/JavaC%2B%2BPython-Top-down-DP-solution). Here we present the Bottom-up DP solution.\\n`dp[i][j]` is the maximum total value from `pile[0]` to `pile[i]`, if choosing exactly `j` coins optimally.\\nWe can pick `0, 1, 2, 3, ... , len(pile[i])` elements from the current `pile[i]` one by one.\\nIt asks for the maximum total value of coins we can have, so we need to return max of all the options.\\n\\n\\n**Complexity**\\nTime `O(m * k)`\\nSpace `O(n * k)`\\nwhere `m = sum(piles[i].length) <= 2000`.\\nTime complexity is well-explained in @DBabichev\\'s [post](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/discuss/1886905/Python-dp-solution-(complexity-updated)-explained), don\\'t be scared by the triple for-loop here.\\n\\n\\n**Python 3 solution**\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n, m = len(piles), 0\\n        prefixSum = []\\n        for i in range(n):\\n            temp = [0]\\n            for j in range(len(piles[i])):\\n                temp.append(temp[-1] + piles[i][j])\\n                m += 1\\n            prefixSum.append(temp)\\n        if m == k:\\n            return sum(temp[-1] for temp in prefixSum)\\n            \\n        dp = [[0] * (k + 1) for _ in range(n)]\\n        for j in range(1, k + 1):\\n            if j < len(prefixSum[0]):\\n                dp[0][j] = prefixSum[0][j]\\n        \\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                for l in range(len(prefixSum[i])):\\n                    if l > j:\\n                        break\\n                    dp[i][j] = max(dp[i][j], prefixSum[i][l] + dp[i - 1][j - l])\\n        return dp[n - 1][k]\\n```\\nPlease upvote if you find this solution helpful.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n, m = len(piles), 0\\n        prefixSum = []\\n        for i in range(n):\\n            temp = [0]\\n            for j in range(len(piles[i])):\\n                temp.append(temp[-1] + piles[i][j])\\n                m += 1\\n            prefixSum.append(temp)\\n        if m == k:\\n            return sum(temp[-1] for temp in prefixSum)\\n            \\n        dp = [[0] * (k + 1) for _ in range(n)]\\n        for j in range(1, k + 1):\\n            if j < len(prefixSum[0]):\\n                dp[0][j] = prefixSum[0][j]\\n        \\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                for l in range(len(prefixSum[i])):\\n                    if l > j:\\n                        break\\n                    dp[i][j] = max(dp[i][j], prefixSum[i][l] + dp[i - 1][j - l])\\n        return dp[n - 1][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418561,
                "title": "recursion-memoization-tabulation-c-striver-beginner-friendly-solution",
                "content": "# Intuition\\nSimple pick or not pick approach. For pick we run a for loop through the array.  \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n# Recusive code which will give you TLE\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n){\\n    if(ind==n or k==0) return 0;\\n    int notPick=sumi(ind+1,piles,k,n);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n);\\n        pick=max(pick,x);\\n    }\\n    return max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        return sumi(ind,piles,k,n);\\n    }\\n```\\n\\n\\n\\n\\n```\\n# Memoized Solution of above\\nclass Solution {\\npublic:\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp){\\n    if(ind==n or k==0) return 0;\\n    if(dp[ind][k]!=-1) return dp[ind][k];\\n    int notPick=sumi(ind+1,piles,k,n,dp);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n,dp);\\n        pick=max(pick,x);\\n    }\\n    return dp[ind][k]=max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        vector<vector<int>> dp(n, vector<int> (k+1,-1));\\n        return sumi(ind,piles,k,n,dp);\\n    }\\n};\\n```\\n```\\n# Tabulation\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n, vector<int> (k+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=k and i<=piles[0].size();i++){\\n            sum+=piles[0][i-1];\\n            dp[0][i]=sum;\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<=k;j++){\\n                int notPick=dp[i-1][j];\\n                int pick=0;\\n                int sum=0;\\n                for(int k=1;k<=j and k<=piles[i].size();k++){\\n                    sum+=piles[i][k-1];\\n                    pick=max(pick,sum+dp[i-1][j-k]);\\n                }\\n                dp[i][j]=max(pick,notPick);\\n            }\\n        }\\n        return dp[n-1][k];\\n    }\\n};\\n```\\n# ***Please upvote if it helped!***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# Recusive code which will give you TLE\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n){\\n    if(ind==n or k==0) return 0;\\n    int notPick=sumi(ind+1,piles,k,n);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n);\\n        pick=max(pick,x);\\n    }\\n    return max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        return sumi(ind,piles,k,n);\\n    }\\n```\n```\\n# Memoized Solution of above\\nclass Solution {\\npublic:\\n\\nint sumi(int ind, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp){\\n    if(ind==n or k==0) return 0;\\n    if(dp[ind][k]!=-1) return dp[ind][k];\\n    int notPick=sumi(ind+1,piles,k,n,dp);\\n    int pick=0,coins=k,sum=0;\\n    for(int i=0;i<piles[ind].size() and coins>0;i++){\\n        sum+=piles[ind][i];\\n        coins--;\\n        int x=sum+sumi(ind+1,piles,coins,n,dp);\\n        pick=max(pick,x);\\n    }\\n    return dp[ind][k]=max(pick,notPick);\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int ind=0;\\n        vector<vector<int>> dp(n, vector<int> (k+1,-1));\\n        return sumi(ind,piles,k,n,dp);\\n    }\\n};\\n```\n```\\n# Tabulation\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n, vector<int> (k+1,0));\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        int sum=0;\\n        for(int i=1;i<=k and i<=piles[0].size();i++){\\n            sum+=piles[0][i-1];\\n            dp[0][i]=sum;\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<=k;j++){\\n                int notPick=dp[i-1][j];\\n                int pick=0;\\n                int sum=0;\\n                for(int k=1;k<=j and k<=piles[i].size();k++){\\n                    sum+=piles[i][k-1];\\n                    pick=max(pick,sum+dp[i-1][j-k]);\\n                }\\n                dp[i][j]=max(pick,notPick);\\n            }\\n        }\\n        return dp[n-1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886910,
                "title": "c-top-down-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Top-down DP\\n\\nLet `dp[i][j]` be the max value of `j` coins using piles `i ~ N-1`. The answer is `dp[0][k]`.\\n\\nFor `dp[i][j]`, we can try using `t` elements from `A[i]` (`0 <= t <= min(j, A[i].size())`), getting `A[i][0] + ... + A[i][t-1]` value plus `dp[i+1][j-t]` value (the max value of `j-t` coins using piles `i+1 ~ N-1`). We try different `t`s and assign the max value to `dp[i][j]`.\\n\\n```\\ndp[i][j] = max( dp[i+1][j-t] + sum(i, t) | 0 <= t <= min(j, A[i].size()) )\\n            where sum(i, t) = A[i][0] + ... + A[i][t-1]\\n```\\n\\nTrivial case is `dp[N][j] = 0`, i.e. we can\\'t get any value from the nonexistent `A[N]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-286/problems/maximum-value-of-k-coins-from-piles/\\n// Author: github.com/lzl124631x\\n// Time: O(NK)\\n// Space: O(NK)\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& A, int k) {\\n        int N = A.size(), m[1001][2001] = {};\\n        memset(m, -1, sizeof(m));\\n        function<int(int, int)> dp =[&](int i, int j) {\\n            if (m[i][j] != -1) return m[i][j];\\n            if (i == N) return 0;\\n            int ans = dp(i + 1, j), sum = 0;\\n            for (int t = 1; t <= j && t <= A[i].size(); ++t) {\\n                sum += A[i][t - 1];\\n                ans = max(ans, dp(i + 1, j - t) + sum);\\n            }\\n            return m[i][j] = ans;\\n        };\\n        return dp(0, k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = max( dp[i+1][j-t] + sum(i, t) | 0 <= t <= min(j, A[i].size()) )\\n            where sum(i, t) = A[i][0] + ... + A[i][t-1]\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-286/problems/maximum-value-of-k-coins-from-piles/\\n// Author: github.com/lzl124631x\\n// Time: O(NK)\\n// Space: O(NK)\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& A, int k) {\\n        int N = A.size(), m[1001][2001] = {};\\n        memset(m, -1, sizeof(m));\\n        function<int(int, int)> dp =[&](int i, int j) {\\n            if (m[i][j] != -1) return m[i][j];\\n            if (i == N) return 0;\\n            int ans = dp(i + 1, j), sum = 0;\\n            for (int t = 1; t <= j && t <= A[i].size(); ++t) {\\n                sum += A[i][t - 1];\\n                ans = max(ans, dp(i + 1, j - t) + sum);\\n            }\\n            return m[i][j] = ans;\\n        };\\n        return dp(0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418169,
                "title": "leetcode-the-hard-way-dp-memo-explained",
                "content": "Let `dp[i][j]` be the maximum total value we can have if we pick `j` elements starting from `piles[i]`. The answer is `dp[0][k]`. First we calculate the value if we pick any elements in the current pile. Then we try to pick at most `min((int) piles[i].size(), k)` elements and find out the max result.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        function<int(int,int)> dfs = [&](int i, int k) {\\n            // reach the end - return 0\\n            if (i == n || k == 0) return 0;\\n            // calculated previously - return immediately\\n            if (dp[i][k] != -1) return dp[i][k];\\n            // do not take \\n            int res = dfs(i + 1, k), val = 0;\\n            // try to take it one by one \\n            // calculate the value we could have\\n            for (int j = 0; j < min((int) piles[i].size(), k); j++) {\\n                // take this element\\n                val += piles[i][j];\\n                res = max(res, dfs(i + 1, k - 1 - j) + val);\\n            }\\n            return dp[i][k] = res;\\n        };\\n        return dfs(0, k);\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        @lru_cache(None)\\n        def dp(i, k):\\n            # reach the end - return 0\\n            if i == len(piles) or k == 0:\\n                return 0\\n            res = 0\\n            # do not take \\n            res += dp(i + 1, k)\\n            # try to take it one by one \\n            # calculate the value we could have\\n            take = 0\\n            for j in range(min(k, len(piles[i]))):\\n                # take this element\\n                take += piles[i][j]\\n                res = max(res, dp(i + 1, k - 1 - j) + take)\\n            return res\\n        return dp(0, k)\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        function<int(int,int)> dfs = [&](int i, int k) {\\n            // reach the end - return 0\\n            if (i == n || k == 0) return 0;\\n            // calculated previously - return immediately\\n            if (dp[i][k] != -1) return dp[i][k];\\n            // do not take \\n            int res = dfs(i + 1, k), val = 0;\\n            // try to take it one by one \\n            // calculate the value we could have\\n            for (int j = 0; j < min((int) piles[i].size(), k); j++) {\\n                // take this element\\n                val += piles[i][j];\\n                res = max(res, dfs(i + 1, k - 1 - j) + val);\\n            }\\n            return dp[i][k] = res;\\n        };\\n        return dfs(0, k);\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        @lru_cache(None)\\n        def dp(i, k):\\n            # reach the end - return 0\\n            if i == len(piles) or k == 0:\\n                return 0\\n            res = 0\\n            # do not take \\n            res += dp(i + 1, k)\\n            # try to take it one by one \\n            # calculate the value we could have\\n            take = 0\\n            for j in range(min(k, len(piles[i]))):\\n                # take this element\\n                take += piles[i][j]\\n                res = max(res, dp(i + 1, k - 1 - j) + take)\\n            return res\\n        return dp(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136042,
                "title": "dp-memoization-easy-to-understand",
                "content": "In the problem, we have to select ****K**** coins from the given piles of coins. In one step we can select one coin from the top of the n piles.\\nOur task is to ****maximize the total money we can get****.\\nFrom the ith pile, we can select between 0 to k coins.\\nTherefore, for every pile we have choice to take 0 coin to k coins. Simply, we can write the recursive code exploring all the choices.\\n\\n**Recursive Solution-**\\n\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k)\\n    {\\n        if(k==0 )return 0; // no more coins can be taken\\n        if(ind==piles.size())return INT_MIN;// no more piles are left\\n        int ans=fun(piles,ind+1,k); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++)// taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1));\\n        }\\n        return max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        return fun(piles,0,k);\\n    }\\n};\\n```\\nAs we can clearly see, we have overlapping subproblems, therefore,  we can solve the problem with the help of Dynamic Programming. \\nThe state variables for the given dynamic programming problem are ind(index) and k. \\nWe can create a **dp[n][k+1]** and store the answer for the problem with i and k state variables.\\n\\n**Dynamic Programming (Memoization)-**\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k,vector<vector<int>>&dp)\\n    {\\n        if(k==0 )return 0;   //no more coins can be taken \\n        if(ind==piles.size())return INT_MIN; // no more piles are left\\n        if(dp[ind][k]!=-1)return dp[ind][k]; // if already calculated, simply return\\n        int ans=fun(piles,ind+1,k,dp); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++) // taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1,dp));\\n        }\\n        return dp[ind][k] = max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return fun(piles,0,k,dp);\\n    }\\n};\\n```\\nThe above is the memoized dynamic programming solution.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k)\\n    {\\n        if(k==0 )return 0; // no more coins can be taken\\n        if(ind==piles.size())return INT_MIN;// no more piles are left\\n        int ans=fun(piles,ind+1,k); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++)// taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1));\\n        }\\n        return max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        return fun(piles,0,k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& piles,int ind,int k,vector<vector<int>>&dp)\\n    {\\n        if(k==0 )return 0;   //no more coins can be taken \\n        if(ind==piles.size())return INT_MIN; // no more piles are left\\n        if(dp[ind][k]!=-1)return dp[ind][k]; // if already calculated, simply return\\n        int ans=fun(piles,ind+1,k,dp); // if we take 0 coin from the pile\\n        int score=0;\\n        int secAns=INT_MIN;\\n        for(int i=0;i<k && i<piles[ind].size();i++) // taking 1 to k coins from the pile\\n        {\\n            score+=piles[ind][i];\\n            secAns=max(secAns,score+fun(piles,ind+1,k-i-1,dp));\\n        }\\n        return dp[ind][k] = max(ans,secAns);                                      \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return fun(piles,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417924,
                "title": "java-easy-solution-dp",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; \\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int l=0; l < Math.min(currPile.size(), j); l++){\\n                    coinSum += currPile.get(l);\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - l - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; \\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int l=0; l < Math.min(currPile.size(), j); l++){\\n                    coinSum += currPile.get(l);\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - l - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886976,
                "title": "c-memoization",
                "content": "```\\nvector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k){\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++){\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k){\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++){\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1886922,
                "title": "java-bottom-up-dp",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        int[][] ans = new int[n+1][2001];\\n        Collections.sort(piles, (List<Integer> a, List<Integer> b) ->  b.size() - a.size());\\n        for(int i = 1; i <= k; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                int sizeOfPile = piles.get(j-1).size();\\n                List<Integer> pile = piles.get(j-1);\\n                int sum = 0;\\n                ans[j][i] = ans[j-1][i];\\n                for(int l = 1; l <= Math.min(i, sizeOfPile); l++) {\\n                    // Take K from this pile + remaining from previous piles\\n                    sum += pile.get(l-1);\\n                    int rem = i - l;\\n                    ans[j][i] = Math.max(ans[j][i], sum + ans[j-1][rem]);\\n                }\\n            }\\n        }\\n        \\n        return ans[n][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        int[][] ans = new int[n+1][2001];\\n        Collections.sort(piles, (List<Integer> a, List<Integer> b) ->  b.size() - a.size());\\n        for(int i = 1; i <= k; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                int sizeOfPile = piles.get(j-1).size();\\n                List<Integer> pile = piles.get(j-1);\\n                int sum = 0;\\n                ans[j][i] = ans[j-1][i];\\n                for(int l = 1; l <= Math.min(i, sizeOfPile); l++) {\\n                    // Take K from this pile + remaining from previous piles\\n                    sum += pile.get(l-1);\\n                    int rem = i - l;\\n                    ans[j][i] = Math.max(ans[j][i], sum + ans[j-1][rem]);\\n                }\\n            }\\n        }\\n        \\n        return ans[n][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419285,
                "title": "golang-recursive-mem-optimised-dp",
                "content": "# Intuition\\nWe need to find a Min/Max of something in an array/matrix => It\\'s a Dynamic Programming problem (rarely a Greedy problem).\\n\\n# Approach - Simple recursive function\\nDon\\'t try to write a final optimized code from the start, it will break your mind. Always start with defining a recursive function:\\n\\n`rec(pile_idx, used) = max_over_j(sum_of_j_coins_from_this_pile + rec(pile_idx + 1, used - j)`\\nAnd the answer can be found with `rec(0, k)`\\n\\nThe following code works fine with small test cases but will hit the TimeLimit if you submit it. Check out the next approach.\\n\\n\\n# Code - Simple recursive function\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n---\\n\\n# Approach - Recursive function with Memo\\nCreate a memo matrix with size of `len(piles)\\u22C5k` and use it for caching `rec()` results. It will pass all test cases.\\n\\n![Screenshot 2023-04-15 at 14.40.13.png](https://assets.leetcode.com/users/images/2dc8d044-7249-40d1-86b7-62400f33d94f_1681555225.9792976.png)\\n\\n# Code - Recursive function with Memo\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        if memo[i][used] > 0 { return memo[i][used] }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        memo[i][used] = res\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n---\\n\\n# Approach - Bottom-up DP\\nWe understand how our memo matrix must look like and how we can fill it in recursively. Now we need to do the same using loops.\\n\\nTraverse all `piles` and `used` in a nested loop and change `rec(i+1, used)` into `memo[i+1][used]`. Almost all the code remains the same (that\\'s the neat part of this process).\\n\\n![Screenshot 2023-04-15 at 14.45.07.png](https://assets.leetcode.com/users/images/c84423aa-bdc7-4753-9365-bfdc9ab27d5d_1681555517.5403607.png)\\n\\n# Code - Bottom-up DP\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n+1)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=0; used<=k; used++ {\\n            accum := 0\\n            res := memo[i+1][used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + memo[i+1][used-j-1])\\n            }\\n            memo[i][used] = res\\n        }\\n    }\\n    return memo[0][k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n---\\n\\n# Approach - Bottom-up Mem Optimised DP\\nNotice that we need only the values from `memo[i]` and `memo[i+1]`, so no need to keep the whole matrix in the memory. Just create a one dimensional list `dp` of size `k`.\\n\\n![Screenshot 2023-04-15 at 15.00.41.png](https://assets.leetcode.com/users/images/82ad0e39-fd25-4e03-a4c8-2dad71573b2b_1681556636.8669186.png)\\n\\n# Code - Bottom-up Mem Optimised DP\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    dp := make([]int, k+1)\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            res := dp[used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + dp[used-j-1])\\n            }\\n            dp[used] = res\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n### Do some code optimisations\\n\\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    dp := make([]int, k+1)\\n\\n    for i := range piles {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                dp[used] = max(dp[used], accum + dp[used-j-1])\\n            }\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(totalCoinsNum\\u22C5k)$$\\n\\n- Space complexity: $$O(k)$$",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    var rec func(int, int) int\\n    rec = func(i int, used int) int {\\n        if i == n { return 0 }\\n        if memo[i][used] > 0 { return memo[i][used] }\\n        accum := 0\\n        res := rec(i+1, used)\\n        for j:=0; j<min(len(piles[i]), used); j++ {\\n            accum += piles[i][j]\\n            res = max(res, accum + rec(i+1, used-j-1))\\n        }\\n        memo[i][used] = res\\n        return res\\n    }\\n    return rec(0, k)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    memo := make([][]int, n+1)\\n    for i := range memo {\\n        memo[i] = make([]int, k+1)\\n    }\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=0; used<=k; used++ {\\n            accum := 0\\n            res := memo[i+1][used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + memo[i+1][used-j-1])\\n            }\\n            memo[i][used] = res\\n        }\\n    }\\n    return memo[0][k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    n := len(piles)\\n    dp := make([]int, k+1)\\n\\n    for i:=n-1; i>=0; i-- {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            res := dp[used]\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                res = max(res, accum + dp[used-j-1])\\n            }\\n            dp[used] = res\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```\\nfunc maxValueOfCoins(piles [][]int, k int) int {\\n    dp := make([]int, k+1)\\n\\n    for i := range piles {\\n        for used:=k; used>=0; used-- {\\n            accum := 0\\n            for j:=0; j<min(len(piles[i]), used); j++ {\\n                accum += piles[i][j]\\n                dp[used] = max(dp[used], accum + dp[used-j-1])\\n            }\\n        }\\n    }\\n    return dp[k]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418388,
                "title": "space-optimised-tabulation-memoization-recursion",
                "content": "# Intuition\\nThe problem is to maximize the sum of k coins collected from n piles of coins, where each pile has a different number of coins. The constraint is that you can only take coins from the top of each pile. The given solution uses a depth-first search (DFS) approach to explore all possible choices of taking coins from different piles and computes the maximum sum of coins that can be collected.\\n\\n<hr>\\n\\n# Approach\\nThe solution is implemented using a recursive function `helper()` which takes three parameters: `idx` (the current pile index), `coins` (the number of coins left to collect), and `piles` (the 2D vector of piles with coins).\\n\\nThe base case for the recursion is when the current pile index `idx` reaches the total number of `piles`. In this case, the function `returns 0`, as no more coins can be collected.\\n\\nThe main logic is divided into two cases:\\n1. Not taking any coins from the current pile, in which case we move to the next pile by calling the `helper()` function with `idx + 1` and the same number of coins left to collect.\\n2. Taking some coins from the current pile. In this case, we iterate through the coins in the current pile, taking at most `min(n, coins)` coins, where n is the total number of coins in the current pile. For each coin taken, we add its value to the `curr_total`, and then call the `helper()` function for the next pile with `idx + 1` and the updated number of coins left to collect `(coins - i - 1)`. We keep track of the maximum total coins collected in `max_total`.\\n\\nIn the end, the helper function returns `max_total` which is the maximum sum of coins that can be collected by considering all possible choices of taking coins from the current pile and subsequent piles.\\n\\nThe main function `maxValueOfCoins()` initiates the recursion by calling the `helper()` function with `idx = 0` (starting pile) and `coins = k` (the total number of coins to collect).\\n<hr>\\n\\n# Implementations\\n\\n## Recursion - _Time Limit Exceeded_ \\u203C\\uFE0F\\n```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return helper(0, k, piles);\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k^n)$$\\n\\n- **Space complexity:** $$O(k * m)$$\\n<hr>\\n\\n## Memoization (Top-Down) - _Accepted_ \\u2705\\nIt can be clearly seen from the recursive approcah that we are doing a lot of repeated work and there are overlapping sub-problems hence we can use dynamic programming to optimise out recursive approach. So let us memoize our recursion.\\n```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles, vector<vector<int>>& dp) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n        if(dp[idx][coins] != -1) {\\n            return dp[idx][coins];\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles, dp);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles, dp);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return dp[idx][coins] = max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\\n        return helper(0, k, piles, dp);\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k * n)$$\\n\\n- **Space complexity:** $$O(k * m)$$\\n<hr>\\n\\n## Tabulation (Bottom-Up) - _Accepted_ \\u2705\\u2705\\nLet us now tabulise the memoization solution that we did above.\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(k + 1, 0));\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = dp[idx + 1][coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = dp[idx + 1][coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                dp[idx][coins] = max_total;                \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k * n)$$\\n\\n- **Space complexity:** $$O(k * m)$$\\n<hr>\\n\\n## Space Optimised Tabulation - _Accepted_ \\u2705\\u2705\\u2705\\nFrom the above tabulation code we can observe that the current pile `(dp[idx])` is always dependant on the next pile `(dp[idx + 1])`. So why not just keep 2 vectors of size `k + 1` each, one for `dp[idx]` and one for `dp[idx + 1]`. In this way we can save a lot of space by just computing two rows of the dp table at any instant instead of the entire `k x n` grid.\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<int> curr(k + 1), next(k + 1, 0);\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = next[coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = next[coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                curr[coins] = max_total;                \\n            }\\n            next = curr; //Make next = current for the next iteration\\n        }\\n        return next[k];\\n    }\\n};\\n```\\n\\nIf `k` is the number of coins to collect, `m` is the number of piles and `n` is the total number of coins in all piles then:\\n- **Time complexity:** $$O(k * n)$$\\n\\n- **Space complexity:** $$O(k)$$\\n<hr>\\n\\n\\uD83D\\uDE4F **_If you like the entire explanation and all the implementations I showed, please do take a moment to upvote this post._** \\uD83D\\uDE4F",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return helper(0, k, piles);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int helper(int idx, int coins, vector<vector<int>>& piles, vector<vector<int>>& dp) {\\n        //Base case\\n        if(idx == piles.size()) {\\n            return 0;\\n        }\\n        if(dp[idx][coins] != -1) {\\n            return dp[idx][coins];\\n        }\\n\\n        //Explore all paths\\n        int n = piles[idx].size();\\n\\n        //Path 1 - Not take any coin from the current pile\\n        int max_total = helper(idx + 1, coins, piles, dp);\\n\\n        //Path 2 - Take (i + 1) number of coins from the current pile\\n        int curr_total = 0;\\n        for(int i = 0; i < min(n, coins); i++) {\\n            curr_total += piles[idx][i];\\n            int next_total = helper(idx + 1, coins - i - 1, piles, dp);\\n            max_total = max(max_total, curr_total + next_total);\\n        }\\n        return dp[idx][coins] = max_total;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\\n        return helper(0, k, piles, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(k + 1, 0));\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = dp[idx + 1][coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = dp[idx + 1][coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                dp[idx][coins] = max_total;                \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        vector<int> curr(k + 1), next(k + 1, 0);\\n        for(int idx = m - 1; idx >= 0; idx--) {\\n            for(int coins = 1; coins <= k; coins++) {\\n                //Explore all paths\\n                int n = piles[idx].size();\\n\\n                //Path 1 - Not take any coin from the current pile\\n                int max_total = next[coins];\\n\\n                //Path 2 - Take (i + 1) number of coins from the current pile\\n                int curr_total = 0;\\n                for(int i = 0; i < min(n, coins); i++) {\\n                    curr_total += piles[idx][i];\\n                    int next_total = next[coins - i - 1];\\n                    max_total = max(max_total, curr_total + next_total);\\n                }\\n                curr[coins] = max_total;                \\n            }\\n            next = curr; //Make next = current for the next iteration\\n        }\\n        return next[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738377,
                "title": "c-recursion-top-down",
                "content": "// recursion \\n```\\nint solve(vector<vector<int>>& arr,int i,int k,int n){\\n    if (k==0 || i==n)\\n    {\\n        return 0;\\n    }\\n    int ans=0;\\n    for (int j = 0; j <=k; j++)\\n    {\\n        if (arr[i].size()>=j)\\n        {\\n            if(j==0){\\n                ans=max(ans,solve(arr,i+1,k,n)) ;\\n            }\\n            else{\\n            ans=max(ans,arr[i][j-1]+solve(arr,i+1,k-j,n));\\n            }\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n    return ans;\\n}\\n int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,0,k,n);\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n```\\n\\t// Top-Down\\n\\n```\\nint solve(vector<vector<int>>& arr,int k2,int n){\\n    vector<vector<int>>dp(n+1,vector<int>(k2+1,0));\\n    for (int i = n-1; i >=0; i--)\\n    {\\n        for (int k = 0; k<=k2; k++)\\n        {\\n          \\n                for (int j = 0; j <=k; j++)\\n                {\\n                    if (arr[i].size()>=j)\\n                    {\\n                        if(j==0){\\n                            dp[i][k]=max(dp[i][k],dp[i+1][k]) ;\\n                        }\\n                        else{\\n                        dp[i][k]=max(dp[i][k],arr[i][j-1]+dp[i+1][k-j]);\\n                        }\\n                    }\\n                    else{\\n                        break;\\n                    }\\n    }\\n   \\n\\n\\n        }\\n        \\n    }\\n    return dp[0][k2];\\n    \\n\\n\\n\\n }\\n\\n  int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,k,n);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<vector<int>>& arr,int i,int k,int n){\\n    if (k==0 || i==n)\\n    {\\n        return 0;\\n    }\\n    int ans=0;\\n    for (int j = 0; j <=k; j++)\\n    {\\n        if (arr[i].size()>=j)\\n        {\\n            if(j==0){\\n                ans=max(ans,solve(arr,i+1,k,n)) ;\\n            }\\n            else{\\n            ans=max(ans,arr[i][j-1]+solve(arr,i+1,k-j,n));\\n            }\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n    return ans;\\n}\\n int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,0,k,n);\\n    }\\n\\t\\n\\t\\n\\t\\n\\t\\n```\n```\\nint solve(vector<vector<int>>& arr,int k2,int n){\\n    vector<vector<int>>dp(n+1,vector<int>(k2+1,0));\\n    for (int i = n-1; i >=0; i--)\\n    {\\n        for (int k = 0; k<=k2; k++)\\n        {\\n          \\n                for (int j = 0; j <=k; j++)\\n                {\\n                    if (arr[i].size()>=j)\\n                    {\\n                        if(j==0){\\n                            dp[i][k]=max(dp[i][k],dp[i+1][k]) ;\\n                        }\\n                        else{\\n                        dp[i][k]=max(dp[i][k],arr[i][j-1]+dp[i+1][k-j]);\\n                        }\\n                    }\\n                    else{\\n                        break;\\n                    }\\n    }\\n   \\n\\n\\n        }\\n        \\n    }\\n    return dp[0][k2];\\n    \\n\\n\\n\\n }\\n\\n  int maxValueOfCoins(vector<vector<int>>& arr, int k) {\\n        int n=arr.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < arr[i].size(); j++)\\n            {\\n               arr[i][j]+=arr[i][j-1];\\n            }\\n            \\n        }\\n        return solve(arr,k,n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418857,
                "title": "c-easy-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int c(vector<vector<int>>& p,int i,int k,vector<vector<int>>&dp){\\n        if(k==0)return 0;\\n        if(i>=p.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans=0;\\n        int mx=c(p,i+1,k,dp);\\n        for(int j=0;j<p[i].size();j++){\\n            ans += p[i][j];\\n            if(k>=j+1)\\n           mx = max(mx,ans+c(p,i+1,k-j-1,dp));\\n           else break;\\n        }\\n        dp[i][k]=mx;\\n        return mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return c(p,0,k,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/6562a796-f88c-4354-91ae-9f672244bb39_1681546108.315926.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int c(vector<vector<int>>& p,int i,int k,vector<vector<int>>&dp){\\n        if(k==0)return 0;\\n        if(i>=p.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans=0;\\n        int mx=c(p,i+1,k,dp);\\n        for(int j=0;j<p[i].size();j++){\\n            ans += p[i][j];\\n            if(k>=j+1)\\n           mx = max(mx,ans+c(p,i+1,k-j-1,dp));\\n           else break;\\n        }\\n        dp[i][k]=mx;\\n        return mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(k+1,-1));\\n        return c(p,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417903,
                "title": "prefix-sum-bottom-up-dp-detailed-explanation-c-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        // total n piles and k coins we can choose.\\n        // so for any dp[i][j] it will store the max coins we\\n        // get using i piles and j coins used.\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        // Since we want to be dealing with the sums of coins,\\n        // it would be real convenient, if our piles just stored\\n        // the prefix sum instead. This can be done on the piles\\n        // matrix directly, however, it is a good practice to not\\n        // to change anything provided in the problem. Make pref\\n        vector<vector<int>> pref(n, vector<int>()); // prefix-sum\\n        for (int i = 0; i < n; i++) {\\n            pref[i].resize(piles[i].size()); // uneven matrix so resize()\\n            pref[i][0] = piles[i][0]; // initialize for pref_sum\\n            for (int j = 1; j < piles[i].size(); j++) {\\n                // calculating prefix sum\\n                pref[i][j] = pref[i][j - 1] + piles[i][j];\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // Let the coins chosen from the current pile be cur\\n                for (int cur = 0; cur <= piles[i - 1].size(); cur++) {\\n                    // Check for all combinations of coins that sum up to j coins.\\n                    // We can pick w coins from this pile and j-w coins from previous piles (dp[i-1][j-w]).\\n                    // i.e., (j-w) + w = j coins in total.\\n                    if(cur <= j)\\n                        if(cur > 0){\\n                            // if cur > 0 we can consider prefix sum since in-bounds\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1]);\\n                        }\\n                        else{\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur]);\\n                        }\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n\\n\\n```\\nPython code for the same:\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        pref = [[] for _ in range(n)]  \\n        for i in range(n):\\n            pref[i] = [0] * len(piles[i])  \\n            pref[i][0] = piles[i][0]  \\n            for j in range(1, len(piles[i])):\\n                pref[i][j] = pref[i][j - 1] + piles[i][j]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, k + 1):\\n                for cur in range(len(piles[i - 1]) + 1):\\n                    if cur <= j:\\n                        if cur > 0:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1])\\n                        else:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur])\\n        return dp[n][k]\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        // total n piles and k coins we can choose.\\n        // so for any dp[i][j] it will store the max coins we\\n        // get using i piles and j coins used.\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n        // Since we want to be dealing with the sums of coins,\\n        // it would be real convenient, if our piles just stored\\n        // the prefix sum instead. This can be done on the piles\\n        // matrix directly, however, it is a good practice to not\\n        // to change anything provided in the problem. Make pref\\n        vector<vector<int>> pref(n, vector<int>()); // prefix-sum\\n        for (int i = 0; i < n; i++) {\\n            pref[i].resize(piles[i].size()); // uneven matrix so resize()\\n            pref[i][0] = piles[i][0]; // initialize for pref_sum\\n            for (int j = 1; j < piles[i].size(); j++) {\\n                // calculating prefix sum\\n                pref[i][j] = pref[i][j - 1] + piles[i][j];\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // Let the coins chosen from the current pile be cur\\n                for (int cur = 0; cur <= piles[i - 1].size(); cur++) {\\n                    // Check for all combinations of coins that sum up to j coins.\\n                    // We can pick w coins from this pile and j-w coins from previous piles (dp[i-1][j-w]).\\n                    // i.e., (j-w) + w = j coins in total.\\n                    if(cur <= j)\\n                        if(cur > 0){\\n                            // if cur > 0 we can consider prefix sum since in-bounds\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1]);\\n                        }\\n                        else{\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur]);\\n                        }\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        pref = [[] for _ in range(n)]  \\n        for i in range(n):\\n            pref[i] = [0] * len(piles[i])  \\n            pref[i][0] = piles[i][0]  \\n            for j in range(1, len(piles[i])):\\n                pref[i][j] = pref[i][j - 1] + piles[i][j]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, k + 1):\\n                for cur in range(len(piles[i - 1]) + 1):\\n                    if cur <= j:\\n                        if cur > 0:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur] + pref[i - 1][cur - 1])\\n                        else:\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - cur])\\n        return dp[n][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059614,
                "title": "java-knapsack-variation-dynammic-programming-easy-to-undestand",
                "content": "TC - O(N*M) \\nn=size of piles,\\nm=size of piles[i]\\n\\nclass Solution {\\n    public int helper(List<List<Integer>> piles,int idx,int k,int [][]dp){\\n        \\n        if(idx<0 || k == 0) return 0;\\n        if(dp[idx][k] != -1) return dp[idx][k];\\n        \\n    \\n        // exclude case \\n        int exclude = helper(piles,idx-1,k,dp);\\n        \\n        \\n        // include case\\n        int sum = 0;\\n        int include = 0;\\n        \\n        List<Integer> curr_pile = piles.get(idx);\\n        \\n        for(int i=0;i<Math.min(curr_pile.size(),k);i++){\\n            sum += curr_pile.get(i);\\n            include = Math.max(sum + helper(piles,idx-1,k-i-1,dp),include);\\n        }\\n        return dp[idx][k] = Math.max(include,exclude);\\n    }\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n       \\n        int n = piles.size();\\n        int [][]dp = new int[n+1][k+1];\\n        for(int []d:dp) Arrays.fill(d,-1);\\n        \\n        return helper(piles,n-1,k,dp);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int helper(List<List<Integer>> piles,int idx,int k,int [][]dp){\\n        \\n        if(idx<0 || k == 0) return 0;\\n        if(dp[idx][k] != -1) return dp[idx][k];\\n        \\n    \\n        // exclude case \\n        int exclude = helper(piles,idx-1,k,dp);\\n        \\n        \\n        // include case\\n        int sum = 0;\\n        int include = 0;\\n        \\n        List<Integer> curr_pile = piles.get(idx);\\n        \\n        for(int i=0;i<Math.min(curr_pile.size(),k);i++){\\n            sum += curr_pile.get(i);\\n            include = Math.max(sum + helper(piles,idx-1,k-i-1,dp),include);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1901374,
                "title": "recursion-to-space-optimized-dp-java-explained-solution-easy-to-understand",
                "content": "\\nThis question is a variation of 0/1 Unbounded Knapsack. Here we are allowed to pick coins any no. of times with 2 included constraints. \\n- These picking up of coins from a particular pile cannot exceed k\\n- The coins in a particular pile are of different denomination\\n\\nIf these two constraints are removed the question is basic 0/1 Unbounded knapsack. So, similarly we have two options to go for.\\n- either to not pick any coin from a pile\\n- or pick 1 to k coins from a pile\\n\\nRecursion\\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        return solve(piles,n,k);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k){\\n        if(k==0)return 0;\\n        if(i==0)return 0;\\n        int best=solve(piles,i-1,k);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1)));\\n        }\\n        return best;\\n    }\\n```\\nTC= Exponential (For every pile we have either to pick upto k coins or not pick at all)\\nSC= O(nk)\\n\\nRecursion with Memoization\\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n\\t\\tint[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n\\t\\t\\tArrays.fill(dp[i],-1);\\n        return solve(piles,n,k,dp);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k,int[][] dp){\\n\\t\\tif(k==0)return 0;\\n        if(i==0)return 0;\\n\\t\\tif(dp[i][k]!=-1)return dp[i][k];\\n        int best=solve(piles,i-1,k,dp);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1),dp));\\n        }\\n        return dp[i][k]= best;\\n    }\\n```\\nTC= O(nk)\\nSC= O(nk)+O(nk)\\n\\nTabulation DP\\n```\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)dp[i][j]=0;\\n                else{\\n                    int best=dp[i-1][j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+dp[i-1][j-(x+1)]);\\n                    }\\n                    dp[i][j]= best;\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n```\\nTC= O(nk)\\nSC= O(nk)\\n\\nTabulation DP with Space optimization\\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] prev=new int[k+1];\\n        for(int i=0;i<=n;i++){\\n            int[] curr=new int[k+1];\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)curr[j]=0;\\n                else{\\n                    int best=prev[j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+prev[j-(x+1)]);\\n                    }\\n                    curr[j]= best;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[k];\\n    }\\n```\\nTC= O(nk)\\nSC= O(2k)=O(k)\\n\\nHope you liked the solution. If yes, do upvote. Thanks!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        return solve(piles,n,k);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k){\\n        if(k==0)return 0;\\n        if(i==0)return 0;\\n        int best=solve(piles,i-1,k);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1)));\\n        }\\n        return best;\\n    }\\n```\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n\\t\\tint[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n\\t\\t\\tArrays.fill(dp[i],-1);\\n        return solve(piles,n,k,dp);\\n    }\\n    \\n    public int solve(List<List<Integer>> piles,int i,int k,int[][] dp){\\n\\t\\tif(k==0)return 0;\\n        if(i==0)return 0;\\n\\t\\tif(dp[i][k]!=-1)return dp[i][k];\\n        int best=solve(piles,i-1,k,dp);\\n        List<Integer> pile=piles.get(i-1);\\n        int sum=0;\\n        for(int x=0;x<Math.min(k,pile.size());x++){\\n            sum+=pile.get(x);\\n            best=Math.max(best,+solve(piles,i-1,k-(x+1),dp));\\n        }\\n        return dp[i][k]= best;\\n    }\\n```\n```\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[][] dp=new int[n+1][k+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)dp[i][j]=0;\\n                else{\\n                    int best=dp[i-1][j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+dp[i-1][j-(x+1)]);\\n                    }\\n                    dp[i][j]= best;\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n```\n```\\n public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] prev=new int[k+1];\\n        for(int i=0;i<=n;i++){\\n            int[] curr=new int[k+1];\\n            for(int j=0;j<=k;j++){\\n                if(i==0 || j==0)curr[j]=0;\\n                else{\\n                    int best=prev[j];\\n                    List<Integer> pile=piles.get(i-1);\\n                    int sum=0;\\n                    for(int x=0;x<Math.min(j,pile.size());x++){\\n                        sum+=pile.get(x);\\n                        best=Math.max(best,sum+prev[j-(x+1)]);\\n                    }\\n                    curr[j]= best;\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[k];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887263,
                "title": "cpp-dp-recursive-approach-easy-to-understand",
                "content": "**Explantion**: The problem is similar to knapsack\\'s dp solution, where everything all boils down to select / not select current value. Similary In this problem we traverse pile by pile (denoted by `i`) and for every value in pile (`j`) we select (add `pile[i][j]` to our wallet) or we move to next pile (`i+1`). For Memoization, we make use of variables `i` and `k` denoting pile number and coin added in wallet respectively. We store value in DP vector only when our value of `j` is 0 i.e we have moved to new pile.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int j, int k, vector<vector<int>> &dp) {\\n        if (k == 0)\\n            return 0;\\n        \\n        if (i >= piles.size())\\n            return INT_MIN;\\n        \\n        if (j >= piles[i].size())\\n            return solve (piles, i+1, 0, k, dp); // emptied current pile, move to next pile\\n\\t\\t\\t\\n        if (dp[i][k] != -1 && j == 0)\\n            return dp[i][k];\\n\\t\\t\\t\\n        int a = 0, b = 0;\\n        a = solve (piles, i, j+1, k-1, dp) + piles[i][j];   // Pick current pile\\'s top\\n        b = solve (piles, i+1, 0, k, dp);                   // Don\\'t pick and move to next pile\\n        \\n        if (j == 0)\\n            dp[i][k] = max (a, b);\\n        \\n        return max (a, b);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        int ans = solve (piles, 0, 0, k, dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int j, int k, vector<vector<int>> &dp) {\\n        if (k == 0)\\n            return 0;\\n        \\n        if (i >= piles.size())\\n            return INT_MIN;\\n        \\n        if (j >= piles[i].size())\\n            return solve (piles, i+1, 0, k, dp); // emptied current pile, move to next pile\\n\\t\\t\\t\\n        if (dp[i][k] != -1 && j == 0)\\n            return dp[i][k];\\n\\t\\t\\t\\n        int a = 0, b = 0;\\n        a = solve (piles, i, j+1, k-1, dp) + piles[i][j];   // Pick current pile\\'s top\\n        b = solve (piles, i+1, 0, k, dp);                   // Don\\'t pick and move to next pile\\n        \\n        if (j == 0)\\n            dp[i][k] = max (a, b);\\n        \\n        return max (a, b);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        int ans = solve (piles, 0, 0, k, dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887025,
                "title": "java-top-down-dp",
                "content": "**Logic**\\nYou have n piles\\nSo you can take from `ith` pile min = 0 coins and atmost max(sizeOf(pile), k) \\nWe can do it with dynamic programming using dp table\\n\\n\\n```\\nclass Solution {\\n    Integer dp[][]; // store state\\n    private int solve(List<List<Integer>>piles, int i, int k){\\n        // if i < 0 there are no piles or \\n        // k <= 0 you cannnot pick any \\n        // return 0\\n        if(i < 0 || k <= 0) return 0; \\n        // if already stored that state return value\\n        if(dp[i][k] != null) return dp[i][k];\\n        // you can take max(size of that pile, k)\\n        int n = Math.min(piles.get(i).size(), k);\\n        // you will not choose that pile\\n        int exclude = solve(piles, i-1, k);\\n        // you will take 1, 2, ... k from that pile\\n        // and store the max in \\'include\\' variable\\n        int include = 0;\\n        for(int j=0, sum=0; j<n; j++){\\n            // store the sum from 0th index to jth index\\n            sum += piles.get(i).get(j);\\n            // take max from (sum + remaining k coins) and max value \\n            include = Math.max(sum + solve(piles, i-1, k-j-1), include);\\n        }\\n        // take max of include, exclude\\n        int res = Math.max(include, exclude);\\n        // store in dp\\n        dp[i][k] = res;\\n        return res;\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        dp = new Integer[n+5][k+5];\\n        return solve(piles, piles.size()-1, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][]; // store state\\n    private int solve(List<List<Integer>>piles, int i, int k){\\n        // if i < 0 there are no piles or \\n        // k <= 0 you cannnot pick any \\n        // return 0\\n        if(i < 0 || k <= 0) return 0; \\n        // if already stored that state return value\\n        if(dp[i][k] != null) return dp[i][k];\\n        // you can take max(size of that pile, k)\\n        int n = Math.min(piles.get(i).size(), k);\\n        // you will not choose that pile\\n        int exclude = solve(piles, i-1, k);\\n        // you will take 1, 2, ... k from that pile\\n        // and store the max in \\'include\\' variable\\n        int include = 0;\\n        for(int j=0, sum=0; j<n; j++){\\n            // store the sum from 0th index to jth index\\n            sum += piles.get(i).get(j);\\n            // take max from (sum + remaining k coins) and max value \\n            include = Math.max(sum + solve(piles, i-1, k-j-1), include);\\n        }\\n        // take max of include, exclude\\n        int res = Math.max(include, exclude);\\n        // store in dp\\n        dp[i][k] = res;\\n        return res;\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        dp = new Integer[n+5][k+5];\\n        return solve(piles, piles.size()-1, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418187,
                "title": "easy-c-dp",
                "content": "# Intuition\\nSome point that are directly hit to mind.\\n`if we take piles[i][j] coin we need to take all the coins above index j in that i pile.`\\n\\n`from above we can conlude that instead of taking one by one coin from a given row we take in bunch`\\n\\n# Approach\\n\\n`TRY ALL POSSIBLE WAYS`\\n\\n`To take bunch of coins we used presum of all indivisual piles of coins`\\n```\\nfor(int i=0;i<n;i++){\\n  int su=0;\\n    for( int a : pp[i]){\\n        pre[i].push_back(su);\\n        su+=a;\\n    }\\n    pre[i].push_back(su);\\n}\\n```\\nZero index means we are not taking any coin from that pile.\\n\\nNow we can take connect whole problem to 0/1 knapsack\\n\\nNeed to select a index from every presum of piles of coins and add to aur answer , and eqaully dicreasing count of k.\\n\\n`NOW USE DP`\\n\\nHere we can easily see only current number of pile and count remaning to add (k) is changing in our recursive code.\\n\\nso lets make 2D DP vector to store. \\n\\n# Complexity\\n- Time complexity:\\nO(N2)    {mota mota}\\n\\n- Space complexity:\\nO(N*K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<vector<int>> &pp , int cu , int k, vector<vector<int>> &dp ){\\n        if(cu>=pp.size()) return 0;\\n        if(dp[cu][k] != -1 ) return dp[cu][k];\\n        int mx=0;\\n        for(int i=0;i<pp[cu].size();i++){\\n            if(k-i>=0) mx = max(mx , pp[cu][i]+fun(pp,cu+1,k-i,dp));\\n        }\\n        return dp[cu][k] = mx;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pp, int k) {\\n        int  n = pp.size();\\n        vector<vector<int>> pre(n);\\n        vector<vector<int>> dp(n+2,vector<int>(k+2,-1));\\n        for(int i=0;i<n;i++){\\n            int su=0;\\n            for( int a : pp[i]){\\n                pre[i].push_back(su);\\n                su+=a;\\n            }\\n            pre[i].push_back(su);\\n        }\\n        return fun(pre,0,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor(int i=0;i<n;i++){\\n  int su=0;\\n    for( int a : pp[i]){\\n        pre[i].push_back(su);\\n        su+=a;\\n    }\\n    pre[i].push_back(su);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<vector<int>> &pp , int cu , int k, vector<vector<int>> &dp ){\\n        if(cu>=pp.size()) return 0;\\n        if(dp[cu][k] != -1 ) return dp[cu][k];\\n        int mx=0;\\n        for(int i=0;i<pp[cu].size();i++){\\n            if(k-i>=0) mx = max(mx , pp[cu][i]+fun(pp,cu+1,k-i,dp));\\n        }\\n        return dp[cu][k] = mx;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pp, int k) {\\n        int  n = pp.size();\\n        vector<vector<int>> pre(n);\\n        vector<vector<int>> dp(n+2,vector<int>(k+2,-1));\\n        for(int i=0;i<n;i++){\\n            int su=0;\\n            for( int a : pp[i]){\\n                pre[i].push_back(su);\\n                su+=a;\\n            }\\n            pre[i].push_back(su);\\n        }\\n        return fun(pre,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418060,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def dp(i,K):\\n            if k==0 or i==len(piles):\\n                return 0\\n\\n            res,cur=dp(i+1,K),0\\n\\n            for j in range(min(len(piles[i]),K)):\\n                cur+=piles[i][j]\\n                res=max(res,cur+dp(i+1,K-j-1))\\n\\n            return res\\n\\n\\n        return dp(0,k)          \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def dp(i,K):\\n            if k==0 or i==len(piles):\\n                return 0\\n\\n            res,cur=dp(i+1,K),0\\n\\n            for j in range(min(len(piles[i]),K)):\\n                cur+=piles[i][j]\\n                res=max(res,cur+dp(i+1,K-j-1))\\n\\n            return res\\n\\n\\n        return dp(0,k)          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683141,
                "title": "easy-understanding-dp-memoziation-solution",
                "content": "UPVOTE IF YOU LIKE THE SOLUTION.\\n```\\nclass Solution {\\npublic:\\n    //memoization Solution\\n    int helper(int i, vector<vector<int>>& piles, int k, vector<vector<int>>& dp){\\n        //base condition\\n        if(i == piles.size() || k <= 0){\\n            return 0;\\n        }\\n        \\n        //check if this condition is reached before\\n        if(dp[i][k] != -1){\\n            return dp[i][k];\\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int j = 0; j < piles[i].size(); j++){\\n            //if j becomes greater than k-1 break\\n            if(j > k-1)\\n                break;\\n            \\n            //take starting j+1 coins from the ith pile\\n            long long take = piles[i][j] + helper(i+1, piles, k-j-1, dp);\\n            \\n            //store the max value in ans\\n            ans = max(ans, take);\\n        }\\n        \\n        //donot take any coins from ith piles\\n        long long ntake = helper(i+1, piles, k, dp);\\n        ans = max(ans, ntake);\\n        \\n        //memoize it\\n        return dp[i][k] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //dp vector\\n        vector<vector<int>> dp(piles.size(), vector<int>(k+1,-1));\\n        \\n        //prefix vector\\n        vector<vector<int>> prefix;\\n        for(auto a: piles){\\n            int n = a.size();\\n            vector<int> temp(n);\\n            temp[0] = a[0];\\n            for(int i = 1; i < n; i++){\\n                temp[i] = temp[i-1] + a[i];\\n            }\\n            prefix.push_back(temp);\\n        }\\n        return helper(0, prefix, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //memoization Solution\\n    int helper(int i, vector<vector<int>>& piles, int k, vector<vector<int>>& dp){\\n        //base condition\\n        if(i == piles.size() || k <= 0){\\n            return 0;\\n        }\\n        \\n        //check if this condition is reached before\\n        if(dp[i][k] != -1){\\n            return dp[i][k];\\n        }\\n        \\n        long long ans = INT_MIN;\\n        for(int j = 0; j < piles[i].size(); j++){\\n            //if j becomes greater than k-1 break\\n            if(j > k-1)\\n                break;\\n            \\n            //take starting j+1 coins from the ith pile\\n            long long take = piles[i][j] + helper(i+1, piles, k-j-1, dp);\\n            \\n            //store the max value in ans\\n            ans = max(ans, take);\\n        }\\n        \\n        //donot take any coins from ith piles\\n        long long ntake = helper(i+1, piles, k, dp);\\n        ans = max(ans, ntake);\\n        \\n        //memoize it\\n        return dp[i][k] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //dp vector\\n        vector<vector<int>> dp(piles.size(), vector<int>(k+1,-1));\\n        \\n        //prefix vector\\n        vector<vector<int>> prefix;\\n        for(auto a: piles){\\n            int n = a.size();\\n            vector<int> temp(n);\\n            temp[0] = a[0];\\n            for(int i = 1; i < n; i++){\\n                temp[i] = temp[i-1] + a[i];\\n            }\\n            prefix.push_back(temp);\\n        }\\n        return helper(0, prefix, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520676,
                "title": "python-explained-with-diagram-iterative-dp-solution-beats-98-tc",
                "content": "Worst Case time complexity = O(n*k^2)\\n\\n**Intuition** - Let\\'s say we are standing at pile[i] and have already computed piles<i. And we have calculated the maximum possible sum of r (0<r<=k) number of coins uptill pile[i]. Now to calculate maximum possible sum using pile[i]  following steps can be followed:-\\n1) maximum sum uptill pile[i] is stored in array max_arr for 0<coins<=k\\n2) maintain an array cur_arr which stores coin sum including pile[i]. In pile[i], we have to calculate sum one by one using  0<top-coins<=k from pile[i]. cur_arr will hold the maximum value for a particular no. of coins less than using pile[i].\\n3) After cur_arr is calculated using k coins of pile[i], max_arr is updated to include greater values from cur_arr.\\n4) After all n piles are iterated, return max_arr[k].\\n  ![image](https://assets.leetcode.com/users/images/219e4955-2835-4798-a905-b715042b5a07_1662145396.921648.jpeg)![image](https://assets.leetcode.com/users/images/44ad72f0-8d6e-4775-ba27-aec22309741d_1662145445.133529.jpeg)\\n![image](https://assets.leetcode.com/users/images/fc346985-0b6e-4cb5-9d5c-27f6b126a5a4_1662146313.2433224.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n=len(piles)\\n        topk=[]\\n            \\n        cur_arr=[0]*(k+1)\\n        max_arr=[0]*(k+1)\\n        \\n        for x in piles:\\n            i=0\\n            cursum=0\\n            while i<k and i<len(x):\\n                cursum+=x[i]\\n                j=0\\n                while i+1+j<=k:\\n                    if j>0 and max_arr[j]==0:\\n                        break\\n                    cur_arr[i+1+j]=max(cur_arr[i+1+j],max_arr[j]+cursum)\\n                    j+=1\\n                i+=1\\n                \\n            for t in range(i+j):\\n                if cur_arr[t]>max_arr[t]:\\n                    max_arr[t]=cur_arr[t]\\n                    \\n        return max_arr[k]\\n            \\n            \\n                ```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n=len(piles)\\n        topk=[]\\n            \\n        cur_arr=[0]*(k+1)\\n        max_arr=[0]*(k+1)\\n        \\n        for x in piles:\\n            i=0\\n            cursum=0\\n            while i<k and i<len(x):\\n                cursum+=x[i]\\n                j=0\\n                while i+1+j<=k:\\n                    if j>0 and max_arr[j]==0:\\n                        break\\n                    cur_arr[i+1+j]=max(cur_arr[i+1+j],max_arr[j]+cursum)\\n                    j+=1\\n                i+=1\\n                \\n            for t in range(i+j):\\n                if cur_arr[t]>max_arr[t]:\\n                    max_arr[t]=cur_arr[t]\\n                    \\n        return max_arr[k]\\n            \\n            \\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 1896747,
                "title": "dp-memoization-well-explained-c",
                "content": "The main idea here is to use **Dynamic programming** and I have used **prefix sum** to get the total sum of the top elements uptil the index where I am standing at any instance.\\n\\nDp states are :  (index , k) \\n* ***index*** defines the stack which we are currently on \\n* ***k*** defines the number of elements which we can remove from the top of the stacks\\n\\nWe have 2 choice sstanding at any index : either take the elements \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tor skip the current stack and find for optimal answers in other indexes;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nIf we take the elements from the stack we have options to take as much elements from the current stack as we want( limitations : until k gets finished or the stack gets finished ) by running a loop we can iterate over all the possibilities and get the optimal option from it.\\n\\nDo upvote if you like my approach!! \\n\\n```\\nclass Solution {\\n    \\n    int help(int ind , int k, vector<vector<int>>&a, vector<vector<int>>&dp){\\n\\t\\t//base cases\\n\\t\\tif(k == 0)  return 0;\\n        if(k < 0)   return INT_MIN;\\n        if(ind < 0)    return 0;\\n\\t\\t\\n\\t\\t//memoization step\\n        int &ans = dp[ind][k];\\n        if(ans != -1)   return ans;     \\n\\t\\t//you can either skip the current stack or take from it\\n\\t\\t\\n        ans = help(ind-1, k , a, dp);  // option 1. skip the current stack\\n        int current_pile_size = a[ind].size();\\n\\t\\t// this is the limit of elements you can take from the current stack\\n        int limit = min(k, current_pile_size-1);  \\n        \\n        for(int i=0;i<=limit;i++){ //this loop will give me how many items i can take from the stack\\n            int take = a[ind][i] ;   // since prefix sum is done we get the total elements uptil this index using a[ind][i]\\n            ans = max(ans, take + help(ind-1, k-i-1, a, dp));  // we take the max of all the available options\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int size = piles.size(); \\n        for(auto &it: piles){\\n            int n = it.size();\\n            for(int i=1;i<n;i++)\\n                it[i] += it[i-1];  // prefix sum ...so we can get cumulative sum upto a point\\n        }\\n        vector<vector<int>>dp(size+1, vector<int>(k+1, -1));\\n        return help(size-1, k, piles, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int help(int ind , int k, vector<vector<int>>&a, vector<vector<int>>&dp){\\n\\t\\t//base cases\\n\\t\\tif(k == 0)  return 0;\\n        if(k < 0)   return INT_MIN;\\n        if(ind < 0)    return 0;\\n\\t\\t\\n\\t\\t//memoization step\\n        int &ans = dp[ind][k];\\n        if(ans != -1)   return ans;     \\n\\t\\t//you can either skip the current stack or take from it\\n\\t\\t\\n        ans = help(ind-1, k , a, dp);  // option 1. skip the current stack\\n        int current_pile_size = a[ind].size();\\n\\t\\t// this is the limit of elements you can take from the current stack\\n        int limit = min(k, current_pile_size-1);  \\n        \\n        for(int i=0;i<=limit;i++){ //this loop will give me how many items i can take from the stack\\n            int take = a[ind][i] ;   // since prefix sum is done we get the total elements uptil this index using a[ind][i]\\n            ans = max(ans, take + help(ind-1, k-i-1, a, dp));  // we take the max of all the available options\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int size = piles.size(); \\n        for(auto &it: piles){\\n            int n = it.size();\\n            for(int i=1;i<n;i++)\\n                it[i] += it[i-1];  // prefix sum ...so we can get cumulative sum upto a point\\n        }\\n        vector<vector<int>>dp(size+1, vector<int>(k+1, -1));\\n        return help(size-1, k, piles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887607,
                "title": "typescript-dp-iterative-beats-100-00-time-o-nk-2-space-o-k",
                "content": "Time: O(nk^2)\\nSpace: O(k)\\nLanguage: javascript, typescript\\n\\nRuntime: 325 ms, faster than 100.00%\\nMemory Usage: 45.1 MB, less than 100.00%\\n\\n```\\nfunction maxValueOfCoins(piles: number[][], coins: number): number {\\n    let dp = new Array(coins + 1).fill(0);\\n    \\n    for (let i = 0; i < piles.length; ++i) {\\n\\t    for (let j = coins; j > 0; --j) {\\n\\t\\t\\t// \"sum\" is a count of coins from piles[i]\\n            let sum = 0;\\n\\n            for (let k = 1; k <= Math.min(j, piles[i].length); k++) {\\n                sum += piles[i][k - 1];\\n\\n\\t\\t\\t\\t// take \"k\" coins from piles[i] and the previous best \"j-k\" coins\\n                dp[j] = Math.max(dp[j], dp[j-k] + sum);\\n            }\\n        }\\n    }\\n    \\n    return dp[coins];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nfunction maxValueOfCoins(piles: number[][], coins: number): number {\\n    let dp = new Array(coins + 1).fill(0);\\n    \\n    for (let i = 0; i < piles.length; ++i) {\\n\\t    for (let j = coins; j > 0; --j) {\\n\\t\\t\\t// \"sum\" is a count of coins from piles[i]\\n            let sum = 0;\\n\\n            for (let k = 1; k <= Math.min(j, piles[i].length); k++) {\\n                sum += piles[i][k - 1];\\n\\n\\t\\t\\t\\t// take \"k\" coins from piles[i] and the previous best \"j-k\" coins\\n                dp[j] = Math.max(dp[j], dp[j-k] + sum);\\n            }\\n        }\\n    }\\n    \\n    return dp[coins];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420493,
                "title": "python-3-9-lines-recursion-t-m-91-33",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```\\n[https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/submissions/934256020/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*^2).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420464,
                "title": "python-3-9-lines-recursion-t-m-91-33",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```\\n[https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/submissions/934247436/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*^2).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418977,
                "title": "rust-dp-concise",
                "content": "# Intuition\\nThis is dynamic programming task. The only tricky part is to find subtask.\\nThe subtask is to solve it for smaller number of piles (i left most piles) and for smaller k.\\nOn each step we iterate over new pile for all numbers from `0` to `k` and search for best value of `l` coins from new pile and `k - l` from previous subtask.\\n\\n\\n# Code\\n```\\nuse std::cmp::{min,max};\\n\\nimpl Solution {\\n    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let mut dp = vec![vec![0; k + 1]; piles.len() + 1];\\n        for i in 1..dp.len() {\\n            for j in 1..k + 1 {\\n                let mut s = 0;\\n                for l in 0..min(j + 1, piles[i - 1].len() + 1) {\\n                    dp[i][j] = max(dp[i][j], s + dp[i - 1][j - l]);\\n                    if l < piles[i - 1].len() {\\n                        s += piles[i - 1][l];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[piles.len()][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::{min,max};\\n\\nimpl Solution {\\n    pub fn max_value_of_coins(piles: Vec<Vec<i32>>, k: i32) -> i32 {\\n        let k = k as usize;\\n        let mut dp = vec![vec![0; k + 1]; piles.len() + 1];\\n        for i in 1..dp.len() {\\n            for j in 1..k + 1 {\\n                let mut s = 0;\\n                for l in 0..min(j + 1, piles[i - 1].len() + 1) {\\n                    dp[i][j] = max(dp[i][j], s + dp[i - 1][j - l]);\\n                    if l < piles[i - 1].len() {\\n                        s += piles[i - 1][l];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[piles.len()][k];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418374,
                "title": "c-memoization-dp-easy-to-understnad",
                "content": "````\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &v,vector<vector<int>> &dp,int s,int k,int &n){\\n        if(s>=n)return 0;\\n        if(k==0)return 0;\\n        if(dp[s][k] != -1)return dp[s][k];\\n        int mx = solve(v,dp,s+1,k,n);\\n        int cur = 0;\\n        for(int i = 0; i < v[s].size(); i++){\\n            cur += v[s][i];\\n            if(k-i-1 >= 0){\\n                mx = max(mx,cur+solve(v,dp,s+1,k-i-1,n));\\n            }\\n        }\\n        return dp[s][k] = mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(piles,dp,0,k,n);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &v,vector<vector<int>> &dp,int s,int k,int &n){\\n        if(s>=n)return 0;\\n        if(k==0)return 0;\\n        if(dp[s][k] != -1)return dp[s][k];\\n        int mx = solve(v,dp,s+1,k,n);\\n        int cur = 0;\\n        for(int i = 0; i < v[s].size(); i++){\\n            cur += v[s][i];\\n            if(k-i-1 >= 0){\\n                mx = max(mx,cur+solve(v,dp,s+1,k-i-1,n));\\n            }\\n        }\\n        return dp[s][k] = mx;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(piles,dp,0,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418160,
                "title": "basic-approach-java-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        //dp[i][j] means when we just use the first i piles and j picks, the maximum coins we can get\\n        int[][] dp = new int[piles.size()+1][k+1];\\n        for (int i = 1; i <= piles.size(); i++){\\n            for (int j = 1; j <= k; j++){\\n                int sum = 0;\\n                // At first we don\\'t pick anything, so the coins you can get is the same and for i-1 condition\\n                dp[i][j] = dp[i-1][j];\\n                //Begin to traverse the ith pile\\n                //Note here we use min function to prevent index out of bound\\n                for (int h = 0; h < Math.min(j, piles.get(i-1).size()); h++){\\n                    //We take the current (hth) coin\\n                    sum += piles.get(i-1).get(h);\\n                    //Check if pick it can maximize our score\\n                    //Note that if we pick it, we can only get the coins for j-1-h picks when we are at i-1th coin\\n                    dp[i][j] = Math.max(dp[i][j], sum + dp[i-1][j-1-h]);\\n                }\\n            }\\n        }\\n        //The result is when we use all of the piles and k picks\\n        return dp[piles.size()][k]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        //dp[i][j] means when we just use the first i piles and j picks, the maximum coins we can get\\n        int[][] dp = new int[piles.size()+1][k+1];\\n        for (int i = 1; i <= piles.size(); i++){\\n            for (int j = 1; j <= k; j++){\\n                int sum = 0;\\n                // At first we don\\'t pick anything, so the coins you can get is the same and for i-1 condition\\n                dp[i][j] = dp[i-1][j];\\n                //Begin to traverse the ith pile\\n                //Note here we use min function to prevent index out of bound\\n                for (int h = 0; h < Math.min(j, piles.get(i-1).size()); h++){\\n                    //We take the current (hth) coin\\n                    sum += piles.get(i-1).get(h);\\n                    //Check if pick it can maximize our score\\n                    //Note that if we pick it, we can only get the coins for j-1-h picks when we are at i-1th coin\\n                    dp[i][j] = Math.max(dp[i][j], sum + dp[i-1][j-1-h]);\\n                }\\n            }\\n        }\\n        //The result is when we use all of the piles and k picks\\n        return dp[piles.size()][k]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418100,
                "title": "easy-to-understand-python-logically-explained-dp",
                "content": "**Pre-Requisites - 0/1 Knapsack**\\n\\n**Solution -**\\nLet\\'s do some ground work first.\\nFor all the piles we can make them into prefix sum arrays\\neg:- [2, 7, 3] -> [0, 2, 9, 12]\\nNow the question is not how many of elements of each array to take rather which element of each prefix sum array to take.\\nAlso, we can associate weights with each element (basically denoting the number of elements taken from that array).\\nTaking the previous array, [[0, 0], [2, 1], [9, 2], [12, 3]] - 0, 1, 2, 3 are the number of elements taken\\n\\nNow, we have to take one of them from each pile and the sum of weights should be k, seems kinda like knapsack, right?\\nThe only difference is we can\\'t independently take elements as taking [2, 1] & [9, 2] would just mean we\\'re taking the element \\'2\\' twice.\\nSo we have to take one element from each pile (more preceisely one element of prefix sum array)\\n\\nNow this is easily solvable as in 0/1 knapsack, we used to go to the previous row to check the maximum possible answer with remaining weight (column_number - weight) and in this we\\'ll go to the last row which contained weights from the previous pile and not the current one (to avoid picking up any weight twice)\\n\\n**Code -**\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n = len(piles)\\n            \\n        prefix = []\\n        \\n        #prev array represents where the elements from last pile ended\\n        prev = [0]\\n        \\n        for pile in piles:\\n            curr = [0]\\n            for ele in pile:\\n                curr.append(curr[-1]+ele)\\n            prefix.append(curr)\\n            \\n            prev.append(prev[-1]+len(pile))\\n            \\n        dp = [[0]*(k+1) for i in range(prev[-1]+1)]\\n            \\n        for i in range(n):\\n            for j in range(1, len(prefix[i])):\\n                \\n                profit = prefix[i][j]\\n                wt = j\\n\\n                # lvl represents row number\\n                # We\\'ve given a different row to every prefix sum array element.   \\n                lvl = prev[i]+j \\n                \\n                for w in range(1, k+1): \\n                    if wt > w:\\n                        dp[lvl][w] = dp[lvl-1][w]\\n                    else:\\n                        dp[lvl][w] = max(dp[lvl-1][w], profit+dp[prev[i]][w-wt])\\n        return dp[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "**Pre-Requisites - 0/1 Knapsack**\\n\\n**Solution -**\\nLet\\'s do some ground work first.\\nFor all the piles we can make them into prefix sum arrays\\neg:- [2, 7, 3] -> [0, 2, 9, 12]\\nNow the question is not how many of elements of each array to take rather which element of each prefix sum array to take.\\nAlso, we can associate weights with each element (basically denoting the number of elements taken from that array).\\nTaking the previous array, [[0, 0], [2, 1], [9, 2], [12, 3]] - 0, 1, 2, 3 are the number of elements taken\\n\\nNow, we have to take one of them from each pile and the sum of weights should be k, seems kinda like knapsack, right?\\nThe only difference is we can\\'t independently take elements as taking [2, 1] & [9, 2] would just mean we\\'re taking the element \\'2\\' twice.\\nSo we have to take one element from each pile (more preceisely one element of prefix sum array)\\n\\nNow this is easily solvable as in 0/1 knapsack, we used to go to the previous row to check the maximum possible answer with remaining weight (column_number - weight) and in this we\\'ll go to the last row which contained weights from the previous pile and not the current one (to avoid picking up any weight twice)\\n\\n**Code -**\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        n = len(piles)\\n            \\n        prefix = []\\n        \\n        #prev array represents where the elements from last pile ended\\n        prev = [0]\\n        \\n        for pile in piles:\\n            curr = [0]\\n            for ele in pile:\\n                curr.append(curr[-1]+ele)\\n            prefix.append(curr)\\n            \\n            prev.append(prev[-1]+len(pile))\\n            \\n        dp = [[0]*(k+1) for i in range(prev[-1]+1)]\\n            \\n        for i in range(n):\\n            for j in range(1, len(prefix[i])):\\n                \\n                profit = prefix[i][j]\\n                wt = j\\n\\n                # lvl represents row number\\n                # We\\'ve given a different row to every prefix sum array element.   \\n                lvl = prev[i]+j \\n                \\n                for w in range(1, k+1): \\n                    if wt > w:\\n                        dp[lvl][w] = dp[lvl-1][w]\\n                    else:\\n                        dp[lvl][w] = max(dp[lvl-1][w], profit+dp[prev[i]][w-wt])\\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 3417985,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            int sz = piles[i-1].size();\\n            for(int j=1; j<=k; j++)\\n            {\\n                int tmp = dp[i-1][j];\\n                int curr = 0, s = 0;\\n                for(int t=1; t<=sz; t++)\\n                {\\n                    s += piles[i-1][t-1];\\n                    if(j-t >= 0)\\n                        curr = max(curr, dp[i-1][j-t] + s);\\n\\n                    dp[i][j] = max(dp[i-1][j], curr);\\n                }\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            int sz = piles[i-1].size();\\n            for(int j=1; j<=k; j++)\\n            {\\n                int tmp = dp[i-1][j];\\n                int curr = 0, s = 0;\\n                for(int t=1; t<=sz; t++)\\n                {\\n                    s += piles[i-1][t-1];\\n                    if(j-t >= 0)\\n                        curr = max(curr, dp[i-1][j-t] + s);\\n\\n                    dp[i][j] = max(dp[i-1][j], curr);\\n                }\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417871,
                "title": "daily-leetcoding-challenge-april-day-15",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1977616,
                "title": "java-c-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Java***\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        // for each pile to do dp.\\n        for(List<Integer> pile:piles){\\n            //use prefix sum to record each pile\\'s first i elments;\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            //use current pile to do dp, the dp is\\n            // we have two pile previous pile\\'s dp result and current pile--> reduce to two pile problem.\\n            // pile 0, 1 ,2 ,3 , 4, ...\\n            // pile (0,1),2,3,4...\\n            //      (0,1) is dp result for next calculation.\\n            // pile (0,1,2),3,4...\\n            // ...\\n            // pile (0,1,2,3,4... )\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n   int dp[1001][2001]; //Dp array For Memoization.\\n   int solve(vector<vector<int>>&v,int index,int coin)\\n   {\\n       if(index>=v.size()||coin==0)  //Base Condition\\n           return 0;\\n       if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n           return dp[index][coin];\\n       \\n       \\n       /* Our 1st choice :- We not take any Coin from that pile*/\\n       int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n       \\n      \\n       /*Otherwise we can take Coins from that Pile.*/\\n       int loop=v[index].size()-1;\\n       int sum=0;\\n       \\n       for(int j=0;j<=min(coin-1,loop);j++) //\\n       {\\n           sum=sum+v[index][j];\\n           ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n           \\n           /*Aove we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n       }\\n       \\n       return dp[index][coin]=ans;\\n   }\\n   int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n       memset(dp,-1,sizeof(dp));\\n       return solve(piles,0,k);\\n   }\\n};\\n```\\n\\n***Python***\\n```\\nimport numpy as np\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        best = np.zeros(k+1)\\n        for pile in piles:\\n            temp = best.copy()\\n            for used, value in enumerate(accumulate(pile), 1):\\n                if used > k: break\\n                temp2 = best+value\\n                temp2 = np.concatenate((np.zeros(used), temp2[:-used]))\\n                temp = np.maximum(temp, temp2)\\n            best = temp\\n        return int(best[-1])\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        // for each pile to do dp.\\n        for(List<Integer> pile:piles){\\n            //use prefix sum to record each pile\\'s first i elments;\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            //use current pile to do dp, the dp is\\n            // we have two pile previous pile\\'s dp result and current pile--> reduce to two pile problem.\\n            // pile 0, 1 ,2 ,3 , 4, ...\\n            // pile (0,1),2,3,4...\\n            //      (0,1) is dp result for next calculation.\\n            // pile (0,1,2),3,4...\\n            // ...\\n            // pile (0,1,2,3,4... )\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n   int dp[1001][2001]; //Dp array For Memoization.\\n   int solve(vector<vector<int>>&v,int index,int coin)\\n   {\\n       if(index>=v.size()||coin==0)  //Base Condition\\n           return 0;\\n       if(dp[index][coin]!=-1) //Check wheather It is Already Calculated Or not.\\n           return dp[index][coin];\\n       \\n       \\n       /* Our 1st choice :- We not take any Coin from that pile*/\\n       int ans=solve(v,index+1,coin); //Just Call function for next Pile.\\n       \\n      \\n       /*Otherwise we can take Coins from that Pile.*/\\n       int loop=v[index].size()-1;\\n       int sum=0;\\n       \\n       for(int j=0;j<=min(coin-1,loop);j++) //\\n       {\\n           sum=sum+v[index][j];\\n           ans=max(ans,sum+solve(v,index+1,coin-(j+1)));\\n           \\n           /*Aove we Pass coin-(j+1). Because till j\\'th index we have taken j+1 coin from that pile.*/\\n       }\\n       \\n       return dp[index][coin]=ans;\\n   }\\n   int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n       memset(dp,-1,sizeof(dp));\\n       return solve(piles,0,k);\\n   }\\n};\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        best = np.zeros(k+1)\\n        for pile in piles:\\n            temp = best.copy()\\n            for used, value in enumerate(accumulate(pile), 1):\\n                if used > k: break\\n                temp2 = best+value\\n                temp2 = np.concatenate((np.zeros(used), temp2[:-used]))\\n                temp = np.maximum(temp, temp2)\\n            best = temp\\n        return int(best[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887372,
                "title": "c-2d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& P, int k) {\\n        int m = P.size();\\n        for(int i = 0 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j = 1 ; j<n; ++j){\\n                P[i][j] += P[i][j-1];\\n            }\\n        }// sum of value if we take j elements from top of any pile of coins.\\n        vector<int> mxc(k+1,0);\\n        for(int j = min(k,(int)P[0].size()) ; j>0; --j){\\n            mxc[j] = P[0][j-1];\\n        }\\n        for(int i = 1 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j=k; j>0 ; --j){//Final Sum\\n                for(int l=min(j,n); l>0; --l){\\n                    mxc[j] = max(mxc[j-l]+P[i][l-1],mxc[j]);\\n                }\\n                 \\n            }\\n        }\\n        return mxc[k];\\n        \\n    }\\n};\\n```\\n\\n0-1 Knapsack problem variant.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& P, int k) {\\n        int m = P.size();\\n        for(int i = 0 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j = 1 ; j<n; ++j){\\n                P[i][j] += P[i][j-1];\\n            }\\n        }// sum of value if we take j elements from top of any pile of coins.\\n        vector<int> mxc(k+1,0);\\n        for(int j = min(k,(int)P[0].size()) ; j>0; --j){\\n            mxc[j] = P[0][j-1];\\n        }\\n        for(int i = 1 ; i< m ; i++){\\n            int n = P[i].size();\\n            for(int j=k; j>0 ; --j){//Final Sum\\n                for(int l=min(j,n); l>0; --l){\\n                    mxc[j] = max(mxc[j-l]+P[i][l-1],mxc[j]);\\n                }\\n                 \\n            }\\n        }\\n        return mxc[k];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886926,
                "title": "c-solution-simple-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[2005][2005];\\n    \\n    int K;\\n    long long MaxValue(vector<vector<int>>& piles, int taken,int pile)\\n    {\\n        if(taken==K) return 0;\\n        if(pile>=piles.size()||taken>K) return INT_MIN;\\n       \\n        if(dp[taken][pile]!=-1) return dp[taken][pile];\\n        \\n        long long ans=0;\\n\\t\\t// if we want to pick and try atleast one coin from this pile\\n\\t\\t\\n        for(int i=0;i<piles[pile].size();i++)\\n        {\\n            ans=max(ans,piles[pile][i]+MaxValue(piles,taken+i+1,pile+1));\\n        }\\n        \\n        ans=max(ans,MaxValue(piles,taken,pile+1)); // if we want to skip this pile altogether\\n        \\n        return dp[taken][pile]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t\\n\\t\\t// storing the prefix sum so as to know if we pick the ith coin out of a pile, what will be the total sum of all the coins above the ith coin \\n\\t\\t\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++) piles[i][j]+=piles[i][j-1];\\n        }\\n        \\n        K=k;\\n        return MaxValue(piles,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[2005][2005];\\n    \\n    int K;\\n    long long MaxValue(vector<vector<int>>& piles, int taken,int pile)\\n    {\\n        if(taken==K) return 0;\\n        if(pile>=piles.size()||taken>K) return INT_MIN;\\n       \\n        if(dp[taken][pile]!=-1) return dp[taken][pile];\\n        \\n        long long ans=0;\\n\\t\\t// if we want to pick and try atleast one coin from this pile\\n\\t\\t\\n        for(int i=0;i<piles[pile].size();i++)\\n        {\\n            ans=max(ans,piles[pile][i]+MaxValue(piles,taken+i+1,pile+1));\\n        }\\n        \\n        ans=max(ans,MaxValue(piles,taken,pile+1)); // if we want to skip this pile altogether\\n        \\n        return dp[taken][pile]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t\\n\\t\\t// storing the prefix sum so as to know if we pick the ith coin out of a pile, what will be the total sum of all the coins above the ith coin \\n\\t\\t\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++) piles[i][j]+=piles[i][j-1];\\n        }\\n        \\n        K=k;\\n        return MaxValue(piles,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543128,
                "title": "c-memoization-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& piles, int k, int ind, vector<vector<int>> & dp){\\n        if(ind<0)return 0;\\n        if(k==0)return 0;\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        int a=helper(piles, k, ind-1, dp);\\n        \\n        int ans=a;\\n        for(int i=0; i<piles[ind].size(); i++){\\n            int b=0;\\n            if(i+1<=k){\\n                b=piles[ind][i]+helper(piles, k-i-1, ind-1, dp);\\n                ans=max(ans, b);\\n            }\\n        }\\n        return dp[ind][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0; i<piles.size(); i++){\\n            for(int j=1; j<piles[i].size(); j++){\\n                piles[i][j]+=piles[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return helper(piles, k, n-1, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& piles, int k, int ind, vector<vector<int>> & dp){\\n        if(ind<0)return 0;\\n        if(k==0)return 0;\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        int a=helper(piles, k, ind-1, dp);\\n        \\n        int ans=a;\\n        for(int i=0; i<piles[ind].size(); i++){\\n            int b=0;\\n            if(i+1<=k){\\n                b=piles[ind][i]+helper(piles, k-i-1, ind-1, dp);\\n                ans=max(ans, b);\\n            }\\n        }\\n        return dp[ind][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0; i<piles.size(); i++){\\n            for(int j=1; j<piles[i].size(); j++){\\n                piles[i][j]+=piles[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return helper(piles, k, n-1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421114,
                "title": "python-short-and-clean-recursive-dp-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(m * k)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`m is number of total coins from all piles`\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: list[list[int]], k_: int) -> int:\\n        prefix_piles = [list(accumulate(p, initial=0)) for p in piles]\\n\\n        @cache\\n        def max_value(n: int, k: int) -> int:\\n            return max(\\n                max_value(n - 1, k - i) + x\\n                for i, x in enumerate(islice(prefix_piles[n - 1], k + 1))\\n            ) if n and k else 0\\n        \\n        return max_value(len(piles), k_)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: list[list[int]], k_: int) -> int:\\n        prefix_piles = [list(accumulate(p, initial=0)) for p in piles]\\n\\n        @cache\\n        def max_value(n: int, k: int) -> int:\\n            return max(\\n                max_value(n - 1, k - i) + x\\n                for i, x in enumerate(islice(prefix_piles[n - 1], k + 1))\\n            ) if n and k else 0\\n        \\n        return max_value(len(piles), k_)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421056,
                "title": "prefix-sum-2d-dp",
                "content": "# Intuition\\nUse DP and prefix sum\\n\\n# Approach\\nFirst for each pile, build a prefix sum (aka cummulative sum) up to k elements (we can just trim/ignore if there is more).\\n\\nThen focus on the first pile.\\nWe can take first coin, or two, or ... k and then deal with smaller problem (one less pile and same or less coins to consider).\\n\\nSo the base cases are:\\n- we have considered all piles\\n- we have no more coins to take\\n\\nIn the meoized helper DP function, we take two parameters:\\n`start_pile` - index of the pile we focus on (and later deal only with piles with bigger index)\\n`hp` - the helper version of k, that is remaining coins we need to consider\\n\\nOn the helper function we looking for the maximum,\\nconsidering taking from the start_pile 0 up to hk coins and remaining coins from the next piles recursively.\\n\\nHaving such helper function, the answer will be found by `helper(start_pile=0, hk=k)`\\n\\nIf you find it helpful please up-vote. Thank you!\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\times k)$$ I think...\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n\\\\times k)$$ I think...\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n\\n        # Turn each pile to cummulative sum trimmed to k elements\\n        for pi in range(n):\\n            piles[pi] = list(accumulate(piles[pi][:k]))\\n        \\n        @cache\\n        def helper(start_pile: int, hk: int):\\n            if start_pile >= n or hk == 0:\\n                return 0\\n            # Consider we don\\'t take anything from start_pile\\n            ans = helper(start_pile + 1, hk)\\n            for i, v in enumerate(piles[start_pile], start=1):\\n                # Consider we take first i coins from start_pile\\n                ans = max(ans, v + helper(start_pile + 1, hk - i))\\n                if i == hk:\\n                    break\\n            return ans\\n        \\n        return helper(0, k)```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n\\n        # Turn each pile to cummulative sum trimmed to k elements\\n        for pi in range(n):\\n            piles[pi] = list(accumulate(piles[pi][:k]))\\n        \\n        @cache\\n        def helper(start_pile: int, hk: int):\\n            if start_pile >= n or hk == 0:\\n                return 0\\n            # Consider we don\\'t take anything from start_pile\\n            ans = helper(start_pile + 1, hk)\\n            for i, v in enumerate(piles[start_pile], start=1):\\n                # Consider we take first i coins from start_pile\\n                ans = max(ans, v + helper(start_pile + 1, hk - i))\\n                if i == hk:\\n                    break\\n            return ans\\n        \\n        return helper(0, k)```",
                "codeTag": "Java"
            },
            {
                "id": 3419911,
                "title": "c-recursion-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];\\n    int fun(int i, int k, vector<vector<int>> &v, int n, vector<vector<int>> &pre){\\n        if(i>=n || k==0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int maxi=-1;\\n        for(int p=0;p<=min(k,(int)v[i].size());p++){\\n            int ans=0;\\n            if(p==0){\\n                if(dp[i+1][k]!=-1)\\n                ans+=dp[i+1][k];\\n                else\\n                ans+=fun(i+1,k,v,n,pre);\\n            }\\n            else{\\n                ans+=pre[i][min({p,k,(int)v[i].size()})-1];\\n                if(dp[i+1][k-min({p,k,(int)v[i].size()})]!=-1)\\n                ans+=dp[i+1][k-min({p,k,(int)v[i].size()})];\\n                else\\n                ans+=fun(i+1,k-min({p,k,(int)v[i].size()}),v,n,pre);\\n            }\\n            maxi=max(maxi,ans);\\n        }\\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<int>> pre;\\n        for(int i=0;i<piles.size();i++){\\n            int sum=0;\\n            vector<int> p;\\n            for(int j=0;j<piles[i].size();j++){\\n                sum+=piles[i][j];\\n                p.push_back(sum);\\n            }\\n            pre.push_back(p);\\n        }\\n        \\n        return fun(0,k,piles,piles.size(),pre);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];\\n    int fun(int i, int k, vector<vector<int>> &v, int n, vector<vector<int>> &pre){\\n        if(i>=n || k==0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int maxi=-1;\\n        for(int p=0;p<=min(k,(int)v[i].size());p++){\\n            int ans=0;\\n            if(p==0){\\n                if(dp[i+1][k]!=-1)\\n                ans+=dp[i+1][k];\\n                else\\n                ans+=fun(i+1,k,v,n,pre);\\n            }\\n            else{\\n                ans+=pre[i][min({p,k,(int)v[i].size()})-1];\\n                if(dp[i+1][k-min({p,k,(int)v[i].size()})]!=-1)\\n                ans+=dp[i+1][k-min({p,k,(int)v[i].size()})];\\n                else\\n                ans+=fun(i+1,k-min({p,k,(int)v[i].size()}),v,n,pre);\\n            }\\n            maxi=max(maxi,ans);\\n        }\\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<int>> pre;\\n        for(int i=0;i<piles.size();i++){\\n            int sum=0;\\n            vector<int> p;\\n            for(int j=0;j<piles[i].size();j++){\\n                sum+=piles[i][j];\\n                p.push_back(sum);\\n            }\\n            pre.push_back(p);\\n        }\\n        \\n        return fun(0,k,piles,piles.size(),pre);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419681,
                "title": "c-recursion-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int> (k + 1, -1));\\n        return helper(piles, 0, k, dp);\\n    }\\n\\n    int helper(vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int mx = helper(piles, i + 1, k, dp), sum = 0;\\n        for(int j = 0; j < piles[i].size() && j < k; j++)\\n            mx = max(mx, (sum += piles[i][j]) + helper(piles, i + 1, k - j - 1, dp));\\n\\n        return dp[i][k] = mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int> (k + 1, -1));\\n        return helper(piles, 0, k, dp);\\n    }\\n\\n    int helper(vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int mx = helper(piles, i + 1, k, dp), sum = 0;\\n        for(int j = 0; j < piles[i].size() && j < k; j++)\\n            mx = max(mx, (sum += piles[i][j]) + helper(piles, i + 1, k - j - 1, dp));\\n\\n        return dp[i][k] = mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419393,
                "title": "ruby-prefix-sum-and-recursion",
                "content": "# Code\\n```ruby\\nclass Array\\n  def scan(st) = map { st = yield st, _1 }\\n  def prefsum = scan(0, &:+).unshift(0)\\nend\\n\\ndef max_value_of_coins(piles, k)\\n  @pile_prefs = piles.map(&:prefsum)\\n  @size_prefs = piles.map(&:size).prefsum\\n  @_dp = Array.new(piles.size) { [] } << -> _ { 0 }\\n  dp(0, k)\\nend\\n\\ndef dp(i, k)\\n  @_dp[i][k] ||= begin\\n    pref = @pile_prefs[i]\\n    rem = @size_prefs[-1] - @size_prefs[i + 1]\\n    (max(0, k - rem)..min(k, pref.size - 1)).map { pref[_1] + dp(i + 1, k - _1) }.max\\n  end\\nend\\n\\ndef min(a, b) = a < b ? a : b\\ndef max(a, b) = a > b ? a : b\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(\\\\sum|\\\\text{piles}_i|)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(\\\\sum|\\\\text{piles}_i|)$$",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```ruby\\nclass Array\\n  def scan(st) = map { st = yield st, _1 }\\n  def prefsum = scan(0, &:+).unshift(0)\\nend\\n\\ndef max_value_of_coins(piles, k)\\n  @pile_prefs = piles.map(&:prefsum)\\n  @size_prefs = piles.map(&:size).prefsum\\n  @_dp = Array.new(piles.size) { [] } << -> _ { 0 }\\n  dp(0, k)\\nend\\n\\ndef dp(i, k)\\n  @_dp[i][k] ||= begin\\n    pref = @pile_prefs[i]\\n    rem = @size_prefs[-1] - @size_prefs[i + 1]\\n    (max(0, k - rem)..min(k, pref.size - 1)).map { pref[_1] + dp(i + 1, k - _1) }.max\\n  end\\nend\\n\\ndef min(a, b) = a < b ? a : b\\ndef max(a, b) = a > b ? a : b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419223,
                "title": "easy-java-solution-dynamic-programming",
                "content": "![upvote.png](https://assets.leetcode.com/users/images/944f8a25-3a7e-4b2c-80ef-3eea96f03fd4_1681555329.6333501.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[][];\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        dp = new int[n+1][k+1];\\n        for(int i = 1; i <= n; i++){\\n            for(int coins = 0; coins <= k; coins++){\\n                dp[i][coins] = -1;\\n            }\\n        }\\n        return helper(piles,n,k);\\n    }\\n\\n    private int helper(List<List<Integer>> piles, int i, int coins){\\n        if(i==0)return 0;\\n\\n        if(dp[i][coins] != -1)return dp[i][coins];\\n\\n        int currSum = 0;\\n        for(int currCoins = 0; currCoins <= Math.min(piles.get(i-1).size(), coins); currCoins++){\\n            if(currCoins > 0){\\n                currSum += piles.get(i-1).get(currCoins-1);\\n            }\\n            dp[i][coins] = Math.max(dp[i][coins], helper(piles, i-1, coins-currCoins)+currSum);\\n        }\\n        return dp[i][coins];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n = piles.size();\\n        dp = new int[n+1][k+1];\\n        for(int i = 1; i <= n; i++){\\n            for(int coins = 0; coins <= k; coins++){\\n                dp[i][coins] = -1;\\n            }\\n        }\\n        return helper(piles,n,k);\\n    }\\n\\n    private int helper(List<List<Integer>> piles, int i, int coins){\\n        if(i==0)return 0;\\n\\n        if(dp[i][coins] != -1)return dp[i][coins];\\n\\n        int currSum = 0;\\n        for(int currCoins = 0; currCoins <= Math.min(piles.get(i-1).size(), coins); currCoins++){\\n            if(currCoins > 0){\\n                currSum += piles.get(i-1).get(currCoins-1);\\n            }\\n            dp[i][coins] = Math.max(dp[i][coins], helper(piles, i-1, coins-currCoins)+currSum);\\n        }\\n        return dp[i][coins];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419107,
                "title": "simple-solution-using-recursion-and-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  int sumi(int index, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp)\\n  {\\n    if (index == n or k == 0)\\n      return 0;\\n    if (dp[index][k] != -1)\\n      return dp[index][k];\\n    int notPick = sumi(index + 1, piles, k, n, dp);\\n    int pick = 0, coins = k, sum = 0;\\n    for (int i = 0; i < piles[index].size() and coins > 0; i++)\\n    {\\n      sum += piles[index][i];\\n      coins--;\\n      int x = sum + sumi(index + 1, piles, coins, n, dp);\\n      pick = max(pick, x);\\n    }\\n    return dp[index][k] = max(pick, notPick);\\n  }\\n  int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n  {\\n    int n = piles.size();\\n    int index = 0;\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return sumi(index, piles, k, n, dp);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int sumi(int index, vector<vector<int>> &piles, int k, int n, vector<vector<int>> &dp)\\n  {\\n    if (index == n or k == 0)\\n      return 0;\\n    if (dp[index][k] != -1)\\n      return dp[index][k];\\n    int notPick = sumi(index + 1, piles, k, n, dp);\\n    int pick = 0, coins = k, sum = 0;\\n    for (int i = 0; i < piles[index].size() and coins > 0; i++)\\n    {\\n      sum += piles[index][i];\\n      coins--;\\n      int x = sum + sumi(index + 1, piles, coins, n, dp);\\n      pick = max(pick, x);\\n    }\\n    return dp[index][k] = max(pick, notPick);\\n  }\\n  int maxValueOfCoins(vector<vector<int>> &piles, int k)\\n  {\\n    int n = piles.size();\\n    int index = 0;\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return sumi(index, piles, k, n, dp);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419062,
                "title": "bottom-up-dp-explained",
                "content": "We define `dp[i][j]` as the the answer considering 1st `i` piles for at most `j` coins. Hence final answer is `dp[n][k]`. In base case we consider `i=0` ie considering zero piles. This row will be just zeroes. Similarly for `j=0` column also, it will be all zeroes. \\n\\nConsider any general `dp[i][j]`. \\n\\nWe can take 0 coins from `i`th pile and all the `j` coins from the first `i-1` piles. The value for this situation is `dp[i-1][j] + 0`.\\n\\nWe can also take 3 coins from `ith pile` (assume valid) and `j-3` coins from the first `i-1` piles. The value for this situation is `dp[i-1][j-3] + piles[i-1][0]+piles[i-1][1]+piles[i-1][2]`. \\n\\nSimilarly we can have other possiblities as well. `dp[i][j]` is the maximum of all these possibilities.\\n\\nWe define `cur` as the number of coins we take from the current pile and `curSum` as the sum of values of these `cur` coins.\\n\\n\\n```\\nint maxValueOfCoins(vector<vector<int>>& piles, int k) \\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n+1, vector<int>(k+1, 0));\\n    for (int i=1; i<=n; i++)\\n    {\\n        for (int j=0; j<=k; j++)\\n        {\\n            dp[i][j] = dp[i-1][j]; // cur=0\\n            int curSum = 0;\\n            for (int cur=1; cur<=min((int)piles[i-1].size(),j); cur++)\\n            {\\n                curSum += piles[i-1][cur-1];\\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cur]+curSum);\\n            }\\n        }\\n    }\\n    return dp[n][k];\\n}\\n```\\n\\n$$TC= O(n\\\\sum_{i=1}^n {P_i})$$ where $P_i$ is the size of ith pile.\\n$$SC: O(nk)$$",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxValueOfCoins(vector<vector<int>>& piles, int k) \\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n+1, vector<int>(k+1, 0));\\n    for (int i=1; i<=n; i++)\\n    {\\n        for (int j=0; j<=k; j++)\\n        {\\n            dp[i][j] = dp[i-1][j]; // cur=0\\n            int curSum = 0;\\n            for (int cur=1; cur<=min((int)piles[i-1].size(),j); cur++)\\n            {\\n                curSum += piles[i-1][cur-1];\\n                dp[i][j] = max(dp[i][j], dp[i-1][j-cur]+curSum);\\n            }\\n        }\\n    }\\n    return dp[n][k];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419035,
                "title": "c-easiest-solution-memoization-top-down-dp-recursive",
                "content": "**APPROACH**\\n**I have two option**\\n**Option 1: I will not anything from the current ith pile**\\n**Option 2: I wiil take some coins the from current ith pile and rest from other piles**\\n```\\nclass Solution\\n{\\n    public:\\n        int dp[1001][2001];\\n    int solver(vector<vector < int>> &arr, int coins, int idx=0)\\n    {\\n\\n       \\t// I have no coin and no piles\\n        if (idx >= arr.size() || coins == 0) return 0;\\n\\n        if (dp[idx][coins] != -1) return dp[idx][coins];\\n\\n        int ans = INT_MIN;\\n\\n       \\t//Option1: I will not take anything from this pile\\n        ans = solver(arr, coins, idx + 1);\\n\\n       \\t//options2: I will try to take some coins from here and other coins from some other pile ..so that I can have maximum amount\\n\\n\\t\\t//current pile size\\n        int sz = arr[idx].size();\\n        int sum = 0;\\n\\t\\t\\n\\t //[Need to iterate till min(coins,sz)because we can take only k coins  at max ]\\n        for (int i = 0; i < min(coins, sz); i++)\\n        {\\n            sum = sum + arr[idx][i];\\n\\n           \\t//trying to take some coins from others also including mine\\n            ans = max(ans, sum + solver(arr, coins - (i + 1), idx + 1));\\n        }\\n\\n        return dp[idx][coins] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector < int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return solver(piles, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int dp[1001][2001];\\n    int solver(vector<vector < int>> &arr, int coins, int idx=0)\\n    {\\n\\n       \\t// I have no coin and no piles\\n        if (idx >= arr.size() || coins == 0) return 0;\\n\\n        if (dp[idx][coins] != -1) return dp[idx][coins];\\n\\n        int ans = INT_MIN;\\n\\n       \\t//Option1: I will not take anything from this pile\\n        ans = solver(arr, coins, idx + 1);\\n\\n       \\t//options2: I will try to take some coins from here and other coins from some other pile ..so that I can have maximum amount\\n\\n\\t\\t//current pile size\\n        int sz = arr[idx].size();\\n        int sum = 0;\\n\\t\\t\\n\\t //[Need to iterate till min(coins,sz)because we can take only k coins  at max ]\\n        for (int i = 0; i < min(coins, sz); i++)\\n        {\\n            sum = sum + arr[idx][i];\\n\\n           \\t//trying to take some coins from others also including mine\\n            ans = max(ans, sum + solver(arr, coins - (i + 1), idx + 1));\\n        }\\n\\n        return dp[idx][coins] = ans;\\n    }\\n    int maxValueOfCoins(vector<vector < int>> &piles, int k)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return solver(piles, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418491,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k)\\n    {\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++)\\n        {\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) \\n    {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int func(vector<vector<int>>& p,int i,int k)\\n    {\\n        if(i==p.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=func(p,i+1,k);\\n        int a=0;\\n        for(int j=0;j<p[i].size()&&j<k;j++)\\n        {\\n            a+=p[i][j];\\n            ans=max(ans,a+func(p,i+1,k-j-1));\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) \\n    {\\n        dp=vector<vector<int>>(p.size(),vector<int>(k+1,-1));\\n        return func(p,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418108,
                "title": "python-easy-solution-with-explanation-recursion-with-caching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndynamic programming problem \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we first skip all nodes to start from last assume i have 4 piles (try last piles , then try 3rd and last pile , etc)\\n- with base case if i ==n or k ==0 return 0\\n- in for loop i try all possible coins in cur pile to last pile in limit with k\\n- cur_val save the value of cur try , ans res save max res of all tries \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        cache ={}\\n        def dfs(i,k ):\\n            if (i,k) in cache:\\n                return cache[(i,k)]\\n            if k==0 or i == len(piles):\\n                return 0\\n            # skip piles until reach end , then try all possible from last to first \\n            dfs(i+1 , k) \\n            res , cur_val = dfs(i+1 , k),0\\n            for j in range(min(k , len(piles[i]))):\\n                cur_val += piles[i][j]\\n                # print(cur_val ,res )\\n                res = max(res , cur_val + dfs(i+1 , k-j-1))\\n            cache[(i,k)]=res\\n            return cache[(i,k)]\\n        return dfs(0,k)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxValueOfCoins(self, piles, k):\\n        \"\"\"\\n        :type piles: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        cache ={}\\n        def dfs(i,k ):\\n            if (i,k) in cache:\\n                return cache[(i,k)]\\n            if k==0 or i == len(piles):\\n                return 0\\n            # skip piles until reach end , then try all possible from last to first \\n            dfs(i+1 , k) \\n            res , cur_val = dfs(i+1 , k),0\\n            for j in range(min(k , len(piles[i]))):\\n                cur_val += piles[i][j]\\n                # print(cur_val ,res )\\n                res = max(res , cur_val + dfs(i+1 , k-j-1))\\n            cache[(i,k)]=res\\n            return cache[(i,k)]\\n        return dfs(0,k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637855,
                "title": "dp-isn-t-scary-dude",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n     /*\\n     -> Pick the first coin from the pile and move to next.\\n     -> Don\\'t pick the first coin from pile and move to next.\\n     -> Pick first coin and stay on the same pile to pick the next coin.\\n     */   \\n        int[][] dp = new int[piles.size()][k + 1];\\n        for(var i:dp) Arrays.fill(i,-1);\\n        return move(piles,k,0,dp);\\n    }\\n    private int move(List<List<Integer>> piles, int k, int pileInd,int[][] dp) {\\n        if(k == 0) return 0;\\n        if(pileInd == piles.size())\\n            return 0;\\n        if(dp[pileInd][k] != -1) return dp[pileInd][k];\\n        int dontPick = move(piles,k,pileInd + 1,dp);\\n        int s = 0;\\n        for(int i = 0; i < k && i < piles.get(pileInd).size(); i++) {\\n            s += piles.get(pileInd).get(i);\\n            dontPick = Math.max(dontPick,s + move(piles,k - (i + 1), pileInd + 1,dp));\\n        }\\n        // int dontPick = move(piles,k,pileInd + 1,sum,dp);\\n        return dp[pileInd][k] = dontPick;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n     /*\\n     -> Pick the first coin from the pile and move to next.\\n     -> Don\\'t pick the first coin from pile and move to next.\\n     -> Pick first coin and stay on the same pile to pick the next coin.\\n     */   \\n        int[][] dp = new int[piles.size()][k + 1];\\n        for(var i:dp) Arrays.fill(i,-1);\\n        return move(piles,k,0,dp);\\n    }\\n    private int move(List<List<Integer>> piles, int k, int pileInd,int[][] dp) {\\n        if(k == 0) return 0;\\n        if(pileInd == piles.size())\\n            return 0;\\n        if(dp[pileInd][k] != -1) return dp[pileInd][k];\\n        int dontPick = move(piles,k,pileInd + 1,dp);\\n        int s = 0;\\n        for(int i = 0; i < k && i < piles.get(pileInd).size(); i++) {\\n            s += piles.get(pileInd).get(i);\\n            dontPick = Math.max(dontPick,s + move(piles,k - (i + 1), pileInd + 1,dp));\\n        }\\n        // int dontPick = move(piles,k,pileInd + 1,sum,dp);\\n        return dp[pileInd][k] = dontPick;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522444,
                "title": "c-solution-dp-o-m-k-time-o-k-space",
                "content": "`Time Complexity` : `O(m * k)`\\n`Space Complexity` : `O(k)`\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> dp(k + 1, 0);\\n        for(auto& pile: piles) {\\n            for(size_t i = k; i >= 1; i--) {\\n                int csum = 0;\\n                for(int j = 0; j < min(i, pile.size()); j++) {\\n                    csum += pile[j];\\n                    dp[i] = max(dp[i], dp[i - j - 1] + csum);\\n                }\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> dp(k + 1, 0);\\n        for(auto& pile: piles) {\\n            for(size_t i = k; i >= 1; i--) {\\n                int csum = 0;\\n                for(int j = 0; j < min(i, pile.size()); j++) {\\n                    csum += pile[j];\\n                    dp[i] = max(dp[i], dp[i - j - 1] + csum);\\n                }\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446235,
                "title": "recursive-3d-dp-with-2d-1d-mapping-reduction-using-hashing",
                "content": "I kept 3 variables for a state ,\\nIndex_of_pile --> which pile am i currently standing at  --> [i]\\nindex_in_current_pile  --> which index is at the top at the moment for piles[index], -->  [j]\\nNo_of_purchaces_remaining  ---> how many transactions do I have left with me ---> [k]\\n\\nDp[i][j][k] = returns me the maximum money i can retreive from here \\nat this state i have 2 choices \\ntake the jth coin (topmost coin) on pile i  and stay on the same pile\\ndont take the jth coin and move the next pile\\n\\ntake : piles[i][j] + func(i , j + 1 , k - 1)\\ndont take : func(i + 1 , 0 , k - 1 ) --> 0 because now 0 is the topmost coin of the new pile\\n\\nTime Complexity : O(piles.size()*K + calculationforhas = Piles.size())\\n\\n```class Solution {\\n   \\n    \\n   \\n    \\n    int dp[3003][2001];\\n\\t\\n\\t /*\\n    state which i can think of is that \\n    given (index_of_pile , index_in_pile , no_of_transactions_left) \\n    what is the maximum money i can generate \\n    index_in_pile---> the index of the coin to be pick from pile(index_of_pile)\\n    */\\n     \\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        vector<vector<int>> has;\\n        int cnt = -1;\\n        \\n        for(int i = 0 ; i < piles.size() ; i ++ ) {\\n            vector<int> row;\\n            for(int j = 0 ; j < piles[i].size() ; j ++) {\\n                row.push_back(-1);\\n            }\\n            row.push_back(-1);\\n            has.push_back(row);\\n        }\\n        \\n       \\n        for(int i = 0 ; i < has.size() ; i ++ ) {\\n            for(int j = 0 ; j < has[i].size() ; j ++ ) {\\n                has[i][j] = ++cnt;\\n                // this has function is \\n                // converting the row and the col of the  cell \\n                // into a single value\\n                // has{i , j} ---> cnt\\n            }\\n        } \\n        \\n    \\n        return func(piles , k , 0 , 0 , has);\\n      \\n    }\\n    \\n   \\n    \\n    int func(vector<vector<int>>& piles, int no_of_transactions , int index , int pileposition , \\n         vector<vector<int>>& has  ) {\\n        if(index >= piles.size() or no_of_transactions <= 0 ) \\n            return 0;\\n        \\n        // if(pileposition >= piles[index].size()) {\\n        //     return 0;\\n        // }\\n        int i = index;\\n        int j = pileposition;\\n        int k = no_of_transactions;\\n        \\n        if(dp[has[i][j]][k] != -1)\\n        return dp[has[i][j]][k];    \\n    \\n        \\n        int take = 0;\\n        int dont_take = 0;\\n        // two choices , i decide to take the index\\n        if(pileposition < piles[index].size()) {\\n            take = +piles[index][pileposition] + func(piles , no_of_transactions - 1 , index , pileposition + 1 , has);\\n        }\\n        \\n        // I stop taking values from pile number index and start taking from the next pile , hence the pile no index will never be \\n        // considered in the future if i make this move\\n        // pile position will now become 0 , because am again going to take coins from the top of the new pile \\n        // we increment the index of the pile to index + 1\\n        dont_take = func(piles , no_of_transactions  , index + 1 , 0 , has);\\n        \\n        // if(pileposition >= piles[index].size()) {\\n        //     // i did this just to make the 3rd dp state call pass , \\n        //     // since we dont have entry for pileposition >= piles[index].size\\n        //     // in the has table so we have to query this way \\n        //     // but am proud of the state table that i came up with myself \\n        //     return dont_take;\\n        // }\\n        return dp[has[i][j]][k] = max(take , dont_take);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    \\n   \\n    \\n    int dp[3003][2001];\\n\\t\\n\\t /*\\n    state which i can think of is that \\n    given (index_of_pile , index_in_pile , no_of_transactions_left) \\n    what is the maximum money i can generate \\n    index_in_pile---> the index of the coin to be pick from pile(index_of_pile)\\n    */\\n     \\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp , -1 , sizeof(dp));\\n        vector<vector<int>> has;\\n        int cnt = -1;\\n        \\n        for(int i = 0 ; i < piles.size() ; i ++ ) {\\n            vector<int> row;\\n            for(int j = 0 ; j < piles[i].size() ; j ++) {\\n                row.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2223585,
                "title": "c-top-down-dp-solution-with-explaination",
                "content": "**Intuition**\\nTop down dynamic programming.\\n\\n\\n**Explanation**\\ndp[i,k] means picking k elements from pile[i] to pile[n-1].\\nWe can pick 0,1,2,3... elements from the current pile[i] one by one.\\nIt asks for the maximum total value of coins we can have,\\nso we need to return max of all the options.\\n\\n\\n**Complexity**\\nTime `O(nm)`\\nSpace `O(nk)`\\nwhere `m = sum(piles[i].length) <= 2000`\\n\\n***C++ CODE :***\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int n=piles.size();\\n        vector<vector<int>> memo(n+1, vector<int>(k+1,0));\\n        \\n        function <int (int,int)> dp = [&](int i,int k){\\n            if(i==n || k==0)\\n                return 0;\\n            if(memo[i][k]) \\n                return memo[i][k];\\n            \\n            int res=dp(i+1,k), curr=0;\\n            \\n            for(int j=0;j<piles[i].size() and j<k ;++j){\\n                curr += piles[i][j];\\n                res=max(res,dp(i+1,k-j-1)+curr);\\n            }\\n            return memo[i][k]=res;\\n        };\\n        return dp(0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int n=piles.size();\\n        vector<vector<int>> memo(n+1, vector<int>(k+1,0));\\n        \\n        function <int (int,int)> dp = [&](int i,int k){\\n            if(i==n || k==0)\\n                return 0;\\n            if(memo[i][k]) \\n                return memo[i][k];\\n            \\n            int res=dp(i+1,k), curr=0;\\n            \\n            for(int j=0;j<piles[i].size() and j<k ;++j){\\n                curr += piles[i][j];\\n                res=max(res,dp(i+1,k-j-1)+curr);\\n            }\\n            return memo[i][k]=res;\\n        };\\n        return dp(0,k);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1901776,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n\\nRecursively include each `j`<sup>th</sup> value of each `i`<sup>th</sup> row of the input matrix `A` onto a running total `t` to consider each candidate `cand` in order to find the `best` candidate for each `i`<sup>th</sup> row.  Then we have 2 choices for each each `i`<sup>th</sup> row\\'s `best` candidate:\\n\\n1. \\u2705 include\\n2. \\uD83D\\uDEAB exclude\\n\\nOptimally choose the maximum at each `i`<sup>th</sup> sub-problem to formulate the overall optimal solution as the recursive stack unwinds.\\n\\n**Note:** the problem statement\\'s image is misleading, ie. \"buckets\" are drawn as columns, however, the \"buckets\" are actually stored in the input matrix `A` as rows.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var (t, best) = Pair(0, 0)\\n            for (j in 0 until Math.min(A[i].size, k)) {\\n                t += A[i][j]\\n                var cand = t + go(i + 1, k - 1 - j)\\n                best = Math.max(best, cand)\\n            }\\n            return Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var key = \"$i,$k\"\\n            if (!m.contains(key)) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + go(i + 1, k - 1 - j)\\n                    best = Math.max(best, cand)\\n                }\\n                m[key] = Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var dp = Array(M + 1) { IntArray(K + 1 ) { 0 } }\\n        for (i in M - 1 downTo 0) {\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + dp[i + 1][k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                dp[i][k] = Math.max(best, dp[i + 1][k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K]\\n    }\\n}\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var pre = IntArray(K + 1) { 0 }\\n        for (i in M - 1 downTo 0) {\\n            var cur = IntArray(K + 1) { 0 }\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + pre[k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                cur[k] = Math.max(best, pre[k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur\\n        }\\n        return pre[K]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let [t, best] = [0, 0];\\n        for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n            t += A[i][j];\\n            let cand = t + go(i + 1, k - 1 - j);\\n            best = Math.max(best, cand);\\n        }\\n        return Math.max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet maxValueOfCoins = (A, K, m = new Map()) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let key = `${i},${k}`;\\n        if (!m.has(key)) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + go(i + 1, k - 1 - j);\\n                best = Math.max(best, cand);\\n            }\\n            m.set(key, Math.max(best, go(i + 1, k))); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let dp = [...Array(M + 1)].map(_ => Array(K + 1).fill(0));\\n    for (let i = M - 1; 0 <= i; --i) {\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + dp[i + 1][k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            dp[i][k] = Math.max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n    }\\n    return dp[0][K];\\n};\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let pre = Array(K + 1).fill(0);\\n    for (let i = M - 1; 0 <= i; --i) {\\n        let cur = Array(K + 1).fill(0);\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + pre[k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            cur[k] = Math.max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        pre = cur;\\n    }\\n    return pre[K];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        @cache\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        dp = [[0] * (K + 1) for _ in range(M + 1)]\\n        for i in range(M - 1, -1, -1):\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + dp[i + 1][k - 1 - j]\\n                    best = max(best, cand)\\n                dp[i][k] = max(best, dp[i + 1][k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return dp[0][K]\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        pre = [0] * (K + 1)\\n        for i in range(M - 1, -1, -1):\\n            cur = [0] * (K + 1)\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + pre[k - 1 - j]\\n                    best = max(best, cand)\\n                cur[k] = max(best, pre[k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            pre = cur\\n        return pre[K]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut dp = vec![vec![0; K + 1]; M + 1];\\n        for i in (0..M).rev() {\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n}\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut pre = vec![0; K + 1];\\n        for i in (0..M).rev() {\\n            let mut cur = vec![0; K + 1];\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto [t, best] = make_pair(0, 0);\\n            for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                t += A[i][j];\\n                auto cand = t + go(i + 1, k - 1 - j);\\n                best = max(best, cand);\\n            }\\n            return max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxValueOfCoins(VVI& A, int K, Map m = {}) {\\n        int M = A.size();\\n        auto hash = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto key = hash(i, k);\\n            if (m.find(key) == m.end()) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + go(i + 1, k - 1 - j);\\n                    best = max(best, cand);\\n                }\\n                m[key] = max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VVI dp(M + 1, VI(K + 1));\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n};\\n```\\n\\n4. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VI pre(K + 1);\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            VI cur(K + 1);\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var (t, best) = Pair(0, 0)\\n            for (j in 0 until Math.min(A[i].size, k)) {\\n                t += A[i][j]\\n                var cand = t + go(i + 1, k - 1 - j)\\n                best = Math.max(best, cand)\\n            }\\n            return Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, k: Int = K): Int {\\n            if (i == M || k == 0)\\n                return 0\\n            var key = \"$i,$k\"\\n            if (!m.contains(key)) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + go(i + 1, k - 1 - j)\\n                    best = Math.max(best, cand)\\n                }\\n                m[key] = Math.max(best, go(i + 1, k)) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var dp = Array(M + 1) { IntArray(K + 1 ) { 0 } }\\n        for (i in M - 1 downTo 0) {\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + dp[i + 1][k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                dp[i][k] = Math.max(best, dp[i + 1][k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maxValueOfCoins(A: List<List<Int>>, K: Int): Int {\\n        var M = A.size\\n        var pre = IntArray(K + 1) { 0 }\\n        for (i in M - 1 downTo 0) {\\n            var cur = IntArray(K + 1) { 0 }\\n            for (k in 1..K) {\\n                var (t, best) = Pair(0, 0)\\n                for (j in 0 until Math.min(A[i].size, k)) {\\n                    t += A[i][j]\\n                    var cand = t + pre[k - 1 - j]\\n                    best = Math.max(best, cand)\\n                }\\n                cur[k] = Math.max(best, pre[k]) // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur\\n        }\\n        return pre[K]\\n    }\\n}\\n```\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let [t, best] = [0, 0];\\n        for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n            t += A[i][j];\\n            let cand = t + go(i + 1, k - 1 - j);\\n            best = Math.max(best, cand);\\n        }\\n        return Math.max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxValueOfCoins = (A, K, m = new Map()) => {\\n    let M = A.length;\\n    let go = (i = 0, k = K) => {\\n        if (i == M || !k)\\n            return 0;\\n        let key = `${i},${k}`;\\n        if (!m.has(key)) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + go(i + 1, k - 1 - j);\\n                best = Math.max(best, cand);\\n            }\\n            m.set(key, Math.max(best, go(i + 1, k))); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let dp = [...Array(M + 1)].map(_ => Array(K + 1).fill(0));\\n    for (let i = M - 1; 0 <= i; --i) {\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + dp[i + 1][k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            dp[i][k] = Math.max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n    }\\n    return dp[0][K];\\n};\\n```\n```\\nlet maxValueOfCoins = (A, K) => {\\n    let M = A.length;\\n    let pre = Array(K + 1).fill(0);\\n    for (let i = M - 1; 0 <= i; --i) {\\n        let cur = Array(K + 1).fill(0);\\n        for (let k = 1; k <= K; ++k) {\\n            let [t, best] = [0, 0];\\n            for (let j = 0; j < Math.min(A[i].length, k); ++j) {\\n                t += A[i][j];\\n                let cand = t + pre[k - 1 - j];\\n                best = Math.max(best, cand);\\n            }\\n            cur[k] = Math.max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        }\\n        pre = cur;\\n    }\\n    return pre[K];\\n};\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        @cache\\n        def go(i = 0, k = K):\\n            if i == M or not k:\\n                return 0\\n            t, best = 0, 0\\n            for j in range(0, min(len(A[i]), k)):\\n                t += A[i][j]\\n                cand = t + go(i + 1, k - 1 - j)\\n                best = max(best, cand)\\n            return max(best, go(i + 1, k)) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return go()\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        dp = [[0] * (K + 1) for _ in range(M + 1)]\\n        for i in range(M - 1, -1, -1):\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + dp[i + 1][k - 1 - j]\\n                    best = max(best, cand)\\n                dp[i][k] = max(best, dp[i + 1][k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        return dp[0][K]\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, A: List[List[int]], K: int) -> int:\\n        M = len(A)\\n        pre = [0] * (K + 1)\\n        for i in range(M - 1, -1, -1):\\n            cur = [0] * (K + 1)\\n            for k in range(K, -1, -1):\\n                t, best = 0, 0\\n                for j in range(0, min(len(A[i]), k)):\\n                    t += A[i][j]\\n                    cand = t + pre[k - 1 - j]\\n                    best = max(best, cand)\\n                cur[k] = max(best, pre[k]) # \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            pre = cur\\n        return pre[K]\\n```\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\n```\\n// TODO: how to write recursive closure in Rust which captures the parent\\'s scope?\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut dp = vec![vec![0; K + 1]; M + 1];\\n        for i in (0..M).rev() {\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n}\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn max_value_of_coins(A: VVI, K_: i32) -> i32 {\\n        let M = A.len();\\n        let K = K_ as usize;\\n        let mut pre = vec![0; K + 1];\\n        for i in (0..M).rev() {\\n            let mut cur = vec![0; K + 1];\\n            for k in 1..=K {\\n                let (mut t, mut best) = (0, 0);\\n                for j in 0..min(A[i].len(), k) {\\n                    t += A[i][j];\\n                    let cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto [t, best] = make_pair(0, 0);\\n            for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                t += A[i][j];\\n                auto cand = t + go(i + 1, k - 1 - j);\\n                best = max(best, cand);\\n            }\\n            return max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maxValueOfCoins(VVI& A, int K, Map m = {}) {\\n        int M = A.size();\\n        auto hash = [](auto i, auto k) {\\n            stringstream ss; ss << i << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto k) {\\n            if (i == M || !k)\\n                return 0;\\n            auto key = hash(i, k);\\n            if (m.find(key) == m.end()) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + go(i + 1, k - 1 - j);\\n                    best = max(best, cand);\\n                }\\n                m[key] = max(best, go(i + 1, k)); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            return m[key];\\n        };\\n        return go(0, K);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VVI dp(M + 1, VI(K + 1));\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + dp[i + 1][k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                dp[i][k] = max(best, dp[i + 1][k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n        }\\n        return dp[0][K];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxValueOfCoins(VVI& A, int K) {\\n        int M = A.size();\\n        VI pre(K + 1);\\n        for (auto i{ M - 1 }; 0 <= i; --i) {\\n            VI cur(K + 1);\\n            for (auto k{ 1 }; k <= K; ++k) {\\n                auto [t, best] = make_pair(0, 0);\\n                for (auto j{ 0 }; j < min((int)A[i].size(), k); ++j) {\\n                    t += A[i][j];\\n                    auto cand = t + pre[k - 1 - j];\\n                    best = max(best, cand);\\n                }\\n                cur[k] = max(best, pre[k]); // \\u2705 include or \\uD83D\\uDEAB exclude i-th row\\'s best candidate\\n            }\\n            pre = cur;\\n        }\\n        return pre[K];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888531,
                "title": "c-2d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    \\n    int helper(int idx,vector<vector<int>>& preffix,int k){\\n        \\n        if(idx >= preffix.size() || k<=0){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n        \\n        int max_score = INT_MIN;\\n        \\n        \\n        for(int i=0;i<=k && i<=preffix[idx].size();i++){\\n             int sum = 0;\\n            \\n             if(i>0){\\n                sum += preffix[idx][i-1];      \\n             }\\n           \\n             int score = helper(idx+1,preffix,k-i) + sum;\\n             max_score = max(max_score,score);   \\n        }\\n       \\n        return dp[idx][k] = max_score;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k){\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<int>> preffix;\\n        \\n        for(int i=0;i<piles.size();i++){\\n            vector<int> v(piles[i].size());\\n            v[0] = piles[i][0];\\n            \\n            \\n            for(int j=1;j<piles[i].size();j++){\\n                v[j] = piles[i][j] + v[j-1];\\n            }\\n            \\n            preffix.push_back(v);\\n        }\\n       \\n        return helper(0,preffix,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[2001][2001];\\n    \\n    int helper(int idx,vector<vector<int>>& preffix,int k){\\n        \\n        if(idx >= preffix.size() || k<=0){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n        \\n        int max_score = INT_MIN;\\n        \\n        \\n        for(int i=0;i<=k && i<=preffix[idx].size();i++){\\n             int sum = 0;\\n            \\n             if(i>0){\\n                sum += preffix[idx][i-1];      \\n             }\\n           \\n             int score = helper(idx+1,preffix,k-i) + sum;\\n             max_score = max(max_score,score);   \\n        }\\n       \\n        return dp[idx][k] = max_score;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k){\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<int>> preffix;\\n        \\n        for(int i=0;i<piles.size();i++){\\n            vector<int> v(piles[i].size());\\n            v[0] = piles[i][0];\\n            \\n            \\n            for(int j=1;j<piles[i].size();j++){\\n                v[j] = piles[i][j] + v[j-1];\\n            }\\n            \\n            preffix.push_back(v);\\n        }\\n       \\n        return helper(0,preffix,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888110,
                "title": "c-simple-bottom-up-dp",
                "content": "Solution:\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        // dp[i][j] = maximum money after taking j coins from first i piles.\\n        vector<vector<int> > dp(n+1, vector<int>(k+1, -2000000000));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<=k; j++){\\n                \\n                // do not take any coin from this pile.\\n                dp[i+1][j]=max(dp[i+1][j], dp[i][j]);\\n                \\n                int sum=0, cnt=0;\\n                for(int p: piles[i]){\\n                    sum+=p;\\n                    cnt++;\\n                    if(j+cnt<=k)\\n                        // take first cnt coins from this pile.\\n                        dp[i+1][j+cnt]=max(dp[i+1][j+cnt], dp[i][j]+sum);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\\n\\nTime complexity: O(k * sum(piles[i].length))\\nProof: In iterative solutions it is much easier to deduce the time complexity.\\n```\\nfor each pile:\\n\\tfor each k:\\n\\t\\tfor each prefix of pile:\\n```\\nis equivalent to\\n```\\nfor each pile:\\n\\tfor each prefix of pile:\\n\\t\\tfor each k:\\n```\\n\\nO(piles[0].length * k + piles[1].length * k + ...... + piles[n-1].length * k) = O(k * sum(piles[i].length))",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        // dp[i][j] = maximum money after taking j coins from first i piles.\\n        vector<vector<int> > dp(n+1, vector<int>(k+1, -2000000000));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<=k; j++){\\n                \\n                // do not take any coin from this pile.\\n                dp[i+1][j]=max(dp[i+1][j], dp[i][j]);\\n                \\n                int sum=0, cnt=0;\\n                for(int p: piles[i]){\\n                    sum+=p;\\n                    cnt++;\\n                    if(j+cnt<=k)\\n                        // take first cnt coins from this pile.\\n                        dp[i+1][j+cnt]=max(dp[i+1][j+cnt], dp[i][j]+sum);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```\n```\\nfor each pile:\\n\\tfor each k:\\n\\t\\tfor each prefix of pile:\\n```\n```\\nfor each pile:\\n\\tfor each prefix of pile:\\n\\t\\tfor each k:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887572,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n\\t\\t//dp[i][j] - > maximum total value of coins using i piles and j coins.\\n        vector<vector<int>> dp(n+1,vector<int>(k+1));\\n\\t\\t// store the prefix sum for each pile.\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<(int)piles[i].size();j++)\\n                piles[i][j]+=piles[i][j-1];\\n            \\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=k;j++) // calculate max total value to pick  j coins using i piles.\\n                for(int w=0;w<=(int)piles[i-1].size() and w<=j;w++) // check for all combinations of coins that sum upto j coins. we can pick w coins from this pile and j-w coins from previous piles(dp[i-1][j-w]) i.e=> (j-w)+w=j coins in total.\\n                    dp[i][j]=max(dp[i][j],dp[i-1][j-w]+((w-1>=0)?piles[i-1][w-1]:0));\\n        \\n        return dp[n][k];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n\\t\\t//dp[i][j] - > maximum total value of coins using i piles and j coins.\\n        vector<vector<int>> dp(n+1,vector<int>(k+1));\\n\\t\\t// store the prefix sum for each pile.\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<(int)piles[i].size();j++)\\n                piles[i][j]+=piles[i][j-1];\\n            \\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=k;j++) // calculate max total value to pick  j coins using i piles.\\n                for(int w=0;w<=(int)piles[i-1].size() and w<=j;w++) // check for all combinations of coins that sum upto j coins. we can pick w coins from this pile and j-w coins from previous piles(dp[i-1][j-w]) i.e=> (j-w)+w=j coins in total.\\n                    dp[i][j]=max(dp[i][j],dp[i-1][j-w]+((w-1>=0)?piles[i-1][w-1]:0));\\n        \\n        return dp[n][k];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1887499,
                "title": "ignore-the-sc-and-understand-the-logic",
                "content": "There are only 2 ways\\n1. Take :\\n\\tif you choose the top element there are again two possibilities \\n\\t1. take current element and move to next list or \\n\\t2. take curr element and stand on the same list and call recursion for the next element in the same list.\\n2. Not Take :\\n\\tjust simply move to next list.\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int max=0;\\n        for(List<Integer> curr: piles){\\n            max=Math.max(max,curr.size());\\n        }\\n        Integer dp[][][]=new Integer[piles.size()][max][k+1];\\n        return f(piles,piles.size()-1,0,k,dp);\\n    }\\n    \\n    public int f(List<List<Integer>> piles, int n, int i, int k,Integer dp[][][]){\\n        if(n==-1 || i>=piles.get(n).size() || k<=0){\\n            return 0;\\n        }\\n    \\n        if(dp[n][i][k]!=null) return dp[n][i][k];\\n        int take=0;\\n        if(i<piles.get(n).size()){\\n            \\n            take=piles.get(n).get(i)+ Math.max(f(piles,n,i+1,k-1,dp),f(piles,n-1,0,k-1,dp));\\n        }\\n        int notTake=f(piles,n-1,0,k,dp);\\n        return dp[n][i][k]=Math.max(take,notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int max=0;\\n        for(List<Integer> curr: piles){\\n            max=Math.max(max,curr.size());\\n        }\\n        Integer dp[][][]=new Integer[piles.size()][max][k+1];\\n        return f(piles,piles.size()-1,0,k,dp);\\n    }\\n    \\n    public int f(List<List<Integer>> piles, int n, int i, int k,Integer dp[][][]){\\n        if(n==-1 || i>=piles.get(n).size() || k<=0){\\n            return 0;\\n        }\\n    \\n        if(dp[n][i][k]!=null) return dp[n][i][k];\\n        int take=0;\\n        if(i<piles.get(n).size()){\\n            \\n            take=piles.get(n).get(i)+ Math.max(f(piles,n,i+1,k-1,dp),f(piles,n-1,0,k-1,dp));\\n        }\\n        int notTake=f(piles,n-1,0,k,dp);\\n        return dp[n][i][k]=Math.max(take,notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887376,
                "title": "dp-c",
                "content": "Let\\'s define dp[i][j] = maximum total value with j coins till i-th pile .\\n\\nif we take x coins from i-th pile then we need (j-x) coins till (i-1)-th pile i.e dp[i-1][j-x] . \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                dp[i][j]=dp[i-1][j];\\n                int sum=0;\\n                for(int x=1;x<=j && x<=piles[i-1].size();x++){\\n                    sum += piles[i-1][x-1];\\n                    dp[i][j]=max(dp[i][j], sum + dp[i-1][j-x]);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                dp[i][j]=dp[i-1][j];\\n                int sum=0;\\n                for(int x=1;x<=j && x<=piles[i-1].size();x++){\\n                    sum += piles[i-1][x-1];\\n                    dp[i][j]=max(dp[i][j], sum + dp[i-1][j-x]);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887357,
                "title": "c-2d-dp-memoization-easy",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2D dp + Memoization.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n* Base Case-> if piles completed or k coins taken\\n* skip current pile and call recursion\\n* check for current pile and call recursion for further piles\\n* keep max value\\n* update memoizated 2d vector\\n\\n\\n\\nTIME COMPLEXITY : O(N^N) , N is size of matrix    **Beats 90.02%**\\nSPACE COMPLEXITY : O(N^N),                                **Beats 70.50%**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\n int solve(int i,vector<vector<int>>&p, int k,vector<vector<int>> &dp){\\n        if(i>=p.size() || k<=0) return 0;     //Base Case-> if piles completed or k coins taken\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int fur = solve(i+1,p,k,dp), cur=0;   // skip current pile\\n        \\n        for(int idx=0;idx<p[i].size() && idx<k; idx++){  // check for current pile \\n            cur += p[i][idx];\\n            fur = max(fur, cur+solve(i+1,p,k-idx-1,dp));  // recursive call for further piles\\n        }\\n        return dp[i][k]=fur;                 // update dp\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        vector<vector<int>> dp(p.size(), vector<int>(k+1,-1));\\n        return solve(0,p,k,dp);\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2D dp + Memoization.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\n int solve(int i,vector<vector<int>>&p, int k,vector<vector<int>> &dp){\\n        if(i>=p.size() || k<=0) return 0;     //Base Case-> if piles completed or k coins taken\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int fur = solve(i+1,p,k,dp), cur=0;   // skip current pile\\n        \\n        for(int idx=0;idx<p[i].size() && idx<k; idx++){  // check for current pile \\n            cur += p[i][idx];\\n            fur = max(fur, cur+solve(i+1,p,k-idx-1,dp));  // recursive call for further piles\\n        }\\n        return dp[i][k]=fur;                 // update dp\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        vector<vector<int>> dp(p.size(), vector<int>(k+1,-1));\\n        return solve(0,p,k,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887189,
                "title": "java-solution-memoization",
                "content": "```\\nclass Solution {\\n    \\n    Integer [][]dp;\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        dp = new Integer[piles.size() + 1][k + 1];\\n        return maxPoints(piles, piles.size() - 1, k);\\n    }\\n    \\n        \\n    private int maxPoints(List<List<Integer>>piles, int i, int k){\\n\\n        if(i < 0 || k <= 0) \\n            return 0;\\n\\n        if(dp[i][k] != null) \\n            return dp[i][k];\\n\\n        int notTake = maxPoints(piles, i-1, k);\\n\\n        int take = 0;\\n        \\n        for(int j=0, sum=0; j <  Math.min(piles.get(i).size(), k) ; j++){\\n\\n            sum += piles.get(i).get(j);\\n\\n            take = Math.max(sum + maxPoints(piles, i-1, k-j-1), take);\\n        }\\n\\n        int res = Math.max(take, notTake);\\n\\n        dp[i][k] = res;\\n        return res;\\n    }\\n}\\n```\\n\\n#### BOTTOM UP\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        \\n        int n = piles.size();\\n        int[][] dp = new int[n+1][k+1];\\n\\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= k; j ++) {\\n                \\n                dp[i][j] = dp[i-1][j];\\n                int sum = 0;\\n                \\n                for(int l = 1 ; l <= Math.min(piles.get(i-1).size() , j) ; l++) {\\n\\n                    sum += piles.get(i - 1).get(l - 1);\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j-l]+sum);\\n                    \\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer [][]dp;\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        dp = new Integer[piles.size() + 1][k + 1];\\n        return maxPoints(piles, piles.size() - 1, k);\\n    }\\n    \\n        \\n    private int maxPoints(List<List<Integer>>piles, int i, int k){\\n\\n        if(i < 0 || k <= 0) \\n            return 0;\\n\\n        if(dp[i][k] != null) \\n            return dp[i][k];\\n\\n        int notTake = maxPoints(piles, i-1, k);\\n\\n        int take = 0;\\n        \\n        for(int j=0, sum=0; j <  Math.min(piles.get(i).size(), k) ; j++){\\n\\n            sum += piles.get(i).get(j);\\n\\n            take = Math.max(sum + maxPoints(piles, i-1, k-j-1), take);\\n        }\\n\\n        int res = Math.max(take, notTake);\\n\\n        dp[i][k] = res;\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        \\n        int n = piles.size();\\n        int[][] dp = new int[n+1][k+1];\\n\\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= k; j ++) {\\n                \\n                dp[i][j] = dp[i-1][j];\\n                int sum = 0;\\n                \\n                for(int l = 1 ; l <= Math.min(piles.get(i-1).size() , j) ; l++) {\\n\\n                    sum += piles.get(i - 1).get(l - 1);\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-1][j-l]+sum);\\n                    \\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897107,
                "title": "dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int r, vector<vector<int>> &piles, int k, vector<vector<int>> &dp)\\n{\\n    if (r == piles.size())\\n    {\\n        if(k == 0)\\n        {\\n            return 0;\\n        }\\n        return -1e9;\\n    }\\n    \\n    if(dp[r][k] != -1)\\n    {\\n        return dp[r][k];\\n    }\\n       \\n    int ans = solve(r + 1, piles, k, dp);\\n    int temp = 0;\\n\\n    for (int i = 0; i < min((int)piles[r].size(), k); i++)\\n    {\\n        temp += piles[r][i];\\n        ans = max(ans, temp + solve(r + 1, piles, k - i - 1, dp));\\n    }\\n\\n    return dp[r][k] = ans;\\n}\\n\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return solve(0, piles, k, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int r, vector<vector<int>> &piles, int k, vector<vector<int>> &dp)\\n{\\n    if (r == piles.size())\\n    {\\n        if(k == 0)\\n        {\\n            return 0;\\n        }\\n        return -1e9;\\n    }\\n    \\n    if(dp[r][k] != -1)\\n    {\\n        return dp[r][k];\\n    }\\n       \\n    int ans = solve(r + 1, piles, k, dp);\\n    int temp = 0;\\n\\n    for (int i = 0; i < min((int)piles[r].size(), k); i++)\\n    {\\n        temp += piles[r][i];\\n        ans = max(ans, temp + solve(r + 1, piles, k - i - 1, dp));\\n    }\\n\\n    return dp[r][k] = ans;\\n}\\n\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n    return solve(0, piles, k, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426217,
                "title": "python-divid-and-conquer-without-dp-100",
                "content": "#### Idea\\nCreate a helper function getValues(s, e) that returns a vector vals. \\nvals[i] stores the maximum value that you can get from picking i coins from piles s, s+1, s+2, ..., e.\\nWith the helper fucntion, the final result will be geValues(1, n)[k].\\n\\nThe basic case of getValues is when s equal to t. In this case, there is only one pile. Therefore, for vals[i], we just need to pick the first i coins.\\nFor s < e, we split the piles into two parts ( (s, mid), (mid+1, e)) and get the values of both parts. \\nWith the vals of left and right piles, we can calculate vals[i] by consider taking different j coins from the left part piles and take i-j coins from the right part piles and select the j that can have the maximum value.\\n\\n#### Complexity\\n\\nTime: O(K^2) \\nThis method is better than the DP solution when sum(piles[i].length) is larger than 2000, such as sum(piles[i].length) = 20000.\\nSpace: O(K)\\n\\n#### Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        def getValues(s, e): # return maximum values of getting different numbers from pile s to plie e\\n            if s == e: # only one piles\\n                coin_num = min(len(piles[s]), k)\\n                vals = [0] * (coin_num+1)\\n                for i in range(1, coin_num + 1):\\n                    vals[i] = (vals[i-1] + piles[s][i-1])\\n                return vals\\n            \\n            # more than one piles\\n            mid = (s+e)//2\\n            left_vals = getValues(s, mid)\\n            right_vals = getValues(mid+1, e)\\n            \\n            coin_num_l = len(left_vals) -1\\n            coin_num_r = len(right_vals) -1\\n            coin_num = min(k, coin_num_l+coin_num_r)\\n            vals = [0] * (coin_num+1)\\n            for i in range(1, coin_num+1): # calculate max value of picking i coins (vals[i])\\n                vals[i] = -1\\n                min_l = max(0, (i - coin_num_r)) # minimum coins that need to take from left in order to take i coins  from both sides \\n                max_l = min(i, coin_num_l) + 1 # maxmum coins that need to take from left in order to take i coins  from both sides \\n                for j in range(min_l, max_l): # consider the case of select j coins from the left side\\n                    tmp = left_vals[j] + right_vals[i-j] \\n                    if vals[i] < tmp:\\n                        vals[i] = tmp\\n            return vals\\n        \\n        vals = getValues(0, len(piles)-1)\\n        \\n        return vals[k]\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        def getValues(s, e): # return maximum values of getting different numbers from pile s to plie e\\n            if s == e: # only one piles\\n                coin_num = min(len(piles[s]), k)\\n                vals = [0] * (coin_num+1)\\n                for i in range(1, coin_num + 1):\\n                    vals[i] = (vals[i-1] + piles[s][i-1])\\n                return vals\\n            \\n            # more than one piles\\n            mid = (s+e)//2\\n            left_vals = getValues(s, mid)\\n            right_vals = getValues(mid+1, e)\\n            \\n            coin_num_l = len(left_vals) -1\\n            coin_num_r = len(right_vals) -1\\n            coin_num = min(k, coin_num_l+coin_num_r)\\n            vals = [0] * (coin_num+1)\\n            for i in range(1, coin_num+1): # calculate max value of picking i coins (vals[i])\\n                vals[i] = -1\\n                min_l = max(0, (i - coin_num_r)) # minimum coins that need to take from left in order to take i coins  from both sides \\n                max_l = min(i, coin_num_l) + 1 # maxmum coins that need to take from left in order to take i coins  from both sides \\n                for j in range(min_l, max_l): # consider the case of select j coins from the left side\\n                    tmp = left_vals[j] + right_vals[i-j] \\n                    if vals[i] < tmp:\\n                        vals[i] = tmp\\n            return vals\\n        \\n        vals = getValues(0, len(piles)-1)\\n        \\n        return vals[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421191,
                "title": "dp-solution-easy-to-understand-step-by-step-explanation-c",
                "content": "# Intuition\\n<!--  -->\\nIt\\'s obvious that there is no greedy solution for this problem since there are multiple combinations and also restriction of picking topmost of pile.\\n So, we are probably going to explore all combinations and choose the most optimal one. \\nThis should give a hint for a recursive complete search solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet the **state** of our DP be DP[i][k].\\n\\nHere DP[i][k] is defined as the maximum profit we can get starting from the i-th pile and still having room for k more coins.\\n\\nNow, the **transition** is going to be simple. There are two choices:\\n1. Don\\'t pick any coin from this pile. In that case, DP[i][k] = DP[i+1][k]\\n2. Pick exactly j coins from this pile (given that j <= k).\\nIn this case, DP[i][k] = sum of topmost j coins + DP[i+1][k-j].\\n\\nNow, coming to the **base cases**:\\n1. If we don\\'t have space for any more coins, then profit will be 0.\\n    So, DP[...][0]=0\\n2. If we are at the end of our list of piles, we can no longer generate anymore profit. \\n    So, DP[n][...]=0\\n\\nOur final answer, is going to be present in DP[0][k]. \\nWe can construct a DP table of size (N*K) and use it to store and fill in the DP values. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n* k * |pile[i]| )$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*k)$$\\n# Code\\nHere\\'s the Dynamic Programming Solution:\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=(int)piles.size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1, vector<int>(k+1,0));\\n        // State: dp[i][k]-> Max profit starting from i-th pile and remaining k coins\\n        // Transition: dp[i][k]=max(dp[i+1][k], (pick first j coins) -> dp[i+1][k-j])\\n        // Base Case: dp[n][...]=0, dp[...][0]=0\\n        // Final Answer: dp[0][k]\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int coins=0;coins<=k;coins++){\\n                // Don\\'t take any coin.\\n                dp[i][coins]=dp[i+1][coins];\\n                int cost=0;\\n                // Take j coins (j<=coins)\\n                for(int j=0;j<(int)piles[i].size() && j<coins;j++){\\n                    cost+=piles[i][j];\\n                    dp[i][coins]=max(dp[i][coins], cost + dp[i+1][coins - (j+1)]);\\n                }\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=(int)piles.size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1, vector<int>(k+1,0));\\n        // State: dp[i][k]-> Max profit starting from i-th pile and remaining k coins\\n        // Transition: dp[i][k]=max(dp[i+1][k], (pick first j coins) -> dp[i+1][k-j])\\n        // Base Case: dp[n][...]=0, dp[...][0]=0\\n        // Final Answer: dp[0][k]\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=0;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int coins=0;coins<=k;coins++){\\n                // Don\\'t take any coin.\\n                dp[i][coins]=dp[i+1][coins];\\n                int cost=0;\\n                // Take j coins (j<=coins)\\n                for(int j=0;j<(int)piles[i].size() && j<coins;j++){\\n                    cost+=piles[i][j];\\n                    dp[i][coins]=max(dp[i][coins], cost + dp[i+1][coins - (j+1)]);\\n                }\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421076,
                "title": "easy-c-solution-recursion-to-memoization-using-prefix-sum",
                "content": "# Intuition\\nWe can iterate through piles and decide if we want to take something from the pile or not take it. \\nIf we decide to take coins from a particular pile, then we have the choice of how many coins to take.\\n\\n# Approach\\nLet\\'s try to think of a recursive solution. \\nWe have two choices, to take coins from a particular pile, or to take nothing. Suppose we start from the last pile, then we have two choices:\\n\\n**notTake: f(i-1, k)**  // *just move to the next pile*\\n**take: (sum of x coins) + f(i-1, k-x)**  // *if we decide to take x coins from pile[i], then we need the sum of all coins from 0 to x, and my k is reduced accordingly, this can be done using a for loop*\\n\\nInstead of calculating sum of x coins everytime I decide to take coins from the pile, we can make a prefix sum array so we can access the sum by going the xth index in the ith pile, it piles[i][x];\\n\\n\\n# Code\\n**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles){\\n        // if we reach the end of piles, or k becomes 0 we return 0\\n        if(i<0 || k==0) return 0;\\n\\n        int temp=prefixPiles[i].size();\\n        //we can only take coins from a pile n times.\\n        int n=min(temp, k);\\n\\n        //move to the next index and k remains same\\n        int notTake=f(i-1, k, prefixPiles);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            //take coins from pile\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles));\\n        }\\n        //return max\\n        return max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //calling recursion starting from the last pile\\n        return f(piles.size()-1, k, prefixPiles);\\n    }\\n};\\n```\\n\\n**Memoization:**\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles, vector<vector<int>>& dp){\\n        if(i<0 || k==0) return 0;\\n\\n        //if value is available for a particular index, use it\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int temp=prefixPiles[i].size();\\n        int n=min(temp, k);\\n        int notTake=f(i-1, k, prefixPiles, dp);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles, dp));\\n        }\\n        //store max in dp array\\n        return dp[i][k]=max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //declare dp array\\n        vector<vector<int>> dp(piles.size()+1, vector<int>(k+1,-1));\\n        return f(piles.size()-1, k, prefixPiles, dp);\\n    }\\n};\\n```\\n**Please upvote if you understood the solution.**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles){\\n        // if we reach the end of piles, or k becomes 0 we return 0\\n        if(i<0 || k==0) return 0;\\n\\n        int temp=prefixPiles[i].size();\\n        //we can only take coins from a pile n times.\\n        int n=min(temp, k);\\n\\n        //move to the next index and k remains same\\n        int notTake=f(i-1, k, prefixPiles);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            //take coins from pile\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles));\\n        }\\n        //return max\\n        return max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //calling recursion starting from the last pile\\n        return f(piles.size()-1, k, prefixPiles);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i, int k, vector<vector<int>>& prefixPiles, vector<vector<int>>& dp){\\n        if(i<0 || k==0) return 0;\\n\\n        //if value is available for a particular index, use it\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int temp=prefixPiles[i].size();\\n        int n=min(temp, k);\\n        int notTake=f(i-1, k, prefixPiles, dp);\\n\\n        int take=0;\\n        for(int j=0; j<n; j++){\\n            take=max(take, prefixPiles[i][j]+f(i-1, k-j-1, prefixPiles, dp));\\n        }\\n        //store max in dp array\\n        return dp[i][k]=max(take, notTake);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        //making a prefix sum array to aviod adding coins everytime.\\n        vector<vector<int>> prefixPiles;\\n        for(int i=0; i<piles.size(); i++){\\n            vector<int> temp;\\n            temp.push_back(piles[i][0]);\\n            for(int j=1; j<piles[i].size(); j++){\\n                temp.push_back(temp[j-1]+piles[i][j]);\\n            }\\n            prefixPiles.push_back(temp);\\n        }\\n        //declare dp array\\n        vector<vector<int>> dp(piles.size()+1, vector<int>(k+1,-1));\\n        return f(piles.size()-1, k, prefixPiles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421061,
                "title": "php-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k * s)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $piles\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function maxValueOfCoins($piles, $k)\\n    {\\n        $a = array_fill(0, 2, array_fill(1, $k, 0));\\n        $c = 0;\\n        foreach ($piles as $pile) {\\n            for ($i = 1; $i <= $k; $i++) {\\n                for ($j = 0, $s = 0, $kk = min($i, count($pile)) ; $j < $kk; $j++) {\\n                    $s += $pile[$j];\\n                    $a[$c][$i] = max($a[$c][$i], $a[1 - $c][$i], $s + $a[1 - $c][$i - $j - 1]);\\n                }\\n            }\\n            $c = 1 - $c;\\n        }\\n\\n        return end($a[1 - $c]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[][] $piles\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function maxValueOfCoins($piles, $k)\\n    {\\n        $a = array_fill(0, 2, array_fill(1, $k, 0));\\n        $c = 0;\\n        foreach ($piles as $pile) {\\n            for ($i = 1; $i <= $k; $i++) {\\n                for ($j = 0, $s = 0, $kk = min($i, count($pile)) ; $j < $kk; $j++) {\\n                    $s += $pile[$j];\\n                    $a[$c][$i] = max($a[$c][$i], $a[1 - $c][$i], $s + $a[1 - $c][$i - $j - 1]);\\n                }\\n            }\\n            $c = 1 - $c;\\n        }\\n\\n        return end($a[1 - $c]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420694,
                "title": "c-top-down-dp-linear-space-complexity-bottom-up-dp",
                "content": "# Top Down DP linear space\\n```\\nclass Solution {\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<int> dp(k + 1);\\n        dp[0] = 0;\\n\\n        for(int j = 1; j <= k; j++)\\n            dp[j] = dp[j - 1] + (j - 1 < piles[n - 1].size() ? piles[n - 1][j - 1] : 0);\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            vector<int> _dp(k + 1);\\n            _dp[0] = 0;\\n            for(int j = 1; j <= k; j++)\\n            {\\n                int preSum = 0;\\n                int currMax = dp[j];\\n                for(int x = 1; x <= j && x - 1 < piles[i].size(); x++)\\n                {\\n                    preSum += piles[i][x - 1];\\n                    currMax = max(currMax, preSum + dp[j - x]);\\n                }\\n                _dp[j] = currMax;\\n            }\\n            dp.swap(_dp);\\n        }\\n\\n        return dp[k];\\n    }\\n};\\n\\n```\\n\\n\\n# Bottom Up DP\\n```\\n\\nclass Solution {\\n\\n    int DFS(int index, int k, vector<vector<int>>& piles, vector<vector<int>> &dp)\\n    {\\n        if(index >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[index][k] != -1)\\n            return dp[index][k];\\n\\n        int ret = 0;\\n        int preSum = 0;\\n        \\n        // completely ignore the current pile\\n        ret = DFS(index + 1, k, piles, dp);\\n\\n        // try to add more and more coins from current pile and then move on\\n        for(int i = 0; i < piles[index].size() && k - i - 1 >= 0; i++)\\n        {\\n            preSum += piles[index][i];\\n            ret = max(ret, preSum + DFS(index + 1, k - i - 1, piles, dp));\\n        }\\n\\n        return dp[index][k] = ret;\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(k + 1, -1));\\n        return DFS(0, k, piles, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        vector<int> dp(k + 1);\\n        dp[0] = 0;\\n\\n        for(int j = 1; j <= k; j++)\\n            dp[j] = dp[j - 1] + (j - 1 < piles[n - 1].size() ? piles[n - 1][j - 1] : 0);\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            vector<int> _dp(k + 1);\\n            _dp[0] = 0;\\n            for(int j = 1; j <= k; j++)\\n            {\\n                int preSum = 0;\\n                int currMax = dp[j];\\n                for(int x = 1; x <= j && x - 1 < piles[i].size(); x++)\\n                {\\n                    preSum += piles[i][x - 1];\\n                    currMax = max(currMax, preSum + dp[j - x]);\\n                }\\n                _dp[j] = currMax;\\n            }\\n            dp.swap(_dp);\\n        }\\n\\n        return dp[k];\\n    }\\n};\\n\\n```\n```\\n\\nclass Solution {\\n\\n    int DFS(int index, int k, vector<vector<int>>& piles, vector<vector<int>> &dp)\\n    {\\n        if(index >= piles.size() || k == 0)\\n            return 0;\\n\\n        if(dp[index][k] != -1)\\n            return dp[index][k];\\n\\n        int ret = 0;\\n        int preSum = 0;\\n        \\n        // completely ignore the current pile\\n        ret = DFS(index + 1, k, piles, dp);\\n\\n        // try to add more and more coins from current pile and then move on\\n        for(int i = 0; i < piles[index].size() && k - i - 1 >= 0; i++)\\n        {\\n            preSum += piles[index][i];\\n            ret = max(ret, preSum + DFS(index + 1, k - i - 1, piles, dp));\\n        }\\n\\n        return dp[index][k] = ret;\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        vector<vector<int>> dp(piles.size(), vector<int>(k + 1, -1));\\n        return DFS(0, k, piles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420685,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        presum = [list(accumulate(p, initial=0)) for p in piles]\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        for i, s in enumerate(presum, 1):\\n            for j in range(k + 1):\\n                for idx, v in enumerate(s):\\n                    if j >= idx:\\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - idx] + v)\\n        return dp[-1][-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        presum = [list(accumulate(p, initial=0)) for p in piles]\\n        n = len(piles)\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        for i, s in enumerate(presum, 1):\\n            for j in range(k + 1):\\n                for idx, v in enumerate(s):\\n                    if j >= idx:\\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - idx] + v)\\n        return dp[-1][-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419962,
                "title": "easy-c-dp-memoization-without-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        int sum=0;\\n        for(int ind=0;ind<piles[i].size() and ind+1<=k;ind++)\\n        {\\n            sum+=piles[i][ind];\\n            p=max(p,sum+solve(i+1,k-ind-1,dp,piles));\\n            \\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);  \\n }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        int sum=0;\\n        for(int ind=0;ind<piles[i].size() and ind+1<=k;ind++)\\n        {\\n            sum+=piles[i][ind];\\n            p=max(p,sum+solve(i+1,k-ind-1,dp,piles));\\n            \\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);  \\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419918,
                "title": "easy-c-dp-memoization-tabulation-with-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nMEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        for(int ind=0;ind<piles[i].size();ind++)\\n        {\\n            if(ind+1<=k)\\n            {\\n                p=max(p,piles[i][ind]+solve(i+1,k-ind-1,dp,piles));\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);        \\n    }\\n};\\n```\\nTABULATION\\n```\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,0));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                int np = dp[i+1][j];\\n                int p=0;\\n                for(int ind=0;ind<piles[i].size();ind++)\\n                {\\n                    if(ind+1<=j)\\n                    {\\n                        p=max(p,piles[i][ind]+dp[i+1][j-ind-1]);\\n                    }\\n                    else\\n                    {   \\n                        break;\\n                    }\\n                }\\n                dp[i][j]=max(p,np); \\n            }\\n        }return dp[0][k];\\n\\n        //return solve(0,k,dp,piles);        \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<vector<int>>& dp,vector<vector<int>>& piles)\\n    {\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int np = solve(i+1,k,dp,piles);\\n        int p=0;\\n        for(int ind=0;ind<piles[i].size();ind++)\\n        {\\n            if(ind+1<=k)\\n            {\\n                p=max(p,piles[i][ind]+solve(i+1,k-ind-1,dp,piles));\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=max(p,np);\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return solve(0,k,dp,piles);        \\n    }\\n};\\n```\n```\\n int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n            for(int j=1;j<piles[i].size();j++)\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,0));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                int np = dp[i+1][j];\\n                int p=0;\\n                for(int ind=0;ind<piles[i].size();ind++)\\n                {\\n                    if(ind+1<=j)\\n                    {\\n                        p=max(p,piles[i][ind]+dp[i+1][j-ind-1]);\\n                    }\\n                    else\\n                    {   \\n                        break;\\n                    }\\n                }\\n                dp[i][j]=max(p,np); \\n            }\\n        }return dp[0][k];\\n\\n        //return solve(0,k,dp,piles);        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419910,
                "title": "java-runtime-53-ms-beats-95-6-memory-43-1-mb-beats-82-72",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        for(List<Integer> pile:piles){\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n=piles.size();\\n        int[] dp=new int[k+1];// k steps dynamic programming;\\n        for(List<Integer> pile:piles){\\n            int m=pile.size();\\n            int[] cum=new int[m+1];\\n            for(int i=0;i<m;i++) cum[i+1]=cum[i]+pile.get(i);\\n            int[] curdp=new int[k+1];\\n            for(int i=0;i<=k;i++){\\n                for(int j=0;j<=m&& i+j <=k;j++){\\n                    curdp[i+j]=Math.max(curdp[i+j],dp[i]+cum[j]);\\n                }\\n            }\\n            dp=curdp;\\n        }\\n        return dp[k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419644,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\tpublic static int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n\\t\\tint[] mv = new int[k + 1];\\n\\t\\tint[] pileSum = new int[k + 1];\\n\\t\\tfor (List<Integer> pile : piles) {\\n\\t\\t\\tint n = Math.min(k, pile.size());\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t\\tpileSum[i] = sum += pile.get(i - 1);\\n\\t\\t\\tfor (int i = k; i > 0; i--) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\tfor (int j = Math.min(i, n); j >= 0; j--)\\n\\t\\t\\t\\t\\tmax = Math.max(max, pileSum[j] + mv[i - j]);\\n\\t\\t\\t\\tmv[i] = max;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mv[k];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n\\t\\tint[] mv = new int[k + 1];\\n\\t\\tint[] pileSum = new int[k + 1];\\n\\t\\tfor (List<Integer> pile : piles) {\\n\\t\\t\\tint n = Math.min(k, pile.size());\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t\\tpileSum[i] = sum += pile.get(i - 1);\\n\\t\\t\\tfor (int i = k; i > 0; i--) {\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\tfor (int j = Math.min(i, n); j >= 0; j--)\\n\\t\\t\\t\\t\\tmax = Math.max(max, pileSum[j] + mv[i - j]);\\n\\t\\t\\t\\tmv[i] = max;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mv[k];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419627,
                "title": "choose-or-dont-choose-that-pile-with-how-many-are-you-going-to-choose-from-that-pile-is-the-idea",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int npile , int coins, int n,vector<vector<int>>& p,vector<vector<int>> &c)\\n    {\\n        if(npile>=n || coins <= 0)\\n            return 0;\\n        if(c[npile][coins]!=-1)\\n            return c[npile][coins];\\n        c[npile][coins] = dfs(npile+1,coins,n,p,c);\\n        int cpile = 0;\\n        for(int j=0;j<min(coins,(int)p[npile].size());j++)\\n        {\\n            cpile+=p[npile][j];\\n            c[npile][coins] = max(c[npile][coins],cpile+dfs(npile+1,coins-1-j,n,p,c));\\n        }\\n        return c[npile][coins];\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        \\n        int n = p.size();\\n        vector<vector<int>> cache(n+1,vector<int> (k+1,-1));\\n        return dfs(0,k,n,p,cache);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int npile , int coins, int n,vector<vector<int>>& p,vector<vector<int>> &c)\\n    {\\n        if(npile>=n || coins <= 0)\\n            return 0;\\n        if(c[npile][coins]!=-1)\\n            return c[npile][coins];\\n        c[npile][coins] = dfs(npile+1,coins,n,p,c);\\n        int cpile = 0;\\n        for(int j=0;j<min(coins,(int)p[npile].size());j++)\\n        {\\n            cpile+=p[npile][j];\\n            c[npile][coins] = max(c[npile][coins],cpile+dfs(npile+1,coins-1-j,n,p,c));\\n        }\\n        return c[npile][coins];\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        \\n        int n = p.size();\\n        vector<vector<int>> cache(n+1,vector<int> (k+1,-1));\\n        return dfs(0,k,n,p,cache);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419423,
                "title": "2218-maximum-value-of-k-coins-from-piles-java",
                "content": "```\\nclass Solution {\\n    public int solve (List<List<Integer>> piles,int i,int k,int [][] dp )\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int max=0;\\n            max=Math.max(max,solve(piles,i+1,k,dp));\\n        for(int j=0;j<piles.get(i).size();j++)\\n        {\\n            if(j+1<=k)\\n                max=Math.max(max,piles.get(i).get(j)+solve(piles,i+1,k-j-1,dp));\\n            else\\n                break;\\n        }\\n        return dp[i][k]=max;\\n    }\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n         \\n         for(int j=1;j<piles.get(i).size();j++)\\n            {   \\n                int removed=  piles.get(i).get(j);\\n                removed+=  piles.get(i).get(j-1);\\n                piles.get(i).set(j,removed); \\n            } \\n        }\\n        int n=piles.size();\\n        int [][]dp=new int [n+1][k+1];\\n        for(int x[]:dp)\\n            Arrays.fill(x,-1);\\n        return solve(piles,0,k,dp);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int solve (List<List<Integer>> piles,int i,int k,int [][] dp )\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int max=0;\\n            max=Math.max(max,solve(piles,i+1,k,dp));\\n        for(int j=0;j<piles.get(i).size();j++)\\n        {\\n            if(j+1<=k)\\n                max=Math.max(max,piles.get(i).get(j)+solve(piles,i+1,k-j-1,dp));\\n            else\\n                break;\\n        }\\n        return dp[i][k]=max;\\n    }\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for(int i=0;i<piles.size();i++)\\n        {\\n         \\n         for(int j=1;j<piles.get(i).size();j++)\\n            {   \\n                int removed=  piles.get(i).get(j);\\n                removed+=  piles.get(i).get(j-1);\\n                piles.get(i).set(j,removed); \\n            } \\n        }\\n        int n=piles.size();\\n        int [][]dp=new int [n+1][k+1];\\n        for(int x[]:dp)\\n            Arrays.fill(x,-1);\\n        return solve(piles,0,k,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419414,
                "title": "c-take-and-nottake-dp-memoization-simple-and-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n*k)\\n\\n- Space complexity:\\no(n*k)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, vector<vector<int>>& piles, vector<vector<int>>& dp, int k) {\\n        if(ind >= piles.size()) return 0;\\n\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n\\n        int sum = 0, take = 0;\\n\\n        //not taking from current pile;\\n        int notTake = 0 + solve(ind+1,piles,dp,k);\\n\\n        //taking from current pile if we can take according to given k and move towards next ind\\n        for(int i=0;i<piles[ind].size();i++) {\\n            sum += piles[ind][i];\\n\\n            if(k - (i+1) >= 0) {\\n                take = max(take, sum + solve(ind+1, piles, dp, k-(i+1)));\\n            }\\n        }\\n\\n        return dp[ind][k] = max(take, notTake);\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return solve(0,piles,dp,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, vector<vector<int>>& piles, vector<vector<int>>& dp, int k) {\\n        if(ind >= piles.size()) return 0;\\n\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n\\n        int sum = 0, take = 0;\\n\\n        //not taking from current pile;\\n        int notTake = 0 + solve(ind+1,piles,dp,k);\\n\\n        //taking from current pile if we can take according to given k and move towards next ind\\n        for(int i=0;i<piles[ind].size();i++) {\\n            sum += piles[ind][i];\\n\\n            if(k - (i+1) >= 0) {\\n                take = max(take, sum + solve(ind+1, piles, dp, k-(i+1)));\\n            }\\n        }\\n\\n        return dp[ind][k] = max(take, notTake);\\n    }\\n\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return solve(0,piles,dp,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419195,
                "title": "kotlin-prefix-sum-dp-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nUse top-down dp to find max value of coin.\\n\\nSave every optimal value in dp table and use that value at next iteration.\\n\\nFlow goes like this:\\n\\n![Screenshot 1.png](https://assets.leetcode.com/users/images/abeeeae2-06c1-45ab-98ec-e99d61aaf750_1681554282.2017314.png)\\n\\n![Screenshot 2.png](https://assets.leetcode.com/users/images/4177b469-39d5-4caa-bde3-8a3e783423c1_1681554331.997646.png)\\n\\n![Screenshot 3.png](https://assets.leetcode.com/users/images/26f7b9be-ddfd-4433-9779-047d65f30417_1681554338.7622476.png)\\n\\n![Screenshot 4.png](https://assets.leetcode.com/users/images/f384cb7e-1371-4d88-8edf-c60e73325969_1681554343.7514818.png)\\n\\n![Screenshot 5.png](https://assets.leetcode.com/users/images/476ca714-3bfc-4901-b983-129cbe384803_1681554361.4551725.png)\\n\\n![Screenshot 6.png](https://assets.leetcode.com/users/images/a8dfd35d-1eff-4c1d-bb4d-cc743ec3cbef_1681554384.7290597.png)\\n\\n![Screenshot 7.png](https://assets.leetcode.com/users/images/781dd1af-b1c0-4fdf-bf95-481d894f4e1e_1681554394.5070295.png)\\n\\n![Screenshot 8.png](https://assets.leetcode.com/users/images/f0d1fc8a-21a2-4f23-baff-d3b77a3de1ef_1681554401.5723536.png)\\n\\n![Screenshot 9.png](https://assets.leetcode.com/users/images/5571a620-8666-4c19-98ed-9a06cdc9123e_1681554419.5653806.png)\\n\\n![Screenshot 10.png](https://assets.leetcode.com/users/images/59b913fc-712b-4493-8ff6-c96e3956570f_1681554441.5546458.png)\\n\\n![Screenshot 11.png](https://assets.leetcode.com/users/images/5ae3a06d-6a14-47c9-822d-49ddb10ccbe0_1681554486.8244655.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n       val dp = Array(piles.size + 1) { IntArray(k + 1) }\\n\\n        for (i in piles.lastIndex downTo 0) {\\n            for (kIndex in k downTo 1) {\\n                var currentValue = 0\\n                var maxValue = dp[i + 1][kIndex]\\n\\n                for (j in 0 until minOf(kIndex, piles[i].size)) {\\n                    currentValue += piles[i][j]\\n                    maxValue = maxOf(maxValue, currentValue + dp[i + 1][kIndex - (j + 1)])\\n                }\\n\\n                dp[i][kIndex] = maxValue\\n            }\\n        }\\n\\n        return dp[0][k]\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n       val dp = Array(piles.size + 1) { IntArray(k + 1) }\\n\\n        for (i in piles.lastIndex downTo 0) {\\n            for (kIndex in k downTo 1) {\\n                var currentValue = 0\\n                var maxValue = dp[i + 1][kIndex]\\n\\n                for (j in 0 until minOf(kIndex, piles[i].size)) {\\n                    currentValue += piles[i][j]\\n                    maxValue = maxOf(maxValue, currentValue + dp[i + 1][kIndex - (j + 1)])\\n                }\\n\\n                dp[i][kIndex] = maxValue\\n            }\\n        }\\n\\n        return dp[0][k]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419176,
                "title": "c-dp-recursion",
                "content": "# Intuition\\nUse DP and recursion.\\n\\n# Approach\\nCreate the method\\n```\\nprivate int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n```\\n, where\\n- (int index, int k) key contains the index of a current pile and k - the number of coins\\n- Dictionary<(int index, int k), int> dic is a dictionary with a result for a certain key\\n- IList<IList<int>> piles is an initial piles\\nCall this method recursively.\\n# Complexity\\n- Time complexity:\\n$$O(sum(len(piles[i])))$$\\n\\n- Space complexity:\\n$$O(sum(len(piles[i])))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        var rs = MaxValueOfCoins((0, k), new Dictionary<(int index, int k), int>(), piles);\\n        return rs;\\n    }\\n    private int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n    {\\n        if (piles.Count <= key.index || key.k <= 0) return 0;\\n        if (dic.ContainsKey(key)) return dic[key];\\n        var rs = MaxValueOfCoins((key.index + 1, key.k), dic, piles);\\n        var sum = 0;\\n        for (int i = 0; i < Math.Min(piles[key.index].Count, key.k); i++)\\n        {\\n            sum += piles[key.index][i];\\n            var rs0 = sum + MaxValueOfCoins((key.index + 1, key.k - (i + 1)), dic, piles);\\n            if (rs < rs0) rs = rs0;\\n        }\\n        if (!dic.ContainsKey(key)) dic.Add(key, rs);\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nprivate int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n```\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n        var rs = MaxValueOfCoins((0, k), new Dictionary<(int index, int k), int>(), piles);\\n        return rs;\\n    }\\n    private int MaxValueOfCoins((int index, int k) key, Dictionary<(int index, int k), int> dic, IList<IList<int>> piles)\\n    {\\n        if (piles.Count <= key.index || key.k <= 0) return 0;\\n        if (dic.ContainsKey(key)) return dic[key];\\n        var rs = MaxValueOfCoins((key.index + 1, key.k), dic, piles);\\n        var sum = 0;\\n        for (int i = 0; i < Math.Min(piles[key.index].Count, key.k); i++)\\n        {\\n            sum += piles[key.index][i];\\n            var rs0 = sum + MaxValueOfCoins((key.index + 1, key.k - (i + 1)), dic, piles);\\n            if (rs < rs0) rs = rs0;\\n        }\\n        if (!dic.ContainsKey(key)) dic.Add(key, rs);\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419122,
                "title": "no-brainer-dfs-solution-with-cache",
                "content": "# Intuition\\nIntuition 1: for pile i, I can pick l = 0, 1, ..., min(k, len(pile[i])) coins from pile i;\\nIntuition 2: when I pick l coins on pile i, I then can pick k-l coins from i+1 to N-1 piles.\\n        \\n# Approach\\nSolve a subproblem: Find the maximum total value if we are picking from ith pile upto (N-1)th pile for a total of k coins.\\n\\n# Complexity\\n- Time complexity:\\n$$O(Nmk)$$ - N is the length of piles, m is the number of coins in each pile.\\n\\n- Space complexity:\\n$$O(Nk)$$ - N is the length of piles.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Intuition 1: for pile i, I can pick l = 0, 1, ..., min(k, len(pile[i])) coins from pile i;\\n        Intuition 2: when I pick l coins on pile i, from i+1 to N-1 piles, I then can k-l coins.\\n        Subproblem: Find the maximum total value if we pick from i-th pile and up for a total of k coins.\\n        \"\"\"\\n        @cache\\n        def solve(i: int, k: int) -> int:\\n            # end of piles or no more room for any coin\\n            if i == len(piles) or k == 0:\\n                return 0\\n\\n            # don\\'t pick this pile\\n            res = solve(i+1, k)\\n            cur_total = 0\\n\\n            # If we pick this pile, try all possible number of coins that we can pick, e.g. 1, 2, ..., or\\n            # up to k or the total number of coins in piles[i] whenever which one comes first.\\n            for l in range(min(k, len(piles[i]))):\\n                cur_total += piles[i][l]\\n\\n                # once I pick l+1 coins in i-th pile, then solve the subproblem\\n                # for (i+1)th and onward piles, with k-l-1 room left to fill.\\n                res = max(res, cur_total + solve(i+1, k-l-1))\\n\\n            return res\\n\\n        return solve(0,k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \"\"\"\\n        Intuition 1: for pile i, I can pick l = 0, 1, ..., min(k, len(pile[i])) coins from pile i;\\n        Intuition 2: when I pick l coins on pile i, from i+1 to N-1 piles, I then can k-l coins.\\n        Subproblem: Find the maximum total value if we pick from i-th pile and up for a total of k coins.\\n        \"\"\"\\n        @cache\\n        def solve(i: int, k: int) -> int:\\n            # end of piles or no more room for any coin\\n            if i == len(piles) or k == 0:\\n                return 0\\n\\n            # don\\'t pick this pile\\n            res = solve(i+1, k)\\n            cur_total = 0\\n\\n            # If we pick this pile, try all possible number of coins that we can pick, e.g. 1, 2, ..., or\\n            # up to k or the total number of coins in piles[i] whenever which one comes first.\\n            for l in range(min(k, len(piles[i]))):\\n                cur_total += piles[i][l]\\n\\n                # once I pick l+1 coins in i-th pile, then solve the subproblem\\n                # for (i+1)th and onward piles, with k-l-1 room left to fill.\\n                res = max(res, cur_total + solve(i+1, k-l-1))\\n\\n            return res\\n\\n        return solve(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419084,
                "title": "c-memoization-tabulation",
                "content": "# Memoization Code\\n```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint solve(vector<vector<int>> &piles, int idx, int k)\\n{\\n    if (k == 0)\\n        return 0;\\n    if (idx >= piles.size())\\n        return 0;\\n    if (dp[idx][k] != -1)\\n        return dp[idx][k];\\n\\n    int ans = INT_MIN;\\n    int s = 0;\\n    int res = solve(piles, idx + 1, k);// if not choosing idxth pile\\n    for (int j = 0; j < piles[idx].size() && j<=k-1; j++)\\n    {\\n       s = s + piles[idx][j];\\n       ans = max({ans, s + solve(piles, idx + 1, k - (j + 1)), res});\\n    }\\n    if (ans < 0) return dp[idx][k] = 0;\\n    return dp[idx][k] = ans;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    return solve(piles, 0, k);\\n}\\n};\\n```\\n# Tabulation Code\\n```\\nclass Solution {\\npublic:\\nint solve_tab(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n\\n    // last row and first column initialized with 0\\n    // for idx use r and for k use c\\n    for (int r = n - 1; r >= 0; r--)\\n    {\\n        for (int c = 1; c <= k; c++)\\n        {\\n            int ans = INT_MIN;\\n            int s = 0;\\n            int res = dp[r+1][c];// if not choosing rth pile\\n            for(int j=0; j<piles[r].size() && j<=c-1; j++)\\n            {\\n                s = s+piles[r][j];\\n                ans = max({ ans, s+dp[r+1][c-(j+1)] , res });\\n            }\\n            if(ans<0) dp[r][c] = 0;\\n            else dp[r][c] = ans;\\n        }\\n    }\\n    return dp[0][k];\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    return solve_tab(piles, k);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint solve(vector<vector<int>> &piles, int idx, int k)\\n{\\n    if (k == 0)\\n        return 0;\\n    if (idx >= piles.size())\\n        return 0;\\n    if (dp[idx][k] != -1)\\n        return dp[idx][k];\\n\\n    int ans = INT_MIN;\\n    int s = 0;\\n    int res = solve(piles, idx + 1, k);// if not choosing idxth pile\\n    for (int j = 0; j < piles[idx].size() && j<=k-1; j++)\\n    {\\n       s = s + piles[idx][j];\\n       ans = max({ans, s + solve(piles, idx + 1, k - (j + 1)), res});\\n    }\\n    if (ans < 0) return dp[idx][k] = 0;\\n    return dp[idx][k] = ans;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    memset(dp, -1, sizeof(dp));\\n    return solve(piles, 0, k);\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solve_tab(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n\\n    // last row and first column initialized with 0\\n    // for idx use r and for k use c\\n    for (int r = n - 1; r >= 0; r--)\\n    {\\n        for (int c = 1; c <= k; c++)\\n        {\\n            int ans = INT_MIN;\\n            int s = 0;\\n            int res = dp[r+1][c];// if not choosing rth pile\\n            for(int j=0; j<piles[r].size() && j<=c-1; j++)\\n            {\\n                s = s+piles[r][j];\\n                ans = max({ ans, s+dp[r+1][c-(j+1)] , res });\\n            }\\n            if(ans<0) dp[r][c] = 0;\\n            else dp[r][c] = ans;\\n        }\\n    }\\n    return dp[0][k];\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    return solve_tab(piles, k);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419067,
                "title": "maximum-value-of-k-coins-from-piles-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n               int n = piles.Count;\\n        int[][] dp = new int[n + 1][];\\n        for (int i = 0; i < dp.Length; i++) {\\n            dp[i] = new int[k + 1];\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int coins = 0; coins <= k; coins++) {\\n                int current_sum = 0;\\n                for (int current_coins = 0; current_coins <= Math.Min(piles[i - 1].Count, coins); current_coins++) {\\n                    if (current_coins > 0) {\\n                        current_sum += piles[i - 1][current_coins - 1];\\n                    }\\n                    dp[i][coins] = Math.Max(dp[i][coins], dp[i - 1][coins - current_coins] + current_sum);\\n                }\\n            }\\n        }\\n        return dp[n][k]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxValueOfCoins(IList<IList<int>> piles, int k) {\\n               int n = piles.Count;\\n        int[][] dp = new int[n + 1][];\\n        for (int i = 0; i < dp.Length; i++) {\\n            dp[i] = new int[k + 1];\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            for (int coins = 0; coins <= k; coins++) {\\n                int current_sum = 0;\\n                for (int current_coins = 0; current_coins <= Math.Min(piles[i - 1].Count, coins); current_coins++) {\\n                    if (current_coins > 0) {\\n                        current_sum += piles[i - 1][current_coins - 1];\\n                    }\\n                    dp[i][coins] = Math.Max(dp[i][coins], dp[i - 1][coins - current_coins] + current_sum);\\n                }\\n            }\\n        }\\n        return dp[n][k]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419036,
                "title": "ruby-recursion-memoization",
                "content": "# Intuition\\nTry (1..k) from the first pile and calculate max for the rest with new k = k - tried, and so on\\n\\n# Approach\\nReworked translation to Ruby of [aryan_0077 C++ solution](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solutions/3417959/image-explanation-top-down-dp-easy-concise-c-java-python/) (same idea, technical details taken from his solution)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*k)$$\\n\\n- Space complexity:\\n$$O(n*k)$$\\n\\n# Code\\n```ruby\\n# Reworked translation to Ruby of aryan_0077 C++ solution\\n\\nclass Solver\\n    attr_reader :piles, :k, :dp\\n\\n    def initialize(piles, k)\\n        @piles, @k = piles, k\\n        @dp = Array.new(piles.size + 1) {|i| Array.new(k + 1) }\\n    end\\n\\n    def solve(i = 0, kk = k)\\n        cur = 0 # If cur is included in inject() param below then TLE\\n        @dp[i][kk] ||= (i >= piles.size || !kk.positive?) ? \\n            0 :\\n            [piles[i].size, kk].min.times.inject(solve(i + 1, kk)) {|res, j|\\n                cur += piles[i][j]\\n                [res, cur + solve(i + 1, kk - j - 1)].max\\n            }\\n    end\\nend\\n\\ndef max_value_of_coins(piles, k)\\n    Solver.new(piles, k).solve\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```ruby\\n# Reworked translation to Ruby of aryan_0077 C++ solution\\n\\nclass Solver\\n    attr_reader :piles, :k, :dp\\n\\n    def initialize(piles, k)\\n        @piles, @k = piles, k\\n        @dp = Array.new(piles.size + 1) {|i| Array.new(k + 1) }\\n    end\\n\\n    def solve(i = 0, kk = k)\\n        cur = 0 # If cur is included in inject() param below then TLE\\n        @dp[i][kk] ||= (i >= piles.size || !kk.positive?) ? \\n            0 :\\n            [piles[i].size, kk].min.times.inject(solve(i + 1, kk)) {|res, j|\\n                cur += piles[i][j]\\n                [res, cur + solve(i + 1, kk - j - 1)].max\\n            }\\n    end\\nend\\n\\ndef max_value_of_coins(piles, k)\\n    Solver.new(piles, k).solve\\nend\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418932,
                "title": "prefix-sum-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp) {\\n        if(!k || i == n) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int ans = 0;\\n        for(int j=0; j<min((int)piles[i].size(), k); j++) {\\n            int notpick = dfs(i + 1, k, n, piles, dp), pick = 0;\\n            if(k - j - 1 >= 0) pick = piles[i][j] + dfs(i + 1, k - j - 1, n, piles, dp);\\n            ans = max({ans, pick, notpick});\\n        }\\n        return dp[i][k] = ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        for(auto &p : piles) {\\n            for(int i=1; i<p.size(); i++) p[i] += p[i - 1];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        return dfs(0, k, n, piles, dp);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp) {\\n        if(!k || i == n) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int ans = 0;\\n        for(int j=0; j<min((int)piles[i].size(), k); j++) {\\n            int notpick = dfs(i + 1, k, n, piles, dp), pick = 0;\\n            if(k - j - 1 >= 0) pick = piles[i][j] + dfs(i + 1, k - j - 1, n, piles, dp);\\n            ans = max({ans, pick, notpick});\\n        }\\n        return dp[i][k] = ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        for(auto &p : piles) {\\n            for(int i=1; i<p.size(); i++) p[i] += p[i - 1];\\n        }\\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        return dfs(0, k, n, piles, dp);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418709,
                "title": "very-easy-to-understand-c-recursion-memoization",
                "content": "# APPROACH :\\n\\nSo we have n number of piles where each pile contains m={m1,m2,m3...}\\nno of coins.\\n\\nSo from each pile we can take atmost \\'m\\' no of coins. So from 1st pile we can take \\'0\\' coins upto \\'m1\\' coins from this pile.\\n\\nSimilarly we can apply this logic to all piles.\\n\\nwhen (k-total coins selected)==0 then it is valid to return ;\\n\\nnow we need to max of all the valid solutions.\\n# Recursion\\n```\\nint solve(int i,vector<vector<int>>& piles,int k )\\n    {\\n        if(k==0)\\n        return 0;\\n        if(i>=piles.size())\\n        return 0;\\n         \\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j ));\\n        } \\n        return  maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        return solve(0,piles,k);    \\n    }\\n```\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i,vector<vector<int>>& piles,int k,vector<vector<int>>&dp)\\n    {\\n        \\n\\n        if(k==0)\\n        return 0;\\n\\n        if(i>=piles.size())\\n        return 0;\\n\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n\\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j,dp));\\n        }\\n         \\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,piles,k,dp);\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint solve(int i,vector<vector<int>>& piles,int k )\\n    {\\n        if(k==0)\\n        return 0;\\n        if(i>=piles.size())\\n        return 0;\\n         \\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j ));\\n        } \\n        return  maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        \\n        return solve(0,piles,k);    \\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i,vector<vector<int>>& piles,int k,vector<vector<int>>&dp)\\n    {\\n        \\n\\n        if(k==0)\\n        return 0;\\n\\n        if(i>=piles.size())\\n        return 0;\\n\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n\\n        int maxi=0;\\n        int sum=0;\\n        for(int j=0;j<=k && j<=piles[i].size() ;j++)\\n        {\\n            if(j!=0)\\n            sum+=piles[i][j-1];\\n            maxi=max(maxi,sum+solve(i+1,piles,k-j,dp));\\n        }\\n         \\n        return dp[i][k]=maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,piles,k,dp);\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418651,
                "title": "java-prefix-sum-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            for (int j = 1; j < piles.get(i).size(); j++) {\\n                piles.get(i).set(j, piles.get(i).get(j) + piles.get(i).get(j-1));\\n            }\\n        }\\n\\n    int n = piles.size();\\n    int[][] dp = new int[n+1][k+1];\\n\\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= k; j++) {\\n            dp[i][j] = -1;\\n        }\\n    }\\n\\n    return solve(piles, k, 0, dp);\\n    }\\n\\n    public int solve (List<List<Integer>> p,int k,int i, int[][]dp){\\n         if (i == p.size())\\n            return 0;\\n\\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int max = 0;\\n        max = Math.max(max, solve(p, k, i+1, dp));\\n\\n        for (int j = 0; j < p.get(i).size(); j++) {\\n            if (j+1 <= k) {\\n                max = Math.max(max, p.get(i).get(j) + solve(p, k-j-1, i+1, dp));\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return dp[i][k] = max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            for (int j = 1; j < piles.get(i).size(); j++) {\\n                piles.get(i).set(j, piles.get(i).get(j) + piles.get(i).get(j-1));\\n            }\\n        }\\n\\n    int n = piles.size();\\n    int[][] dp = new int[n+1][k+1];\\n\\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= k; j++) {\\n            dp[i][j] = -1;\\n        }\\n    }\\n\\n    return solve(piles, k, 0, dp);\\n    }\\n\\n    public int solve (List<List<Integer>> p,int k,int i, int[][]dp){\\n         if (i == p.size())\\n            return 0;\\n\\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n\\n        int max = 0;\\n        max = Math.max(max, solve(p, k, i+1, dp));\\n\\n        for (int j = 0; j < p.get(i).size(); j++) {\\n            if (j+1 <= k) {\\n                max = Math.max(max, p.get(i).get(j) + solve(p, k-j-1, i+1, dp));\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return dp[i][k] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418646,
                "title": "from-tle-to-optimes-dp-c-recursion-memoization",
                "content": "# Intuition\\nwe have to take k element from top so we have two options at every element either to take or not. SO we can apply here pick or notPick concept of dp\\n\\nIn basic method if we take 3 varibles i,j,k where i and j is for piles[i][j] then we have to apply 3-D dp which leads to TLE. \\n\\nTo optimise this we can run a loop in j and take only those elements where k>0. it will reduce a lot of operations.\\n\\n# Approach\\nFor TLE CODE:\\n```\\nmap<vector<int>,int>mp;\\n    int f(int i, int j, int k, vector<vector<int>> &piles){\\n        if(i>=piles.size() || j>=piles[i].size() || k<=0) return 0;\\n\\n        if(mp.find({i,j,k})!=mp.end()){\\n            return mp[{i,j,k}];\\n        }\\n\\n        int f1=piles[i][j]+f(i,j+1,k-1,piles);\\n        int f2=piles[i][j]+f(i+1,0,k-1,piles);\\n        int f3=f(i+1,0,k,piles);\\n\\n        return mp[{i,j,k}]=max({f1,f2,f3});\\n    }\\n```\\n\\nOPTIMISE APPROACH:\\n```\\nint f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n^3) & O(n*k)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return f(0,k,piles,dp);\\n    }\\n};\\n```\\nPLEASEEE UPVOTEE IF IT HELPED",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nmap<vector<int>,int>mp;\\n    int f(int i, int j, int k, vector<vector<int>> &piles){\\n        if(i>=piles.size() || j>=piles[i].size() || k<=0) return 0;\\n\\n        if(mp.find({i,j,k})!=mp.end()){\\n            return mp[{i,j,k}];\\n        }\\n\\n        int f1=piles[i][j]+f(i,j+1,k-1,piles);\\n        int f2=piles[i][j]+f(i+1,0,k-1,piles);\\n        int f3=f(i+1,0,k,piles);\\n\\n        return mp[{i,j,k}]=max({f1,f2,f3});\\n    }\\n```\n```\\nint f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int f(int i,int k,vector<vector<int>> &v,vector<vector<int>> &dp){\\n        if(i>=n || k<=0) return 0;\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\n        int notTake=f(i+1,k,v,dp);\\n        int Take=0;\\n        for(int j=0;j<v[i].size();++j){\\n            Take+=v[i][j];\\n            if(k-j-1>=0){\\n                notTake=max(notTake,Take+f(i+1,k-j-1,v,dp));\\n            }\\n        }\\n\\n        return dp[i][k]=notTake;\\n    }\\n\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));\\n        return f(0,k,piles,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418569,
                "title": "easy-solution-recursive-dp-using-memoization-prefix-sum",
                "content": "# Intuition\\nFor each pile i, what will be the total value of coins we can collect if we choose the first j coins? Gives Hint for PrefixSum.\\nThan problem is reduced to Coin Change II Dp pattern.\\n\\n# Approach\\nFirst take PrefixSum of all piles in same pile from top to bottom\\nsuch that pile[i][j] defines first j coins in ith pile.\\n\\nSecond Define State of DP:\\nDP[k][n]=optimal sum of k coins from first n piles\\n\\nThird form a recurrance relation(same way as in coin change II):\\nset mAx = 0\\nif(we include nth pile) then\\n    loop: take max of all by considering first k coins of nth pile \\nthen if take max without including nth pile\\n\\n# Complexity\\n- Time complexity:\\nPrefixSum = O(n*k)\\nDP with Memoization = O(n*k)*O(k) i.e. (No. of Call * work in each Calls) but overall will be only O(n*k) as very rarely in each call it will take O(k).\\n\\ntotal TC = O(n*k) + O(n*k) = O(n*k)\\n\\n- Space complexity:\\nFor memoization matrix: O(n*k);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getMax(vector<vector<int>> &memo,vector<vector<int>> &pil,int k,int n){\\n        if(memo[k][n]==-1){\\n            if(k==0 || n==0) return 0;\\n            for(int i=0;i<pil[n-1].size();i++){\\n                if(i<k){\\n                    memo[k][n]=max(memo[k][n],pil[n-1][i]+getMax(memo,pil,k-(i+1),n-1));\\n                }\\n                else break;\\n            }\\n            memo[k][n]=max(memo[k][n],getMax(memo,pil,k,n-1));  \\n        }\\n        return memo[k][n];\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pil, int k) {\\n        for(int i=0;i<pil.size();i++){\\n            for(int j=1;j<pil[i].size();j++){\\n                pil[i][j]+=pil[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> memo(k+1,vector<int>(pil.size()+1,-1));\\n        return getMax(memo,pil,k,pil.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getMax(vector<vector<int>> &memo,vector<vector<int>> &pil,int k,int n){\\n        if(memo[k][n]==-1){\\n            if(k==0 || n==0) return 0;\\n            for(int i=0;i<pil[n-1].size();i++){\\n                if(i<k){\\n                    memo[k][n]=max(memo[k][n],pil[n-1][i]+getMax(memo,pil,k-(i+1),n-1));\\n                }\\n                else break;\\n            }\\n            memo[k][n]=max(memo[k][n],getMax(memo,pil,k,n-1));  \\n        }\\n        return memo[k][n];\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& pil, int k) {\\n        for(int i=0;i<pil.size();i++){\\n            for(int j=1;j<pil[i].size();j++){\\n                pil[i][j]+=pil[i][j-1];\\n            }\\n        }\\n        vector<vector<int>> memo(k+1,vector<int>(pil.size()+1,-1));\\n        return getMax(memo,pil,k,pil.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418550,
                "title": "c-dp-memoization-recursion-95-fastest-solution-easily-understandable-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the problem, it is very obvious that it is an extension of Knapsack problem. The similarity is that here we can from each pile choose at most min(k, size of the current pile) and at least no coins.\\nWe move through all the piles one by one collecting zero or more coins from each of them. At the end when we pass the last index and reach the nth position, we make sure that we have taken exactly k coins.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple considering that you have solved 0/1 Knapsack problem.\\n1. We maintain an index i for the current pile.\\n2. Value K is maintained for the number of coins that are yet to be used.\\n3. In each pile we traverse j from 0 to pile[i].size() in order to add the current coin to currVal which is initialized zero.\\n4. When j == 0, we do not add anything as we can also choose to leave the complete pile and in all the other cases we add the piles[i][j - 1] to the currVal and then make a call for the next pile (i + 1);\\n5. At the end when we reach the nth index, we check that we have k == 0 and return 0 otherwise we return -1e9;\\n6. From each recursive call we return maxVal which is initialized to be -1e9 and is maximised with every recusrive call.\\n\\n# Recusrive Solution (TLE)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j));\\n            }\\n        }\\n        return maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        return f(piles, n, 0, k);\\n    }\\n};\\n```\\n\\n# Memoization Solution\\n\\n# Complexity\\n**Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k * maximum pile size)$$\\n\\n**Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k) + Auxiliiary Stack Space$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k, \\n    vector<vector<int>>& dp) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        if (dp[i][k] != -1) return dp[i][k];\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k, dp));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j, dp));\\n            }\\n        }\\n        return dp[i][k] = maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, - 1));\\n        return f(piles, n, 0, k, dp);\\n    }\\n};\\n```\\n\\n# Dynamic Programming Solution\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k * maximum pile size)$$\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1e9));\\n        dp[n][0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, dp[i + 1][K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + dp[i + 1][K - j]);\\n                    }\\n                }\\n                dp[i][K] = maxVal;\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n\\n# Space Optimized Dynamic Programming Solution\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * k * maximum pile size)$$\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<int> prev(k + 1, -1e9), curr(k + 1, -1e9);\\n        prev[0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, prev[K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + prev[K - j]);\\n                    }\\n                }\\n                curr[K] = maxVal;\\n            }\\n            prev = curr;\\n        }\\n        return prev[k];\\n    }\\n};\\n```\\n\\n## Kindly like / upvote if you like my solution :-)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j));\\n            }\\n        }\\n        return maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        return f(piles, n, 0, k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& piles, int n, int i, int k, \\n    vector<vector<int>>& dp) {\\n        if (i == n) {\\n            if (!k) return 0;\\n            return -1e9;\\n        }\\n        if (dp[i][k] != -1) return dp[i][k];\\n        int maxVal = -1e9, currVal = 0;\\n        for (int j = 0; j <= piles[i].size(); j++){\\n            if (j == 0) maxVal = max(maxVal, f(piles, n, i + 1, k, dp));\\n            else if (k - j >= 0){\\n                currVal += piles[i][j - 1];\\n                maxVal = max(maxVal, currVal + f(piles, n, i + 1, \\n                k - j, dp));\\n            }\\n        }\\n        return dp[i][k] = maxVal;\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k + 1, - 1));\\n        return f(piles, n, 0, k, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1e9));\\n        dp[n][0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, dp[i + 1][K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + dp[i + 1][K - j]);\\n                    }\\n                }\\n                dp[i][K] = maxVal;\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<int> prev(k + 1, -1e9), curr(k + 1, -1e9);\\n        prev[0] = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int K = 0; K <= k; K++) {\\n                int maxVal = -1e9, currVal = 0;\\n                for (int j = 0; j <= piles[i].size(); j++){\\n                    if (j == 0) \\n                        maxVal = max(maxVal, prev[K]);\\n                    else if (K - j >= 0){\\n                        currVal += piles[i][j - 1];\\n                        maxVal = max(maxVal, currVal + prev[K - j]);\\n                    }\\n                }\\n                curr[K] = maxVal;\\n            }\\n            prev = curr;\\n        }\\n        return prev[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418512,
                "title": "best-solution-c-knapsack-algorithm-applying-prefix-sum-easy-to-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the maximum total value of coins we can have in our wallet if we choose at most k coins from all the piles.\\n\\nWe can choose at most one coin from each pile, and we can choose any number of coins from each pile as long as the total number of coins chosen is at most k.\\n\\nWe can solve this problem using dynamic programming.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array mv of size k+1 , where mv[i] represents the maximum total value of coins we can have in our wallet if we choose at most i coins from all the piles considered so far.\\n2. Initialize an array pileSum of size k+1 , where pileSum[i] represents the sum of coins taken from the current pile for i coins. For each pile in piles , do the following:\\n\\n---\\n\\ni) Calculate the number of coins in the pile to consider, which is the minimum of k and the length of the pile.\\n\\nii) Calculate the sum of coins taken from the pile for each possible number of coins (from 1 to the minimum of the number of coins in the pile and k ), and store it in the pileSum array.\\n\\niii) Iterate over each possible number of coins (from k to 1), and for each number of coins, do the following: Initialize a variable maxVal to 0.\\n\\niv) Iterate over each possible number of coins taken from the current pile (from the minimum of the number of coins in the pile and the current number of coins to 0), and for each number of coins taken, do the following:\\n\\n---\\n\\na) Update maxVal to be the maximum of its current value and the sum of coins taken from the current pile and the maximum total value of coins we can have in our wallet if we choose the remaining coins from the previous piles.\\n\\nb) Update mv[i] to be maxVal . Return mv[k] , which represents the maximum total value of coins we can have in our wallet if we choose at most k coins from all the piles.\\n# Complexity\\n- Time complexity: O(k*s), where s is the total number of coins in all piles.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k), due to the use of the mv and pileSum arrays.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> v(k+1, 0), pileSum(k+1, 0);\\n        for(auto &pile : piles) {\\n            int n = min(k, (int)pile.size());\\n            for(int i = 1; i <= n; i++) pileSum[i] = pileSum[i-1] + pile[i-1];\\n            for(int i = k; i > 0; i--) {\\n                int large = 0;\\n                for(int j = min(i, n); j >= 0; j--) large = max(large, pileSum[j] + v[i-j]);\\n                v[i] = large;\\n            }\\n        }\\n        return v[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<int> v(k+1, 0), pileSum(k+1, 0);\\n        for(auto &pile : piles) {\\n            int n = min(k, (int)pile.size());\\n            for(int i = 1; i <= n; i++) pileSum[i] = pileSum[i-1] + pile[i-1];\\n            for(int i = k; i > 0; i--) {\\n                int large = 0;\\n                for(int j = min(i, n); j >= 0; j--) large = max(large, pileSum[j] + v[i-j]);\\n                v[i] = large;\\n            }\\n        }\\n        return v[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418497,
                "title": "java-solution-with-comments-memoization",
                "content": "# Complexity\\n- Time complexity:\\n`f(x,y) = f(x, y-1) +  f(x-1, y-1)`\\nassume x and y to be equal\\n`T(n) = 2T(n-1) + C`\\n$$O(2^n)$$    where $$n = max(i, k)$$\\n\\n- Space complexity: $$O(logn)$$ height of recursive tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[][] dp;\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int N = piles.size();\\n        \\n        dp = new Integer[N+1][k+1];\\n\\n        return getScore(piles, N-1, k);        \\n    }\\n\\n    /**\\n    * Calculates maximum total value that can be obtained using given no. of choices\\n    *\\n    * @param piles  - List of piles, piles.get(i) represents a single pile\\n    * @param i      - Index of pile under consideration\\n    * @param k      - Maximum no. of elements that can be choosen from all the piles\\n    * @return       - Max. value that can be achieved by making k choices from piles 0 to i\\n    */\\n    int getScore(List<List<Integer>> piles, int i, int k) {\\n        if (i < 0 || k < 0)\\n            return 0;\\n        \\n        if (dp[i][k] != null)\\n            return dp[i][k];\\n\\n        // At max, we can process k elements from current pile\\n        int N = Math.min(k, piles.get(i).size());\\n\\n        // When no item from current pile is choosen and we move to the next pile\\n        int exclude = getScore(piles, i-1, k);\\n\\n        // when 1 or more items from current pile is choosen\\n        int include = 0, sum = 0;\\n        for (int j = 0; j < N; j++) {\\n            // when j+1 elements are included from current pile\\n            // and we move to the next pile\\n            sum += piles.get(i).get(j);\\n            include = Math.max(include, sum + getScore(piles, i-1, k-j-1));\\n        }\\n\\n        // return maximum possible value achieved after exploring all possibilities\\n        return dp[i][k] = Math.max(include, exclude);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] dp;\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int N = piles.size();\\n        \\n        dp = new Integer[N+1][k+1];\\n\\n        return getScore(piles, N-1, k);        \\n    }\\n\\n    /**\\n    * Calculates maximum total value that can be obtained using given no. of choices\\n    *\\n    * @param piles  - List of piles, piles.get(i) represents a single pile\\n    * @param i      - Index of pile under consideration\\n    * @param k      - Maximum no. of elements that can be choosen from all the piles\\n    * @return       - Max. value that can be achieved by making k choices from piles 0 to i\\n    */\\n    int getScore(List<List<Integer>> piles, int i, int k) {\\n        if (i < 0 || k < 0)\\n            return 0;\\n        \\n        if (dp[i][k] != null)\\n            return dp[i][k];\\n\\n        // At max, we can process k elements from current pile\\n        int N = Math.min(k, piles.get(i).size());\\n\\n        // When no item from current pile is choosen and we move to the next pile\\n        int exclude = getScore(piles, i-1, k);\\n\\n        // when 1 or more items from current pile is choosen\\n        int include = 0, sum = 0;\\n        for (int j = 0; j < N; j++) {\\n            // when j+1 elements are included from current pile\\n            // and we move to the next pile\\n            sum += piles.get(i).get(j);\\n            include = Math.max(include, sum + getScore(piles, i-1, k-j-1));\\n        }\\n\\n        // return maximum possible value achieved after exploring all possibilities\\n        return dp[i][k] = Math.max(include, exclude);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418483,
                "title": "java-naive-recursion-brute-force-approach",
                "content": "```\\n// Approach 1: Naive Recursion - Brute Force Approach => LTE\\n\\n// Time complexity: O(2^s), where s is total no of coins.\\n// Space complexity: O(2^s)\\n\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        return dfs(piles, 0, k);\\n    }\\n    \\n    private int dfs(List<List<Integer>> piles, int i, int coins) {\\n       if (i == piles.size())\\n           return 0;\\n        \\n        int res = dfs(piles, i + 1, coins); // skip curr pile\\n        \\n        int currPile = 0; // get 1 to k coins from curr pile\\n        \\n        for (int j = 0; j < Math.min(piles.get(i).size(), coins); j++) {\\n            currPile += piles.get(i).get(j);\\n            res = Math.max(res, currPile + dfs(piles, i + 1, coins - j - 1));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Approach 1: Naive Recursion - Brute Force Approach => LTE\\n\\n// Time complexity: O(2^s), where s is total no of coins.\\n// Space complexity: O(2^s)\\n\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        return dfs(piles, 0, k);\\n    }\\n    \\n    private int dfs(List<List<Integer>> piles, int i, int coins) {\\n       if (i == piles.size())\\n           return 0;\\n        \\n        int res = dfs(piles, i + 1, coins); // skip curr pile\\n        \\n        int currPile = 0; // get 1 to k coins from curr pile\\n        \\n        for (int j = 0; j < Math.min(piles.get(i).size(), coins); j++) {\\n            currPile += piles.get(i).get(j);\\n            res = Math.max(res, currPile + dfs(piles, i + 1, coins - j - 1));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418481,
                "title": "easiest-c-memoaization-dp-solution-beats-80-striver-s-knapsack-approach-well-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple knapsack dp problem implementation, just traverse the piles vector one by one and then use pick/notpick approach and write recursive approches accordingly.\\n\\nGive the code a good read and you will be able to grasp the logic and intuition behind it.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n```\\nThanks to striver for teaching DP so well, couldn\\'t have had solved the problem without his videos !\\n```\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lol(int ind, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp){\\n        //base case\\n        //if we reach the end of pile traversal\\n        //or if we reach the max limit of coins chosen\\n        if(ind==n or k==0) return 0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n\\n        int maxi=INT_MIN;\\n        //dont pick from that pile, move to next\\n        int notpick= lol(ind+1,k,n,piles,dp);\\n        //ctc is variable holding the number of coins \\n        //we have left to choose\\n        int pick=0, ctc=k, sum=0;\\n\\n        for(int i=0;i<piles[ind].size() and ctc>0;i++){\\n            ctc--;\\n            sum+=piles[ind][i];\\n            int r= sum + lol(ind+1,ctc,n,piles,dp);\\n            pick=max(pick,r);\\n        }\\n        return dp[ind][k]= max(pick,notpick);        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n= piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return lol(0,k,n,piles,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nThanks to striver for teaching DP so well, couldn\\'t have had solved the problem without his videos !\\n```\n```\\nclass Solution {\\npublic:\\n    int lol(int ind, int k, int n, vector<vector<int>> &piles, vector<vector<int>> &dp){\\n        //base case\\n        //if we reach the end of pile traversal\\n        //or if we reach the max limit of coins chosen\\n        if(ind==n or k==0) return 0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n\\n        int maxi=INT_MIN;\\n        //dont pick from that pile, move to next\\n        int notpick= lol(ind+1,k,n,piles,dp);\\n        //ctc is variable holding the number of coins \\n        //we have left to choose\\n        int pick=0, ctc=k, sum=0;\\n\\n        for(int i=0;i<piles[ind].size() and ctc>0;i++){\\n            ctc--;\\n            sum+=piles[ind][i];\\n            int r= sum + lol(ind+1,ctc,n,piles,dp);\\n            pick=max(pick,r);\\n        }\\n        return dp[ind][k]= max(pick,notpick);        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n= piles.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return lol(0,k,n,piles,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418394,
                "title": "python-3-top-down-dp",
                "content": "# Intuition\\nFrom the question, you need to exhaust the possibilities of:\\n1.picking certain number of coin from a pile\\n2.loop the remaining piles with k_remain\\n\\nThese are the 2 state variables.\\n\\nFrom eg.2, you know you can\\'t do greedy. Previous choice affect future choice. So DP is the only solution.\\n\\n# Approach\\ntop-down DP\\n\\n# Complexity\\n- Time complexity:\\nO(nk) -> need to do all state variables combination\\n\\n- Space complexity:\\nO(nk) -> cache size\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n\\n        import collections\\n        ind2sumdict = collections.defaultdict(collections.defaultdict) # ind: {coin token: sum}\\n\\n        for i in range(len(piles)):\\n            ind2sumdict[i][0] = 0\\n            end = min(k, len(piles[i]))\\n            total = 0\\n            for j in range(end):\\n                total += piles[i][j]\\n                ind2sumdict[i][j+1] = total\\n        \\n        @lru_cache(None)\\n        def dp(i, k_remain):\\n            if k_remain == 0 or i == len(piles): # can\\'t take / exceed piles len\\n                return 0\\n            end = min(len(ind2sumdict[i]) - 1, k_remain)\\n            ans = 0\\n            for take_coin in range(end+1):\\n                ans = max(ans, ind2sumdict[i][take_coin] + dp(i+1, k_remain - take_coin))\\n            return ans\\n\\n        return dp(0, k)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n\\n        import collections\\n        ind2sumdict = collections.defaultdict(collections.defaultdict) # ind: {coin token: sum}\\n\\n        for i in range(len(piles)):\\n            ind2sumdict[i][0] = 0\\n            end = min(k, len(piles[i]))\\n            total = 0\\n            for j in range(end):\\n                total += piles[i][j]\\n                ind2sumdict[i][j+1] = total\\n        \\n        @lru_cache(None)\\n        def dp(i, k_remain):\\n            if k_remain == 0 or i == len(piles): # can\\'t take / exceed piles len\\n                return 0\\n            end = min(len(ind2sumdict[i]) - 1, k_remain)\\n            ans = 0\\n            for take_coin in range(end+1):\\n                ans = max(ans, ind2sumdict[i][take_coin] + dp(i+1, k_remain - take_coin))\\n            return ans\\n\\n        return dp(0, k)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418104,
                "title": "swift-solution-with-detailed-explanations",
                "content": "# Approach\\n1. create a memo array, which is a 2D array of size (piles.length + 1) x (k + 1)\\n2. fill the memo array with -1\\n3. call a function dp, which returns the maximum value of coins, with the following arguments:\\n    - piles: the 2D array of piles, where each pile is an array of coins\\n    - memo: the memo array\\n    - i: the current index of the piles array\\n    - k: the number of piles that can be picked\\n4. the dp function does the following:\\n    - if k is 0 or i is the length of the piles array, return 0\\n    - if the value of the memo array at index i and k is not -1, return that value\\n    - set res to the result of calling dp with the following arguments:\\n        - piles\\n        - memo\\n        - i + 1\\n        - k\\n    - set cur to 0\\n    - loop through the coins in the current pile\\n        - add the current coin to cur\\n        - set res to the max of res and cur + the result of calling dp with the following arguments:\\n            - piles\\n            - memo\\n            - i + 1\\n            - k - j - 1\\n    - set the value of the memo array at index i and k to res\\n    - return res \\n\\n# Complexity\\n- Time complexity: O(n^2 * k)\\n- Space complexity: O(n * k)\\n\\n# Code\\n```\\nclass Solution {\\n    func maxValueOfCoins(_ piles: [[Int]], _ k: Int) -> Int {\\n        var memo = Array(repeating: Array(repeating: -1, count: k + 1), count: piles.count + 1)\\n        return dp(piles, &memo, 0, k)\\n    }\\n    func dp(_ piles: [[Int]], _ memo: inout [[Int]], _ i: Int, _ k: Int) -> Int {\\n        if k == 0 || i == piles.count { return 0 }\\n        if memo[i][k] != -1 { return memo[i][k] }\\n\\n        var res = dp(piles, &memo, i + 1, k)\\n        var cur = 0\\n\\n        for j in 0..<min(piles[i].count, k) {\\n            cur += piles[i][j]\\n            res = max(res, cur + dp(piles, &memo, i + 1, k - j - 1))\\n        }\\n        memo[i][k] = res\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxValueOfCoins(_ piles: [[Int]], _ k: Int) -> Int {\\n        var memo = Array(repeating: Array(repeating: -1, count: k + 1), count: piles.count + 1)\\n        return dp(piles, &memo, 0, k)\\n    }\\n    func dp(_ piles: [[Int]], _ memo: inout [[Int]], _ i: Int, _ k: Int) -> Int {\\n        if k == 0 || i == piles.count { return 0 }\\n        if memo[i][k] != -1 { return memo[i][k] }\\n\\n        var res = dp(piles, &memo, i + 1, k)\\n        var cur = 0\\n\\n        for j in 0..<min(piles[i].count, k) {\\n            cur += piles[i][j]\\n            res = max(res, cur + dp(piles, &memo, i + 1, k - j - 1))\\n        }\\n        memo[i][k] = res\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418077,
                "title": "c-dp-memo-faster-easy-to-understand",
                "content": "* ***Memo***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[1005][2005];\\n    \\n    int helper(vector<vector<int>>& piles, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n || k == 0)\\n            return 0;\\n        \\n        // if alreday claculated\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int max_sum = 0;\\n        \\n        // inclusion part\\n        \\n        for(int pos = 0; pos < piles[i].size(); pos++)\\n        {\\n            if(k - pos - 1 >= 0)\\n            {\\n                max_sum = max({max_sum, piles[i][pos] + helper(piles, i + 1, n, k - pos - 1), helper(piles, i + 1, n, k)});\\n            }\\n        }\\n        \\n        // exclusion part\\n        \\n         max_sum = max(max_sum, helper(piles, i + 1, n, k));\\n        \\n        // store the result and return it\\n        \\n        return dp[i][k] = max_sum;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        // calculate the prefix sum of each row\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < piles[i].size(); j++)\\n            {\\n                piles[i][j] += piles[i][j - 1];\\n            }\\n        }\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(piles, 0, n, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[1005][2005];\\n    \\n    int helper(vector<vector<int>>& piles, int i, int n, int k)\\n    {\\n        // base case\\n        \\n        if(i == n || k == 0)\\n            return 0;\\n        \\n        // if alreday claculated\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int max_sum = 0;\\n        \\n        // inclusion part\\n        \\n        for(int pos = 0; pos < piles[i].size(); pos++)\\n        {\\n            if(k - pos - 1 >= 0)\\n            {\\n                max_sum = max({max_sum, piles[i][pos] + helper(piles, i + 1, n, k - pos - 1), helper(piles, i + 1, n, k)});\\n            }\\n        }\\n        \\n        // exclusion part\\n        \\n         max_sum = max(max_sum, helper(piles, i + 1, n, k));\\n        \\n        // store the result and return it\\n        \\n        return dp[i][k] = max_sum;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        // calculate the prefix sum of each row\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 1; j < piles[i].size(); j++)\\n            {\\n                piles[i][j] += piles[i][j - 1];\\n            }\\n        }\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return helper(piles, 0, n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417955,
                "title": "kotlin-search",
                "content": "```\\nclass Solution {\\n  fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n    val N = piles.size\\n    val memo = Array(N) { IntArray(k + 1) }\\n    fun dfs(idx: Int, K: Int): Int {\\n      if (K == 0) return 0\\n      if (idx == -1) return Int.MIN_VALUE\\n      if (memo[idx][K] == 0) {\\n        var res = dfs(idx - 1, K)\\n        var sum = 0\\n        for (i in 0 until minOf(K, piles[idx].size)) {\\n          sum += piles[idx][i]\\n          res = maxOf(res, sum + dfs(idx - 1, K - i - 1))\\n        }\\n        memo[idx][K] = res\\n      }\\n      return memo[idx][K]\\n    }\\n    return dfs(N - 1, k)\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {\\n    val N = piles.size\\n    val memo = Array(N) { IntArray(k + 1) }\\n    fun dfs(idx: Int, K: Int): Int {\\n      if (K == 0) return 0\\n      if (idx == -1) return Int.MIN_VALUE\\n      if (memo[idx][K] == 0) {\\n        var res = dfs(idx - 1, K)\\n        var sum = 0\\n        for (i in 0 until minOf(K, piles[idx].size)) {\\n          sum += piles[idx][i]\\n          res = maxOf(res, sum + dfs(idx - 1, K - i - 1))\\n        }\\n        memo[idx][K] = res\\n      }\\n      return memo[idx][K]\\n    }\\n    return dfs(N - 1, k)\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417944,
                "title": "bottom-up-dp-python",
                "content": "\\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        for i in range(1, n + 1):\\n            for coins in range(0, k + 1):\\n                currSum = 0\\n                for currCoins in range(0, min(len(piles[i - 1]), coins) + 1):\\n                    if currCoins > 0:\\n                        currSum += piles[i - 1][currCoins - 1]\\n                    dp[i][coins] = max(dp[i][coins], dp[i - 1][coins - currCoins] + currSum)\\n        return dp[n][k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        for i in range(1, n + 1):\\n            for coins in range(0, k + 1):\\n                currSum = 0\\n                for currCoins in range(0, min(len(piles[i - 1]), coins) + 1):\\n                    if currCoins > 0:\\n                        currSum += piles[i - 1][currCoins - 1]\\n                    dp[i][coins] = max(dp[i][coins], dp[i - 1][coins - currCoins] + currSum)\\n        return dp[n][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417895,
                "title": "maximum-value-of-k-coins-from-piles-java-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach used in my code solution is a recursive approach with memoization (top-down approach). The maxValueOfCoins() method recursively calculates the maximum value of coins that can be obtained by picking exactly k coins from the piles list, starting from the ith pile. The dp array is used for memoization to store the results of previously computed subproblems, so that we can avoid redundant calculations and optimize the time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity of the solution: The time complexity of the solution depends on the number of piles (n) and the maximum value of k. In the worst case, we may need to explore all possible choices of picking coins from each pile. Therefore, the time complexity is O(n * k), where n is the number of piles.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity of the solution: The space complexity of the solution is also dependent on the number of piles (n) and the maximum value of k. We need to store the results of previously computed subproblems in the dp array, which requires O(n * k) space. Additionally, the recursion stack also requires space proportional to the maximum depth of recursion, which can be at most n. Therefore, the overall space complexity is O(n * k + n), which can be simplified to O(n * k).\\n# Code\\n```\\nclass Solution {\\n  public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n    // dp[i][k] := max value of picking k coins from piles[i:]\\n    Integer[][] dp = new Integer[piles.size()][k + 1];\\n    return maxValueOfCoins(piles, 0, k, dp);\\n  }\\n\\n  private int maxValueOfCoins(List<List<Integer>> piles, int i, int k, Integer[][] dp) {\\n    if (i == piles.size() || k == 0)\\n      return 0;\\n    if (dp[i][k] != null)\\n      return dp[i][k];\\n\\n    int ans = maxValueOfCoins(piles, i + 1, k, dp); // Pick 0 coins from current pile\\n    int val = 0;                                // Coins picked from current pile\\n\\n    // Try to pick 1, 2, ..., k coins from current pile\\n    for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n      val += piles.get(i).get(j);\\n      ans = Math.max(ans, val + maxValueOfCoins(piles, i + 1, k - j - 1, dp));\\n    }\\n\\n    return dp[i][k] = ans;\\n  }\\n}\\n\\n```\\nPlease upvote if you find it helpful",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n  public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n    // dp[i][k] := max value of picking k coins from piles[i:]\\n    Integer[][] dp = new Integer[piles.size()][k + 1];\\n    return maxValueOfCoins(piles, 0, k, dp);\\n  }\\n\\n  private int maxValueOfCoins(List<List<Integer>> piles, int i, int k, Integer[][] dp) {\\n    if (i == piles.size() || k == 0)\\n      return 0;\\n    if (dp[i][k] != null)\\n      return dp[i][k];\\n\\n    int ans = maxValueOfCoins(piles, i + 1, k, dp); // Pick 0 coins from current pile\\n    int val = 0;                                // Coins picked from current pile\\n\\n    // Try to pick 1, 2, ..., k coins from current pile\\n    for (int j = 0; j < Math.min(piles.get(i).size(), k); ++j) {\\n      val += piles.get(i).get(j);\\n      ans = Math.max(ans, val + maxValueOfCoins(piles, i + 1, k - j - 1, dp));\\n    }\\n\\n    return dp[i][k] = ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417883,
                "title": "easy-solution-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    Integer[][] cache;\\n    List<List<Integer>> piles;\\n    int m;\\n    \\n    private int res(int pos, int rem) {\\n        if (rem < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        else if (pos == m || rem == 0) {\\n            return 0;\\n        }\\n        else if (cache[pos][rem] != null) {\\n            return cache[pos][rem];\\n        }\\n        else {\\n            List<Integer> pile = piles.get(pos);\\n            int n = pile.size();\\n            int max = res(pos+1, rem);\\n            for (int i = 0; i < n; i++) {\\n                max = Math.max(max, pile.get(i) + res(pos + 1, rem - i - 1));\\n            }\\n            cache[pos][rem] = max;\\n            return max;\\n        }\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.m = piles.size();\\n        this.piles = piles;\\n        this.cache = new Integer[m][k+1];\\n\\t\\t\\n\\t\\t// caculate running sum for each pile.\\n        for (List<Integer> pile: piles) {\\n            int n = pile.size();\\n            for (int i = 1; i < n; i++) {\\n                pile.set(i, pile.get(i) + pile.get(i-1));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// DP\\n        return res(0, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer[][] cache;\\n    List<List<Integer>> piles;\\n    int m;\\n    \\n    private int res(int pos, int rem) {\\n        if (rem < 0) {\\n            return Integer.MIN_VALUE;\\n        }\\n        else if (pos == m || rem == 0) {\\n            return 0;\\n        }\\n        else if (cache[pos][rem] != null) {\\n            return cache[pos][rem];\\n        }\\n        else {\\n            List<Integer> pile = piles.get(pos);\\n            int n = pile.size();\\n            int max = res(pos+1, rem);\\n            for (int i = 0; i < n; i++) {\\n                max = Math.max(max, pile.get(i) + res(pos + 1, rem - i - 1));\\n            }\\n            cache[pos][rem] = max;\\n            return max;\\n        }\\n    }\\n    \\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        this.m = piles.size();\\n        this.piles = piles;\\n        this.cache = new Integer[m][k+1];\\n\\t\\t\\n\\t\\t// caculate running sum for each pile.\\n        for (List<Integer> pile: piles) {\\n            int n = pile.size();\\n            for (int i = 1; i < n; i++) {\\n                pile.set(i, pile.get(i) + pile.get(i-1));\\n            }\\n        }\\n\\t\\t\\n\\t\\t// DP\\n        return res(0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266599,
                "title": "python-solution-dp",
                "content": "# Intuition\\n$dp[i][j]$ is the maximal value after processing the $i$-th pile where the total number of coins is at most $j$. State transition is\\n$dp[i + 1][j] = \\\\max(s_i[q] + dp[i][j - q] : 0 \\\\le q \\\\le \\\\ell_{i + 1})$\\nwhere $\\\\ell_{i + 1} = len(piles[i + 1])$. \\n\\nHere, $s_i[q] := \\\\sum_{j = 0}^{q - 1} piles[i][j] = sum(piles[i][:q])$ be the prefix sum of the $i$-th pile.\\n\\nNote that either $dp[i]$ or $s_i$ can be exhausted in the maximum computation. We can ensure $j - q \\\\ge 0$ by $q \\\\le j$. Hence, $q \\\\le \\\\min(\\\\ell_{i + 1}, j)$. We can use $s_i[\\\\min(q, \\\\ell_{i + 1})]$ to ensure the boundary. It does not affect because the definition of $dp$ requires at most $j$ coins are selected. It is allowed that $i + 1$ contributes less.\\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0] * (k + 1)\\n        for i in range(len(piles)):\\n            # prefix_sum[i] = sum(pile[:i])\\n            s = len(piles[i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            for j in range(k, -1, -1):\\n                temp = 0\\n                for q in range(j + 1):\\n                    temp = max(temp, dp[j - q] + prefix_sum[min(q, s)])\\n                dp[j] = temp\\n        return dp[-1]\\n```\\n\\nThis implementation causes TLE when $k$ is large. The reason is there are many useless computations (giving zero) when $k$ is large. For example, $k = 100$ but the first two piles are of length $1$. Then, the last $99$ slots of $dp$ is not changed at all.\\n\\nTo save more time, we can keep only effectively changeable part of $dp$ in each computation.\\n\\nLet $L_i = len(dp[i]) = \\\\sum_{j = 0}^i \\\\ell_j + 1$.\\n\\n\\nThe index for $dp[i][j - q]$ imposes another condition for $q$. That is $0 \\\\le j - q \\\\le L_i - 1$ which is $j - L_i + 1 \\\\le q \\\\le j$. Then, the intersection of conditions gives\\n$\\\\max(0, j - L_i + 1) \\\\le q \\\\le \\\\min(\\\\ell_{i + 1}, j)$. This is the window of maximum computation.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        prev = [0]\\n        for i in range(len(piles)):\\n            s = len(piles[i])\\n            l = len(prev)\\n            # prefix_sum[i] = sum(pile[:i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            max_size = s + l\\n            dp = [0] * min(k + 1, max_size)\\n            for j in range(len(dp) - 1, -1, -1):\\n                temp = 0\\n                for q in range(max(0, j - l + 1), min(s ,j) + 1):\\n                    temp = max(temp, prev[j - q] + prefix_sum[q])\\n                dp[j] = temp\\n            prev = dp\\n        return dp[k]    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0] * (k + 1)\\n        for i in range(len(piles)):\\n            # prefix_sum[i] = sum(pile[:i])\\n            s = len(piles[i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            for j in range(k, -1, -1):\\n                temp = 0\\n                for q in range(j + 1):\\n                    temp = max(temp, dp[j - q] + prefix_sum[min(q, s)])\\n                dp[j] = temp\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        prev = [0]\\n        for i in range(len(piles)):\\n            s = len(piles[i])\\n            l = len(prev)\\n            # prefix_sum[i] = sum(pile[:i])\\n            prefix_sum = [0] * (s + 1)\\n            for j in range(s):\\n                prefix_sum[j + 1] = prefix_sum[j] + piles[i][j]\\n            max_size = s + l\\n            dp = [0] * min(k + 1, max_size)\\n            for j in range(len(dp) - 1, -1, -1):\\n                temp = 0\\n                for q in range(max(0, j - l + 1), min(s ,j) + 1):\\n                    temp = max(temp, prev[j - q] + prefix_sum[q])\\n                dp[j] = temp\\n            prev = dp\\n        return dp[k]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241714,
                "title": "c-o-2000k-short-1d-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefine state `dp[i][k]` the maximal coin value we can get using the first i piles of coins with total `k` coins taken.\\n\\nWe can see that `dp[i][k]` can be obtained by `dp[i-1][l] + prefixsum[i][k-l]`, where `l <= k`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCan build a 1D dynamic programming table since the state  `dp[i][j]` only depends on `dp[i-1][<=j]`. We can reduce the space by building a DP table `dp[k+1]`, for each new piles we update the table from entry `dp[k]` back to `dp[0]` so that we don\\'t ruin the state `dp[i-1][<j]`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(2000k)$\\nThe worst case is when there is 2000 coins evenly distributed in `n` piles. In that case, the cost to fill out each entry would be `2000/n` and there will be `nk` entries to be filled out. Hence the total time complexity is `O(2000/n*(nk) = 2000k)`, which is tolerable.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(k)$\\n\\n# Code\\n```\\nint dp[2001];\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        // dp of taking first i piles with taking n coins \\n        // dp[i][k] <- dp[i-1][l <= k] + prefsum[i][k-l]\\n        // total coins taken are less than 2000\\n\\n        // to prefix sum\\n        for (auto & v: piles)\\n            for (int i = 1; i < v.size(); ++i)\\n                v[i] += v[i-1];\\n\\n        // 1D dynamic programming\\n        int n = piles.size();\\n        dp[0] = 0;\\n        for (int i = 1; i <= k; ++i)\\n            dp[i] = INT_MIN;\\n        for (int i = 0; i < n; ++i) {\\n            int m = piles[i].size();\\n            for (int j = k; j >= 0; --j) {\\n                for (int l = 1; l <= min(m, j); ++l)\\n                    dp[j] = max(dp[j], dp[j-l] + piles[i][l-1]);\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint dp[2001];\\n\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        // dp of taking first i piles with taking n coins \\n        // dp[i][k] <- dp[i-1][l <= k] + prefsum[i][k-l]\\n        // total coins taken are less than 2000\\n\\n        // to prefix sum\\n        for (auto & v: piles)\\n            for (int i = 1; i < v.size(); ++i)\\n                v[i] += v[i-1];\\n\\n        // 1D dynamic programming\\n        int n = piles.size();\\n        dp[0] = 0;\\n        for (int i = 1; i <= k; ++i)\\n            dp[i] = INT_MIN;\\n        for (int i = 0; i < n; ++i) {\\n            int m = piles[i].size();\\n            for (int j = k; j >= 0; --j) {\\n                for (int l = 1; l <= min(m, j); ++l)\\n                    dp[j] = max(dp[j], dp[j-l] + piles[i][l-1]);\\n            }\\n        }\\n        return dp[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720127,
                "title": "c-top-downn-dp-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int maxValueOfCoins(vector<vector<int>>& A, int K) {\\n        int n = A.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(K + 1, 0));\\n        function<int(int, int)> dp = [&](int i, int k) {\\n            if (memo[i][k] > 0) return memo[i][k];\\n            if (i == n || k == 0) return 0;\\n            int res = dp(i + 1, k), cur = 0;\\n            for (int j = 0; j < A[i].size() && j < k; ++j) {\\n                cur += A[i][j];\\n                res = max(res, dp(i + 1, k - j - 1) + cur);\\n            }\\n            memo[i][k] = res;\\n            return res;\\n        };\\n        return dp(0, K);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533358,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0 for _ in range(k + 1)]\\n        for pile in piles:\\n            for i in range(k, 0, -1):\\n                pileSum = 0\\n                for j in range(min(i, len(pile))):\\n                    pileSum += pile[j]\\n                    dp[i] = max(dp[i], dp[i - j - 1] + pileSum)\\n        return dp[k]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        dp = [0 for _ in range(k + 1)]\\n        for pile in piles:\\n            for i in range(k, 0, -1):\\n                pileSum = 0\\n                for j in range(min(i, len(pile))):\\n                    pileSum += pile[j]\\n                    dp[i] = max(dp[i], dp[i - j - 1] + pileSum)\\n        return dp[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420193,
                "title": "c-easiest-and-cleanest-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> pre;\\n    \\n    int dfs(int i, int k) {\\n        if(i==pre.size()) return k==0 ? 0 : INT_MIN;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=0;\\n        for(int j=0; j<=min(k,(int)pre[i].size()-1); j++)\\n            ans = max(ans,pre[i][j]+dfs(i+1,k-j));\\n        return dp[i][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        dp.resize(n,vector<int>(k+1,-1));\\n        pre.resize(n);\\n        for(int i=0; i<n; i++) {\\n            pre[i].push_back(0);\\n            for(auto &x : piles[i])\\n                pre[i].push_back(pre[i].back()+x);\\n        }\\n        return dfs(0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> pre;\\n    \\n    int dfs(int i, int k) {\\n        if(i==pre.size()) return k==0 ? 0 : INT_MIN;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans=0;\\n        for(int j=0; j<=min(k,(int)pre[i].size()-1); j++)\\n            ans = max(ans,pre[i][j]+dfs(i+1,k-j));\\n        return dp[i][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        dp.resize(n,vector<int>(k+1,-1));\\n        pre.resize(n);\\n        for(int i=0; i<n; i++) {\\n            pre[i].push_back(0);\\n            for(auto &x : piles[i])\\n                pre[i].push_back(pre[i].back()+x);\\n        }\\n        return dfs(0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176850,
                "title": "a-simple-bottom-up-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=k;j++)\\n            {\\n                if(i==0 || j==0) // i = 0 means no items are available and j = 0 means no items are chosen so maximum value = 0 \\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }\\n                int s = 0;\\n                dp[i][j]=dp[i-1][j]; // no items are chosen from i th pile so maximum value is same as chosing j items from (i-1) th pile\\n                for(int k1=1;k1<=min(j,(int)piles[i-1].size());k1++)  // chosing k1 items from i th pile so j - k1 items will be selected from (i-1) th pile \\n                {\\n                    s+=piles[i-1][k1-1];\\n                    dp[i][j] = max(dp[i][j],dp[i-1][j-k1] + s);\\n                }\\n            }\\n        }\\n        return dp[n][k];  // final answer chosing k items from n piles\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        int dp[n+1][k+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=k;j++)\\n            {\\n                if(i==0 || j==0) // i = 0 means no items are available and j = 0 means no items are chosen so maximum value = 0 \\n                {\\n                    dp[i][j]=0;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2174568,
                "title": "c-recursive-bottom-up-memomization",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoinsUtils(vector<vector<int>> &piles, int n, int k, vector<vector<int>> & dp)\\n    {\\n        if(k == 0 || n == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[n-1][k] != -1)\\n        {\\n            return dp[n-1][k];\\n        }\\n        \\n        /*\\n         * Selected a Pile\\n         */\\n        int sum = 0;\\n        int n_selected_pile = 0;\\n        for(int i = 0; i < piles[n-1].size() && i < k; i++)\\n        {\\n            sum += piles[n-1][i];\\n            n_selected_pile = max(n_selected_pile, sum + maxValueOfCoinsUtils(piles, n - 1, k - i - 1, dp));\\n        }\\n        \\n        /*\\n         * Not -selected a Pile\\n         */\\n        int n_not_selected_pile = maxValueOfCoinsUtils(piles, n - 1, k, dp);\\n        \\n        return dp[n-1][k] = max(n_selected_pile, n_not_selected_pile);\\n       \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         vector<vector<int>> dp(piles.size(), vector<int>(k+1, -1));\\n         return maxValueOfCoinsUtils(piles, piles.size(), k, dp);   \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoinsUtils(vector<vector<int>> &piles, int n, int k, vector<vector<int>> & dp)\\n    {\\n        if(k == 0 || n == 0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083576,
                "title": "c-memoization",
                "content": "The maximum value will contain a certain number of elements from some stacks, therefore in this approach we visit each index and iterate through the different number of items we can take from that index, after which we move to the next index\\n\\nSubproblems: S(index,k)=The maxium value that can be obtained if we have to take exactly k coins from piles[index:]\\n\\nRelations: We can either:-\\n1. Not take any coins from pile[index]=ans1=S(index+1,k)\\n2. Take a certain coins, we will choose the number that maximises the value at the end=ans2=max{piles[index][j]+S(index+1,k-j-1) **for all** j **in** [0,min(k,piles[index].size)]}\\nThe final answer: S(index,k)=max{ans1,ans2}\\n\\nBase case: \\n1. S(index,k)=0 if k==0\\n2. S(index,k)=INT_MIN if index>=n and k!=0\\n\\nOriginal problem: S(0,K)\\n\\nTime complexity: O(NK)xO(K)=O(NK^2)\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int solve(vector<vector<int>>&piles,int index,int k){\\n        if(k<=0){\\n            return 0;\\n        } else if(index>=piles.size()){\\n            return INT_MIN;\\n        } else if(mem[index][k]!=-1){\\n            return mem[index][k];\\n        } else {\\n            int ans1=solve(piles,index+1,k);\\n            int value=0,ans2=INT_MIN;\\n            for(int j=0;j<k and j<piles[index].size();j++){\\n                value+=piles[index][j];\\n                int rec=solve(piles,index+1,k-j-1);\\n                ans2=max(ans2,rec+value);\\n            }\\n            return mem[index][k]=max(ans1,ans2);\\n        }\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        mem=vector<vector<int>>(n,vector<int>(k+1,-1));\\n        return solve(piles,0,k);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int solve(vector<vector<int>>&piles,int index,int k){\\n        if(k<=0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2071770,
                "title": "c-easy-to-understand-clean-code-93-faster",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int solve(vector<vector<int>>& v,int index,int k){\\n        if(k==0 || index<0) return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int not_take = solve(v,index-1,k); //skip the current pile!!\\n        int sum = 0;\\n        \\n        int n = v[index].size();\\n        int allowed = min(n,k);\\n        int take = 0;\\n        for(int i=0;i<allowed;i++) //iterations for consuming the current pile!\\n        {\\n            sum+=v[index][i];\\n            take=max(take,sum+solve(v,index-1,k-i-1));\\n        }\\n        int ans = max(take, not_take);\\n        return dp[index][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp.resize(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,piles.size()-1,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int solve(vector<vector<int>>& v,int index,int k){\\n        if(k==0 || index<0) return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int not_take = solve(v,index-1,k); //skip the current pile!!\\n        int sum = 0;\\n        \\n        int n = v[index].size();\\n        int allowed = min(n,k);\\n        int take = 0;\\n        for(int i=0;i<allowed;i++) //iterations for consuming the current pile!\\n        {\\n            sum+=v[index][i];\\n            take=max(take,sum+solve(v,index-1,k-i-1));\\n        }\\n        int ans = max(take, not_take);\\n        return dp[index][k]=ans;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp.resize(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,piles.size()-1,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059670,
                "title": "easy-c-code",
                "content": "```\\nint solve(vector<vector<int>>& v,int index,int k,vector<vector<int>>& dp){\\n        if(k==0 || index==v.size())return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int ans=solve(v,index+1,k,dp);\\n        int sum=0;\\n        \\n        for(int i=0;i<v[index].size() && i<k;i++){\\n            sum=sum+v[index][i];\\n            ans=max(ans,sum+solve(v,index+1,k-i-1,dp));\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> dp(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,0,k,dp);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint solve(vector<vector<int>>& v,int index,int k,vector<vector<int>>& dp){\\n        if(k==0 || index==v.size())return 0;\\n        \\n        if(dp[index][k]!=0)return dp[index][k];\\n        \\n        int ans=solve(v,index+1,k,dp);\\n        int sum=0;\\n        \\n        for(int i=0;i<v[index].size() && i<k;i++){\\n            sum=sum+v[index][i];\\n            ans=max(ans,sum+solve(v,index+1,k-i-1,dp));\\n        }\\n        return dp[index][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> dp(piles.size(),vector<int>(k+1,0));\\n        return solve(piles,0,k,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931769,
                "title": "easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];// dp of 2 states,,since i and k are the only parameters changing .. we created a dp for that \\n    int fun(int i,int k,vector<vector<int>>& piles,int n)\\n    {\\n        if(i>=n || k<0){return 0;}\\n        if(dp[i][k]!=-1){return dp[i][k];}\\n        int ans=fun(i+1,k,piles,n);//first choice ,to skip the current stack\\n        for(int j=0;j<piles[i].size();j++)//either u want top coin or top 2 coins or top 3....and so on\\n        {     if(k-(j+1)<0){break;} //it is not possible to take more than k coins,,\\n            int temp=piles[i][j]+fun(i+1,k-(j+1),piles,n);\\n            if(temp>ans){ans=temp;}\\n        }\\n        return dp[i][k]=ans;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++)\\n            {\\n                piles[i][j]=piles[i][j-1]+piles[i][j];//prefix sum ,,think about it\\n            }\\n        }\\n         memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,k,piles,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2001];// dp of 2 states,,since i and k are the only parameters changing .. we created a dp for that \\n    int fun(int i,int k,vector<vector<int>>& piles,int n)\\n    {\\n        if(i>=n || k<0){return 0;}\\n        if(dp[i][k]!=-1){return dp[i][k];}\\n        int ans=fun(i+1,k,piles,n);//first choice ,to skip the current stack\\n        for(int j=0;j<piles[i].size();j++)//either u want top coin or top 2 coins or top 3....and so on\\n        {     if(k-(j+1)<0){break;} //it is not possible to take more than k coins,,\\n            int temp=piles[i][j]+fun(i+1,k-(j+1),piles,n);\\n            if(temp>ans){ans=temp;}\\n        }\\n        return dp[i][k]=ans;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<piles[i].size();j++)\\n            {\\n                piles[i][j]=piles[i][j-1]+piles[i][j];//prefix sum ,,think about it\\n            }\\n        }\\n         memset(dp,-1,sizeof(dp));\\n        int ans=fun(0,k,piles,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924063,
                "title": "dp-solution-with-nested-loops-easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int n) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            int sum = 0;\\n            for (int k = 0; k < piles[i].size(); k++) {\\n                sum += piles[i][k];\\n                piles[i][k] = sum;\\n            }\\n        }\\n        vector<int> dp(n + 1);\\n        for (int i = 0; i < piles.size(); i++) {\\n            vector<int> temp = dp;\\n            for (int j = 1; j <= n; j++) {\\n                for (int k = 0; k < piles[i].size() && k < j; k++) {\\n                    temp[j] = max(dp[j-k-1] + piles[i][k], temp[j]);\\n                }\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int n) {\\n        for (int i = 0; i < piles.size(); i++) {\\n            int sum = 0;\\n            for (int k = 0; k < piles[i].size(); k++) {\\n                sum += piles[i][k];\\n                piles[i][k] = sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1923748,
                "title": "python3-simple-dp-state-and-transition-explained",
                "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        # just a simple DP once you figure out the state and state transition\\n        # figuring out state and state transition is the tough part\\n        # state: f(i, k) = max value of coins that can be made by taking k coins from stack i and stacks to its right\\n        #           Thus piles[i] is the leftmost stack that we can still use.\\n        # transition: our final answer is just some number of coins taken from the top of each stack,\\n        #   so we can do one stack at a time basically. This means we take all the coins we need from\\n        #   the first stack, then move onto second, etc. Our optimal answer is guaranteed to fit this\\n        #   format. Thus, at any state, we either \\n        #       (1) take no coins from the leftmost stack  ->  0 + f(i+1, k)\\n        #       (2) take between 1 and min(k, len(leftmost stack)) coins from leftmost stack \\n        #               ->  sum(leftmost_stack[0:coins_taken]) + f(i+1, k-coins_taken)\\n        \\n        dp = {} # memo table\\n        \\n        def f(i, k):\\n            \\n            # base cases\\n            if i == len(piles)  or k == 0:\\n                return 0\\n            if (i, k) in dp:\\n                return dp[(i, k)]\\n            \\n            # take no coins from this stack\\n            best = f(i+1, k)\\n            \\n            # take one or more coins from this stack\\n            val_sum = 0\\n            lm_stack = piles[i]\\n            for c in range(min(k, len(lm_stack))):\\n                # take coin at index c\\n                val_sum += lm_stack[c]\\n                best = max(best, val_sum + f(i+1, k-c-1))\\n                \\n            dp[(i, k)] = best\\n            return best\\n        \\n        return f(0, k)\\n    \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        # just a simple DP once you figure out the state and state transition\\n        # figuring out state and state transition is the tough part\\n        # state: f(i, k) = max value of coins that can be made by taking k coins from stack i and stacks to its right\\n        #           Thus piles[i] is the leftmost stack that we can still use.\\n        # transition: our final answer is just some number of coins taken from the top of each stack,\\n        #   so we can do one stack at a time basically. This means we take all the coins we need from\\n        #   the first stack, then move onto second, etc. Our optimal answer is guaranteed to fit this\\n        #   format. Thus, at any state, we either \\n        #       (1) take no coins from the leftmost stack  ->  0 + f(i+1, k)\\n        #       (2) take between 1 and min(k, len(leftmost stack)) coins from leftmost stack \\n        #               ->  sum(leftmost_stack[0:coins_taken]) + f(i+1, k-coins_taken)\\n        \\n        dp = {} # memo table\\n        \\n        def f(i, k):\\n            \\n            # base cases\\n            if i == len(piles)  or k == 0:\\n                return 0\\n            if (i, k) in dp:\\n                return dp[(i, k)]\\n            \\n            # take no coins from this stack\\n            best = f(i+1, k)\\n            \\n            # take one or more coins from this stack\\n            val_sum = 0\\n            lm_stack = piles[i]\\n            for c in range(min(k, len(lm_stack))):\\n                # take coin at index c\\n                val_sum += lm_stack[c]\\n                best = max(best, val_sum + f(i+1, k-c-1))\\n                \\n            dp[(i, k)] = best\\n            return best\\n        \\n        return f(0, k)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919092,
                "title": "c-simple-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> ps(n); //Calculating all the prefix sums\\n        \\n        for(int i=0;i<n;i++){\\n            int sz = piles[i].size();\\n            \\n            ps[i]=vector<int>(sz+1,0);\\n            \\n            for(int j=0;j<sz;j++)\\n                ps[i][j+1]=ps[i][j]+piles[i][j];\\n            \\n        }\\n\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        /*Here dp[i][j] represents the max value obtained after picking up j coins up to the i th pile.\\n\\t\\t   Therefore, dp[i][j] = max(dp[i-1][x] + ps[i-1][j-x]) i.e. max of picking j-x coins upto  i-1 th pile\\n\\t\\t   and then picking the remaining x coins in the ith pile.Here  x can go from 0 to min(k,piles[i-1].size()).\\n\\t\\t*/\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                int lim = min(j,(int)piles[i-1].size());\\n                for(int x=0;x<=lim;x++)\\n                    dp[i][j] = max(dp[i-1][j-x] + ps[i-1][x],dp[i][j]);\\n            }\\n        }\\n        return  dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> ps(n); //Calculating all the prefix sums\\n        \\n        for(int i=0;i<n;i++){\\n            int sz = piles[i].size();\\n            \\n            ps[i]=vector<int>(sz+1,0);\\n            \\n            for(int j=0;j<sz;j++)\\n                ps[i][j+1]=ps[i][j]+piles[i][j];\\n            \\n        }\\n\\n        int dp[n+1][k+1];\\n        memset(dp,0,sizeof(dp));\\n        /*Here dp[i][j] represents the max value obtained after picking up j coins up to the i th pile.\\n\\t\\t   Therefore, dp[i][j] = max(dp[i-1][x] + ps[i-1][j-x]) i.e. max of picking j-x coins upto  i-1 th pile\\n\\t\\t   and then picking the remaining x coins in the ith pile.Here  x can go from 0 to min(k,piles[i-1].size()).\\n\\t\\t*/\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=k;j++){\\n                int lim = min(j,(int)piles[i-1].size());\\n                for(int x=0;x<=lim;x++)\\n                    dp[i][j] = max(dp[i-1][j-x] + ps[i-1][x],dp[i][j]);\\n            }\\n        }\\n        return  dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897467,
                "title": "dp-recursive",
                "content": "```class Solution {\\npublic:\\n    int dp[1001][2002];\\n    int solve(vector<vector<int>>&piles,int k,int start){\\n        \\n        if(start==piles.size() || k==0){\\n            return 0;\\n        }\\n        if(dp[start][k]!=-1){\\n            return dp[start][k];\\n        }\\n        \\n        int ans=0;\\n        int op1=solve(piles,k,start+1);\\n        int op2=0;int sum=0;\\n        for(int i=0;i<piles[start].size();i++){\\n            sum+=piles[start][i];\\n            if(k-(i+1)>=0){\\n                op2=sum+solve(piles,k-(i+1),start+1);\\n            }\\n            int c=max(op1,op2);\\n            ans=max(ans,c);\\n        }\\n        return dp[start][k]=ans;\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(piles,k,0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[1001][2002];\\n    int solve(vector<vector<int>>&piles,int k,int start){\\n        \\n        if(start==piles.size() || k==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1897175,
                "title": "c-top-down-dp-0-1-knapsack-code",
                "content": "```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint func(vector<vector<int>> &nums, int k, int n)\\n{\\n    if (n == 0 or k <= 0)\\n        return 0;\\n\\n    if (dp[n][k] != -1)\\n        return dp[n][k];\\n\\n    int sum = 0, res = 0, i = 0;\\n    int temp = k;\\n    int m = nums[n - 1].size() - 1;\\n    res = max(res, func(nums, k, n - 1));\\n    while (i <= m and k > 0)\\n    {\\n        sum += nums[n - 1][i];\\n        res = max(res, sum + func(nums, k - 1, n - 1));\\n        i++;\\n        k--;\\n    }\\n\\n    return dp[n][temp] = res;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    memset(dp, -1, sizeof(dp));\\n    return func(piles, k, n);\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[1001][2001];\\nint func(vector<vector<int>> &nums, int k, int n)\\n{\\n    if (n == 0 or k <= 0)\\n        return 0;\\n\\n    if (dp[n][k] != -1)\\n        return dp[n][k];\\n\\n    int sum = 0, res = 0, i = 0;\\n    int temp = k;\\n    int m = nums[n - 1].size() - 1;\\n    res = max(res, func(nums, k, n - 1));\\n    while (i <= m and k > 0)\\n    {\\n        sum += nums[n - 1][i];\\n        res = max(res, sum + func(nums, k - 1, n - 1));\\n        i++;\\n        k--;\\n    }\\n\\n    return dp[n][temp] = res;\\n}\\nint maxValueOfCoins(vector<vector<int>> &piles, int k)\\n{\\n    int n = piles.size();\\n    memset(dp, -1, sizeof(dp));\\n    return func(piles, k, n);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895041,
                "title": "top-down-dp-approach-memoization-c-clean-code",
                "content": "Code\\n-----------------\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& piles, vector<vector<int>>& dp, int idx, int k, int n) {\\n        if(k == 0 or idx == n) {\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1) return dp[idx][k];\\n                \\n        int value = solve(piles, dp, idx+1, k, n);\\n        \\n        int sum = 0;\\n        \\n        for(int i=0; i<min(k, (int)piles[idx].size()); i++) {\\n            sum += piles[idx][i];\\n            value = max(value, sum + solve(piles, dp, idx+1, k-(i+1), n));\\n        }\\n        \\n        return dp[idx][k] = value;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return solve(piles, dp, 0, k, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& piles, vector<vector<int>>& dp, int idx, int k, int n) {\\n        if(k == 0 or idx == n) {\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1) return dp[idx][k];\\n                \\n        int value = solve(piles, dp, idx+1, k, n);\\n        \\n        int sum = 0;\\n        \\n        for(int i=0; i<min(k, (int)piles[idx].size()); i++) {\\n            sum += piles[idx][i];\\n            value = max(value, sum + solve(piles, dp, idx+1, k-(i+1), n));\\n        }\\n        \\n        return dp[idx][k] = value;\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return solve(piles, dp, 0, k, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893475,
                "title": "bottom-up-eze-to-understand-complexity-analysis",
                "content": "Either pick all k from previous piles, or choose j from current pile and pick k-j from previous piles\\nRecurrence relation:\\nf(i,k) represents the max sum of coins collected from first i piles and choosing k top coins.\\n```\\nf(i,k) = min(\\n\\t\\t\\tf(i-1,k) // pick k from previous piles\\n\\t\\t\\t,min(f(i-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[i-1].size())) // pick j+1 from current pile and k-j-1 from previous piles\\n\\t\\t)\\n```\\n\\nif k = 0, i.e. you can\\'t pick any coin then ans = 0\\nif n = 0, i.e. you don\\'t have any piles then ans = 0\\nBase cases :\\nf(0,k) = 0\\nf(n,0) = 0\\n\\nComplexity at max will be O(n*k+2000). Why? beacuse its given that sum of all lengths of piles is at max 2000  \\n(1 <= k <= sum(piles[i].length) <= 2000). So you iterate over all **a[i][j]** at max once.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& a, int k) {\\n        int dp[1005][2005]={{0}};\\n        int n=a.size();\\n        //finding prefix sum before hand \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<a[i].size();j++){\\n                a[i][j]+=a[i][j-1];\\n            }\\n        }\\n        //imagine a case when you have to choose from only one pile with diff value of k ,obviously it will be their prefix sum!!\\n       for(int j=1;j<2005;j++){\\n           if(j<=a[0].size())\\n           dp[0][j]+=a[0][j-1];\\n       }\\n        for(int i=1;i<n;i++){\\n           for(int j=1;j<2005;j++){\\n               int x=dp[i-1][j];  //if I dont choose any value from current i.e ith pile\\n               //now i will try to find max value if i choose 1,2,3...(min(a[i].size(),k)) ele fro current pile\\n               int y=0;\\n               for(int l=0;l<a[i].size();l++){\\n                   if(j-l-1>=0)  //(min(a[i].size(),k) condition.\\n                   y=max(y,a[i][l]+dp[i-1][j-l-1]);\\n               }\\n               dp[i][j]=max(x,y); //max of both\\n               \\n        }\\n        }\\n        \\n        return dp[n-1][k];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nf(i,k) = min(\\n\\t\\t\\tf(i-1,k) // pick k from previous piles\\n\\t\\t\\t,min(f(i-1,k-j-1)+sum(0 to j) for j = 0 to min(k,p[i-1].size())) // pick j+1 from current pile and k-j-1 from previous piles\\n\\t\\t)\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& a, int k) {\\n        int dp[1005][2005]={{0}};\\n        int n=a.size();\\n        //finding prefix sum before hand \\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<a[i].size();j++){\\n                a[i][j]+=a[i][j-1];\\n            }\\n        }\\n        //imagine a case when you have to choose from only one pile with diff value of k ,obviously it will be their prefix sum!!\\n       for(int j=1;j<2005;j++){\\n           if(j<=a[0].size())\\n           dp[0][j]+=a[0][j-1];\\n       }\\n        for(int i=1;i<n;i++){\\n           for(int j=1;j<2005;j++){\\n               int x=dp[i-1][j];  //if I dont choose any value from current i.e ith pile\\n               //now i will try to find max value if i choose 1,2,3...(min(a[i].size(),k)) ele fro current pile\\n               int y=0;\\n               for(int l=0;l<a[i].size();l++){\\n                   if(j-l-1>=0)  //(min(a[i].size(),k) condition.\\n                   y=max(y,a[i][l]+dp[i-1][j-l-1]);\\n               }\\n               dp[i][j]=max(x,y); //max of both\\n               \\n        }\\n        }\\n        \\n        return dp[n-1][k];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893337,
                "title": "simple-solution-in-java-iterative-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; // Not taking any coin at all from the current pile\\n                \\n                // For the current pile, we have the option to take the atmost j coins if present\\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int c=0; c < Math.min(currPile.size(), j); c++){\\n                    coinSum += currPile.get(c);\\n                    \\n                    // Take c coins from the current pile and remaining coins from the previous piles\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - c - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int numPiles = piles.size();\\n        \\n        int[][] dp = new int[numPiles+1][k+1];\\n        \\n        for(int i=1; i<=numPiles; i++){\\n            for(int j=1; j<=k; j++){\\n                dp[i][j] = dp[i-1][j]; // Not taking any coin at all from the current pile\\n                \\n                // For the current pile, we have the option to take the atmost j coins if present\\n                List<Integer> currPile = piles.get(i-1);\\n                int coinSum = 0;\\n                for(int c=0; c < Math.min(currPile.size(), j); c++){\\n                    coinSum += currPile.get(c);\\n                    \\n                    // Take c coins from the current pile and remaining coins from the previous piles\\n                    dp[i][j] = Math.max(dp[i][j], coinSum + dp[i-1][j - c - 1]); \\n                }\\n            }\\n        }\\n        \\n        return dp[numPiles][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893060,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * K)***\\n* ***Space Complexity : O(N * K)***\\n\\n```\\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<vector<int>>& piles, int pos, int k)\\n    {\\n        if(pos >= piles.size())\\n            return 0;\\n        \\n        if(k == 0)\\n            return 0;\\n        \\n        if(k < 0)\\n            return INT_MIN + 5000;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        int option_1 = 0;\\n        \\n        int option_2 = 0;\\n        \\n        int taken = 0;\\n        \\n        for(int i = 0; i < min(k, (int)piles[pos].size()); i++)\\n        {\\n            taken += piles[pos][i];\\n            \\n            option_1 = max(option_1, taken + helper(piles, pos + 1, k - 1- i));\\n        }\\n        \\n        option_2 = helper(piles, pos + 1, k);\\n        \\n        return dp[pos][k] = max(option_1, option_2);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (k + 1, -1));\\n        \\n        return helper(piles, 0, k);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    vector<vector<int>> dp;\\n    \\n    int helper(vector<vector<int>>& piles, int pos, int k)\\n    {\\n        if(pos >= piles.size())\\n            return 0;\\n        \\n        if(k == 0)\\n            return 0;\\n        \\n        if(k < 0)\\n            return INT_MIN + 5000;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        int option_1 = 0;\\n        \\n        int option_2 = 0;\\n        \\n        int taken = 0;\\n        \\n        for(int i = 0; i < min(k, (int)piles[pos].size()); i++)\\n        {\\n            taken += piles[pos][i];\\n            \\n            option_1 = max(option_1, taken + helper(piles, pos + 1, k - 1- i));\\n        }\\n        \\n        option_2 = helper(piles, pos + 1, k);\\n        \\n        return dp[pos][k] = max(option_1, option_2);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        int n = piles.size();\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (k + 1, -1));\\n        \\n        return helper(piles, 0, k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891330,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1002][2002] = {};\\n    \\n    int solve(vector<vector<int>>& piles, int pileIdx, int k){\\n        \\n        if(pileIdx >= piles.size() or k <= 0) return 0;\\n        \\n        if(dp[pileIdx][k] != 0) return dp[pileIdx][k];\\n        \\n        // no pick up from this pile\\n        int ans = solve(piles, pileIdx+1, k);\\n        \\n        int sum = 0;\\n        for(int i=0; i< piles[pileIdx].size() and i < k; i++){\\n            \\n            // pick up i+1 coins from this pile\\n            \\n            sum+= piles[pileIdx][i];\\n            \\n            ans = max(ans, sum+solve(piles, pileIdx+1, k-(i+1)));\\n            \\n        }\\n        \\n        return dp[pileIdx][k] = ans;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        return solve(piles,0,k);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1002][2002] = {};\\n    \\n    int solve(vector<vector<int>>& piles, int pileIdx, int k){\\n        \\n        if(pileIdx >= piles.size() or k <= 0) return 0;\\n        \\n        if(dp[pileIdx][k] != 0) return dp[pileIdx][k];\\n        \\n        // no pick up from this pile\\n        int ans = solve(piles, pileIdx+1, k);\\n        \\n        int sum = 0;\\n        for(int i=0; i< piles[pileIdx].size() and i < k; i++){\\n            \\n            // pick up i+1 coins from this pile\\n            \\n            sum+= piles[pileIdx][i];\\n            \\n            ans = max(ans, sum+solve(piles, pileIdx+1, k-(i+1)));\\n            \\n        }\\n        \\n        return dp[pileIdx][k] = ans;\\n        \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        \\n        return solve(piles,0,k);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890924,
                "title": "c-top-down-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& p, int k,int i,vector<vector<int>>& dp){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int notake = 0 + f(p,k,i-1,dp);\\n        int take = 0;\\n        int sum=0;\\n        for(int l=0; l<p[i].size(); l++){\\n            sum+=p[i][l];\\n            if(k>=(l+1)) take = max(take,sum+f(p,k-l-1,i-1,dp));\\n        }\\n        return dp[i][k]=max(notake,take);\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        return f(p,k,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& p, int k,int i,vector<vector<int>>& dp){\\n        if(i<0){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int notake = 0 + f(p,k,i-1,dp);\\n        int take = 0;\\n        int sum=0;\\n        for(int l=0; l<p[i].size(); l++){\\n            sum+=p[i][l];\\n            if(k>=(l+1)) take = max(take,sum+f(p,k-l-1,i-1,dp));\\n        }\\n        return dp[i][k]=max(notake,take);\\n        \\n    }\\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n = p.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        return f(p,k,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890250,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/051db66d8b0518ebeccdb1e18229f849b1291f38) for solutions of weekly 286. \\n\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return \"\"\"\\n            if i == len(piles) or k == 0: return 0 \\n            ans = fn(i+1, k)\\n            prefix = 0 \\n            for j in range(min(k, len(piles[i]))): \\n                prefix += piles[i][j]\\n                ans = max(ans, prefix + fn(i+1, k-j-1))\\n            return ans \\n        \\n        return fn(0, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return \"\"\"\\n            if i == len(piles) or k == 0: return 0 \\n            ans = fn(i+1, k)\\n            prefix = 0 \\n            for j in range(min(k, len(piles[i]))): \\n                prefix += piles[i][j]\\n                ans = max(ans, prefix + fn(i+1, k-j-1))\\n            return ans \\n        \\n        return fn(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888985,
                "title": "c-knapsack",
                "content": "class Solution {\\npublic:\\n\\n    int dp[1001][2001]; \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(p,0,k);\\n    }\\n    int solve(vector<vector<int>>&p ,int i ,int k){\\n      if(i>=p.size())\\n      return 0;\\n      if(dp[i][k] !=-1)\\n        return dp[i][k];\\n      int exclude=solve(p,i+1,k);\\n      int include=0,sum=0;\\n      for(int j=0;j<p[i].size();j++){\\n        sum+=p[i][j];\\n        if(k-j-1>=0)\\n        include=max(include,sum+solve(p,i+1,k-j-1));\\n      }\\n      return dp[i][k]=max(exclude,include);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int dp[1001][2001]; \\n    int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(p,0,k);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1888423,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        \\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int res=0;\\n        res=max(res,solve(piles, i+1, k, dp));\\n        \\n        for(int j=0; j<piles[i].size()&&j+1<=k; j++)\\n        {\\n            res=max(res, piles[i][j]+solve(piles, i+1, k-j-1, dp));\\n        }\\n        return dp[i][k]=res;     \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        for(int i=0; i<piles.size(); i++)\\n        {\\n            for(int j=1; j<piles[i].size(); j++)\\n            {\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n            }\\n        }\\n        int n=piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        return solve(piles, 0, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve (vector<vector<int>> &piles, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i>=piles.size())\\n            return 0;\\n        \\n        if (dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int res=0;\\n        res=max(res,solve(piles, i+1, k, dp));\\n        \\n        for(int j=0; j<piles[i].size()&&j+1<=k; j++)\\n        {\\n            res=max(res, piles[i][j]+solve(piles, i+1, k-j-1, dp));\\n        }\\n        return dp[i][k]=res;     \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        for(int i=0; i<piles.size(); i++)\\n        {\\n            for(int j=1; j<piles[i].size(); j++)\\n            {\\n                piles[i][j]=piles[i][j]+piles[i][j-1];\\n            }\\n        }\\n        int n=piles.size();\\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));\\n        return solve(piles, 0, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888217,
                "title": "c-2d-dp-memomization",
                "content": "```\\nclass Solution {\\n    int fun(vector<vector<int>>& piles,int k,int l,vector<vector<int>> &dp){\\n        int n = piles.size();\\n        if(l == n || k == 0)    return 0;\\n        \\n        if(dp[l][k] != -1)  return dp[l][k];\\n        \\n        int ans = fun(piles,k,l+1,dp);\\n        int sum = 0;\\n       \\n        for(int i=0; i<piles[l].size() && i<k; i++){\\n            sum += piles[l][i];\\n            ans = max(ans, sum + fun(piles,k-i-1,l+1,dp));\\n        }\\n        \\n        dp[l][k] = ans;\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles,int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        \\n        return fun(piles,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int fun(vector<vector<int>>& piles,int k,int l,vector<vector<int>> &dp){\\n        int n = piles.size();\\n        if(l == n || k == 0)    return 0;\\n        \\n        if(dp[l][k] != -1)  return dp[l][k];\\n        \\n        int ans = fun(piles,k,l+1,dp);\\n        int sum = 0;\\n       \\n        for(int i=0; i<piles[l].size() && i<k; i++){\\n            sum += piles[l][i];\\n            ans = max(ans, sum + fun(piles,k-i-1,l+1,dp));\\n        }\\n        \\n        dp[l][k] = ans;\\n        return ans;\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles,int k) {\\n        int n = piles.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1,-1));\\n        \\n        return fun(piles,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888148,
                "title": "c-memoization-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles,int k,int i,vector<vector<int>>& dp)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        if(k==0)\\n            return 0;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        //skipping this pile and moving to the next one\\n        int ans=solve(piles,k,i-1,dp),j,sum=0;\\n        for(j=0;j<piles[i].size();j++)\\n        {\\n            sum+=piles[i][j];\\n            //choose a coin from this pile & then try going to the next pile\\n            //or go deep into this pile and add its value\\n            if(k-j-1>=0)// untill k>=0\\n            {\\n                ans=max(ans,sum+solve(piles,k-j-1,i-1,dp));\\n            }\\n            else //if k<0 then can\\'t do anything else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        return solve(piles,k,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles,int k,int i,vector<vector<int>>& dp)\\n    {\\n        if(i<0)\\n            return 0;\\n        \\n        if(k==0)\\n            return 0;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        //skipping this pile and moving to the next one\\n        int ans=solve(piles,k,i-1,dp),j,sum=0;\\n        for(j=0;j<piles[i].size();j++)\\n        {\\n            sum+=piles[i][j];\\n            //choose a coin from this pile & then try going to the next pile\\n            //or go deep into this pile and add its value\\n            if(k-j-1>=0)// untill k>=0\\n            {\\n                ans=max(ans,sum+solve(piles,k-j-1,i-1,dp));\\n            }\\n            else //if k<0 then can\\'t do anything else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        return solve(piles,k,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888140,
                "title": "easy-recursion-memo-2-d-dp-top-down-o-n-k-time-space",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][2001];\\n    int fun(vector<vector<int>>& piles, int i, int k){\\n        if(k==0 || i==piles.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int skip = fun(piles, i+1, k);\\n        int take = 0, sum = 0;\\n        for(int cur = 0, count = k; cur < piles[i].size() && count; cur++){\\n            sum += piles[i][cur]; count--;\\n            take = max(take, sum + fun(piles, i+1, count));\\n        }\\n        return dp[i][k] = max(skip, take);\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(piles, 0, k);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][2001];\\n    int fun(vector<vector<int>>& piles, int i, int k){\\n        if(k==0 || i==piles.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int skip = fun(piles, i+1, k);\\n        int take = 0, sum = 0;\\n        for(int cur = 0, count = k; cur < piles[i].size() && count; cur++){\\n            sum += piles[i][cur]; count--;\\n            take = max(take, sum + fun(piles, i+1, count));\\n        }\\n        return dp[i][k] = max(skip, take);\\n    }\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(piles, 0, k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888020,
                "title": "racket-dp-solution",
                "content": "```scheme\\n(define/contract (max-value-of-coins piles k)\\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\\n  (define (dp i k)\\n    (cond [(= i (vector-length piles)) 0]\\n          [(= k 0) 0]\\n          [else (let ([maximum (dp (+ i 1) k)]\\n                      [prefix 0])\\n                  (for ([j (range 0 (min (vector-length (vector-ref piles i))\\n                                         k))]\\n                        [vij (vector-ref piles i)])\\n                    (set-var! prefix + vij)\\n                    (set-var! maximum max (+ prefix (dp (+ i 1) (- k j 1)))))\\n                  maximum)]))\\n  (set! piles (list2d->vector2d piles))\\n  (set! dp (vector-memoize dp (vector-length piles) k -1))\\n  (dp 0 k))\\n\\n;; helpers ;;\\n\\n(define (list2d->vector2d ll)\\n  (list->vector (map list->vector ll)))\\n\\n(define (vector2d-ref vec x y)\\n  (vector-ref (vector-ref vec x) y))\\n\\n(define (vector2d-set! vec x y val)\\n  (vector-set! (vector-ref vec x) y val))\\n\\n(define (make-vector2d x y init)\\n  (build-vector x (lambda (row) (make-vector y init))))\\n\\n(define (vector-memoize old-proc xlimit ylimit init)\\n  (let ([vec (make-vector2d (+ xlimit 1) (+ ylimit 1) init)])\\n    (lambda (x y)\\n      (when (= (vector2d-ref vec x y) init)\\n            (vector2d-set! vec x y (old-proc x y)))\\n      (vector2d-ref vec x y))))\\n\\n(define-syntax-rule (set-var! x f delta)\\n  (set! x (f x delta)))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(define/contract (max-value-of-coins piles k)\\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\\n  (define (dp i k)\\n    (cond [(= i (vector-length piles)) 0]\\n          [(= k 0) 0]\\n          [else (let ([maximum (dp (+ i 1) k)]\\n                      [prefix 0])\\n                  (for ([j (range 0 (min (vector-length (vector-ref piles i))\\n                                         k))]\\n                        [vij (vector-ref piles i)])\\n                    (set-var! prefix + vij)\\n                    (set-var! maximum max (+ prefix (dp (+ i 1) (- k j 1)))))\\n                  maximum)]))\\n  (set! piles (list2d->vector2d piles))\\n  (set! dp (vector-memoize dp (vector-length piles) k -1))\\n  (dp 0 k))\\n\\n;; helpers ;;\\n\\n(define (list2d->vector2d ll)\\n  (list->vector (map list->vector ll)))\\n\\n(define (vector2d-ref vec x y)\\n  (vector-ref (vector-ref vec x) y))\\n\\n(define (vector2d-set! vec x y val)\\n  (vector-set! (vector-ref vec x) y val))\\n\\n(define (make-vector2d x y init)\\n  (build-vector x (lambda (row) (make-vector y init))))\\n\\n(define (vector-memoize old-proc xlimit ylimit init)\\n  (let ([vec (make-vector2d (+ xlimit 1) (+ ylimit 1) init)])\\n    (lambda (x y)\\n      (when (= (vector2d-ref vec x y) init)\\n            (vector2d-set! vec x y (old-proc x y)))\\n      (vector2d-ref vec x y))))\\n\\n(define-syntax-rule (set-var! x f delta)\\n  (set! x (f x delta)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887605,
                "title": "top-down-dp-solution-3d-2d",
                "content": "## **Top Down Approach**\\n\\n*Pure top down accepted solution but less efficient*\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, int index[], vector<vector<vector<int>>> &dp) {\\n        if(i == n || k == 0) return 0;\\n        \\n        if(dp[i][index[i]][k] != -1) return dp[i][index[i]][k];\\n        \\n        int x = 0, y = 0;\\n        if(index[i] < piles[i].size()) {\\n            index[i]++;\\n            x = piles[i][index[i]-1] + helper(piles, n, k-1, i, index, dp);\\n            index[i]--;\\n        }\\n        y = helper(piles, n, k, i+1, index, dp);\\n        \\n        return dp[i][index[i]][k] = max(x, y);    \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int index[1000] = {0};\\n        vector<vector<vector<int>>> dp(n);\\n        for(int i=0; i<n; i++) {\\n            vector<vector<int>> temp(piles[i].size()+1, vector<int>(k+1, -1));\\n            dp[i] = temp;\\n        }\\n        \\n        return helper(piles, n, k, 0, index, dp);\\n    }\\n};\\n```\\n\\n\\n*Top down accepted solution and more efficient*\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, vector<vector<int>> &dp) {\\n        if(k == 0) return 0;\\n        else if(i == n || k < 0) return INT_MIN;\\n        \\n        if(dp[i][k] != -1) return dp[i][k];\\n        \\n        int x = 0, sum = 0;\\n        for(int j=0; j<piles[i].size(); j++) {\\n            sum += piles[i][j];\\n            x = max(x, sum + helper(piles, n, k-j-1, i+1, dp));\\n        }\\n        int y = helper(piles, n, k, i+1, dp);\\n        \\n        return dp[i][k] = max(x, y);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        \\n        return helper(piles, n, k, 0, dp);\\n    }\\n};\\n```\\n\\n#1stPost",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, int index[], vector<vector<vector<int>>> &dp) {\\n        if(i == n || k == 0) return 0;\\n        \\n        if(dp[i][index[i]][k] != -1) return dp[i][index[i]][k];\\n        \\n        int x = 0, y = 0;\\n        if(index[i] < piles[i].size()) {\\n            index[i]++;\\n            x = piles[i][index[i]-1] + helper(piles, n, k-1, i, index, dp);\\n            index[i]--;\\n        }\\n        y = helper(piles, n, k, i+1, index, dp);\\n        \\n        return dp[i][index[i]][k] = max(x, y);    \\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        int index[1000] = {0};\\n        vector<vector<vector<int>>> dp(n);\\n        for(int i=0; i<n; i++) {\\n            vector<vector<int>> temp(piles[i].size()+1, vector<int>(k+1, -1));\\n            dp[i] = temp;\\n        }\\n        \\n        return helper(piles, n, k, 0, index, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>> &piles, int n, int k, int i, vector<vector<int>> &dp) {\\n        if(k == 0) return 0;\\n        else if(i == n || k < 0) return INT_MIN;\\n        \\n        if(dp[i][k] != -1) return dp[i][k];\\n        \\n        int x = 0, sum = 0;\\n        for(int j=0; j<piles[i].size(); j++) {\\n            sum += piles[i][j];\\n            x = max(x, sum + helper(piles, n, k-j-1, i+1, dp));\\n        }\\n        int y = helper(piles, n, k, i+1, dp);\\n        \\n        return dp[i][k] = max(x, y);\\n    }\\n    \\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        \\n        return helper(piles, n, k, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887231,
                "title": "dp-tabulation-c-space-optimized-o-k",
                "content": "Problem Simillar to Knapsack.\\n\\n\\n```\\n int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=dp[i+1][j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+dp[i+1][j-m-1]);\\n                 }\\n                dp[i][j]=nt;\\n                }\\n        }\\n        return dp[0][k];\\n    }\\n\\t\\n\\t\\n\\t// T.C.=> O(n*k^2)\\n\\t// S.C=> O(n*k)\\n\\t\\n\\t\\n```\\n\\nAdding more space optimized in future\\n____________________________________________________________________________________\\n\\nEdit:\\nSpace Optimized\\n\\n```\\nint maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n\\t\\t// will not be using 2d Matrix here instead of that we will use two 1-d array of size k+1 \\n        // vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        vector<int> pre(k+1,0),curr(k+1,0);\\n        \\n        \\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=pre[j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+pre[j-m-1]);\\n                 }\\n                \\n                curr[j]=nt;\\n                \\n                }\\n            pre=curr;\\n   \\n        }\\n\\n        return pre[k];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// T.C.=> O(n*k^2)\\n\\t       // S.C=> O(k)\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=dp[i+1][j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+dp[i+1][j-m-1]);\\n                 }\\n                dp[i][j]=nt;\\n                }\\n        }\\n        return dp[0][k];\\n    }\\n\\t\\n\\t\\n\\t// T.C.=> O(n*k^2)\\n\\t// S.C=> O(n*k)\\n\\t\\n\\t\\n```\n```\\nint maxValueOfCoins(vector<vector<int>>& p, int k) {\\n        int n=p.size();\\n\\t\\t// will not be using 2d Matrix here instead of that we will use two 1-d array of size k+1 \\n        // vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        \\n        vector<int> pre(k+1,0),curr(k+1,0);\\n        \\n        \\n        \\n        for(int i=n-1;i>=0;--i){\\n            for(int j=0;j<=k;++j){\\n                int nt=pre[j];\\n                int a=0;\\n                 for(int m=0;m<p[i].size()&&m<j;++m){\\n                     a+=p[i][m];\\n                     nt=max(nt,a+pre[j-m-1]);\\n                 }\\n                \\n                curr[j]=nt;\\n                \\n                }\\n            pre=curr;\\n   \\n        }\\n\\n        return pre[k];\\n\\t\\t\\n\\t\\t\\n\\t\\t\\t// T.C.=> O(n*k^2)\\n\\t       // S.C=> O(k)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887152,
                "title": "c-solution-o-k-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& rows, int k) {\\n        vector<int> dp(k + 1, -1e9);\\n    dp[0] = 0;\\n        for(auto &it:rows)\\n        {\\n            reverse(it.begin(),it.end());\\n        }\\n    for (const auto& nums : rows) {\\n        int n = nums.size();\\n        auto dpc = dp;\\n\\n        for (int i = 1; i <= k; ++i) {\\n            int sum = 0;\\n            for (int j = 1; j <= min(i, n); ++j)\\n                dpc[i] = max(dpc[i], (sum += nums[n - j]) + dp[i - j]);\\n        }\\n\\n        dp = dpc;\\n    }\\n\\n    return dp[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& rows, int k) {\\n        vector<int> dp(k + 1, -1e9);\\n    dp[0] = 0;\\n        for(auto &it:rows)\\n        {\\n            reverse(it.begin(),it.end());\\n        }\\n    for (const auto& nums : rows) {\\n        int n = nums.size();\\n        auto dpc = dp;\\n\\n        for (int i = 1; i <= k; ++i) {\\n            int sum = 0;\\n            for (int j = 1; j <= min(i, n); ++j)\\n                dpc[i] = max(dpc[i], (sum += nums[n - j]) + dp[i - j]);\\n        }\\n\\n        dp = dpc;\\n    }\\n\\n    return dp[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887108,
                "title": "java-memoization",
                "content": "```\\nclass Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n= piles.size();\\n        int[][] memo= new int[n][k+1];\\n        for(int i=0; i<n; i++) Arrays.fill(memo[i], -1);\\n        return maxValue(0, k, new ArrayList<>(piles), memo);\\n    }\\n    \\n    int maxValue(int i, int k, ArrayList<List<Integer>> piles, int[][] memo){\\n        if(k==0) return 0;\\n        int n= piles.size();\\n        if(i==n) return 0;\\n        \\n        if(memo[i][k]!=-1) return memo[i][k];\\n       \\n        List<Integer> pile= piles.get(i);\\n        int len= pile.size(), canTake= Math.min(len, k);\\n        int thisMaxValue= maxValue(i+1, k, piles, memo);\\n        int taken= 0, takenValue= 0;\\n        for(int coin:pile){\\n            if(taken==canTake) break;\\n            taken++;\\n            takenValue+= coin;\\n            thisMaxValue= Math.max(thisMaxValue, takenValue + maxValue(i+1, k-taken, piles, memo));\\n        }\\n        return memo[i][k]= thisMaxValue;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n        int n= piles.size();\\n        int[][] memo= new int[n][k+1];\\n        for(int i=0; i<n; i++) Arrays.fill(memo[i], -1);\\n        return maxValue(0, k, new ArrayList<>(piles), memo);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1887096,
                "title": "dp-java-solution",
                "content": "\\n    class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n      int max=0;\\n        for(List<Integer> l:piles){\\n            max=Math.max(max,l.size());\\n        }\\n        int dp[][][]=new int[piles.size()][max][k+1];\\n        for(int p[][]:dp){\\n            for(int x[]:p){\\n                Arrays.fill(x,-1);\\n            }\\n        }\\n        return maxvalue(0,0,piles,k,dp);\\n    }\\n    public int maxvalue(int i,int j,List<List<Integer>> piles,int k,int dp[][][]){\\n        if(k==0)return 0;\\n        if(i>=piles.size())return 0;\\n        if(j>=piles.get(i).size())return 0;\\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n      int take=0;\\n            take=piles.get(i).get(j)+Math.max(maxvalue(i,j+1,piles,k-1,dp),maxvalue(i+1,0,piles,k-1,dp));\\n            int not=maxvalue(i+1,0,piles,k,dp);\\n        \\n        return dp[i][j][k]=Math.max(take,not);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maxValueOfCoins(List<List<Integer>> piles, int k) {\\n      int max=0;\\n        for(List<Integer> l:piles){\\n            max=Math.max(max,l.size());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1887037,
                "title": "top-down-dp-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& piles,int k,int &n,int i,vector<vector<int>>& dp)\\n    {\\n        if(i==n||k==0)\\n            return 0;\\n       \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans=0;\\n        ans=explore(piles,k,n,i+1,dp);\\n        int sum=0;\\n        int K=k;\\n        for(int j=0;j<piles[i].size()&&k>0;j++)\\n        {\\n            \\n            sum+=piles[i][j];\\n            k--;\\n            ans=max(ans,sum+explore(piles,k,n,i+1,dp));\\n           \\n        }\\n     \\n        return dp[i][K]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2001,-1));\\n        return explore(piles,k,n,0,dp);\\n        \\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& piles,int k,int &n,int i,vector<vector<int>>& dp)\\n    {\\n        if(i==n||k==0)\\n            return 0;\\n       \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans=0;\\n        ans=explore(piles,k,n,i+1,dp);\\n        int sum=0;\\n        int K=k;\\n        for(int j=0;j<piles[i].size()&&k>0;j++)\\n        {\\n            \\n            sum+=piles[i][j];\\n            k--;\\n            ans=max(ans,sum+explore(piles,k,n,i+1,dp));\\n           \\n        }\\n     \\n        return dp[i][K]=ans;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n=piles.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2001,-1));\\n        return explore(piles,k,n,0,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887019,
                "title": "c-2218-maximum-value-of-k-coins-from-piles",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> seen(piles.size(), vector<int>(k+1, -1)); \\n        \\n        function<int(int, int)> fn = [&](int i, int k) {\\n            if (i == piles.size()) return 0; \\n            if (k == 0) return 0; \\n            if (seen[i][k] == -1) {\\n                seen[i][k] = fn(i+1, k); \\n                int prefix = 0; \\n                for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n                    prefix += piles[i][j]; \\n                    seen[i][k] = max(seen[i][k], prefix + fn(i+1, k-j-1)); \\n                }\\n            }\\n            return seen[i][k]; \\n        }; \\n        \\n        return fn(0, k); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        vector<vector<int>> seen(piles.size(), vector<int>(k+1, -1)); \\n        \\n        function<int(int, int)> fn = [&](int i, int k) {\\n            if (i == piles.size()) return 0; \\n            if (k == 0) return 0; \\n            if (seen[i][k] == -1) {\\n                seen[i][k] = fn(i+1, k); \\n                int prefix = 0; \\n                for (int j = 0; j < piles[i].size() && j < k; ++j) {\\n                    prefix += piles[i][j]; \\n                    seen[i][k] = max(seen[i][k], prefix + fn(i+1, k-j-1)); \\n                }\\n            }\\n            return seen[i][k]; \\n        }; \\n        \\n        return fn(0, k); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886946,
                "title": "cpp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int util(int k, int idx, vector<vector<int>>& piles) {\\n        if(idx == piles.size()) return 0;\\n        if(k <= 0) return 0;\\n        if(dp[k][idx] != -1) return dp[k][idx];\\n        int res = util(k, idx + 1, piles);\\n        int cnt = 0;\\n        for(int i = 0; i < piles[idx].size() && k - i - 1 >= 0; i++) {\\n            cnt += piles[idx][i];\\n            res = max(res, cnt + util(k - i - 1, idx + 1, piles));\\n        }\\n        \\n        return dp[k][idx] = res;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp = vector<vector<int>>(k + 1, vector<int>(piles.size(), -1));\\n        return util(k, 0, piles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int util(int k, int idx, vector<vector<int>>& piles) {\\n        if(idx == piles.size()) return 0;\\n        if(k <= 0) return 0;\\n        if(dp[k][idx] != -1) return dp[k][idx];\\n        int res = util(k, idx + 1, piles);\\n        int cnt = 0;\\n        for(int i = 0; i < piles[idx].size() && k - i - 1 >= 0; i++) {\\n            cnt += piles[idx][i];\\n            res = max(res, cnt + util(k - i - 1, idx + 1, piles));\\n        }\\n        \\n        return dp[k][idx] = res;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        dp = vector<vector<int>>(k + 1, vector<int>(piles.size(), -1));\\n        return util(k, 0, piles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886931,
                "title": "c-prefix-sum-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        // prefix sum\\n        vector<vector<int>> pfs(m);\\n        int all_sum = 0;\\n        int all_cnt = 0;\\n        for(int i=0;i<m;i++){\\n            auto& pile = piles[i];\\n            auto& sums = pfs[i];\\n            int pile_nums = 0;\\n            for(int num: pile){\\n                int sum = sums.empty()? num: (num+sums.back());\\n                sums.push_back(sum);\\n                all_sum += num;\\n                all_cnt++;\\n                pile_nums++;\\n                if(pile_nums==k){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(all_cnt<=k){\\n            return all_sum;\\n        }\\n        \\n        vector<vector<int>> dp(m,vector<int>(k+1,0));\\n        \\n        auto get =[&](int i,int num){\\n            auto& sums = pfs[i];\\n            int len = sums.size();\\n            if(len==0||num==0){\\n                return 0;\\n            }\\n            return sums[min(len-1,num-1)];\\n        };\\n        \\n        for(int i=0; i<m;i++){\\n            for(int j=1;j<=k;j++){\\n                for(int get_here =0;get_here<=j&&get_here<=pfs[i].size();get_here++){\\n                    int get_before = j-get_here;\\n                    dp[i][j] = max(dp[i][j], get(i,get_here)+(i==0?0:dp[i-1][get_before]));\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int m = piles.size();\\n        // prefix sum\\n        vector<vector<int>> pfs(m);\\n        int all_sum = 0;\\n        int all_cnt = 0;\\n        for(int i=0;i<m;i++){\\n            auto& pile = piles[i];\\n            auto& sums = pfs[i];\\n            int pile_nums = 0;\\n            for(int num: pile){\\n                int sum = sums.empty()? num: (num+sums.back());\\n                sums.push_back(sum);\\n                all_sum += num;\\n                all_cnt++;\\n                pile_nums++;\\n                if(pile_nums==k){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(all_cnt<=k){\\n            return all_sum;\\n        }\\n        \\n        vector<vector<int>> dp(m,vector<int>(k+1,0));\\n        \\n        auto get =[&](int i,int num){\\n            auto& sums = pfs[i];\\n            int len = sums.size();\\n            if(len==0||num==0){\\n                return 0;\\n            }\\n            return sums[min(len-1,num-1)];\\n        };\\n        \\n        for(int i=0; i<m;i++){\\n            for(int j=1;j<=k;j++){\\n                for(int get_here =0;get_here<=j&&get_here<=pfs[i].size();get_here++){\\n                    int get_before = j-get_here;\\n                    dp[i][j] = max(dp[i][j], get(i,get_here)+(i==0?0:dp[i-1][get_before]));\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886917,
                "title": "c-dp-with-some-explaination",
                "content": "``` c++\\nclass Solution {\\n   public:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n\\n        // dp[i][j]: the maximum value we can get picking j coins from the first\\n        // i piles\\n        vector<vector<int>> dp(n, vector<int>(k + 1));\\n        for (int i = 1; i <= min(k, (int)piles[0].size()); i++) {\\n            dp[0][i] = dp[0][i - 1] + piles[0][i - 1];\\n        }\\n\\n        // the total number of coins of the first (i - 1) piles\\n        int tot = piles[0].size();\\n        for (int i = 1; i < n; i++) {\\n            int pileSize = piles[i].size();\\n\\n            // presum of the i-th pile\\n            vector<int> presum(k + 1);\\n            for (int j = 1; j <= min(k, pileSize); j++) {\\n                presum[j] = presum[j - 1] + piles[i][j - 1];\\n            }\\n\\n            // pick j coins from the first i piles, j should be no greater than\\n            // the sum of the first i piles\\n            for (int j = 0; j <= min(k, tot + pileSize); j++) {\\n                // pick l coins from the first (i - 1) piles\\n                // these j coins consist of two parts:\\n                // 1. l coins from the previous piles, dp[i-1][j]\\n                // 2. j - l coins from the current (i-th) pile, presum[j-l]\\n                for (int l = max(0, j - pileSize); l <= min({j, k, tot}); l++) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][l] + presum[j - l]);\\n                }\\n            }\\n\\n            // update tot\\n            tot += pileSize;\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` c++\\nclass Solution {\\n   public:\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        int n = piles.size();\\n\\n        // dp[i][j]: the maximum value we can get picking j coins from the first\\n        // i piles\\n        vector<vector<int>> dp(n, vector<int>(k + 1));\\n        for (int i = 1; i <= min(k, (int)piles[0].size()); i++) {\\n            dp[0][i] = dp[0][i - 1] + piles[0][i - 1];\\n        }\\n\\n        // the total number of coins of the first (i - 1) piles\\n        int tot = piles[0].size();\\n        for (int i = 1; i < n; i++) {\\n            int pileSize = piles[i].size();\\n\\n            // presum of the i-th pile\\n            vector<int> presum(k + 1);\\n            for (int j = 1; j <= min(k, pileSize); j++) {\\n                presum[j] = presum[j - 1] + piles[i][j - 1];\\n            }\\n\\n            // pick j coins from the first i piles, j should be no greater than\\n            // the sum of the first i piles\\n            for (int j = 0; j <= min(k, tot + pileSize); j++) {\\n                // pick l coins from the first (i - 1) piles\\n                // these j coins consist of two parts:\\n                // 1. l coins from the previous piles, dp[i-1][j]\\n                // 2. j - l coins from the current (i-th) pile, presum[j-l]\\n                for (int l = max(0, j - pileSize); l <= min({j, k, tot}); l++) {\\n                    dp[i][j] = max(dp[i][j], dp[i - 1][l] + presum[j - l]);\\n                }\\n            }\\n\\n            // update tot\\n            tot += pileSize;\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038386,
                "title": "top-down-approach-100-step-by-step-explanation-easy-to-understand",
                "content": "# Intuition\\nYour intuition for solving this problem is not explicitly mentioned in the comments, but it seems like you want to use dynamic programming to keep track of the maximum number of coins that can be obtained while considering the constraints given by k.\\n\\n# Approach\\nYour approach involves using dynamic programming to compute the maximum number of coins you can obtain up to the i-th pile with j chosen coins. Here\\'s a breakdown of your approach:\\n\\nInitialize a 2D vector dp of size (n + 1) x (k + 1) where n is the number of piles.\\n\\nCompute the prefix sum for each pile. This is done by iterating through each pile and accumulating the number of coins from left to right. The prefix sum is stored in the same pile vector, replacing the original values.\\n\\nUse nested loops to iterate through the dp array. The outer loop iterates over the piles (i) from 1 to n, and the inner loop iterates over the number of chosen coins (j) from 1 to k.\\n\\nWithin the inner loop, you initialize dp[i][j] to be equal to dp[i-1][j], which means you are considering not choosing any coins from the current pile.\\n\\nThen, you use another loop (x) to consider choosing from 1 to min(j, (int)piles[i - 1].size()) coins from the current pile (piles[i-1]). For each value of x, you update dp[i][j] with the maximum between its current value (dp[i][j]) and the value obtained by choosing x coins from the current pile (piles[i-1][x-1]) and adding it to the value of dp[i-1][j-x], which represents the maximum obtained from the previous piles with the remaining j-x chosen coins.\\n\\nAfter completing the loops, dp[n][k] will contain the maximum number of coins you can obtain.\\n\\nYour maxValueOfCoins function simply calls maxCoins and returns its result.\\n\\n# Complexity\\n- Time complexity:\\nO(n * k * min(j, (int)piles[i - 1].size()))\\n\\n- Space complexity:\\nO(n * k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<vector<int>>& piles, int k) {\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n \\n    for (int i = 0; i < n; i++) {\\n        int prefixSum = 0;\\n        for (int j = 0; j < piles[i].size(); j++) {\\n            prefixSum += piles[i][j];\\n            piles[i][j] = prefixSum;\\n        }\\n    }\\n    \\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = dp[i - 1][j]; \\n            \\n            for (int x = 1; x <= min(j, (int)piles[i - 1].size()); x++) {\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + piles[i - 1][x - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[n][k];\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n     return maxCoins(piles, k); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCoins(vector<vector<int>>& piles, int k) {\\n    int n = piles.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\\n \\n    for (int i = 0; i < n; i++) {\\n        int prefixSum = 0;\\n        for (int j = 0; j < piles[i].size(); j++) {\\n            prefixSum += piles[i][j];\\n            piles[i][j] = prefixSum;\\n        }\\n    }\\n    \\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = dp[i - 1][j]; \\n            \\n            for (int x = 1; x <= min(j, (int)piles[i - 1].size()); x++) {\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - x] + piles[i - 1][x - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[n][k];\\n}\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n     return maxCoins(piles, k); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023455,
                "title": "simple-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[-1] * (k + 1) for _ in range(n)]\\n\\n        def dfs(i,coins):\\n            if i==n:\\n                return 0\\n            if dp[i][coins] != -1:\\n                return dp[i][coins]\\n            dp[i][coins] = dfs(i + 1, coins) #not take\\n            curPile = 0\\n            for j in range(min(coins, len(piles[i]))):\\n                curPile += piles[i][j] \\n                dp[i][coins] = max(dp[i][coins], curPile + dfs(i + 1, coins - j - 1)) #taking the coin from same piles until it exist and checking \\n            return dp[i][coins]\\n        return dfs(0, k) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n        dp = [[-1] * (k + 1) for _ in range(n)]\\n\\n        def dfs(i,coins):\\n            if i==n:\\n                return 0\\n            if dp[i][coins] != -1:\\n                return dp[i][coins]\\n            dp[i][coins] = dfs(i + 1, coins) #not take\\n            curPile = 0\\n            for j in range(min(coins, len(piles[i]))):\\n                curPile += piles[i][j] \\n                dp[i][coins] = max(dp[i][coins], curPile + dfs(i + 1, coins - j - 1)) #taking the coin from same piles until it exist and checking \\n            return dp[i][coins]\\n        return dfs(0, k) \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1863496,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863543,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863729,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863859,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863595,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863503,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863943,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863510,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1864055,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863574,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863496,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863543,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863729,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863859,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863595,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863503,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863943,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863510,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1864055,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863574,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "LeetCode had us in the first half, not gonna lie. I was expecting a tough stack problems for the weekend "
                    },
                    {
                        "username": "krishchopra22",
                        "content": "[@kausachan](/kausachan) He\\'s saying that the questions of this month till now were either Easy or Medium-Easy. So, this was a trailer and now the real show begins \\uD83D\\uDC80"
                    },
                    {
                        "username": "kausachan",
                        "content": "so u r saying this is an easy question ?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some Tips:-\\n\\n1. Have an iterator to point at the 0th pile.\\n\\n2. At each step, we can either take from this pile or move to the next one.\\n\\n3. If we move to the next one, the number of coins left to take remains the same, so does the value of collected coins.\\n\\n4. If we decide to take coin from the current pile, we can take from 1 coin to min(len(pile),k) coins. For each case among these, we have to do recursive call with reduced k and take the maximum of take and not take case.\\n\\n5. At last, memonize this in a 2d array!."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "At step 4, you said ___\"we can take from 1 coin to min(len(pile),k) coins\"___.\\nSo do we have to make about `k` recursive calls for each value of coin that we can take at this step ?"
                    },
                    {
                        "username": "tejasX",
                        "content": "[@namandt](/namandt) thats what he mentioned in tips, if you go again to 1st pile, shouldn\\'t it be obvious to take it earlier (in first step) only?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Was just missing not pick case. But got done instantly after reading these tips. Thanks !!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Other seem to like, maybe as you have not practised dsa much yet (<10 hard questions) you are having a hard time understanding it"
                    },
                    {
                        "username": "namandt",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) what I am saying is\\nMisleading tips\\nBetter not to post these tips!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Death Note OP (L pfp)  ```<@`-@`>```"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@namandt](/namandt) Do you want me to post my solution here? They are some tips, not full solution. You can reach the solution following these tips, if you are not able to, kindly go to the solution tab  and solve more LC question before attempting hard ones"
                    },
                    {
                        "username": "namandt",
                        "content": "Also whats the point of memoizing the 2D array if in any above steps, we are not using the memoized array\\'s value"
                    },
                    {
                        "username": "namandt",
                        "content": "at each step we can take coin from any \\'i\\' th pile.\\n\\nso for each step, we start from 0th pile, we take and move ahead with reduced \\'k\\'\\nor we go to1st pile .\\n\\nyour explanation make it sound like easy which is not the case"
                    },
                    {
                        "username": "tungpham",
                        "content": "This is a very good tip. It\\'s intuitive and I was able to solve it based on this. I think the hardest part is able to formulate the idea into a recursive function. "
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "Thank you for the tip"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "Thank for giving tips it seem it will help me let me try now."
                    },
                    {
                        "username": "leetdaily11",
                        "content": "leetcode h\\u0336a\\u0336r\\u0336d\\u0336 extreme"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "This question wrecked my brain, ruined my Saturday"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "I need 15min. to just understand the `testcase-2` after that I realized that `700` is not on top of the stack that's why answer not should be `1300`."
                    },
                    {
                        "username": "Ankit_Verma03",
                        "content": "[@patilsuraj2121](/patilsuraj2121)  see, as vipul said  \"We need maximum total value.\\n\" and in the second test case, we can choose k=7 coins optimally, and clearly the last pile will give us maximum -  so, adding the elements of last pile in wallet and removing it will give the maximum sum of 706."
                    },
                    {
                        "username": "patilsuraj2121",
                        "content": "[@saqib_masood](/saqib_masood) same problem bro how it could be 706 it should be 601"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "[@saqib_masood](/saqib_masood) \\nWe need maximum total value.\\nSo, from last stack we take all the coins. and that will give maximum among all the possibilities."
                    },
                    {
                        "username": "saqib_masood",
                        "content": "Still it should be 601...how 706 came?"
                    },
                    {
                        "username": "halfengineer",
                        "content": "Weekend begins\\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "kausachan",
                        "content": "Trying  all possible combinations (Brute force) passes 77 test cases "
                    },
                    {
                        "username": "gmk92lc",
                        "content": "whats the best way to track the index of each pile? using a tuple so i can cache the results is giving me TLE at 77/122"
                    },
                    {
                        "username": "tejasX",
                        "content": "Yeah we can but we need to think of a better way if want to pass the given constraints. Some way in which we don\\'t even need to keep track of it since its way too expensive."
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "I was doing the same thing, with TLE at  77/122. Your solution made me think about this problem in a different way. Thanks"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Just respectively prepare the prefix sum for each group. And scan group by group in dp process."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "just started the question, feels like this might be similar to rod cutting problem"
                    },
                    {
                        "username": "anwendeng",
                        "content": "When using dynamic programming, reducing memory speeds up your program, in fact almost twice as fast"
                    }
                ]
            },
            {
                "id": 1863546,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1863511,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1863618,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 2036283,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 2009740,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 2008157,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1869407,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1867325,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1866029,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1865407,
                "content": [
                    {
                        "username": "JustBored",
                        "content": "tip to avoid TLE: Don't sum up array slices to add to the next dp call, just use a variable to keep track of the running sum for the current pile."
                    },
                    {
                        "username": "c4tdog",
                        "content": "medium https://leetcode.com/problems/filling-bookcase-shelves/ is harder imo"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy peasy Hard problem"
                    },
                    {
                        "username": "atr_str",
                        "content": "The key is to understand that the question requires you to find how many coins you need to pick from each pile, so write a recursive solution with memoization. Once you have it, write a DP solution. One issue is that even if your solution is formally optimal, some further code optimization may be need to pass a pretty tight time limit."
                    },
                    {
                        "username": "Siddhesh_Dhinge",
                        "content": "For those who are stuck and considering having multiple variables for maintaining each pile indices, just rotate the image and think sideways :) "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "What is the expected time & space complexity of this problem ?\\n"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Recursive approach passed 77/122 Testcases"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "unable to find where the following code is not satisfying the condition \\n\\n```class Solution {\\npublic:\\n    int solve(int index,int j,vector<vector<int>>& piles,int sum,int k){\\n        if(k==0)return 0;\\n        if(index<0)return 0;\\n        int notake=0+solve(index-1,j,piles,sum,k);\\n        int take=INT_MIN;\\n        int size=piles[index].size();\\n        int to =min(size,k);\\n        if(j<piles[index].size())\\n        take=piles[index][j]+solve(index,j+1,piles,sum,k-1);\\n\\n        return max(take,notake);\\n\\n    }\\n\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n         int n=piles.size();\\n          return solve(n-1,0,piles,0,k);\\n    }\\n};"
                    },
                    {
                        "username": "Soham_R",
                        "content": "This question is \"medium\" if you go for 3-D DP, but to convert 3-D to 2-D makes it a hard problem."
                    },
                    {
                        "username": "kausachan",
                        "content": "Can you give some extra info on how it is 3-D? what are all the changing factors?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "TC of accepted DP code is O(N*K^2) right ? How is it getting accepted ? Acc. to constraints, it should give TLE."
                    }
                ]
            },
            {
                "id": 1864474,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864458,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864085,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864021,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864010,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1864007,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863927,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863924,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863746,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863731,
                "content": [
                    {
                        "username": "saransh24",
                        "content": "Can we do it without updating piles array to prefix sum ?"
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t think prefix sum will be needed here since you will calculate the running sum only once per pile if you do it correctly"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "can anyone explain ? I have modified the second test case \\n[[1],[100],[100],[100],[100],[100],[10,1,1,1,1,1,700]] k = 5,\\nhow come the expected output is 500 ? since we need to pick coins on  top? could we skip 1 ?  "
                    },
                    {
                        "username": "andrey_linkey",
                        "content": "You can pick some coins from any pile. To get the maximum value, you have to take one coin from each piles that contains coins with a nominal value 100. This way result will be 500"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you seven piles, the middle 5 have 100 on top. Yes you can skip the first one. You can just pick the top coin from all the middle piles"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "If you\\'re like me and got a 120/122 TLE using Java with the below, \\n\\n```java\\nHashMap<Pair<Integer, Integer>, Integer> hm;\\n```\\n\\nchange it to a 2-D int array. That was enough. The problem is that Pair is actually a pretty heavy data structure in terms of time, even though the big-O complexity doesn\\'t change. "
                    },
                    {
                        "username": "UltraNuX",
                        "content": "This is my first day, Im tryin to understand how to understand questions, I dont understand what needs to be done."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "If you are new to leetcode, don\\'t do daily challenge in the beginning, try to solve easy problems first :)"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Spent a Saturday afternoon on it and it timed out at 103/122, how frustrating is that?"
                    },
                    {
                        "username": "thenaitrise",
                        "content": "its gonna be interesting Saturday..."
                    },
                    {
                        "username": "ShubhamPitale",
                        "content": "Can anyone help me to know what is the issue with this solution. I have passed 30 testcases and  also compared it with the original solution but not able to find my fault.\n\n `class Solution {\npublic:\n    int solve(int ind,vector<vector<int>>&piles,int k)\n    {\n\n        if(k==0)\n        {\n            return 0;\n        }\n\n        if(ind<0)\n        {\n            return -1e8;\n        }\n\n        // if(dp[ind][k]!=-1)return dp[ind][k];\n\n        int notTake=solve(ind-1,piles,k);\n        int take=INT_MIN;\n        if(piles[ind].size()>0)\n        {\n            int a=piles[ind][0];\n            piles[ind].erase(piles[ind].begin());\n            take=a+max(solve(ind-1,piles,k-1),solve(ind,piles,k-1));\n        }\n\n        return max(notTake,take);\n    }\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\n        int n=piles.size();\n        // vector<vector<int>>dp(n+1,vector<int>(k+2,-1));\n        return solve(n-1,piles,k);\n    }\n};`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "An easy hard problem. Prepare prefix sum for each group of piles and then search the best result with O(n*k) tc."
                    },
                    {
                        "username": "ayushnemmaniwar12",
                        "content": "What we can do if we have -ve numbers in 2d vector. what would be the base cndtn"
                    },
                    {
                        "username": "namandt",
                        "content": "instead of focusing on solving the problem. I need to first figure out how do I handle the given \\'vectors\\' that have first elements as the top of \\'ith\\' pile.\\n\\nNice going leetcode"
                    }
                ]
            },
            {
                "id": 1863698,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863569,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863550,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863542,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863532,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863516,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863515,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863499,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1863977,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            },
            {
                "id": 1767382,
                "content": [
                    {
                        "username": "user1467TF",
                        "content": " `class Solution {\\npublic:\\n    int solve(vector<vector<int>>& piles, int k, int maxi, int idx){\\n        if(k == 0 || idx == piles.size())\\n            return maxi;\\n        int sum = 0;\\n        for(int i = 0; i < piles[idx].size() && k > 0; i++, k--){\\n            // cout<<maxi<<\" \"<<sum<<\" \"<<idx<<\" \"<<k<<endl;\\n            maxi = max(maxi, solve(piles, k, maxi + sum, idx + 1));\\n            sum += piles[idx][i];\\n        }\\n        return maxi;\\n    }\\n    int maxValueOfCoins(vector<vector<int>>& piles, int k) {\\n        return solve(piles, k, 0, 0);\\n    }\\n};`\\n\\ni don\\'t understand why this code is not working, can anyone please help me for the same"
                    },
                    {
                        "username": "surajku2022",
                        "content": "Can anyone explain me example 2. In the example answer shouldn\\'t be 1300 ? For k=7 if we take all the top element from every piles this will contain 7 coins and will result in maximum value."
                    },
                    {
                        "username": "yash_raileet",
                        "content": "700 is not at the top its at the bottom of the stack  ..and we have to choose exactly k coins,, so if we take 100 from 6 piles then you can take 1 only from last pile so answer will be 601 . So its better to take all 7 coins from last pile which will give 706 ."
                    },
                    {
                        "username": "RomanchenkoAS",
                        "content": "In the 2nd example you can either pull 7 coins from the last pile (starting from the top one and one by one until the last) and get a total of 706 or take all the hundreds from the first couple of piles followed with a '1' from the last pile and get a total of 601\nFirst option is optimal "
                    },
                    {
                        "username": "staticvoidleet",
                        "content": "you can\\'t randomly pick any coin in the pile unless it is the top one"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "you can only take k elements even if they are in separate piles."
                    },
                    {
                        "username": "aminity",
                        "content": "Is there any condition that we can use only k moves ? Because leetcode didnt mention that"
                    },
                    {
                        "username": "charonme",
                        "content": "the problem statement ends with \"...if you choose exactly k coins optimally.\" "
                    },
                    {
                        "username": "daring-calf",
                        "content": "stack + dp = hard"
                    },
                    {
                        "username": "pkafka",
                        "content": "Any tips for the best approach? type of data structure or algorithm to best tackle it without giving the solution away would be much appreciated."
                    },
                    {
                        "username": "kyuhyunp",
                        "content": "I don\\'t know if you still need help but considering brute force would help the most"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "A hard one, here we go..."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem just blew my mind as well as my weekend."
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "How is example 2 correct? Can\\'t we choose the 100s from the other piles? The answer can be 1300?"
                    },
                    {
                        "username": "charonme",
                        "content": "[@infinx25](/infinx25) it does say \"if you choose exactly k coins optimally\""
                    },
                    {
                        "username": "kausachan",
                        "content": "basically piles are stack DS so u can only do pop operation and that too pop operation can only be performed for a maximum of k times"
                    },
                    {
                        "username": "aminity",
                        "content": "I guess Leetcode forgot to mention that moves are also limited to k moves\\n"
                    },
                    {
                        "username": "Movsar",
                        "content": "If you take 100s from first 6 piles you can take only 1 from last pile. Max here will 601\\n\\nIt is better to take all 7 from last pile. Max here will be 6 + 700 = 706"
                    },
                    {
                        "username": "RightHandElf",
                        "content": "The 700 is at the bottom of its stack, not the top."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well this question is one of the easy ones, it\\'s the tag that made us think it\\'s hard "
                    },
                    {
                        "username": "kausachan",
                        "content": "If you\\'re in touch with DP then yes TRUE"
                    },
                    {
                        "username": "VishuKalier",
                        "content": "[leetcode](https://leetcode.com) `public int MaximizedOptimalChoice(List<List<Integer>> coins, int k)\\n    {\\n        int total = 0, sum = 0;     // Sum and the total number of coins in the piles...\\n        int[] dp = new int[coins.size()];    // Creating a DP Array to represent each pile...\\n        for(int i = 0; i < dp.length; i++)\\n        {\\n            dp[i] = coins.get(i).size() - 1;  // Updating the DP Array with the size of each pile to get the lowest coin of every pile...\\n            total = total + coins.get(i).size();\\n        }\\n        for(int i = 0; i < coins.size(); i++)\\n        {\\n            for(int j = 0; j < coins.get(i).size(); j++)\\n                sum = sum + coins.get(i).get(j);    // Summing up the value of all coins...\\n        }\\n        for(int count = 0; count < (total - k); count++)\\n        {   // Now we will remove n - k coins to get exactly k coins left...\\n            int last = 1000000, index = 0;\\n            for(int i = 0; i < dp.length; i++)\\n            {\\n                if((dp[i] >= 0) && (coins.get(i).get(dp[i]) < last))\\n                {   // If the last coin in current pile is lower...\\n                    index = i;     // Update the index of the pile, the current index of the DP Array will give the last element of that pile...\\n                    last = coins.get(i).get(dp[i]);\\n                }\\n            }\\n            sum = sum - coins.get(index).get(dp[index]);   // We remove that coin from the pile and reduce the sum respectively...\\n            dp[index]--;       // Reducing the pile...\\n        }\\n        return sum;    // Returning the evaluated sum...\\n    }`\\nCan anyone please tell me what is the error I tried a unique way to find out the answer but it passed 57/122 test cases. please help."
                    }
                ]
            }
        ]
    }
]