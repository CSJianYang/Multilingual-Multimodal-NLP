[
    {
        "title": "First Missing Positive",
        "question_content": "Given an unsorted integer array nums, return the smallest missing positive integer.\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-231 <= nums[i] <= 231 - 1",
        "solutions": [
            {
                "id": 17071,
                "title": "my-short-c-solution-o-1-space-and-o-n-time",
                "content": "\\nPut each number in its right place.\\n\\nFor example:\\n\\nWhen we find 5, then swap it with A[4].\\n\\nAt last, the first place where its number is not right, return the place + 1.\\n\\n    class Solution\\n    {\\n    public:\\n        int firstMissingPositive(int A[], int n)\\n        {\\n            for(int i = 0; i < n; ++ i)\\n                while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\\n                    swap(A[i], A[A[i] - 1]);\\n            \\n            for(int i = 0; i < n; ++ i)\\n                if(A[i] != i + 1)\\n                    return i + 1;\\n            \\n            return n + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        int firstMissingPositive(int A[], int n)\\n        {\\n            for(int i = 0; i < n; ++ i)\\n                while(A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i])\\n                    swap(A[i], A[A[i] - 1]);\\n            \\n            for(int i = 0; i < n; ++ i)\\n                if(A[i] != i + 1)\\n                    return i + 1;\\n            \\n            return n + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17080,
                "title": "python-o-1-space-o-n-time-solution-with-explanation",
                "content": "     def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n         Basic idea:\\n        1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \\n            so we only have to care about those elements in this range and remove the rest.\\n        2. we can use the array index as the hash to restore the frequency of each number within \\n             the range [1,...,l+1] \\n        \"\"\"\\n        nums.append(0)\\n        n = len(nums)\\n        for i in range(len(nums)): #delete those useless elements\\n            if nums[i]<0 or nums[i]>=n:\\n                nums[i]=0\\n        for i in range(len(nums)): #use the index as the hash to record the frequency of each number\\n            nums[nums[i]%n]+=n\\n        for i in range(1,len(nums)):\\n            if nums[i]/n==0:\\n                return i\\n        return n",
                "solutionTags": [],
                "code": "     def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n         Basic idea:\\n        1. for any array whose length is l, the first missing positive must be in range [1,...,l+1], \\n            so we only have to care about those elements in this range and remove the rest.\\n        2. we can use the array index as the hash to restore the frequency of each number within \\n             the range [1,...,l+1] \\n        \"\"\"\\n        nums.append(0)\\n        n = len(nums)\\n        for i in range(len(nums)): #delete those useless elements\\n            if nums[i]<0 or nums[i]>=n:\\n                nums[i]=0\\n        for i in range(len(nums)): #use the index as the hash to record the frequency of each number\\n            nums[nums[i]%n]+=n\\n        for i in range(1,len(nums)):\\n            if nums[i]/n==0:\\n                return i\\n        return n",
                "codeTag": "Python3"
            },
            {
                "id": 17214,
                "title": "java-simple-solution-with-documentation",
                "content": "This code takes advantage of two insights: \\n\\n 1. Numbers greater then n can be ignored because the missing integer must be in the range 1..n+1\\n 2. If each cell in the array were to contain positive integers only, we can use the negative of the stored number as a flag to mark something (in this case the flag indicates this index was found in some cell of the array)\\n\\n        public class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            int n = nums.length;\\n            \\n            // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \\n            // (we can ignore those because if all number are > n then we'll simply return 1)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= 0 || nums[i] > n) {\\n                    nums[i] = n + 1;\\n                }\\n            }\\n            // note: all number in the array are now positive, and on the range 1..n+1\\n            \\n            // 2. mark each cell appearing in the array, by converting the index for that number to negative\\n            for (int i = 0; i < n; i++) {\\n                int num = Math.abs(nums[i]);\\n                if (num > n) {\\n                    continue;\\n                }\\n                num--; // -1 for zero index based array (so the number 1 will be at pos 0)\\n                if (nums[num] > 0) { // prevents double negative operations\\n                    nums[num] = -1 * nums[num];\\n                }\\n            }\\n            \\n            // 3. find the first cell which isn't negative (doesn't appear in the array)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] >= 0) {\\n                    return i + 1;\\n                }\\n            }\\n            \\n            // 4. no positive numbers were found, which means the array contains all numbers 1..n\\n            return n + 1;\\n        }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            int n = nums.length;\\n            \\n            // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) \\n            // (we can ignore those because if all number are > n then we'll simply return 1)\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= 0 || nums[i] > n) {\\n                    nums[i] = n + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17083,
                "title": "o-1-space-java-solution",
                "content": "The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue.\\n\\n    public class Solution {\\n        public int firstMissingPositive(int[] A) {\\n            int i = 0;\\n            while(i < A.length){\\n                if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;\\n                else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);\\n                else i++;\\n            }\\n            i = 0;\\n            while(i < A.length && A[i] == i+1) i++;\\n            return i+1;\\n        }\\n        \\n        private void swap(int[] A, int i, int j){\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] A) {\\n            int i = 0;\\n            while(i < A.length){\\n                if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;\\n                else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);\\n                else i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17073,
                "title": "share-my-o-n-time-o-1-space-solution",
                "content": "## Share my O(n)/O(1) solution ##\\n\\n----------\\nThe basic idea is ***for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]***. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. \\n\\n----------\\n\\n 1. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. \\n 2. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0<=i<=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds.\\n 3. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn't exist, which is what I want.\\n\\n----------\\n\\n     public int firstMissingPositive(int[] A) {\\n        int n=A.length;\\n        if(n==0)\\n            return 1;\\n        int k=partition(A)+1;\\n        int temp=0;\\n        int first_missing_Index=k;\\n        for(int i=0;i<k;i++){\\n            temp=Math.abs(A[i]);\\n            if(temp<=k)\\n                A[temp-1]=(A[temp-1]<0)?A[temp-1]:-A[temp-1];\\n        }\\n        for(int i=0;i<k;i++){\\n            if(A[i]>0){\\n                first_missing_Index=i;\\n                break;\\n            }\\n        }\\n        return first_missing_Index+1;\\n    }\\n    \\n    public int partition(int[] A){\\n        int n=A.length;\\n        int q=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>0){\\n                q++;\\n                swap(A,q,i);\\n            }\\n        }\\n        return q;\\n    }\\n    \\n    public void swap(int[] A, int i, int j){\\n        if(i!=j){\\n            A[i]^=A[j];\\n            A[j]^=A[i];\\n            A[i]^=A[j];\\n        }\\n    }",
                "solutionTags": [],
                "code": "## Share my O(n)/O(1) solution ##\\n\\n----------\\nThe basic idea is ***for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]***. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. \\n\\n----------\\n\\n 1. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. \\n 2. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0<=i<=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds.\\n 3. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn't exist, which is what I want.\\n\\n----------\\n\\n     public int firstMissingPositive(int[] A) {\\n        int n=A.length;\\n        if(n==0)\\n            return 1;\\n        int k=partition(A)+1;\\n        int temp=0;\\n        int first_missing_Index=k;\\n        for(int i=0;i<k;i++){\\n            temp=Math.abs(A[i]);\\n            if(temp<=k)\\n                A[temp-1]=(A[temp-1]<0)?A[temp-1]:-A[temp-1];\\n        }\\n        for(int i=0;i<k;i++){\\n            if(A[i]>0){\\n                first_missing_Index=i;\\n                break;\\n            }\\n        }\\n        return first_missing_Index+1;\\n    }\\n    \\n    public int partition(int[] A){\\n        int n=A.length;\\n        int q=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>0){\\n                q++;\\n                swap(A,q,i);\\n            }\\n        }\\n        return q;\\n    }\\n    \\n    public void swap(int[] A, int i, int j){\\n        if(i!=j){\\n            A[i]^=A[j];\\n            A[j]^=A[i];\\n            A[i]^=A[j];\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 781724,
                "title": "c-simple-5-line-solution-o-n-time-and-o-1-space",
                "content": "We only need to keep track of which ones of the first n positive integers occur in the array. To do this with no extra space, we can treat the array like a boolean array, where sign(arr[i]) indicates whether the i-th positive integer is present or not. First, we replace all non-positive values with n + 1, since we\\'ll only use these indices as storage space. Then, for every one of the first n positive numbers in the array, we turn the value at their corresponding index negative. Finally, all we need to do is check for the first positive value, which will give us the first missing positive. If we find no such index, then all natural numbers up to n are present, so we return n + 1.\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) if (nums[i] <= 0) nums[i] = n + 1;\\n        for (int i = 0; i < n; i++) if (abs(nums[i]) <= n && nums[abs(nums[i]) - 1] > 0) nums[abs(nums[i]) - 1] *= -1;\\n        for (int i = 0; i < n; i++) if (nums[i] > 0) return i + 1;\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) if (nums[i] <= 0) nums[i] = n + 1;\\n        for (int i = 0; i < n; i++) if (abs(nums[i]) <= n && nums[abs(nums[i]) - 1] > 0) nums[abs(nums[i]) - 1] *= -1;\\n        for (int i = 0; i < n; i++) if (nums[i] > 0) return i + 1;\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767105,
                "title": "short-c-o-n-time-o-1-space-steps-explained",
                "content": "**Approach :** \\nIt is evident that the answer lies between ```[1,n+1]```. So bring all the elements to their respective position\\ni.e if the element is 3 bring it to 3rd position or 2nd index.\\nfor example if the array is ```[3,1,-4,7]``` let\\'s say it is nums.\\niterate through the array and **neglect the element if it is greater than n or leass than equal to 0**.\\notherwise bring it to its position by swapping using condition ```while(nums[i]!=nums[nums[i]-1])```.\\n1. at index 0 ```3 != nums[3-1]``` hence swap and the array becomes ```[-4,1,3,7]```\\n2. now at index 0 value is negative hence neglect and move forward.\\n3. at index 1 ```1!=nums[1-1]``` hence swap now the array becomes ```[1,-4,3,7]```\\n4. now at index 1 value is negative hence neglect and move forward.\\n5. at index 2 ```3==nums[3-1]``` the condition is true and 3 is at right position hence neglect and move forward.\\n6. at index 3 value is 7 which is greater than n hence neglect\\n\\nSo the final array is ```[1,-4,3,7]```\\nnow iterate through this array and find the first index for which ```nums[i]!=i+1``` or the element which is not at correct position.\\nthis is the answer so in ```[1,-4,3,7]``` ans is 2.\\n\\n**so you have to swap if** ```nums[i]!=nums[nums[i]-1]``` along with the condition  ```0<nums[i]<=n``` **for all the index.**\\n\\npls Upvote if you like it...\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            while(nums[i]>0 and nums[i]<=n and nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        }\\n        for(int i=0 ; i<n ; i++) if(nums[i] != i+1) return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```[1,n+1]```\n```[3,1,-4,7]```\n```while(nums[i]!=nums[nums[i]-1])```\n```3 != nums[3-1]```\n```[-4,1,3,7]```\n```1!=nums[1-1]```\n```[1,-4,3,7]```\n```3==nums[3-1]```\n```[1,-4,3,7]```\n```nums[i]!=i+1```\n```[1,-4,3,7]```\n```nums[i]!=nums[nums[i]-1]```\n```0<nums[i]<=n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            while(nums[i]>0 and nums[i]<=n and nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n        }\\n        for(int i=0 ; i<n ; i++) if(nums[i] != i+1) return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872448,
                "title": "python-o-n-solution-with-constant-space-explained-with-clear-train-of-thoughts",
                "content": "\\u2014\\u2014Jump to the final code if you\\'re easly bored, down below!\\n\\nOk, you\\'re still here eh. Here are the train of thoughts to arrive to the final solution:\\n\\n* The answer is always between `1` to `length of nums + 1`. Why? Because the biggest positive integer we can put as answer for the input of length n, is when the input is `[1, 2, 3, ..., n]`, in that case the answer is `n+1`. Otherwise, if the input is not exactly as mentioned (in any order), then the answer must be a positive integer that is less than `n+1`. \\n\\n* Given that the answer is limited to said range, then we can simply solve this with linear time and linear space. We can create a `flag` booleans that indicate whether an `index` is appearing in the `nums` or not. See simple code below!\\n```Python\\nflags = [False] * len(nums)\\n\\nfor num in nums:\\n\\tif num > 0:\\n\\t\\tflags[num-1] = True // notice that we -1, so that the answer set 1..n becomes 0-indexed 0..n-1\\n\\t\\t\\nfor index in range(len(flags)):\\n\\tif flags[index] == False:\\n\\t\\treturn index + 1\\n\\t\\t\\nreturn len(nums) + 1 // happens when all flags are true\\n```\\n\\n* Now, how do we improve this to be a better solution with constant additional space? In other words, how to get rid of the additional booleans? You can probably guess it already. Yes by using the original `nums` array as flags. \\n\\n* Let say we flag it by changing the value in `index` to `None` if it\\'s appearing in `nums`. Problem? Yes, we still need to retain the original values in `nums`, because as we loop over the `nums` to flag the `index`, we will definitely get in trouble if the `index` we\\'re flagging hasn\\'t been evaluated yet. Take an example of `[3,1,2]` (which supposed to have the answer `4`), here is how the `nums` array is being evaluated, in each loop-step:\\n** Before loop: `[3,1,2]`\\n** Loop at index 0: `[3, 1, None]`. The `index` that `3` points to is index `2`, therefore the value becomes `None`.  This is the part where we change index `2`, while index `2` itself hasn\\'t been evaluated yet.\\n** Loop at index 1: `[None, 1, None]`. The `index` that `1` points to is index `0`, therefore the value becomes `None`.\\n** Loop at index 2: `[None, 1, None]`. At this step, it\\'s doing nothing because the original value of `2` has already been changed to `None`, and we have no way to flag index `1` as `None`.\\n\\n*  So how do we flag elements in `nums` while also retaining original `value` **that matters**? Notice I mentioned \\'that matters\\', because we only care about positive integers. We can simply discard anything that is not positive integers. And because of that, we can use positive and negative value as flag\\u2014multiply the value with `-1` to flag it so it becomes negative. So positive means hasn\\'t been flagged, negative means has been flagged. Whether it\\'s positive or negative, we can get the original value with `abs`. So for above example, the correct steps would be:\\n** Before loop: `[3, 1, 2]`\\n** Loop at index 0: `[3, 1, -2]`\\n** Loop at index 1: `[-3, 1, -2]`\\n** Loop at index 2: `[-3, -1, -2]`\\nAnd finally when we\\'re looking for the answer, we find that all the values are negative (flagged), therefore the answer is `4`.\\n\\n* Final thoughts: what about those zeros and negative nums??? Simply change them to 0 before entering the main algorithm explained above. We just need to be careful not to multiply those zeros to `-1` when flagging, instead change it to something like `-inf` (as long as it\\'s a negative value, then it\\'s flagged) \\n\\nHere is the final full code:\\n```python\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n\\tfor i,num in enumerate(nums):\\n\\t\\tif num <= 0:\\n\\t\\t\\tnums[i] = 0\\n\\n\\tfor i,num in enumerate(nums):\\n\\t\\tindex = abs(num)-1\\n\\t\\tif index >= 0 and index < len(nums):\\n\\t\\t\\tif nums[index] == 0:\\n\\t\\t\\t\\tnums[index] = -inf\\n\\t\\t\\telif nums[index] > 0: // we dont want to make negative to be positive again, when its duplicated num\\n\\t\\t\\t\\tnums[index] *= -1\\n\\n\\tfor index,num in enumerate(nums):\\n\\t\\tif num >= 0:\\n\\t\\t\\treturn index + 1\\n\\n\\treturn len(nums) + 1\\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\nPlease upvote if you find this useful, comment if you find any improvement points!\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nflags = [False] * len(nums)\\n\\nfor num in nums:\\n\\tif num > 0:\\n\\t\\tflags[num-1] = True // notice that we -1, so that the answer set 1..n becomes 0-indexed 0..n-1\\n\\t\\t\\nfor index in range(len(flags)):\\n\\tif flags[index] == False:\\n\\t\\treturn index + 1\\n\\t\\t\\nreturn len(nums) + 1 // happens when all flags are true\\n```\n```python\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n\\tfor i,num in enumerate(nums):\\n\\t\\tif num <= 0:\\n\\t\\t\\tnums[i] = 0\\n\\n\\tfor i,num in enumerate(nums):\\n\\t\\tindex = abs(num)-1\\n\\t\\tif index >= 0 and index < len(nums):\\n\\t\\t\\tif nums[index] == 0:\\n\\t\\t\\t\\tnums[index] = -inf\\n\\t\\t\\telif nums[index] > 0: // we dont want to make negative to be positive again, when its duplicated num\\n\\t\\t\\t\\tnums[index] *= -1\\n\\n\\tfor index,num in enumerate(nums):\\n\\t\\tif num >= 0:\\n\\t\\t\\treturn index + 1\\n\\n\\treturn len(nums) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17161,
                "title": "python-o-n-and-o-nlgn-solutions",
                "content": "        \\n    # O(n) time\\n    def firstMissingPositive(self, nums):\\n        for i in xrange(len(nums)):\\n            while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\\n                tmp = nums[i]-1\\n                nums[i], nums[tmp] = nums[tmp], nums[i]\\n        for i in xrange(len(nums)):\\n            if nums[i] != i+1:\\n                return i+1\\n        return len(nums)+1\\n        \\n    # O(nlgn) time\\n    def firstMissingPositive(self, nums):\\n        nums.sort()\\n        res = 1\\n        for num in nums:\\n            if num == res:\\n                res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # O(n) time\\n    def firstMissingPositive(self, nums):\\n        for i in xrange(len(nums)):\\n            while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\\n                tmp = nums[i]-1\\n                nums[i], nums[tmp] = nums[tmp], nums[i]\\n        for i in xrange(len(nums)):\\n            if nums[i] != i+1:\\n                return i+1\\n        return len(nums)+1\\n        \\n    # O(nlgn) time\\n    def firstMissingPositive(self, nums):\\n        nums.sort()\\n        res = 1\\n        for num in nums:\\n            if num == res:\\n                res += 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 858526,
                "title": "cyclic-sort-explained",
                "content": "All the questions where we need to find the repeating numbers, or missing numbers can easily be solved with the help of a pattern that is cyclic sort. In this pattern we simply place the elements of the array on their positions( or at least try to ), like 1 should be at 1st position and 2 at the second position, and then we iterate again and check if for any index we have an element whose value is not equal to index + 1, then that is the missing number.\\n\\nYou can follow this link to learn [more](https://emre.me/coding-patterns/cyclic-sort/)\\n\\nIn this question we can simply ignore the -ve elements as we only need to find the smallest positive element, so we ignore elements that are less than 0 and greater than arrays length and swap only if the element is not at its correct posiition. Then we iterate again and find the missing number and return it.\\n\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        while( i < nums.length){\\n            if(nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(i = 0;i<nums.length;i++){\\n            if(nums[i] != i + 1){\\n                return i + 1;\\n            }\\n        }\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        while( i < nums.length){\\n            if(nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(i = 0;i<nums.length;i++){\\n            if(nums[i] != i + 1){\\n                return i + 1;\\n            }\\n        }\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17126,
                "title": "beat-100-fast-elegant-java-index-based-solution-with-explanation",
                "content": "The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index.\\n\\n    public int firstMissingPositive(int[] nums) {\\n\\n\\t\\tint i = 0, n = nums.length;\\n\\t\\twhile (i < n) {\\n            // If the current value is in the range of (0,length) and it's not at its correct position, \\n            // swap it to its correct position.\\n            // Else just continue;\\n\\t\\t\\tif (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])\\n\\t\\t\\t\\tswap(nums, i, nums[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint k = 1;\\n\\n        // Check from k=1 to see whether each index and value can be corresponding.\\n\\t\\twhile (k < n && nums[k] == k)\\n\\t\\t\\tk++;\\n\\n        // If it breaks because of empty array or reaching the end. K must be the first missing number.\\n\\t\\tif (n == 0 || k < n)\\n\\t\\t\\treturn k;\\n\\t\\telse   // If k is hiding at position 0, K+1 is the number. \\n\\t\\t\\treturn nums[0] == k ? k + 1 : k;\\n\\n\\t}\\n\\n\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\tint temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index.\\n\\n    public int firstMissingPositive(int[] nums) {\\n\\n\\t\\tint i = 0, n = nums.length;\\n\\t\\twhile (i < n) {\\n            // If the current value is in the range of (0,length) and it's not at its correct position, \\n            // swap it to its correct position.\\n            // Else just continue;\\n\\t\\t\\tif (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])\\n\\t\\t\\t\\tswap(nums, i, nums[i]);\\n\\t\\t\\telse\\n\\t\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tint k = 1;\\n\\n        // Check from k=1 to see whether each index and value can be corresponding.\\n\\t\\twhile (k < n && nums[k] == k)\\n\\t\\t\\tk++;\\n\\n        // If it breaks because of empty array or reaching the end. K must be the first missing number.\\n\\t\\tif (n == 0 || k < n)\\n\\t\\t\\treturn k;\\n\\t\\telse   // If k is hiding at position 0, K+1 is the number. \\n\\t\\t\\treturn nums[0] == k ? k + 1 : k;\\n\\n\\t}\\n\\n\\tprivate void swap(int[] nums, int i, int j) {\\n\\t\\tint temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 17168,
                "title": "a-very-nice-solution-from-ants-aasma-stackoverflow",
                "content": "time complexity is O(N) and space complexity is O(1). <br>\\nLink: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list <br>\\nPosted by Ants Aasma on Oct 20 '09.\\n\\nThe code is pasted here: <br>\\n\\n    #Pass 1, move every value to the position of its value\\n    for cursor in range(N): \\n        target = array[cursor]\\n        while target < N and target != array[target]:\\n            new_target = array[target]\\n            array[target] = target\\n            target = new_target\\n    \\n    #Pass 2, find first location where the index doesn't match the value\\n    for cursor in range(N):\\n        if array[cursor] != cursor:\\n            return cursor\\n    return N",
                "solutionTags": [],
                "code": "time complexity is O(N) and space complexity is O(1). <br>\\nLink: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list <br>\\nPosted by Ants Aasma on Oct 20 '09.\\n\\nThe code is pasted here: <br>\\n\\n    #Pass 1, move every value to the position of its value\\n    for cursor in range(N): \\n        target = array[cursor]\\n        while target < N and target != array[target]:\\n            new_target = array[target]\\n            array[target] = target\\n            target = new_target\\n    \\n    #Pass 2, find first location where the index doesn't match the value\\n    for cursor in range(N):\\n        if array[cursor] != cursor:\\n            return cursor\\n    return N",
                "codeTag": "Unknown"
            },
            {
                "id": 3765193,
                "title": "cycle-sort-o-n-o-1-easy-java-solution-detailed-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a hard question, because it is hidden in the question, that cycle sort will be used in solving this. Once, you can see why cycle sort will be used and how it will be used, this becomes easy. :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, basically we are gonna apply cycle sort, but we will ignore negative elements, because positive element is asked in the question. Also, we will ignore all those elements who values are greater than the size of the array. In this way, the first element in the array which is not present in its correct position (index), will be the answer.\\nWhat I mean by correct position is that, in cycle sort, in this question, if we follow the above approach, then index 0 will have element whose value is 1, index 1 will have 2, index 2 will have 3 and so on, and the first element to break this rule, that index, plus 1 will be our answer, because at that index the correct element which was to exist there was an element whose value is index + 1, but if there is some incorrect element present, then index + 1 element is the first missing positive and hence it is the answer.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    \\n        //the first two conditions in the if statement take care \\n        //that negatives and elements greater than the size of \\n        //the array are ignored, while applying cycle sort, and \\n        //rest is the similar code of cycle sort\\n\\n        int i = 0;\\n        while(i < nums.length) {\\n            int correct = nums[i] - 1;\\n            if(nums[i] <= nums.length && nums[i] > 0 && nums[i] != nums[correct]) {\\n\\n                int temp = nums[i];\\n                nums[i] = nums[correct];\\n                nums[correct] = temp;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n\\n    //after cycle sort has been applied, we will find the first element\\n    //which is not at the correct index, and return that index + 1\\n\\n        for(int j = 0; j < nums.length; j++) {\\n\\n            if(nums[j] != j + 1) {\\n                return j + 1;\\n            }\\n        }\\n\\n    //if every element is at its correct index, then obviously the first\\n    //missing positive integer is nums.length + 1\\n\\n        return nums.length + 1;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/534c581c-ce0e-4b09-8c2e-40e316fe3417_1689353156.4622288.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    \\n        //the first two conditions in the if statement take care \\n        //that negatives and elements greater than the size of \\n        //the array are ignored, while applying cycle sort, and \\n        //rest is the similar code of cycle sort\\n\\n        int i = 0;\\n        while(i < nums.length) {\\n            int correct = nums[i] - 1;\\n            if(nums[i] <= nums.length && nums[i] > 0 && nums[i] != nums[correct]) {\\n\\n                int temp = nums[i];\\n                nums[i] = nums[correct];\\n                nums[correct] = temp;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n\\n    //after cycle sort has been applied, we will find the first element\\n    //which is not at the correct index, and return that index + 1\\n\\n        for(int j = 0; j < nums.length; j++) {\\n\\n            if(nums[j] != j + 1) {\\n                return j + 1;\\n            }\\n        }\\n\\n    //if every element is at its correct index, then obviously the first\\n    //missing positive integer is nums.length + 1\\n\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17135,
                "title": "java-solution-with-integers-encode-trick-explained",
                "content": "This is not the most concise solution but it has one trick that may be useful for many beginners that allows to encode two integers into one with possibility to decode it to both integers back. Once you know it you will always use it as it allows to avoid tuples of integers (as java lacks such structure in its libraries) and use just one integer to represent two.\\n\\nSo, if we have two integers `k` and `m` and `m` is always less than some `n` - we can encode both into one integer using formula:\\n\\n    r = k * n + m\\n    (m < n)\\n\\nand now to retrieve them use the following:\\n\\n    k = r / n\\n    m = r % n\\n\\nAnd just to repeat: this trick is possible only if `m` is strictly less than `n`\\n\\nUsing this trick we can solve many interview tasks that require constant space and have some array which contains integers less than size or array `n`. If this array requires some extra information for every item, but we cannot loose the initial item value - this can be solved either creating new array (simple) or just encoding initial value and new value directly in the array.\\n\\n**Turning back to the task:** \\n\\nWe want to \"seriallize\" all values to their indices. So \"1\" will come to `nums[0]`, \"2\" - `nums[1]` etc. After this we can easily find the \"gap\". This is an easy task if we could use extra memory for another array. But we cannot. So we can use the \"encoding\" scheme offered above:\\n\\n1.clean every non-relevant item from the array to match the restriction `m < n`:\\n \\n\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n         if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n    }\\n2.Encode all items to their matching positions:\\n\\n    int m = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        // retrieve the value that initially was at index i (it could be overwritten by encoding)\\n        int prev = nums[i] % m;\\n        if (prev > 0) \\n            // encode it using formula k * n + m, where for 'm' we also use decoding schema\\n            nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n    }\\n\\n3.Find the gap:\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] / m != i + 1) return i + 1;\\n    }\\n\\nAll in one:\\n\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        int m = n + 1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int prev = nums[i] % m;\\n            if (prev > 0) \\n                nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] / m != i + 1) return i + 1;\\n        }\\n        return m;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This is not the most concise solution but it has one trick that may be useful for many beginners that allows to encode two integers into one with possibility to decode it to both integers back. Once you know it you will always use it as it allows to avoid tuples of integers (as java lacks such structure in its libraries) and use just one integer to represent two.\\n\\nSo, if we have two integers `k` and `m` and `m` is always less than some `n` - we can encode both into one integer using formula:\\n\\n    r = k * n + m\\n    (m < n)\\n\\nand now to retrieve them use the following:\\n\\n    k = r / n\\n    m = r % n\\n\\nAnd just to repeat: this trick is possible only if `m` is strictly less than `n`\\n\\nUsing this trick we can solve many interview tasks that require constant space and have some array which contains integers less than size or array `n`. If this array requires some extra information for every item, but we cannot loose the initial item value - this can be solved either creating new array (simple) or just encoding initial value and new value directly in the array.\\n\\n**Turning back to the task:** \\n\\nWe want to \"seriallize\" all values to their indices. So \"1\" will come to `nums[0]`, \"2\" - `nums[1]` etc. After this we can easily find the \"gap\". This is an easy task if we could use extra memory for another array. But we cannot. So we can use the \"encoding\" scheme offered above:\\n\\n1.clean every non-relevant item from the array to match the restriction `m < n`:\\n \\n\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n         if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n    }\\n2.Encode all items to their matching positions:\\n\\n    int m = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        // retrieve the value that initially was at index i (it could be overwritten by encoding)\\n        int prev = nums[i] % m;\\n        if (prev > 0) \\n            // encode it using formula k * n + m, where for 'm' we also use decoding schema\\n            nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n    }\\n\\n3.Find the gap:\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] / m != i + 1) return i + 1;\\n    }\\n\\nAll in one:\\n\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        int m = n + 1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0 || nums[i] > n) nums[i] = 0;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int prev = nums[i] % m;\\n            if (prev > 0) \\n                nums[prev - 1] = (prev * m) + nums[prev - 1] % m;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] / m != i + 1) return i + 1;\\n        }\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17286,
                "title": "my-c-solution-4-ms",
                "content": "    class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1==nums[i]) continue;\\n                int x = nums[i];\\n                while(x>=1 && x<=nums.size() && x!=nums[x-1]){\\n                    swap(x, nums[x-1]);\\n                }\\n            }\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1!=nums[i])    return i+1;\\n            }\\n            return nums.size()+1;\\n        }\\n    };\\n\\nSince we can not use extra space, so thinking about using the nums vector itself to record a positive number occurred.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            for(int i=0; i<nums.size(); i++){\\n                if(i+1==nums[i]) continue;\\n                int x = nums[i];\\n                while(x>=1 && x<=nums.size() && x!=nums[x-1]){\\n                    swap(x, nums[x-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17204,
                "title": "o-n-time-o-1-space-c",
                "content": "Idea is to swap each positive integer you encounter to its \"rightful\" place at index (x-1) where x is the integer. It's O(n) because you visit each integer in at most 2 unique loop iterations. \\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            int i,j;\\n            for(i=0;i<n;i++){\\n                int cur=A[i];\\n                // if in place or non-pos or out of bounds, skip.\\n                if(cur==i+1||cur<=0||cur>n)continue;\\n                swap(A[i],A[cur-1]);\\n                // if not the same, then reprocess it.\\n                if(A[i]!=A[cur-1])\\n                    i--;\\n            }\\n            \\n            for(i=0;i<n;i++)\\n                if(A[i]!=i+1) \\n                    return i+1;\\n            return n+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            int i,j;\\n            for(i=0;i<n;i++){\\n                int cur=A[i];\\n                // if in place or non-pos or out of bounds, skip.\\n                if(cur==i+1||cur<=0||cur>n)continue;\\n                swap(A[i],A[cur-1]);\\n                // if not the same, then reprocess it.\\n                if(A[i]!=A[cur-1])\\n                    i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 871665,
                "title": "python-o-n-solution-without-additional-memory-explained",
                "content": "Notice, that first missinig positive will always be in range `1,2,...n,n+1`, where `n` is length of `nums`. Let us rearrange numbers, putting each number on its place: number `i` on place `i-1` (because indexes start with `0`): let us iterate over our numbers and change two numbers if one of them not on its place: we break if number not in range `1,...,n` or if we are trying to put number on the place, which is already occupied with this place (because we have infinite loop in this case)\\n\\nWhen we iterate all numbers we find for number which is not on its place, using `i == nums[i] - 1`. It can happen that all numbers between `1` and `n` are here, so I add `[0]` to the end. Finally, I found index of `False` in this array: it will be our number.\\n\\n**Complexity**: even though we have `while` loop inside `for` loop, complexity will be `O(n)`: on each step we put at least one number to its proper place. Additional space complexity is `O(1)`, however we modify our `nums`.\\n\\nThis solution is very similar to problem **442. Find All Duplicates in an Array**, see my detailed solution here https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/775738/Python-2-solutions-with-O(n)-timeO(1)-space-explained\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            while nums[i]-1 in range(n) and nums[i] != nums[nums[i]-1]:\\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n                \\n        return next((i + 1 for i, num in enumerate(nums) if num != i + 1), n + 1)   \\n```\\n\\nThanks to **QwerMike** for pointing out that my last line were using `O(n)` memory and he kindly suggested to use iterators instead, code is corrected now.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        for i in range(n):\\n            while nums[i]-1 in range(n) and nums[i] != nums[nums[i]-1]:\\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\\n                \\n        return next((i + 1 for i, num in enumerate(nums) if num != i + 1), n + 1)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340607,
                "title": "look-at-this-solution-you-will-not-say-this-was-hard-one-uses-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/6575114b-a664-4c5b-8acb-b74de3f0ff4e_1679763882.7132435.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        int ans[] = new int[nums.length + 1];\\n\\n        // mark the presence of each positive integer in the input array\\n        for(int i = 0; i < nums.length; i++){\\n            int val = nums[i];\\n            if(val > 0 && val <= nums.length) { // check to avoid index out of bounds\\n                ans[val] = 1;\\n            }\\n        }\\n\\n        // find the smallest missing positive integer by checking the array of marked integers\\n        for(int i = 1; i < ans.length; i++){\\n            if(ans[i] == 0){\\n                return i;\\n            }\\n        }\\n\\n        // if no missing positive integer is found, return the length of the array\\n    return ans.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        int ans[] = new int[nums.length + 1];\\n\\n        // mark the presence of each positive integer in the input array\\n        for(int i = 0; i < nums.length; i++){\\n            int val = nums[i];\\n            if(val > 0 && val <= nums.length) { // check to avoid index out of bounds\\n                ans[val] = 1;\\n            }\\n        }\\n\\n        // find the smallest missing positive integer by checking the array of marked integers\\n        for(int i = 1; i < ans.length; i++){\\n            if(ans[i] == 0){\\n                return i;\\n            }\\n        }\\n\\n        // if no missing positive integer is found, return the length of the array\\n    return ans.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927112,
                "title": "three-js-solutions",
                "content": "```\\nvar firstMissingPositive = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    nums.sort((a,b) => a-b).filter(num => num > 0);\\n    let j = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (j == nums[i]) j++;\\n        else return j;\\n    }\\n    return j;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```\\n\\n```\\nvar firstMissingPositive = function(nums) {    \\n    let m = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        m.set(nums[i], 1);\\n    }\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (!m.has(i)) return i;\\n    }\\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    /*\\n    The worst case (the first missing positive being the greatest) is\\n    when the array is [1,2..,n]. Therefore, in all other cases except this case, \\n    the first missing positive number is less than or equal to n (nums.length).\\n    */\\n}\\n```\\n\\n```\\nvar firstMissingPositive = function(nums) {\\n    // First, we need to understand that the first missing positive number is less than or equal to n (length of array) except for one case. The explanation is in the above.\\n    // We will position every positive integer in the array at its corresponding index\\n    // ex) 1 at index 0, 2 at index 1, 3 at index 2\\n    // In this way, the array can position all integers that are less than or equal to n at their corresponding indices without changing the size of given array.\\n    // Therefore, we can find the first missing positive integer by scanning through the array.\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let idx = nums[i]-1;\\n        if (i == idx || nums[i] == nums[idx]) continue; // already positioned or nums[i] is a duplicate\\n        if (idx >= 0 && idx <= nums.length - 1) {\\n            [nums[i], nums[idx]] = [nums[idx], nums[i]];\\n            i--; // check the swapped number\\n        }\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (i+1 == nums[i]) continue;\\n        else return i+1; // the next positive number which is i+1 doesn\\'t exist in the array\\n    }\\n    \\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar firstMissingPositive = function(nums) {\\n    nums = Array.from(new Set(nums));\\n    nums.sort((a,b) => a-b).filter(num => num > 0);\\n    let j = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (j == nums[i]) j++;\\n        else return j;\\n    }\\n    return j;\\n    // Time Complexity: O(nlog(n))\\n    // Space Complexity: O(n)\\n};\\n```\n```\\nvar firstMissingPositive = function(nums) {    \\n    let m = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        m.set(nums[i], 1);\\n    }\\n    for (let i = 1; i <= nums.length; i++) {\\n        if (!m.has(i)) return i;\\n    }\\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    /*\\n    The worst case (the first missing positive being the greatest) is\\n    when the array is [1,2..,n]. Therefore, in all other cases except this case, \\n    the first missing positive number is less than or equal to n (nums.length).\\n    */\\n}\\n```\n```\\nvar firstMissingPositive = function(nums) {\\n    // First, we need to understand that the first missing positive number is less than or equal to n (length of array) except for one case. The explanation is in the above.\\n    // We will position every positive integer in the array at its corresponding index\\n    // ex) 1 at index 0, 2 at index 1, 3 at index 2\\n    // In this way, the array can position all integers that are less than or equal to n at their corresponding indices without changing the size of given array.\\n    // Therefore, we can find the first missing positive integer by scanning through the array.\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let idx = nums[i]-1;\\n        if (i == idx || nums[i] == nums[idx]) continue; // already positioned or nums[i] is a duplicate\\n        if (idx >= 0 && idx <= nums.length - 1) {\\n            [nums[i], nums[idx]] = [nums[idx], nums[i]];\\n            i--; // check the swapped number\\n        }\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (i+1 == nums[i]) continue;\\n        else return i+1; // the next positive number which is i+1 doesn\\'t exist in the array\\n    }\\n    \\n    return nums.length + 1; // the array is [1,2,...,n]\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351917,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func firstMissingPositive(_ n: [Int]) -> Int {\\n        let set = Set(n)\\n        for i in 0..<n.count where !set.contains(i + 1) { return i + 1 }\\n        return n.count + 1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.firstMissingPositive([1,2,0])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.firstMissingPositive([3,4,-1,1])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.firstMissingPositive([7,8,9,11,12])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func firstMissingPositive(_ n: [Int]) -> Int {\\n        let set = Set(n)\\n        for i in 0..<n.count where !set.contains(i + 1) { return i + 1 }\\n        return n.count + 1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.firstMissingPositive([1,2,0])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.firstMissingPositive([3,4,-1,1])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.firstMissingPositive([7,8,9,11,12])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872224,
                "title": "java-python-supper-clean-concise-time-o-n-space-o-1",
                "content": "**Idea:**\\n1. Marks `zero or negative numbers` as `positive numbers`.\\n2. Mark number `x` as visited by marking `nums[x]` as negative, by using `(x-1)` we can use index 0 of `nums` array.\\n3. Interate from `0..n-1`, if `nums[i] > 0` then it means the number `i+1` is the smallest positive number which is missing.\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length, INF = n + 1;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] <= 0)\\n                nums[i] = INF; // marks zero or negative numbers as infinitive positive numbers\\n                \\n        for (int i = 0; i < n; i++) {\\n            int x = Math.abs(nums[i]) - 1; // use index start with zero\\n            if (x < n)\\n                nums[x] = -Math.abs(nums[x]); // mark `x` as visited by marking `nums[x]` as negative\\n        }\\n               \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] > 0) // if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1;\\n        return n + 1;\\n    }\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        INF = n + 1\\n    \\n        for i in range(n):\\n            if nums[i] <= 0:\\n                nums[i] = INF # marks zero or negative numbers as infinitive positive numbers\\n                \\n        for i in range(n):\\n            x = abs(nums[i]) - 1 # use index start with zero\\n            if x < n:\\n                nums[x] = -abs(nums[x]) # mark `x` as visited by marking `nums[x]` as negative\\n                    \\n        for i in range(n):\\n            if nums[i] > 0: # if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1\\n        return n + 1\\n```\\n\\nPlease give a vote if this post is useful to you.\\nHappy Coding!",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length, INF = n + 1;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] <= 0)\\n                nums[i] = INF; // marks zero or negative numbers as infinitive positive numbers\\n                \\n        for (int i = 0; i < n; i++) {\\n            int x = Math.abs(nums[i]) - 1; // use index start with zero\\n            if (x < n)\\n                nums[x] = -Math.abs(nums[x]); // mark `x` as visited by marking `nums[x]` as negative\\n        }\\n               \\n        for (int i = 0; i < n; i++)\\n            if (nums[i] > 0) // if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1;\\n        return n + 1;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        n = len(nums)\\n        INF = n + 1\\n    \\n        for i in range(n):\\n            if nums[i] <= 0:\\n                nums[i] = INF # marks zero or negative numbers as infinitive positive numbers\\n                \\n        for i in range(n):\\n            x = abs(nums[i]) - 1 # use index start with zero\\n            if x < n:\\n                nums[x] = -abs(nums[x]) # mark `x` as visited by marking `nums[x]` as negative\\n                    \\n        for i in range(n):\\n            if nums[i] > 0: # if nums[i] is positive -> number (i+1) is not visited.\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871646,
                "title": "first-missing-positive-c-two-solutions-o-n-time-100",
                "content": "<b>The problem</b>\\nHonestly, it was surpising to me to find out that this problem is marked as hard.\\nWhen I saw the problem, I thought it was probably easy or medium difficulty.\\nI had done some similar problems previously, that required me to use the original array and negate numbers at indices according to some other values.\\nI guess it can appear hard to solve it in linear time, if you miss the clue.\\n\\n<b>Approach</b>\\nThe main thing here is to really understand the question. They are looking for the first positive integer, of <b>ALL</b> positive integers, that does not exist in the given array.\\nThis implies that the first missing number can be in range from ```1``` to ```N``` (size of the input).\\nNow we only have to figure out which one is the first in the sequence that is not present in the array.\\n\\n<b>Solution 1</b>\\nCreate a new array of input size, with all values set to ```-1```.\\nFor each value in the original array, set ```newArray[value - 1]``` to ```1```, if the value is within the ```1``` - ```N``` range.\\nNow we go through the new array and look for the first ```-1``` value. The missing number is ```index + 1```, since we are looking only for positive numbers and we start count from 1, while index is zero based.\\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\n<b>Solution 2</b>\\nVery similar to first solution, but we use the original array instead of creating a new one. So the space complexity is constant.\\nSince we don\\'t need to look at the negative values in the array, we set them to ```0```. Then we use the original array to negate all the numbers at indices for which the value exists in the array.\\nIt is a little tricky, and my solution might require some polishing, but overall, it isn\\'t difficult.\\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\nAny suggestions or advice on how to improve the solutions are always welcome. Thank you!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```1```\n```N```\n```-1```\n```newArray[value - 1]```\n```1```\n```1```\n```N```\n```-1```\n```index + 1```\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\n```0```\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17298,
                "title": "sharing-my-2ms-c-solution",
                "content": "In the worst case, this will take 2N iterations.  Satisfies O(N) runtime and O(1) space requirements. \\n\\nI got the idea from doing this in JavaScript, first, by popping off any out-of-bounds or duplicate values after moving them to the end of the array.  In the end I got rid of the pop operation and used a partition index, instead.  The neat thing is that it doesn't require a second loop to find the answer. \\n\\n\\n    void swap(int* nums, int j, int k) {\\n        int tmp = nums[k];\\n        nums[k] = nums[j];\\n        nums[j] = tmp;\\n    }\\n    \\n    int firstMissingPositive(int* nums, int numsSize) {\\n        int i = 0;\\n        int p = numsSize;\\n\\n        while (i < p) {\\n            if (nums[i] == i+1)  ++i; // already in the right place,\\n            else if (nums[i] <= 0 || nums[i] > p || nums[i] == nums[nums[i]-1]) {\\n                swap(nums, i, --p); // out of range or duplicate, put it at the end\\n            } else {\\n                swap(nums, i, nums[i]-1); // within range; put it in the right place.\\n            }\\n        }\\n\\n        return p + 1;\\n    }",
                "solutionTags": [],
                "code": "In the worst case, this will take 2N iterations.  Satisfies O(N) runtime and O(1) space requirements. \\n\\nI got the idea from doing this in JavaScript, first, by popping off any out-of-bounds or duplicate values after moving them to the end of the array.  In the end I got rid of the pop operation and used a partition index, instead.  The neat thing is that it doesn't require a second loop to find the answer. \\n\\n\\n    void swap(int* nums, int j, int k) {\\n        int tmp = nums[k];\\n        nums[k] = nums[j];\\n        nums[j] = tmp;\\n    }\\n    \\n    int firstMissingPositive(int* nums, int numsSize) {\\n        int i = 0;\\n        int p = numsSize;\\n\\n        while (i < p) {\\n            if (nums[i] == i+1)  ++i; // already in the right place,\\n            else if (nums[i] <= 0 || nums[i] > p || nums[i] == nums[nums[i]-1]) {\\n                swap(nums, i, --p); // out of range or duplicate, put it at the end\\n            } else {\\n                swap(nums, i, nums[i]-1); // within range; put it in the right place.\\n            }\\n        }\\n\\n        return p + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1206111,
                "title": "python-o-n-time-and-constant-space-solution",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\t\\t\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        for i in range(n):\\n            if abs(nums[i]) > n:\\n                continue\\n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\t\\t\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        for i in range(n):\\n            if abs(nums[i]) > n:\\n                continue\\n            nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17133,
                "title": "simple-javascript-o-n-time-and-o-1-space",
                "content": "```\\nvar firstMissingPositive = function(nums) {\\n    let i = 0;\\n    while (i < nums.length) {\\n        if (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] !== nums[i]) {\\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\\n        } else {\\n            i++;\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) return i + 1;\\n    }\\n    return i + 1;\\n};\\n```\\n1. Go through and place each number at the index of its value (minus one since `0` isn't positive). All the negative and out-of-bounds elements should now be in the missing gap or on the right side of the array.\\n2. Walk through and take the first index (plus one) which does not match its associated value.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar firstMissingPositive = function(nums) {\\n    let i = 0;\\n    while (i < nums.length) {\\n        if (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i] - 1] !== nums[i]) {\\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\\n        } else {\\n            i++;\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) return i + 1;\\n    }\\n    return i + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17157,
                "title": "golang-concise-solution-with-some-explanation",
                "content": "Let's say the array is `[3, 4, -1, 1, 3]`.\\nIf the array doesn't have missing positive integer within its range, the array should be `[1, 2, 3, 4, 5]`.\\n\\nSo, the idea is, we iterate through the array and if we find an integer within `1` to `5`, then put it to the ideal position.  \\nFor example, if we find `1`, then swap it with a value on index `0`. If we find `3`, then swap it with a value on index `2`.\\n\\nAfter we swap the value, we need to examine the swapped new value again, so we should not move to the next position. But we need to be careful about the case when the value is set at the ideal index by default, or we put it already. In this case we need to skip that index, otherwise we'll see the infinite loop :-\\\\\\n\\nwalkthrough:\\n```\\n[3, 4, -1, 1, 3]\\n \\u2191 3, swap with array[2]\\n[-1, 4, 3, 1, 3]\\n \\u2191 -1, this is out of range, so proceed to the next index\\n[-1, 4, 3, 1, 3]\\n     \\u2191 4, swap with array[3]\\n[-1, 1, 3, 4, 3]\\n     \\u2191 1, swap with array[0]\\n[1, -1, 3, 4, 3]\\n     \\u2191 -1, out of range, so proceed to the next index\\n[1, -1, 3, 4, 3]\\n        \\u2191 3, but already on array[2], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n           \\u2191 4, but already on array[3], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n              \\u2191 3, but array[2] already occupied with 3, so proceed to the next index\\nend\\n```\\n\\nAfter this iteration, you will notice that the value who is in  range `1 \\u301c n` will sit on the right index. So what you need to do is iterate this modified array again and find the first integer that doesn't have a value of `i+1`. This case, that is `2` because there is `-1` at index `1`. If there is no such integer, then the first missing integer should be `n+1`.\\n\\n```\\nfunc firstMissingPositive(nums []int) int {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] >= 1 && nums[i] <= nlen && nums[i] != nums[nums[i]-1] {\\n\\t\\t\\tnums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]\\n\\t\\t\\ti-- // keep the same index\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] != i+1 {\\n\\t\\t\\treturn i + 1\\n\\t\\t}\\n\\t}\\n\\treturn nlen + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n[3, 4, -1, 1, 3]\\n \\u2191 3, swap with array[2]\\n[-1, 4, 3, 1, 3]\\n \\u2191 -1, this is out of range, so proceed to the next index\\n[-1, 4, 3, 1, 3]\\n     \\u2191 4, swap with array[3]\\n[-1, 1, 3, 4, 3]\\n     \\u2191 1, swap with array[0]\\n[1, -1, 3, 4, 3]\\n     \\u2191 -1, out of range, so proceed to the next index\\n[1, -1, 3, 4, 3]\\n        \\u2191 3, but already on array[2], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n           \\u2191 4, but already on array[3], so proceed to the next index\\n[1, -1, 3, 4, 3]\\n              \\u2191 3, but array[2] already occupied with 3, so proceed to the next index\\nend\\n```\n```\\nfunc firstMissingPositive(nums []int) int {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] >= 1 && nums[i] <= nlen && nums[i] != nums[nums[i]-1] {\\n\\t\\t\\tnums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]\\n\\t\\t\\ti-- // keep the same index\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < nlen; i++ {\\n\\t\\tif nums[i] != i+1 {\\n\\t\\t\\treturn i + 1\\n\\t\\t}\\n\\t}\\n\\treturn nlen + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17260,
                "title": "clear-java-solution",
                "content": "    public int firstMissingPositive(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int index = nums[start] - 1;\\n            if (index == start)\\n                start++;\\n            else if (index < 0 || index > end || nums[start] == nums[index])\\n                nums[start] = nums[end--];\\n            else {\\n                nums[start] = nums[index];\\n                nums[index] = index + 1;\\n            }\\n        }\\n        return start + 1;\\n    }",
                "solutionTags": [],
                "code": "    public int firstMissingPositive(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int index = nums[start] - 1;\\n            if (index == start)\\n                start++;\\n            else if (index < 0 || index > end || nums[start] == nums[index])\\n                nums[start] = nums[end--];\\n            else {\\n                nums[start] = nums[index];\\n                nums[index] = index + 1;\\n            }\\n        }\\n        return start + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2083286,
                "title": "python-o-n-time-o-1-space-step-by-step-explanation",
                "content": "Plzz **UPVOTE** if you like it.\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\'\\'\\'Step 1 -> The main idea behind it is that the minimum number to be found will always be in the range [1....n]\\n\\t\\t             where \\'n\\' is the length of list. So keep numbers in this range and mark others\\n\\t\\t\\t\\t\\t (here we are marking them with (n+1) value) in the list provided.\\'\\'\\'\\n        \\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] < 1 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        \\'\\'\\'Step 2 -> Ignoring the values greater than \\'n\\', mark the indexes of the numbers in the range [1...n]\\n\\t\\t\\t\\t\\t so as to ensure that this values are present. To mark the indexes, \\n\\t\\t\\t\\t\\t I am negating the value present at that index.\\'\\'\\'\\n        \\n        for i in range(n):\\n            val = abs(nums[i])\\n            if val > n:\\n                continue\\n            val -= 1  #since the list is zero indexed,so every value will be at position val - 1\\n            \\n            if nums[val] > 0: \\n                # For similar numbers, it will keep on fluctuating between negative and positive \\n\\t\\t\\t\\t# which is not our motive here.\\n                \\n                nums[val] = -1 * nums[val]\\n        \\n        \\'\\'\\'Step 3 -> Return the first occurence of the non-negative numbers from the list\\'\\'\\'\\n        \\n        for i in range(n):\\n            if nums[i] >=0:\\n                return (i + 1) # bcoz list is zero indexed\\n        \\n        \\'\\'\\'Step 4 -> We will encounter this if no positives were found. This means that all the \\n\\t\\t\\t         numbers are in the range [1....n]. So the missing positive number will be n+1\\'\\'\\'\\n        \\n        return (n + 1)\\n```\\n\\nFor detailed explaination,  do visit \\uD83D\\uDC47\\uD83D\\uDC47\\nhttps://leetcode.com/problems/first-missing-positive/discuss/319270/Explanation-of-crucial-observation-needed-to-deduce-algorithm",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\'\\'\\'Step 1 -> The main idea behind it is that the minimum number to be found will always be in the range [1....n]\\n\\t\\t             where \\'n\\' is the length of list. So keep numbers in this range and mark others\\n\\t\\t\\t\\t\\t (here we are marking them with (n+1) value) in the list provided.\\'\\'\\'\\n        \\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] < 1 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        \\'\\'\\'Step 2 -> Ignoring the values greater than \\'n\\', mark the indexes of the numbers in the range [1...n]\\n\\t\\t\\t\\t\\t so as to ensure that this values are present. To mark the indexes, \\n\\t\\t\\t\\t\\t I am negating the value present at that index.\\'\\'\\'\\n        \\n        for i in range(n):\\n            val = abs(nums[i])\\n            if val > n:\\n                continue\\n            val -= 1  #since the list is zero indexed,so every value will be at position val - 1\\n            \\n            if nums[val] > 0: \\n                # For similar numbers, it will keep on fluctuating between negative and positive \\n\\t\\t\\t\\t# which is not our motive here.\\n                \\n                nums[val] = -1 * nums[val]\\n        \\n        \\'\\'\\'Step 3 -> Return the first occurence of the non-negative numbers from the list\\'\\'\\'\\n        \\n        for i in range(n):\\n            if nums[i] >=0:\\n                return (i + 1) # bcoz list is zero indexed\\n        \\n        \\'\\'\\'Step 4 -> We will encounter this if no positives were found. This means that all the \\n\\t\\t\\t         numbers are in the range [1....n]. So the missing positive number will be n+1\\'\\'\\'\\n        \\n        return (n + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778385,
                "title": "o-n-time-o-1-space-using-number-as-index-of-hash",
                "content": "Let us understand the whole problem in three steps of progression, with an example nums array, say : 3, -1, 4, 2, 1, 7\\n\\nOne observation that we can make is: *we can always ignore the negative values and 0\\'s present in the array* as they contribute to nothing. We have to find the first missing positive number.\\n\\n**Naive approach:  (extra space)**\\n\\n1. In one pass, we find the largest positive number present in array. (If no positive no., return 1).\\n2. We create an array till the size of the largest positive number present + 1 (+ 1 if following 1 based indexing). We put 0 in every index initially.\\n3. In second pass, we take each positive no. from the array and mark that corresponding index in our array with 1. (we ignore negative numbers and 0)\\n4. We iterate our array and the first index which has not been visited / marked true, is our first missing positive number.\\n\\nDry run:\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we mark index 3 of array as true/1. We ignore -1. And continue like this:\\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5  6  7\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0  0  1\\n```\\n\\nNow when we iterate on this array from index 1 to 7 (following 1 based indexing), we see 5 is the first empty index. So we return 5.\\n\\n**Reducing auxiliary array size:**\\n\\nOne problem with this approach is if there are huge gaps between numbers, say 1, 2, 3, 22471. We will unnecessarily create a huge array. We can avoid that by making the following observation:\\n`first missing positive number has to lie within {1,n+1} , where n-> nums.size()`\\nSo we can create array only of size n + 1.\\n\\nDry run:\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we mark index 3 of array as true/1. We ignore -1. We mark indices 4,2,1 for numbers 4, 2, 1 in array respectively, and ignore 7 ( as 7 > nums.size() )\\n\\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0\\n```\\nWe return 1st index empty index or n + 1 if no empty index.\\n\\n\\n\\nCode for above idea (extra O(n) space ) :\\n\\n```\\nint firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> count(n + 1,0);\\n        for(int _n : nums)\\n\\t\\t\\tif(_n <= 0 || _n > n)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount[_n] += 1;\\n        \\n\\t\\tfor(int i = 1; i < n + 1; ++i)\\n\\t\\t\\tif(count[i] == 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\treturn n + 1;\\n}\\n```\\n\\n**Final approach by modifying above idea for constant space:**\\n\\nTo drop the extra array we are using to maintain index count, we can modify the given array itself to do the hashing.\\nIf we put each nums[i] that lie in range {1, n-1} in that index itself, i.e if nums[i] =3, we put nums[i] in index 3 (or 2 if 0 based indexing), then the first index not containing the number as the index itself will be the first missing positive number. If all indices have nums[i] == i, then we return n + 1.\\n\\nDry run: (using 0 based indexing)\\nnums array -----> 3               -1               4                  2                1                7\\n\\nfor 3, we put 3 in index 2. We ignore -1. We put 4 in index 3. We put 2 in index 1. We put 1 in index 0. We ignore 7.\\n```\\nInitially:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 3 -1  4  2  1  7\\n\\nAfter modification:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 1  2  3  4 -1  7\\n```\\n\\nBelow is the code implementing this idea with a zero-based indexing approach:\\n\\n```\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n) //ignore numbers not in range of {1, n-1}\\n                continue;\\n            else\\n            {\\n                if(nums[nums[i]-1]==nums[i])  //already in correct place, then skip (else infinite loop of swapping)\\n                    continue;\\n                swap(nums[i], nums[nums[i] - 1]);\\n                --i;                          //can\\'t go forward without putting swapped number in correct place.\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(i + 1 != nums[i])\\n                return i + 1;\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5  6  7\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0  0  1\\n```\n```\\nnums array -------------> 3 -1  4  2  1  7\\ncount array indices ----> 0  1  2  3  4  5\\n\\t\\t\\t\\t\\t      0  1  1  1  1  0\\n```\n```\\nint firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> count(n + 1,0);\\n        for(int _n : nums)\\n\\t\\t\\tif(_n <= 0 || _n > n)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount[_n] += 1;\\n        \\n\\t\\tfor(int i = 1; i < n + 1; ++i)\\n\\t\\t\\tif(count[i] == 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\treturn n + 1;\\n}\\n```\n```\\nInitially:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 3 -1  4  2  1  7\\n\\nAfter modification:\\n\\nindices    -------------> 0  1  2  3  4  5\\nnums array -------------> 1  2  3  4 -1  7\\n```\n```\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n) //ignore numbers not in range of {1, n-1}\\n                continue;\\n            else\\n            {\\n                if(nums[nums[i]-1]==nums[i])  //already in correct place, then skip (else infinite loop of swapping)\\n                    continue;\\n                swap(nums[i], nums[nums[i] - 1]);\\n                --i;                          //can\\'t go forward without putting swapped number in correct place.\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(i + 1 != nums[i])\\n                return i + 1;\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119550,
                "title": "two-ways-of-solving-this-floyd-cycle-o-n-time-o-1-space-in-2nd-approach",
                "content": "\\n**Key Insight: If n = nums.length, that is size of nums is n, then the max possible answer can be n + 1 only. Think about it if you are not sure. Think of an input where the answer can be more than n + 1. You won\\'t be able to find it.**\\n\\nFirst way is to create an extra boolean array called `exists`. After filling this array, `exists[i]` should be able to indicate if a number `i+1` is the required answer or not. That is `if exists[i] is false` then this means that `i+1` is the answer.\\n\\n# <ins>First Approach - Extra Space:\\n\\n```java\\n    // TC: O(n), SC: O(n)\\n    public int firstMissingPositive_ExtraArray(int[] nums) {\\n        int n = nums.length;\\n        boolean[] exists = new boolean[n];\\n        for (int num : nums) {\\n            if (num > 0 && num <= n) exists[num - 1] = true;\\n        }\\n        for (int i = 0; i < exists.length; i++) {\\n            if (!exists[i]) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n# <ins>Second Approach - No Space:\\nSame as first approach, but instead of having an extra boolean array, think of using the giving input array itself. \\n\\n**Key Insight in second approach: Remember that we don\\'t care about negative values in the array. Let\\'s throw them into dustbin \\uD83D\\uDE02**\\n\\nSo we override the negatives, and then we manually flip the sign of the numbers to indicate if a value exists or not. Read the comments in the solution below.\\n\\n```java\\n    public int firstMissingPositive_NoSpace(int[] nums) {\\n        int n = nums.length;\\n        // pre-process array so that non-positive ints are overwritten with n + 1;\\n        // why n + 1? coz this is the safest value to choose during\\n        // floyd cycle way which we are about to do in second for loop below\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0) nums[i] = n + 1;\\n        }\\n\\n        // Take abs of A[i] and then make sure its within bounds and use that as index.\\n        // This is also called as Floyd Cycle algorithm or something. Another fancy name I think is tortoise-hare.\\n        for (int i = 0; i < n; i++) {\\n            int num = Math.abs(nums[i]);\\n            if (num > 0 && num <= n) {\\n                // Now indicate that the +ve value num was found.\\n                // We indicate this by setting nums[num - 1] as a negative value;\\n                // Why does this work? We are using the negative sign in the array to indicate that\\n                // a positive value has been found. On the other hand, value itself is encoded in Math.abs(nums[i])\\n                nums[num - 1] = -Math.abs(nums[num - 1]);\\n            }\\n        }\\n\\n        // Now check for the first value where nums[i] is not negative and we have found our answer\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\\n\\n**Essentially in the first approach, we used an extra boolean array, while in the second approach we used existing array itself to do this. We simulated the \"boolean-ness\" using the negative sign. However since the initial input could have negatives already, we just overwrote the negatives to avoid problems for us down the line.**\\n\\nP.S. Correct me if I am wrong about the name of the algorithm(floyd cycle).\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    // TC: O(n), SC: O(n)\\n    public int firstMissingPositive_ExtraArray(int[] nums) {\\n        int n = nums.length;\\n        boolean[] exists = new boolean[n];\\n        for (int num : nums) {\\n            if (num > 0 && num <= n) exists[num - 1] = true;\\n        }\\n        for (int i = 0; i < exists.length; i++) {\\n            if (!exists[i]) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```\n```java\\n    public int firstMissingPositive_NoSpace(int[] nums) {\\n        int n = nums.length;\\n        // pre-process array so that non-positive ints are overwritten with n + 1;\\n        // why n + 1? coz this is the safest value to choose during\\n        // floyd cycle way which we are about to do in second for loop below\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] <= 0) nums[i] = n + 1;\\n        }\\n\\n        // Take abs of A[i] and then make sure its within bounds and use that as index.\\n        // This is also called as Floyd Cycle algorithm or something. Another fancy name I think is tortoise-hare.\\n        for (int i = 0; i < n; i++) {\\n            int num = Math.abs(nums[i]);\\n            if (num > 0 && num <= n) {\\n                // Now indicate that the +ve value num was found.\\n                // We indicate this by setting nums[num - 1] as a negative value;\\n                // Why does this work? We are using the negative sign in the array to indicate that\\n                // a positive value has been found. On the other hand, value itself is encoded in Math.abs(nums[i])\\n                nums[num - 1] = -Math.abs(nums[num - 1]);\\n            }\\n        }\\n\\n        // Now check for the first value where nums[i] is not negative and we have found our answer\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17164,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/76042/python-solution-with-detailed-explanation\\n\\n**First Missing Positive** https://leetcode.com/problems/first-missing-positive/\\n\\n**Solution using extra space: O(N) time and space**\\n* If the length of the nums array is N, then the first missing positive will be between 1 to N+1. Think Why N+1? We can have in the array 1 to N.\\n\\t* Take an temp array of size N and for any number x in nums such that 1<=x<=N, mark temp[x-1]. Then simply walk the temp array and report the first unmarked index.\\n\\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        temp, N = [None]*len(nums), len(nums)\\n        for x in nums:\\n            if 1<=x<=N:\\n                temp[x-1] = x\\n        for i in range(N):\\n            if temp[i] == None:\\n                return i+1\\n        return N+1\\n```\\n\\n**Optimized solution with O(1) Space**\\n* Simply traverse the nums array and put any number within [1, N] in their right place. For example if 2 is in that input, then put 2 at index 1.\\n* Now traverse this \"shuffled\" array again. You expect 1 at 0th index. Otherwise it is missing. Then you expect 2 at 1st index and so on.\\n* Above idea can be a little tricky. What about cases like [1] and [1,1] - i.e. 1 is in its place or there are duplicates - we need to advance pointer regardless.\\n\\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N, i = len(nums), 0\\n        while i < N:\\n            while 1<=nums[i]<=N:\\n                idx_expected = nums[i]-1\\n                if nums[i] == nums[idx_expected]:\\n                    break\\n                nums[i], nums[idx_expected] = nums[idx_expected], nums[i]\\n            i = i + 1\\n        for i in range(N):\\n            if nums[i] != i+1:\\n                return i+1\\n        return N+1\\n```.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        temp, N = [None]*len(nums), len(nums)\\n        for x in nums:\\n            if 1<=x<=N:\\n                temp[x-1] = x\\n        for i in range(N):\\n            if temp[i] == None:\\n                return i+1\\n        return N+1\\n```\n```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N, i = len(nums), 0\\n        while i < N:\\n            while 1<=nums[i]<=N:\\n                idx_expected = nums[i]-1\\n                if nums[i] == nums[idx_expected]:\\n                    break\\n                nums[i], nums[idx_expected] = nums[idx_expected], nums[i]\\n            i = i + 1\\n        for i in range(N):\\n            if nums[i] != i+1:\\n                return i+1\\n        return N+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895048,
                "title": "simple-python-search-beats-98",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        unique = set(nums)\\n        i = 1\\n        while i in unique:\\n            i += 1\\n        return i\\n```\\nIt is quite a simple solution. We first run it through set() to stop duplicate numbers (will cause a runtime error if not there when you submit it). You don\\'t need to sorted() it or anything else because the counter (which is \"i\") will scan through the list for it. \\n\\n\"i\" is the variable that i used as a counter to see if it is in the set(nums) or not. If it not in the set(nums), the `while` function will stop and and move on to the next code which is `return i`.\\n\\n`i += 1` is the same as `i = i + 1` which is what allow the \"while\" loop to continue. \\nYou substitute \"unique\" for \"j\" or something to decrease memory usage.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        unique = set(nums)\\n        i = 1\\n        while i in unique:\\n            i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616956,
                "title": "c-solution-with-clear-explanation-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //the missing number will always be less than or equal to the size of the vector\\n        //place all positive elements less than or equal to the size of the vector to their respective index in the vector, e.g., 1 at index 0\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]); //place element x at index num[x - 1]\\n        \\n        //if the number at index i is not i + 1, the missing number is i + 1\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        //else, the missing number is one more than the size of the vector\\n        return n + 1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //the missing number will always be less than or equal to the size of the vector\\n        //place all positive elements less than or equal to the size of the vector to their respective index in the vector, e.g., 1 at index 0\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]); //place element x at index num[x - 1]\\n        \\n        //if the number at index i is not i + 1, the missing number is i + 1\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        //else, the missing number is one more than the size of the vector\\n        return n + 1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617430,
                "title": "python-swap-sort-o-1-space-and-o-n-time",
                "content": "Swap Sort Playlist by Aditya Verma - https://www.youtube.com/playlist?list=PL_z_8CaSLPWdJfdZHiNYYM46tYQUjbBJx\\n\\nThis problem is a variation of 1 to n missing number problems.\\n\\nHere, Range of numbers is from -2^31 to 2^31 - 1\\n\\nBut as the problem statement says, we need to return the first Missing \"Positive\" number which means we care about only the positive numbers.\\n\\nThe smallest missing positive number = the first missing number.\\n\\nSo, what we can do is we manually pick the range 1 to n where n is the length of given array and then place each element at its correct place.\\n\\n\\t\\tnums = [3,4,-1,1]\\n\\nSo here, n = 4 which means ideally, all numbers from 1 to 4 should be in this array. Lets apply swap sort on this array. We only care about numbers from range 1 to n because that\\'s how swap sort works.\\n\\nDo note that ideally, at index i, element should be i + 1. That\\'s what we are going to check.\\n\\n    at index = 0, we have 3. is 3 > 0 and <= n? YES. SO it can be considered. \\n\\n    It 3 at its correct place? NO. Its correct place is index 2. \\n\\n    So to place 3 at its correct place, swap element at index 2 with 3. \\n\\n    [-1,4,3,1]\\n\\n    Now at index = 0, we have a negative number so we ignore it and move ahead.\\n\\n    At index = 1, we have 4. It should be at index = 3. SO swap\\n\\n    [-1,1,3,4]\\n\\n    Again at index = 1, we have 1. But 1 should be at index = 0. So Swap.\\n\\n    [1,-1,3,4]\\n\\n    And since now we have a negative number at index = 1, ignore it.\\n\\n    At index = 2, we already have correct number i.e, 3\\n\\n    AT index = 3 we already have correct number i.e., 4\\n\\n\\nSo finally, our array becomes [1,-1,3,4]\\n\\nAnd now, we do the second part of Swap Sort algorithm, which is to find the missing number. If at index = i, we do not have i + 1, that means i + 1 is the missing number. And because we are asked to find the first positive missing number, as soon as we find a missing number, that will be the first/smallest so we can return.\\n\\nSo, in [1,-1,3,4] we will see that at index = 1, we should have 2 but instead there is -1. This means 2 is missing. So return 2.\\n\\n# **SPECIAL CASES**\\n\\nThere will be cases where we have arrays like - \\n\\n    [1]\\n\\nAnd in this case, smallest positive missing number is 2. That\\'s because as we know, positive range is from 1 to 2^31 - 1. So if 1 is there, then the next smallest number is 2 which is missing.\\n\\nBut our swap sort algorithm won\\'t be able to find it because we run the loop only till length of the array which in this case is 1.\\n\\nSo, if we did not get a missing number in the given array, that simply means the missing number is (length + 1)\\n\\n\\n```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # First put each number in range 1 to n at its correct place\\n        i = 0\\n        \\n        while i < n:\\n            # Swap\\n            # Only for the range 1 to n check if a number at any index is not at its correct place\\n            if nums[i] > 0 and nums[i] <= n and nums[i] != nums[nums[i] - 1]:\\n                nums[nums[i] - 1], nums[i]= nums[i], nums[nums[i] - 1]\\n            else:\\n                i += 1\\n        \\n        # And now just find the first missing number. That would be the smallest\\n        for i,num in enumerate(nums):\\n            if num != i + 1: return i + 1\\n        \\n        # Otherwise the missing positive number is n + 1 (e,g, for testcases such as [1])\\n        return n + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # First put each number in range 1 to n at its correct place\\n        i = 0\\n        \\n        while i < n:\\n            # Swap\\n            # Only for the range 1 to n check if a number at any index is not at its correct place\\n            if nums[i] > 0 and nums[i] <= n and nums[i] != nums[nums[i] - 1]:\\n                nums[nums[i] - 1], nums[i]= nums[i], nums[nums[i] - 1]\\n            else:\\n                i += 1\\n        \\n        # And now just find the first missing number. That would be the smallest\\n        for i,num in enumerate(nums):\\n            if num != i + 1: return i + 1\\n        \\n        # Otherwise the missing positive number is n + 1 (e,g, for testcases such as [1])\\n        return n + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1227747,
                "title": "java-solution-with-comments-o-n",
                "content": "For this problem, the numbers given are not bound by any range so we can have any number in the input array. We can iterate through the array and try to place the positive numbers between 1 and n in their correct indices. As we do so, we will ignore all the numbers that are out of range (i.e negative numbers and all numbers greater than the length of the array). Once we are done with the sorting, we will iterate through the array and find the first index that does not have the correct number.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        int j;\\n        int n = nums.length;\\n        \\n        // handle case of a single-element array\\n        if (n == 1) {\\n            if (nums[i] == 1) return 2;\\n            else return 1;\\n        }\\n        \\n        // try to place numbers in their correct indices\\n        while (i < n) {  \\n            // ignore numbers out of range (negative numbers and numbers greater than length of the array)\\n            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\\n                swap(nums, i, nums[i] - 1);\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        // loop through the array again\\n        // find the first number that is not at its correct index\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "For this problem, the numbers given are not bound by any range so we can have any number in the input array. We can iterate through the array and try to place the positive numbers between 1 and n in their correct indices. As we do so, we will ignore all the numbers that are out of range (i.e negative numbers and all numbers greater than the length of the array). Once we are done with the sorting, we will iterate through the array and find the first index that does not have the correct number.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        int i = 0;\\n        int j;\\n        int n = nums.length;\\n        \\n        // handle case of a single-element array\\n        if (n == 1) {\\n            if (nums[i] == 1) return 2;\\n            else return 1;\\n        }\\n        \\n        // try to place numbers in their correct indices\\n        while (i < n) {  \\n            // ignore numbers out of range (negative numbers and numbers greater than length of the array)\\n            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\\n                swap(nums, i, nums[i] - 1);\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        // loop through the array again\\n        // find the first number that is not at its correct index\\n        for (i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 382641,
                "title": "c-solution-moving-all-negative-numbers-to-right-side-of-the-array",
                "content": "```\\n\\npublic class Solution {\\n  public int FirstMissingPositive(int[] nums) {\\n    if (nums.Length == 0) return 1;\\n      if (nums.Length == 1) {\\n      if (nums[0] != 1) return 1;\\n      if (nums[0] == 1) return 2;\\n    }\\n      Array.Sort(nums);\\n    int maxNumber = nums.Max();\\n    if (maxNumber < 1) return 1;\\n      int indexPos = 0;\\n    for(int i = 0 ; i < nums.Length; i++)\\n    {\\n        if(nums[i] > 0 && nums[i] != 0)\\n        {\\n          nums[indexPos++] = nums[i];\\n        }\\n    }\\n      int negativeIndex = indexPos;\\n      for(int j = indexPos; j < nums.Length; j++)\\n          nums[indexPos] = -1;\\n      if(nums[0] != 1) return 1;\\n      for(int i = 0 ; i < negativeIndex - 1; i++)\\n      {\\n          if(nums[i + 1] != nums[i] + 1 && nums[i+1] != nums[i])\\n              return nums[i] + 1;\\n      }\\n    return maxNumber + 1;\\n  }\\n}\\n\\n````",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n  public int FirstMissingPositive(int[] nums) {\\n    if (nums.Length == 0) return 1;\\n      if (nums.Length == 1) {\\n      if (nums[0] != 1) return 1;\\n      if (nums[0] == 1) return 2;\\n    }\\n      Array.Sort(nums);\\n    int maxNumber = nums.Max();\\n    if (maxNumber < 1) return 1;\\n      int indexPos = 0;\\n    for(int i = 0 ; i < nums.Length; i++)\\n    {\\n        if(nums[i] > 0 && nums[i] != 0)\\n        {\\n          nums[indexPos++] = nums[i];\\n        }\\n    }\\n      int negativeIndex = indexPos;\\n      for(int j = indexPos; j < nums.Length; j++)\\n          nums[indexPos] = -1;\\n      if(nums[0] != 1) return 1;\\n      for(int i = 0 ; i < negativeIndex - 1; i++)\\n      {\\n          if(nums[i + 1] != nums[i] + 1 && nums[i+1] != nums[i])\\n              return nums[i] + 1;\\n      }\\n    return maxNumber + 1;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207882,
                "title": "python-beats-99-concise-4-line-solution-runtime",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Without space complexity restraint\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        nums_set, i = set(nums), 1\\n        while i in nums_set:\\n            i += 1\\n        return i\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Optimized\\n\\n```\\nclass Solution:\\n    def swap(self, arr, a, b):\\n        tmp = arr[a]\\n        arr[a] = arr[b]\\n        arr[b] = tmp\\n        return arr\\n\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:\\n                nums = self.swap(nums,i,nums[i]-1)\\n        for j in range(n):\\n            if nums[j] != j+1:\\n                return j+1\\n        return n+1\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        nums_set, i = set(nums), 1\\n        while i in nums_set:\\n            i += 1\\n        return i\\n```\n```\\nclass Solution:\\n    def swap(self, arr, a, b):\\n        tmp = arr[a]\\n        arr[a] = arr[b]\\n        arr[b] = tmp\\n        return arr\\n\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:\\n                nums = self.swap(nums,i,nums[i]-1)\\n        for j in range(n):\\n            if nums[j] != j+1:\\n                return j+1\\n        return n+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974305,
                "title": "using-cyclic-sort-technique-solve-any-range-based-questions",
                "content": "# Intuition\\nPrerequistes for solving the question is to know the **cyclic sort algorithm.**\\n\\n**Cyclic sort algorithm -** is used when the elements in the array are in the range 1 to n. \\n(n = size of the array)\\n\\n    Arr :  [4, 5, 2, 1, 3]\\n    index :[0, 1, 2, 3, 4]\\n\\nWe can see in the  above example that the elements in the array are in range 1 to n. \\n***So, how does cyclic sort work upon it to sort the array in O(n) complexity?***\\n\\n    arr: [4,5,2,1,3]\\n    arr[0]: 4 \\n\\n*To sort the array we Check - is the 0th element of the array at the correct index?* \\n-- No, so put it at its correct index by **swapping it with the element at its correct index.** \\n-- If Yes, then simply move to the next element and check.\\n-- Dry Run :- \\n\\n    Arr :  [4, 5, 2, 1, 3]\\n    index :[0, 1, 2, 3, 4]\\n\\n    Arr[0]: 4 [Not at the correct index, swap it]\\n    swap(Arr[0], Arr[4 - 1]) // 4 - 1, since 0 based indexing\\n    Arr: [1, 5, 2, 4, 3] // After placing arr[0] at correct index\\n\\n    Again check after swapping, is the swapperd element at correct index?   \\n    Arr[0]: 1 [At the correct index, move to the next element]\\n\\n    Arr[1]: 5 [Not at the correct index, swap it]\\n    swap(Arr[1], Arr[5 - 1]) \\n    Arr: [1, 3, 2, 4, 5] // After placing arr[1] at correct index\\n\\n    Again check after swapping, is the swapperd element at correct index? \\n    Arr[1]: 3 [Not at the correct index, swap it]\\n    swap(Arr[1], Arr[3 - 1]) \\n    Arr: [1, 2, 3, 4, 5] // After placing arr[1] at correct index\\n\\n     Again check after swapping, is the swapperd element at correct index? \\n    Arr[1]: 2 [At the correct index, move to the next element]\\n\\n    Again check after swapping, is the swapperd element at correct index? \\n    Arr[2]: 3 [At the correct index, move to the next element]\\n    .\\n    .\\n    .\\n    .\\n    Likewise, all the elements fall at right indices and we get a sorted array in O(n) complexity.\\n    P.S. - Works only when numbers in array range from 1 to n.\\n\\n\\n    \\n\\n\\n\\n\\n**We use cyclic sort when the given numbers in the array range from 1 to n.** But in this problem we have *negative numbers & numbers > arr.size()* as well in the array.\\n\\n**So, we need to have some clear observations first ->**\\n-- *The 1st missing number always lies between 1 to n.*\\n(Take few examples, and it will be clear)\\n-- We need not care about the negative numbers & numbers > n.\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n- Space complexity:\\nO(1)\\n\\n# Problems on cylcic sort:-\\n    --> Missing Number\\n    --> Find all numbers disappeared in array\\n    --> Find the Duplicate Numbers\\n    --> Set Mismatch\\n    --> First Missing Positive\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Using Cyclic Sort Technique\\n        for (int i = 0; i < n; ) {\\n\\n            // ignoring the negative & >n numbers, \\n            // as the 1st missing number would always lie between 1 to n \\n            if (nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) \\n                swap(nums[nums[i] - 1], nums[i]);\\n            else \\n                i++;\\n\\n        }\\n        // run a loop to check which is the 1st element, not at the correct index after sorting\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Using Cyclic Sort Technique\\n        for (int i = 0; i < n; ) {\\n\\n            // ignoring the negative & >n numbers, \\n            // as the 1st missing number would always lie between 1 to n \\n            if (nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) \\n                swap(nums[nums[i] - 1], nums[i]);\\n            else \\n                i++;\\n\\n        }\\n        // run a loop to check which is the 1st element, not at the correct index after sorting\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362460,
                "title": "c-simple-c-code-o-n-time-o-1-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Mark all out of range values as n+1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n){\\n                nums[i] = n+1;\\n                continue;\\n            }\\n        }\\n        // mark all ranged valued index as negative;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(abs(nums[i]) >= n+1) continue;\\n            int val = abs(nums[i]);\\n            nums[val-1] = -1*abs(nums[val-1]);\\n        }\\n        // if any ranged valued index is positive return one plus its idex since it is (1th indexing)\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) return i+1;\\n        return n+1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        // Mark all out of range values as n+1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] <= 0 || nums[i] > n){\\n                nums[i] = n+1;\\n                continue;\\n            }\\n        }\\n        // mark all ranged valued index as negative;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(abs(nums[i]) >= n+1) continue;\\n            int val = abs(nums[i]);\\n            nums[val-1] = -1*abs(nums[val-1]);\\n        }\\n        // if any ranged valued index is positive return one plus its idex since it is (1th indexing)\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] > 0) return i+1;\\n        return n+1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905808,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used, if we have parameter nums as inout.\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var ans = 1\\n\\n        for (i, num) in nums.enumerated() {\\n            if num == ans { ans += 1 }\\n            if num <= 0 || num > nums.count { nums[i] = 1 }\\n        }\\n\\n        guard ans != 1, ans != nums.count + 1 else { return ans }\\n\\n        for i in 0..<nums.count {\\n            let num = abs(nums[i])\\n            if num == nums.count {\\n                nums[0] = -abs(nums[0])\\n            } else {\\n                nums[num] = -abs(nums[num])\\n            }\\n        }\\n\\n        for i in 1..<nums.count {\\n            guard nums[i] > 0 else { continue }\\n            return i\\n        }\\n        return nums.count + (nums[0] > 0 ? 0 : 1)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used, if we have parameter nums as inout.\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var ans = 1\\n\\n        for (i, num) in nums.enumerated() {\\n            if num == ans { ans += 1 }\\n            if num <= 0 || num > nums.count { nums[i] = 1 }\\n        }\\n\\n        guard ans != 1, ans != nums.count + 1 else { return ans }\\n\\n        for i in 0..<nums.count {\\n            let num = abs(nums[i])\\n            if num == nums.count {\\n                nums[0] = -abs(nums[0])\\n            } else {\\n                nums[num] = -abs(nums[num])\\n            }\\n        }\\n\\n        for i in 1..<nums.count {\\n            guard nums[i] > 0 else { continue }\\n            return i\\n        }\\n        return nums.count + (nums[0] > 0 ? 0 : 1)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334664,
                "title": "c-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n// we can also use method where we first move all non-positive elements to left\\n// But, this method makes things more easy as we will have our answer in range [1, nums.size()+1]\\n    int firstMissingPositive(vector<int>& nums) {\\n\\t// first of all, make all -ve numbers and zeroes as some +ve value but that should be greater than nums.size()\\n\\t// because we are going to use these (elements-1) as index to mark the presence of corresponding element\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\tif(nums[i]<=0)nums[i]=nums.size()+1;\\n\\t\\t}\\n        \\n\\t\\t// mark the presence of each element if it is between 1 to nums.size()\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\t//since we are marking presence of an element by making element of its corresponding index as -ve\\n\\t\\t\\t// therefore, we need to take +ve value or actual value of that element (as it may have been made -ve during process)\\n\\t\\t\\tint element=abs(nums[i]);\\n\\t\\t\\t// now, presence of each element is marked at an index less by 1 than that element\\n\\t\\t\\t// eg. presence of 1 is marked at index 0\\n\\t\\t\\t// i.e. if 1 is present, we will make element at index 0 as -ve\\n            int index=element-1;;\\n            if(index<nums.size() && nums[index]>0)nums[index]*=(-1);\\n        }\\n        \\n\\t\\t// finally, index that is still having +ve value means that no element marked it\\n\\t\\t// i.e. that index+1 element is not present in the array\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n\\t\\t// & if all elements from 1 to nums.size() are present, then first missing positive integer is  nums.size()+1\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// we can also use method where we first move all non-positive elements to left\\n// But, this method makes things more easy as we will have our answer in range [1, nums.size()+1]\\n    int firstMissingPositive(vector<int>& nums) {\\n\\t// first of all, make all -ve numbers and zeroes as some +ve value but that should be greater than nums.size()\\n\\t// because we are going to use these (elements-1) as index to mark the presence of corresponding element\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\tif(nums[i]<=0)nums[i]=nums.size()+1;\\n\\t\\t}\\n        \\n\\t\\t// mark the presence of each element if it is between 1 to nums.size()\\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\t//since we are marking presence of an element by making element of its corresponding index as -ve\\n\\t\\t\\t// therefore, we need to take +ve value or actual value of that element (as it may have been made -ve during process)\\n\\t\\t\\tint element=abs(nums[i]);\\n\\t\\t\\t// now, presence of each element is marked at an index less by 1 than that element\\n\\t\\t\\t// eg. presence of 1 is marked at index 0\\n\\t\\t\\t// i.e. if 1 is present, we will make element at index 0 as -ve\\n            int index=element-1;;\\n            if(index<nums.size() && nums[index]>0)nums[index]*=(-1);\\n        }\\n        \\n\\t\\t// finally, index that is still having +ve value means that no element marked it\\n\\t\\t// i.e. that index+1 element is not present in the array\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n\\t\\t// & if all elements from 1 to nums.size() are present, then first missing positive integer is  nums.size()+1\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997296,
                "title": "java-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n\\t\\t//set any 0 or negative number as the size of the array + 1\\n\\t\\t//[1,2,*-3*,4] => [1,2,*5*,4]\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] <= 0) {\\n                nums[i] = nums.length + 1;\\n            }\\n        }\\n        \\n\\t\\t//if the absolute value is a valid position of this array, then \\n\\t\\t//negate the value of the respective index\\n\\t\\t// [1,2,5,4] =>  [-1,-2,5,-4]\\n        for(int i = 0; i < nums.length; i++) {\\n            int valueIdx = Math.abs(nums[i]) - 1;\\n            if(valueIdx + 1 > 0 && valueIdx + 1 <= nums.length) {\\n                nums[valueIdx] = -Math.abs(nums[valueIdx]);\\n            }\\n        }\\n        \\n\\t\\t//traverse the array from left to right\\n\\t\\t//if there\\'s any positive number then\\n\\t\\t//we found the missing positive number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n\\t\\t//if all elements of the array are correct\\n\\t\\t//return the lenght of the array + 1\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n\\t\\t//set any 0 or negative number as the size of the array + 1\\n\\t\\t//[1,2,*-3*,4] => [1,2,*5*,4]\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] <= 0) {\\n                nums[i] = nums.length + 1;\\n            }\\n        }\\n        \\n\\t\\t//if the absolute value is a valid position of this array, then \\n\\t\\t//negate the value of the respective index\\n\\t\\t// [1,2,5,4] =>  [-1,-2,5,-4]\\n        for(int i = 0; i < nums.length; i++) {\\n            int valueIdx = Math.abs(nums[i]) - 1;\\n            if(valueIdx + 1 > 0 && valueIdx + 1 <= nums.length) {\\n                nums[valueIdx] = -Math.abs(nums[valueIdx]);\\n            }\\n        }\\n        \\n\\t\\t//traverse the array from left to right\\n\\t\\t//if there\\'s any positive number then\\n\\t\\t//we found the missing positive number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] >= 1) {\\n                return i + 1;\\n            }\\n        }\\n        \\n\\t\\t//if all elements of the array are correct\\n\\t\\t//return the lenght of the array + 1\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17302,
                "title": "concise-o-n-solution",
                "content": "    // ignore all the negative, > n\\n    // put the other value back to its order position A[A[i]-1]\\n    int firstMissingPositive(int A[], int n) {\\n        if (n == 0) return 1;\\n        for (int i = 0; i != n; ) {\\n            if (A[i] != i + 1 && A[i] > 0 && A[i] <= n && A[A[i]-1] != A[i])\\n                swap(A[i], A[A[i] - 1]);\\n            else ++i;\\n        }\\n        \\n        for (int i = 0; i != n; ++i)\\n            if (A[i] != i + 1) return i + 1;\\n        return n+1;\\n    }",
                "solutionTags": [],
                "code": "    // ignore all the negative, > n\\n    // put the other value back to its order position A[A[i]-1]\\n    int firstMissingPositive(int A[], int n) {\\n        if (n == 0) return 1;\\n        for (int i = 0; i != n; ) {\\n            if (A[i] != i + 1 && A[i] > 0 && A[i] <= n && A[A[i]-1] != A[i])\\n                swap(A[i], A[A[i] - 1]);\\n            else ++i;\\n        }\\n        \\n        for (int i = 0; i != n; ++i)\\n            if (A[i] != i + 1) return i + 1;\\n        return n+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3259471,
                "title": "very-easy-solution-in-java-using-hashset-with-comment-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpvote if you like it\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will simply add add the values of nums[] in the hashset, then we will declare an  integer variable and initialize it with 1.\\n\\n- So it is clear that if an array conatins of counting numbers from 1 the max it can have is the length of the array.\\n\\n- So we\\'ll check for all the integers from 1 to nums.length if anyone is missing simply return it otherwise return nums.length +1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158509,
                "title": "beats-83-14-first-missing-positive-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe algorithm works as follows:\\n\\nIterate through the array nums.\\nFor each element x in the array, if x is positive and less than or equal to n, and x is not in its correct position, swap it with the element at index x - 1.\\nAfter the above step, all positive integers in the range [1, n] should be in their correct positions.\\nIterate through the array nums again.\\nReturn the first index i where nums[i] != i + 1. The result is i + 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def firstMissingPositive(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    \\n    for i in range(n):\\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\\n    \\n    for i in range(n):\\n        if nums[i] != i + 1:\\n            return i + 1\\n    \\n    return n + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def firstMissingPositive(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    \\n    for i in range(n):\\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\\n    \\n    for i in range(n):\\n        if nums[i] != i + 1:\\n            return i + 1\\n    \\n    return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871770,
                "title": "java-easy-both-bruteforce-and-optimize-solution-0ms-100",
                "content": "**if helpful .. please do Upvote**\\n```\\nclass Solution {\\n    // public int firstMissingPositive(int[] nums) {\\n    //     //1st approach O(n) time and O(n) space\\n    //     Set<Integer> set=new HashSet<>();\\n    //     for(int i:nums){\\n    //         set.add(i);\\n    //     }\\n    //     for(int i=1;i<=nums.length;i++){\\n    //         if(!set.contains(i)){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return nums.length+1;\\n    // }\\n    \\n    \\n    public int firstMissingPositive(int[] nums) {\\n        //2nd approach O(n) time and O(1) space\\n       boolean oneExist=false;\\n        for(int i:nums){\\n            if(i==1){\\n                oneExist=true;\\n            }\\n        }\\n        if(!oneExist){\\n            return 1;\\n        }\\n        \\n        //making sure we will never see a number in the array apart from 1...n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=0 || nums[i]>nums.length){\\n                nums[i]=1; //make those numbers 1\\n            }\\n        }\\n        \\n        //Numbers which we are found in the array mark its corresponding indices visited by making them -ve \\n        for(int i=0;i<nums.length;i++){\\n            int n=Math.abs(nums[i]);\\n            if(n==nums.length){\\n                nums[0]=-1*Math.abs(nums[0]);\\n            }\\n            else{\\n                nums[n]=-1*Math.abs(nums[n]);\\n            }\\n        }\\n        \\n        //now 1st +ve number we get in array that corresponding index is our required answer \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>0){\\n                return i;\\n            }\\n        }\\n        if(nums[0]>0) return nums.length;\\n        \\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // public int firstMissingPositive(int[] nums) {\\n    //     //1st approach O(n) time and O(n) space\\n    //     Set<Integer> set=new HashSet<>();\\n    //     for(int i:nums){\\n    //         set.add(i);\\n    //     }\\n    //     for(int i=1;i<=nums.length;i++){\\n    //         if(!set.contains(i)){\\n    //             return i;\\n    //         }\\n    //     }\\n    //     return nums.length+1;\\n    // }\\n    \\n    \\n    public int firstMissingPositive(int[] nums) {\\n        //2nd approach O(n) time and O(1) space\\n       boolean oneExist=false;\\n        for(int i:nums){\\n            if(i==1){\\n                oneExist=true;\\n            }\\n        }\\n        if(!oneExist){\\n            return 1;\\n        }\\n        \\n        //making sure we will never see a number in the array apart from 1...n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<=0 || nums[i]>nums.length){\\n                nums[i]=1; //make those numbers 1\\n            }\\n        }\\n        \\n        //Numbers which we are found in the array mark its corresponding indices visited by making them -ve \\n        for(int i=0;i<nums.length;i++){\\n            int n=Math.abs(nums[i]);\\n            if(n==nums.length){\\n                nums[0]=-1*Math.abs(nums[0]);\\n            }\\n            else{\\n                nums[n]=-1*Math.abs(nums[n]);\\n            }\\n        }\\n        \\n        //now 1st +ve number we get in array that corresponding index is our required answer \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>0){\\n                return i;\\n            }\\n        }\\n        if(nums[0]>0) return nums.length;\\n        \\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549123,
                "title": "python-straight-forward-with-explanation-must-read-beats-99",
                "content": "#3-pass solution\\n       #nums => [3, 4, 1, 0, -1]\\n#Pass 1: Replace all the non-positive numbers by (length of array)+1\\n       #nums => [3, 4, 1, 6, 6]\\n#Pass 2: Treat input array as array of index and make numbers present at the given index negative. \\n       #nums => [-3, 4, -1, -6, 6]\\n#Pass 3: Return the first index with positive number \\n       #Return 2 (As second number is positive)\\n\\n\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n \\n\\t#Pass 1\\n        for i,n in enumerate(nums):\\n            if n<=0:\\n                nums[i]=len(nums)+1\\n        \\n\\t#Pass 2\\n        for n in nums:\\n            n = abs(n)\\n            if n<=len(nums):\\n                nums[n-1] = -1 * abs(nums[n-1])    \\n     \\n\\t #Pass 3\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                return i+1\\n            \\n        return len(nums)+1",
                "solutionTags": [],
                "code": "#3-pass solution\\n       #nums => [3, 4, 1, 0, -1]\\n#Pass 1: Replace all the non-positive numbers by (length of array)+1\\n       #nums => [3, 4, 1, 6, 6]\\n#Pass 2: Treat input array as array of index and make numbers present at the given index negative. \\n       #nums => [-3, 4, -1, -6, 6]\\n#Pass 3: Return the first index with positive number \\n       #Return 2 (As second number is positive)\\n\\n\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n \\n\\t#Pass 1\\n        for i,n in enumerate(nums):\\n            if n<=0:\\n                nums[i]=len(nums)+1\\n        \\n\\t#Pass 2\\n        for n in nums:\\n            n = abs(n)\\n            if n<=len(nums):\\n                nums[n-1] = -1 * abs(nums[n-1])    \\n     \\n\\t #Pass 3\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                return i+1\\n            \\n        return len(nums)+1",
                "codeTag": "Python3"
            },
            {
                "id": 489072,
                "title": "c-simple-o-n-time-beats-100-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/first-missing-positive/solution/\\n    \\n    The idea is to move each number to its correct 0-indexed position. Then traverse\\n    the array for the second time and the first index where the number doesn\\'t match is\\n    the answer. If the array has everything in place, then N + 1 is the answer.\\n    The fact that the array size is N, so even if there are numbers greater than N,\\n    they need not be considered as the array that should be at that place can always be the\\n    answer even if all other numbers are present, so need to consider > N.\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i = 0; i < nums.size();) {\\n            // swap the current number to its correct position\\n            if(nums[i] >= 0 && nums[i] - 1 >= 0 && nums[i] - 1 < nums.size()) {\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n            // if the current number is -ve, 0 or greater than array length or\\n            // the number is already at its correct position or the correct position\\n            // of the current number already has a duplicate of this, skip current number\\n            if(nums[i] <= 0 || nums[i] == i+1 || nums[i] > nums.size() ||\\n               nums[nums[i]-1] == nums[i])\\n                ++i;\\n        }\\n        \\n        // answer is the first position (1 based) that doesn\\'t match the number there\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/first-missing-positive/solution/\\n    \\n    The idea is to move each number to its correct 0-indexed position. Then traverse\\n    the array for the second time and the first index where the number doesn\\'t match is\\n    the answer. If the array has everything in place, then N + 1 is the answer.\\n    The fact that the array size is N, so even if there are numbers greater than N,\\n    they need not be considered as the array that should be at that place can always be the\\n    answer even if all other numbers are present, so need to consider > N.\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i = 0; i < nums.size();) {\\n            // swap the current number to its correct position\\n            if(nums[i] >= 0 && nums[i] - 1 >= 0 && nums[i] - 1 < nums.size()) {\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n            // if the current number is -ve, 0 or greater than array length or\\n            // the number is already at its correct position or the correct position\\n            // of the current number already has a duplicate of this, skip current number\\n            if(nums[i] <= 0 || nums[i] == i+1 || nums[i] > nums.size() ||\\n               nums[nums[i]-1] == nums[i])\\n                ++i;\\n        }\\n        \\n        // answer is the first position (1 based) that doesn\\'t match the number there\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311888,
                "title": "clearing-problem-description-with-detailed-solution-explaination",
                "content": "**Clearing problem description:**\\n- Problem is asking you to find the number \"starting from 1\" which is missing. For example:\\n- - [1,2,0], we are ignoring numbers<=0 so if we write this in order we get \"1 2\" here 3 is first missing positive\\n- - [3,4,-1,1] , writing this in order we get \"1 3 4\" and thus 2 is first missing positive\\n- - [7,8,9,10], starting from 1, here 1 is first missing positive\\n\\n**Solution:**\\nI am going to give you an O(3n) solution but using this similarly you can get the O(2n) solution. Note that both are O(n) solution\\n\\nTake N = length of array\\nFirst of all in array, set all \"zero and numbers greater than N\" to -1 since they are no use to us. I will tell you later why I chose -1.\\n\\nNow for all positive numbers \"p\" left in the array, we will set array[p-1] = 0, but before doing so we should also take care of the number present in (p-1)th position.\\nHere 0 implies that number p is present in the array. So later when we see 0 at index i in array we can say that i+1 is definitely present in the array. \\nAfter settings zeros, the first missing number will be:  index(\"non zero number\") +1\\nIf all are zeros then first missing number will be len(array)+1\\n\\nFor example: [3,4,-1,1] ,\\nApplying above procedure:\\n- when i=0 --> [3 4 0 1]\\n- when i =1 -->[3 4 0 0] --> [0 4 0 0]\\n- when i=2 since idx<0 pass\\n- when i=3 since idx<0 pass\\nwe get [0 4 0 0] so first missing is 2\\n\\n**Algorithm(pseudocode):**\\n\\nFor i in ( 0 to length(array)-1 )\\n**{**\\n\\n p = array[i];  \\n Index idx = p-1;\\n\\nwhile(idx>=0 and idx<length(array)) {\\n* store the value at idx to a variable temp. i.e. temp = array[idx]\\n* Set array[idx] = 0.  \\n* Jump to temp-1 location by doing idx=temp-1 \\n}\\n\\n**}**\\n\\nSo what will happen is that for all the positive numbers the inner loop will jump and set array[idx]=0 for numbers in the array. When temp<=0 then idx=temp-1<0, so inner loop will break. This is why I set useless items to -1.\\nOuter loop will ensure that no numbers are left out.\\n\\nTime complexity is O(3n) because setting all \"zero and numbers greater than N\" to -1 takes O(n),\\nouter loop takes O(n)\\nInner jumps will be at max O(n) because after setting all positive number\\'s corresponding indexes to 0 there will be no jump.\\n\\n**Python code:**\\n```\\ndef firstMissingPositive(self, nums):\\n\\tif not nums:\\n\\t    return 1\\n\\n\\tN = len(nums)\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] ==0 or nums[i] > N:\\n\\t        nums[i] = -1\\n\\tfor i in xrange(len(nums)):\\n\\t    idx = nums[i]-1\\n\\t    while(idx>=0 and idx<N):\\n\\t        tmp = nums[idx]\\n\\t        nums[idx] = 0\\n\\t        idx = tmp-1\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] != 0:\\n\\t        return i+1\\n\\treturn len(nums)+1\\n```\\n\\nThe O(2n) method involves setting array[idx] = idx+1 and breaking the inner while loop when array[idx] = idx+1 is already set",
                "solutionTags": [],
                "code": "```\\ndef firstMissingPositive(self, nums):\\n\\tif not nums:\\n\\t    return 1\\n\\n\\tN = len(nums)\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] ==0 or nums[i] > N:\\n\\t        nums[i] = -1\\n\\tfor i in xrange(len(nums)):\\n\\t    idx = nums[i]-1\\n\\t    while(idx>=0 and idx<N):\\n\\t        tmp = nums[idx]\\n\\t        nums[idx] = 0\\n\\t        idx = tmp-1\\n\\tfor i in xrange(len(nums)):\\n\\t    if nums[i] != 0:\\n\\t        return i+1\\n\\treturn len(nums)+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3243954,
                "title": "java-easy-approach-constant-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nput the element that are in range 1 to n to their correct pos like \\nnums[i]-1 pos. then the first element which does match with their pos is the ans.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n       int i=0;\\n       while(i<n){\\n           int a=nums[i];\\n           if(a>=1 && a<=n){\\n               if(nums[a-1]!=a){\\n                   nums[i]=nums[a-1];\\n                   nums[a-1]=a;\\n               }\\n               else i++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n      for(int j=0;j<n;j++){\\n          if(nums[j]!=j+1)return j+1;\\n      }\\n      return n+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n       int i=0;\\n       while(i<n){\\n           int a=nums[i];\\n           if(a>=1 && a<=n){\\n               if(nums[a-1]!=a){\\n                   nums[i]=nums[a-1];\\n                   nums[a-1]=a;\\n               }\\n               else i++;\\n           }\\n           else{\\n               i++;\\n           }\\n       }\\n      for(int j=0;j<n;j++){\\n          if(nums[j]!=j+1)return j+1;\\n      }\\n      return n+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764215,
                "title": "python-o-n-with-explanation-inverse-pigeonhole-principle",
                "content": "Since we have to use constant space (ie. can\\'t allocate something of `nums` size), we can modify the original input array `nums` to help us instead. \\n\\n**Idea:** Modify `nums` in-place as an array that represents each positive integer\\'s (\\u2208 [1, n]) presence. Then scan from left to right to find smallest index without presence.\\n\\n`eg. nums = [3, 4, -1, 1]`\\n\\nFirst, since `nums` is of size n, we know the first missing positive will be in the range [1, n + 1]. Thus, we will transform all values outside of the range [1, n] to n + 1. You will see why I used n + 1 in the next step, but ultimately, it has to be a value > n or = 0.\\n\\n```\\nn = 4\\n[3, 4, 5, 1]\\n```\\n\\nNext, for each x \\u2208 `nums`, if x is in range [1, n], we mark `nums[x - 1]` as a negative value. We use the +/- representation here as a pseudo boolean value (seen in the code below) as we don\\'t want to modify the (absolute) value itself as the value may be accessed later on.\\n\\n`[-3, 4, -5, -1]`\\n\\nFinally, from left to right, if `nums[i] > 0`, then the `i + 1` value must be the first missing positive. If we go through this loop without finding a positive value, then `n + 1` must be the first missing positive.\\n\\n`[-3, 4, -5, -1] -> return 2 ( i = 1)`\\n\\n**Code:**\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if not (0 < nums[i] <= n):\\n                nums[i] = n + 1\\n        for i in range(n):\\n            x = abs(nums[i])\\n            if 0 < x <= n:\\n                nums[x - 1] = abs(nums[x - 1]) * -1\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```\\nPS. This relies on something I\\'ll call inverse pigeonhole principle. If there are n values from [1, m], and each x \\u2208 [1, m] is put into index x - 1 of m containers with n <= m, then at least one container will not have anything, or m + 1 will be the smallest container we have to add that will not have anything.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nn = 4\\n[3, 4, 5, 1]\\n```\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            if not (0 < nums[i] <= n):\\n                nums[i] = n + 1\\n        for i in range(n):\\n            x = abs(nums[i])\\n            if 0 < x <= n:\\n                nums[x - 1] = abs(nums[x - 1]) * -1\\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024371,
                "title": "c-0ms-runtime-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int firstMissingPositive(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        for(int i = 0; i < nums.size(); ++ i)\\n            while(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n        \\n        for(int i = 0; i < nums.size(); ++ i)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int firstMissingPositive(vector<int>nums)\\n    {\\n        int n=nums.size();\\n        for(int i = 0; i < nums.size(); ++ i)\\n            while(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n        \\n        for(int i = 0; i < nums.size(); ++ i)\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722399,
                "title": "no-code-just-explanation-o-n-time-o-1-space-complexity",
                "content": "If we have an array of length n we know \"smallest missing positive integer\" must be in between 1 and n+1(inclusive).\\n\\nFor example:\\n[3,1,2,8,9] in this case we have an array of length n=5, so our smallest missing positive integer must lie between 1 and 5+1 = 6(inclusive).\\n\\nClearly, those values that are greater than n(5) should not be in here. Because if we have any value greater than n those values are occupying some samller values place. For example, 8 is occupying index 3 where we should have either 4 or 5 and also 9 is occupying index 4 where we should have either 5 or 4.\\n\\nThe same goes for any value less than or equal to 0.\\n\\nFor example:\\n[-1,-2,3,1,2]\\n-1 is at index 0 where we should either 4 or 5, the same is true for -2 as well.\\n\\nSo, values that are >n and <=0 are all garbage. We don\\'t need those.\\n\\nLet\\'s modify the array:\\n[3,1,2,8,9] will become [3,1,2,1,1]\\n[-1,-2,3,1,2] will become [1,1,3,1,2]\\n\\nWhy are we putting 1 in place of those values?\\n\\nWe know that, 1 is the smallest positive integer from 1 to infinity.\\n\\nSo if our array does not contain 1 then we know for sure that 1 is going to be the answer. There is no point checking further.\\n\\nBut, if we do have 1 as an item inside the array then some other value[ >1 && <=n ] inside the array which is missing will be the answer. If none are missing then n+1 will be the answer.\\n\\nWith that in mind when we see any garbage value that should not be in this array we replace that value with 1, which we already knew is present in the array. Between garbage value and 1, only 1 is allowed to be present in our modified array.\\n\\nOnce we are done processing our array, we know all the values inside the array should lie between 1 & n(inclusive).\\n\\nOne more processing needs to happen before we look for the answer.\\nAs an easier example, let\\'s say after processing up till this point we got an array like this:\\n[1,2,3,3]\\nIn an ideal case we should have had [1,2,3,4], if all the values were present. Now in this case which one is not present? How can you tell? \\nIf we take each value of each index and update the corresponding value to it\\'s negative then we will have an array like this [-1,-2,-3,3].\\nHow? Take i=2, update whatever is present to negative:\\n```\\n                int index = Math.abs(nums[i])-1;\\n                nums[index] = -Math.abs(nums[index]);\\n```\\n[1,2,2,3] , similarly:\\n[-1,-2,-2,3]\\n\\nAfter that, we will check for the first index where the value is still positive. Our answer will be that index+1.\\n\\nIf this is not the case then our answer will be n+1 since all the values between 1 and n are present in the array.\\n\\nHope this will help anyone who is not looking for code but explanation.\\n\\n**Still need the solution? \\nhttps://nextswe.com/leetcode-41-first-missing-positive/ \\nCode is at the bottom of the explanation.**",
                "solutionTags": [],
                "code": "```\\n                int index = Math.abs(nums[i])-1;\\n                nums[index] = -Math.abs(nums[index]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17230,
                "title": "java-accepted-no-swap-just-use-push",
                "content": "number i should be in index i-1 of nums.\\nkeep pushing number A into its right place, and push out the existing number B from this place and continue push number B into its right place again.\\n\\ni.e. start from the first number 3\\n \\nIndex:0, 1, 2, 3,  4\\n\\nArray: 3, 4, 5, 1, -1  curr number 3\\n\\nArray: 3, 4, 3, 1, -1 push 3 to index 2, the number being pushed out is 5\\n\\nArray: 3, 4, 3, 1, 5  push 5 to index 4, the number being pushed out is -1, so we stop.\\n\\nArray: 3, 4, 3, 4, 5  next number is 4, push 4 to index 3, the number being pushed out is 1\\n\\nArray: 1, 4, 3, 4, 5  push 1 to index 0, the number being pushed out is 3\\n\\nArray: 1, 4, 3, 4, 5  since 3 is already at index 2 (right place), we stop\\n\\ncheck next number is 3 (already right place), then 4 (right place), then 5 (right place), stop.\\n\\nNow we compare each number with its index, should be number == index+1, otherwise the number is the first missing positive.\\n\\n    public class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            // nums[i] -> i+1\\n            int next;\\n            for (int i = 0 ; i < nums.length; i++) {\\n                int curr = nums[i];\\n                if (curr > 0 && curr != i+1 && curr <= nums.length) {\\n                    do {\\n                        next = nums[curr-1];\\n                        nums[curr-1] = curr;\\n                        curr = next;\\n                    } while (curr > 0 && curr <= nums.length && nums[curr-1] != curr);\\n                }\\n            }\\n            int j;\\n            for (j = 0; j < nums.length; j++) {\\n                if (nums[j] != j+1)\\n                    break;\\n            }\\n            return j+1;\\n        }\\n    }",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n        public int firstMissingPositive(int[] nums) {\\n            // nums[i] -> i+1\\n            int next;\\n            for (int i = 0 ; i < nums.length; i++) {\\n                int curr = nums[i];\\n                if (curr > 0 && curr != i+1 && curr <= nums.length) {\\n                    do {\\n                        next = nums[curr-1];\\n                        nums[curr-1] = curr;\\n                        curr = next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 17256,
                "title": "short-python-solution-using-abs",
                "content": "set the index of the corresponding number to negative if the number does not exceed the length of list.\\n\\n    class Solution(object):\\n        def firstMissingPositive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            for i in xrange(n):\\n                if nums[i] <= 0: nums[i] = len(nums)+1\\n            for i in xrange(n):\\n                if abs(nums[i]) <= n: nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1])\\n            for i in xrange(n):\\n                if nums[i] > 0: return i+1\\n            return n+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "set the index of the corresponding number to negative if the number does not exceed the length of list.\\n\\n    class Solution(object):\\n        def firstMissingPositive(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n = len(nums)\\n            for i in xrange(n):\\n                if nums[i] <= 0: nums[i] = len(nums)+1\\n            for i in xrange(n):\\n                if abs(nums[i]) <= n: nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1])\\n            for i in xrange(n):\\n                if nums[i] > 0: return i+1\\n            return n+1",
                "codeTag": "Java"
            },
            {
                "id": 2644922,
                "title": "both-apporch-you-can-understand-easily",
                "content": "```\\nint firstMissingPositive(vector<int>& nums) {\\n\\n        unordered_map<int,int>m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n           m[nums[i]]++;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            if(m.find(i)==m.end())\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\t// t(c)=o(n)\\n\\ts(c)=o(n)\\n\\t\\n\\t\\n\\t// swap sort\\n\\t int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            if(nums[i]>0&&nums[i]<=n&&nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n            else\\n                i++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n               return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n\\t\\tt(c)=o(n);\\n\\t\\ts(c)=o(1);\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(vector<int>& nums) {\\n\\n        unordered_map<int,int>m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n           m[nums[i]]++;\\n        }\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            if(m.find(i)==m.end())\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\t// t(c)=o(n)\\n\\ts(c)=o(n)\\n\\t\\n\\t\\n\\t// swap sort\\n\\t int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            if(nums[i]>0&&nums[i]<=n&&nums[i]!=nums[nums[i]-1])\\n                swap(nums[i],nums[nums[i]-1]);\\n            else\\n                i++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n               return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n\\t\\tt(c)=o(n);\\n\\t\\ts(c)=o(1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2148440,
                "title": "cpp-solution-with-added-comments-o-1-memory-o-n-time",
                "content": "#  Runtime 54.15% and Memory 77.83%\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n//         we have no use with -ve elements iin list so, make them useless by making them out of range\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]<=0){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n       //         we convert our existing array to a map, without using extra space\\n//  so, all we need to check if you have the elements in range[1,nums.size()+1]\\n//         so basically if that element is present just go to tht index and make it negative\\n        for(int i =0;i<nums.size();i++){\\n            int ind = abs(nums[i])-1;\\n            if (ind>=0 and ind<nums.size() and nums[ind]>0) \\n                nums[ind]=-nums[ind];\\n        }\\n//         finally the missing element basically wont be flagged negative so return that position\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]>=0)\\n                return i+1;\\n        }\\n// in case the array was flagged completely negative basically the missing element is 1 more than size of array\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n//         we have no use with -ve elements iin list so, make them useless by making them out of range\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]<=0){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n       //         we convert our existing array to a map, without using extra space\\n//  so, all we need to check if you have the elements in range[1,nums.size()+1]\\n//         so basically if that element is present just go to tht index and make it negative\\n        for(int i =0;i<nums.size();i++){\\n            int ind = abs(nums[i])-1;\\n            if (ind>=0 and ind<nums.size() and nums[ind]>0) \\n                nums[ind]=-nums[ind];\\n        }\\n//         finally the missing element basically wont be flagged negative so return that position\\n        for(int i=0;i<nums.size();i++){\\n            if (nums[i]>=0)\\n                return i+1;\\n        }\\n// in case the array was flagged completely negative basically the missing element is 1 more than size of array\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704248,
                "title": "easy-c-solution-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First, we store the minimum value in ***mn*** & in between make all values 1 which are less than 1 or greater than n.\\n- **The logic behind it:** if the array is size n, then max possible n positive character. if any value is greater than n, then there is already an element from 1 to n that is not present.\\n- After the loop ends, if we find ***mn is greater than 1***, that means 1 is not present & simply ***return 1***.\\n- Else we\\u2019ll iterate again & go to the index from elements and if it\\u2019s not negative then make it negative.\\n- Again iterate all elements & the first index where ***the element is positive***, which means that element is not present. So ***return i+1***.\\n- Still, we iterate all elements and didn\\u2019t find the ans that means elements are from 1 to n, in the array, so return ***n+1***.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0 && mn>nums[i])\\n                mn = nums[i];\\n            if(nums[i]<1 || nums[i]>n) \\n                nums[i]=1;\\n        }\\n        if(mn > 1)\\n            return 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[abs(nums[i])-1]>0) \\n                nums[abs(nums[i])-1] *= -1;            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0) return i+1;\\n        }\\n        \\n        return n+1;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0 && mn>nums[i])\\n                mn = nums[i];\\n            if(nums[i]<1 || nums[i]>n) \\n                nums[i]=1;\\n        }\\n        if(mn > 1)\\n            return 1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[abs(nums[i])-1]>0) \\n                nums[abs(nums[i])-1] *= -1;            \\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0) return i+1;\\n        }\\n        \\n        return n+1;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318705,
                "title": "java-1-ms-time-beats-96-3-progressive-methods-with-idea",
                "content": "**Method 1:**\\n**T/S:** O(n lg n)/O(1)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar lastPositiveSeen = 1;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] <= 0 || (i > 0 && nums[i] == nums[i - 1])) // ignore non-positives and duplicates\\n\\t\\t\\tcontinue;\\n\\t\\tif (nums[i] == lastPositiveSeen)\\n\\t\\t\\tlastPositiveSeen++;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn lastPositiveSeen;\\n}\\n```\\n\\n**Method 2:**\\n**T/S:** O(n)/O(n)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar max = Integer.MIN_VALUE;\\n\\tvar set = new HashSet<Integer>();\\n\\tfor (var num : nums) {\\n\\t\\tset.add(num);\\n\\t\\tmax = Math.max(max, num);\\n\\t}\\n\\tif (max < 1)\\n\\t\\treturn 1;\\n\\tfor (var i = 1; i <= max; i++)\\n\\t\\tif (!set.contains(i))\\n\\t\\t\\treturn i;\\n\\treturn max + 1;\\n}\\n```\\n\\n**Method 3:**\\n**Idea:**\\n* Progress from Method 2 to Method 3, thinking on the line of O(1) time access. Index of array can be paired up with values of array to give a hint on the solution.\\n* Ignore non-positives.\\n* The technique is a bit similar to wiggle sort. \\n* It needs some practice, experience and hitting the questions from multiple directions to arrive to this solution.\\n* Constant run-time in arrays is usually achieved with two-pointers, swapping, multi-scan (this question required traversing the array twice) etc.\\n* Arrays provide O(1) time access and are often used as look-up tables if the keys (array index) can be kept within bounds.\\n* Here we put positives in their \"right place\" which is defined as value of the number - 1\\n\\n**T/S:** O(n)/O(1) (This constraint makes it LC Hard)\\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\t//  put positives in their right place as long as possible\\n\\t\\twhile (0 <= nums[i] - 1 && nums[i] - 1 < n && nums[i] != nums[nums[i] - 1]) \\n\\t\\t\\tswap(nums, nums[i] - 1, i);\\n\\n\\t// scan for first missing positive\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1)\\n\\t\\t\\treturn i + 1;\\n\\treturn n + 1;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```\\n\\n```\\nWhat swap would look like for this array: [2, 3, 7, 6, 8, -1, -10, 15]\\n\\n[2, 3, 7, 6, 8, -1, -10, 15]\\n[3, 2, 7, 6, 8, -1, -10, 15]\\n[7, 2, 3, 6, 8, -1, -10, 15]\\n[-10, 2, 3, 6, 8, -1, 7, 15]\\n[-10, 2, 3, -1, 8, 6, 7, 15]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int firstMissingPositive(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tvar lastPositiveSeen = 1;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] <= 0 || (i > 0 && nums[i] == nums[i - 1])) // ignore non-positives and duplicates\\n\\t\\t\\tcontinue;\\n\\t\\tif (nums[i] == lastPositiveSeen)\\n\\t\\t\\tlastPositiveSeen++;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn lastPositiveSeen;\\n}\\n```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar max = Integer.MIN_VALUE;\\n\\tvar set = new HashSet<Integer>();\\n\\tfor (var num : nums) {\\n\\t\\tset.add(num);\\n\\t\\tmax = Math.max(max, num);\\n\\t}\\n\\tif (max < 1)\\n\\t\\treturn 1;\\n\\tfor (var i = 1; i <= max; i++)\\n\\t\\tif (!set.contains(i))\\n\\t\\t\\treturn i;\\n\\treturn max + 1;\\n}\\n```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tvar n = nums.length;\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\t//  put positives in their right place as long as possible\\n\\t\\twhile (0 <= nums[i] - 1 && nums[i] - 1 < n && nums[i] != nums[nums[i] - 1]) \\n\\t\\t\\tswap(nums, nums[i] - 1, i);\\n\\n\\t// scan for first missing positive\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tif (nums[i] != i + 1)\\n\\t\\t\\treturn i + 1;\\n\\treturn n + 1;\\n}\\n\\nprivate void swap(int[] nums, int i, int j) {\\n\\tvar temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```\n```\\nWhat swap would look like for this array: [2, 3, 7, 6, 8, -1, -10, 15]\\n\\n[2, 3, 7, 6, 8, -1, -10, 15]\\n[3, 2, 7, 6, 8, -1, -10, 15]\\n[7, 2, 3, 6, 8, -1, -10, 15]\\n[-10, 2, 3, 6, 8, -1, 7, 15]\\n[-10, 2, 3, -1, 8, 6, 7, 15]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478668,
                "title": "java-clean-100-o-1-space-o-n-time-comments",
                "content": "```    \\n    /**\\n     * The insight here is that each number in the array must fall within the size of the array.\\n     * For example, if the size of the array is 20, then the first missing positive integer has\\n     * to be [1..21] (note 21 is the case where all the given numbers fall within the size of\\n     * the array).\\n     *\\n     * So, to figure out which number is missing, we place each number into the index that cooresponds\\n     * to the numbers\\'s value+1 (similar to a modified count sort).  If the number falls outside the\\n     * range of the array then it can\\'t be a missing value.\\n     *\\n     * Finally, we run through the array to find which index didn\\'t have a corresponding value.\\n     * In the case all values are present then the first one \"missing\" is the length of the array+1.\\n     */\\n    public static int firstMissingPositive(int[] nums) {\\n        \\n        for (int i=0; i < nums.length; i++) {\\n            int insertIdx = nums[i]-1;\\n            if (insertIdx >= 0 && insertIdx < nums.length && nums[insertIdx] != nums[i]) {\\n                int temp = nums[insertIdx];\\n                nums[insertIdx] = nums[i];\\n                nums[i] = temp;\\n                i--;\\n            }\\n        }\\n\\n        for (int i=0; i < nums.length; i++) {\\n            if (nums[i]-1 != i) return i+1;\\n        }\\n\\n        return nums.length+1;\\n    }",
                "solutionTags": [],
                "code": "```    \\n    /**\\n     * The insight here is that each number in the array must fall within the size of the array.\\n     * For example, if the size of the array is 20, then the first missing positive integer has\\n     * to be [1..21] (note 21 is the case where all the given numbers fall within the size of\\n     * the array).\\n     *\\n     * So, to figure out which number is missing, we place each number into the index that cooresponds\\n     * to the numbers\\'s value+1 (similar to a modified count sort).  If the number falls outside the\\n     * range of the array then it can\\'t be a missing value.\\n     *\\n     * Finally, we run through the array to find which index didn\\'t have a corresponding value.\\n     * In the case all values are present then the first one \"missing\" is the length of the array+1.\\n     */\\n    public static int firstMissingPositive(int[] nums) {\\n        \\n        for (int i=0; i < nums.length; i++) {\\n            int insertIdx = nums[i]-1;\\n            if (insertIdx >= 0 && insertIdx < nums.length && nums[insertIdx] != nums[i]) {\\n                int temp = nums[insertIdx];\\n                nums[insertIdx] = nums[i];\\n                nums[i] = temp;\\n                i--;\\n            }\\n        }\\n\\n        for (int i=0; i < nums.length; i++) {\\n            if (nums[i]-1 != i) return i+1;\\n        }\\n\\n        return nums.length+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 231337,
                "title": "python-solution",
                "content": "Idea: change `nums[n-1]` to `float(\\'inf\\')` for all `n` in `nums` if `1 <= n <= len(nums)`, meaning that we have seen `n` in `nums`. Then we traverse `nums` once more, and find the first `idx` such that `nums[idx] != float(\\'inf\\')`, then `idx+1` will be the first missing positive in `nums`. If no such `idx` exists, it means that we have seen `1, 2, ..., len(nums)` in `nums`, hence the first missing positive is `len(nums)+1`.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                continue\\n            else:\\n                while n <= len(nums) and n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = float(\\'inf\\')\\n                    n = tmp\\n        for i in range(len(nums)):\\n            if nums[i] != float(\\'inf\\'):\\n                return i+1\\n            \\n        return len(nums)+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        for i, n in enumerate(nums):\\n            if n < 0:\\n                continue\\n            else:\\n                while n <= len(nums) and n > 0:\\n                    tmp = nums[n-1]\\n                    nums[n-1] = float(\\'inf\\')\\n                    n = tmp\\n        for i in range(len(nums)):\\n            if nums[i] != float(\\'inf\\'):\\n                return i+1\\n            \\n        return len(nums)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181362,
                "title": "o-n-time-o-1-space-solution-x-2",
                "content": "### Solution 1\\nMark all non-positve `nums` as `MAX`, and mark `nums[abs(nums[i]) - 1]` as negative when we first met `abs(nums[i])`. In this way, the first missing positive is the `index` of the first positive element in nums `+ 1`\\n****\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums.length == 0) return 1;\\n        \\n        int numLen = nums.length;\\n\\t\\t\\n        // Mark non-positive as MAX.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] <= 0) nums[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Mark on original array.\\n        for (int i = 0; i < numLen; i++) {\\n            int absNum = Math.abs(nums[i]);\\n            if (absNum != Integer.MAX_VALUE && absNum - 1 < numLen && nums[absNum - 1] > 0) {\\n                nums[absNum - 1] = -nums[absNum - 1];\\n            }\\n        }\\n        \\n        // Get first missing positive.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] > 0) return i + 1;  \\n        }\\n\\n        return numLen + 1;\\n    }\\n```\\n### Solution 2\\nIf nums are consecutive, then `each nums[i] == i + 1`. If we put valid nums[i] into their right position by swapping, then the first `i + 1 such that nums[i] != i + 1` must be the first missing number.\\n```\\n    public int firstMissingPositive(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 \\n                && nums[i] >= 1\\n                && nums[i] <= nums.length\\n                && nums[nums[i] - 1] != nums[i]) {\\n                swap(i, nums[i] - 1, nums);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    \\n    private void swap(int i, int j, int[] nums) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums.length == 0) return 1;\\n        \\n        int numLen = nums.length;\\n\\t\\t\\n        // Mark non-positive as MAX.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] <= 0) nums[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Mark on original array.\\n        for (int i = 0; i < numLen; i++) {\\n            int absNum = Math.abs(nums[i]);\\n            if (absNum != Integer.MAX_VALUE && absNum - 1 < numLen && nums[absNum - 1] > 0) {\\n                nums[absNum - 1] = -nums[absNum - 1];\\n            }\\n        }\\n        \\n        // Get first missing positive.\\n        for (int i = 0; i < numLen; i++) {\\n            if (nums[i] > 0) return i + 1;  \\n        }\\n\\n        return numLen + 1;\\n    }\\n```\n```\\n    public int firstMissingPositive(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] != i + 1 \\n                && nums[i] >= 1\\n                && nums[i] <= nums.length\\n                && nums[nums[i] - 1] != nums[i]) {\\n                swap(i, nums[i] - 1, nums);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        \\n        return nums.length + 1;\\n    }\\n    \\n    \\n    private void swap(int i, int j, int[] nums) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599047,
                "title": "1-ms-java-solution-o-n-time-and-o-1-space",
                "content": "if you like it please upvote it\\n\\nclass Solution \\n{\\npublic int firstMissingPositive(int[] nums)\\n{\\n      int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=0 || nums[i]>n)\\n            { \\n              nums[i]=n+1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=Math.abs(nums[i]);\\n            if(val>n)continue;\\n            \\n            if(nums[val-1]>0)\\n             nums[val-1]=-nums[val-1];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)return i+1;\\n        }\\n        \\n        return n+1;\\n        \\n    }\\n}\\n-------------------------------------------------------------------\\n![image](https://assets.leetcode.com/users/images/d0c2c8ad-0b3c-46eb-94f0-75caf904b4c4_1663623875.2498913.png)\\n-------------------------------------------------------------------\\nApproach Explaination :- \\n-----------------\\n1. Assign all the values which is less than 1 and greater than n as n+1\\n2. Now iterate value one by one and mark the value as negative . Negative means value exist in array.\\n3. After completion of previous step iterate array again .\\n4. Now check for positive value  ! if you find any return index+1 . else return n+1\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution \\n{\\npublic int firstMissingPositive(int[] nums)\\n{\\n      int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=0 || nums[i]>n)\\n            { \\n              nums[i]=n+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1641066,
                "title": "c-logical-solution-without-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }\\n            \\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                return i+1;\\n            }\\n        }\\n        \\n        return n+1;\\n        \\n    }\\n};\\n\\n\\n// please upvote if found helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1326347,
                "title": "6-lines-solution-c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] <= 0) nums[i] = 1000000;\\n\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++)\\n            if (abs(nums[i]) - 1 < nums.size())\\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\\n\\t\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++) if (nums[i] > 0) break;\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i;\\n        for (i = 0; i < nums.size(); i++)\\n            if (nums[i] <= 0) nums[i] = 1000000;\\n\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++)\\n            if (abs(nums[i]) - 1 < nums.size())\\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\\n\\t\\t\\t\\t\\n        for (i = 0; i < nums.size(); i++) if (nums[i] > 0) break;\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764421,
                "title": "c-o-1-space-o-n-time-with-explanation",
                "content": "For an array size of ```N```, we have that the first missing positive is between ```0``` and ```N+1```. This may take some time to think about but the best case is you have all the positive integers from ```0``` to ```N```, in which case the answer is ```N+1```. If you change any one of those values to something greater than ```N``` or less than ```0```, then the answer will be between ```0``` and ```N+1```. So this property holds.\\n\\nWe can abuse this property. Any number less than ```0``` and greater than ```N+1``` will not be inside this range. So we can iterate through and change these values to ```N+1``` (to keep it simple, but they need to be set to something that is at least ```N+1``` or bigger) since they are useless to us.\\n\\nThe next step is to iterate through the array again and use a simple hack: treat the numbers as indicies. We index the array using this value and we make the indexed value negative to \"tick\" it off. We need to remember to take the absoloute value every time we calculate the index because we are using the array for two purposes: to keep track which ones we tick off, and which ones we need to tick off still. This may be a little unintitive so here is how I thought about it (using an extrra array for visual purposes only):\\n\\nStarting array: ```[-5, 2, 3, 5, 1, 8]```\\nTicked off (```#``` is none, ```-``` is ticked): ```[#,#,#,#,#,#]```\\n\\nAfter setting to ```N+1```: ```[7, 2, 3, 5, 1, 7]```\\nTicked off: ```[#,#,#,#,#,#]```\\n\\nWe index ```nums[abs(7-1)]``` which is invalid. So we have\\nArray: ```[7, 2, 3, 5, 1, 7]```\\nTicked off: ```[#,#,#,#,#,#]```\\n\\n\\nWe index ```nums[abs(2)-1]``` which is ```2```. So we have\\nArray: ```[7, -2, 3, 5, 1, 7]```\\nTicked off: ```[#,-,#,#,#,#]```\\n\\nWe index ```nums[abs(3)-1]``` which is ```3```. So we have\\nArray: ```[7, -2, -3, 5, 1, 7]```\\nTicked off: ```[#,-,-,#,#,#]```\\n\\nWe index ```nums[abs(5)-1]``` which is ```1```. So we have\\nArray: ```[7, -2, -3, 5, -1, 7]```\\nTicked off: ```[#,-,-,#,-,#]```\\n\\nWe index ```nums[abs(-1)-1]``` which is ```7```. So we have\\nArray: ```[-7, -2, -3, 5, -1, 7]```\\nTicked off: ```[-,-,-,#,-,#]```\\n\\nWe index ```nums[abs(7)-1]``` which is not valid. So we have\\nArray: ```[-7, -2, -3, 5, 1, 7]```\\nTicked off: ```[-,-,-,#,-,#]```\\n\\nWe can see from the example that the ticked array matches the signs in the original array.\\n\\nWe finally iterate through the array (the index of the array starts at ```1``` for this problem) and return the first index that has a positive number. This will be the first number that has not been ticked off yet. So in the example, we would return ```4``` as ```nums[4]=5``` is not ticked off.\\n\\nHere is the code for reference:\\n\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int negatives = nums.size()-1;\\n        \\n        // change all negative numbers and numbers bigger than N \\n\\t\\t// (the amount of elements in the list)\\n        for (int i = nums.size()-1; i >= 0; i--){\\n            if (nums[i] <= 0 || nums[i] > nums.size()){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n        \\n        int min = 1;\\n        \\n        // use nums[i] as the index and mark them off\\n        for (int i =0; i < nums.size(); i++){\\n            int index = abs(nums[i])-1;\\n            \\n            // check to see if it\\'s within the bounds and indexable\\n\\t\\t\\t// and check to not tick off the same value twice\\n            if ((index < nums.size() && index >= 0) && nums[index] > 0){\\n                nums[index] = -nums[index];\\n            }\\n        }\\n        \\n        // first positive value not ticked off \\n        for (min = 0; min < nums.size(); min++){\\n            if (nums[min] > 0){\\n                break;\\n            }\\n        }\\n        return min+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```N```\n```0```\n```N+1```\n```0```\n```N```\n```N+1```\n```N```\n```0```\n```0```\n```N+1```\n```0```\n```N+1```\n```N+1```\n```N+1```\n```[-5, 2, 3, 5, 1, 8]```\n```#```\n```-```\n```[#,#,#,#,#,#]```\n```N+1```\n```[7, 2, 3, 5, 1, 7]```\n```[#,#,#,#,#,#]```\n```nums[abs(7-1)]```\n```[7, 2, 3, 5, 1, 7]```\n```[#,#,#,#,#,#]```\n```nums[abs(2)-1]```\n```2```\n```[7, -2, 3, 5, 1, 7]```\n```[#,-,#,#,#,#]```\n```nums[abs(3)-1]```\n```3```\n```[7, -2, -3, 5, 1, 7]```\n```[#,-,-,#,#,#]```\n```nums[abs(5)-1]```\n```1```\n```[7, -2, -3, 5, -1, 7]```\n```[#,-,-,#,-,#]```\n```nums[abs(-1)-1]```\n```7```\n```[-7, -2, -3, 5, -1, 7]```\n```[-,-,-,#,-,#]```\n```nums[abs(7)-1]```\n```[-7, -2, -3, 5, 1, 7]```\n```[-,-,-,#,-,#]```\n```1```\n```4```\n```nums[4]=5```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int negatives = nums.size()-1;\\n        \\n        // change all negative numbers and numbers bigger than N \\n\\t\\t// (the amount of elements in the list)\\n        for (int i = nums.size()-1; i >= 0; i--){\\n            if (nums[i] <= 0 || nums[i] > nums.size()){\\n                nums[i] = nums.size()+1;\\n            }\\n        }\\n        \\n        int min = 1;\\n        \\n        // use nums[i] as the index and mark them off\\n        for (int i =0; i < nums.size(); i++){\\n            int index = abs(nums[i])-1;\\n            \\n            // check to see if it\\'s within the bounds and indexable\\n\\t\\t\\t// and check to not tick off the same value twice\\n            if ((index < nums.size() && index >= 0) && nums[index] > 0){\\n                nums[index] = -nums[index];\\n            }\\n        }\\n        \\n        // first positive value not ticked off \\n        for (min = 0; min < nums.size(); min++){\\n            if (nums[min] > 0){\\n                break;\\n            }\\n        }\\n        return min+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746638,
                "title": "o-n-time-o-1-space-0ms-solution-beats-100",
                "content": "```\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n                i--;\\n            }\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                ans=i+1;\\n                break;\\n            }\\n        }\\n        if(ans==-1)\\n        {\\n            ans=nums.size()+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int firstMissingPositive(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1])\\n            {\\n                swap(nums[i],nums[nums[i]-1]);\\n                i--;\\n            }\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                ans=i+1;\\n                break;\\n            }\\n        }\\n        if(ans==-1)\\n        {\\n            ans=nums.size()+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566511,
                "title": "simple-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        #Sorting positive numbers according to their space E.g [1,2,3,4]\\n        index = 0\\n        while index < len(nums):\\n            # Already in the place\\n            if index + 1 == nums[index]:    \\n                index += 1\\n            # No-use\\n            elif nums[index] <= 0:       \\n                  index += 1\\n            # No-use\\n            elif nums[index] > len(nums):  \\n                   index += 1\\n            # Already swapped\\n            elif nums[index] == nums[nums[index]-1]:\\n                index += 1\\n            else:\\n                A,B = index,nums[index]-1\\n                nums[A], nums[B] = nums[B], nums[A]\\n                \\n        #Smallest no which does not follow the true space\\n        for index in range(len(nums)):\\n            if index + 1 != nums[index]:   \\n                return index + 1\\n        # Otherwise, return the next positive number\\n        return len(nums) + 1\\n```\\n\\nNOTE : Improvements and comments are welcomed.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        #Sorting positive numbers according to their space E.g [1,2,3,4]\\n        index = 0\\n        while index < len(nums):\\n            # Already in the place\\n            if index + 1 == nums[index]:    \\n                index += 1\\n            # No-use\\n            elif nums[index] <= 0:       \\n                  index += 1\\n            # No-use\\n            elif nums[index] > len(nums):  \\n                   index += 1\\n            # Already swapped\\n            elif nums[index] == nums[nums[index]-1]:\\n                index += 1\\n            else:\\n                A,B = index,nums[index]-1\\n                nums[A], nums[B] = nums[B], nums[A]\\n                \\n        #Smallest no which does not follow the true space\\n        for index in range(len(nums)):\\n            if index + 1 != nums[index]:   \\n                return index + 1\\n        # Otherwise, return the next positive number\\n        return len(nums) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271306,
                "title": "java-0ms-solution",
                "content": "The idea is simple: put the positive integer ```n``` (```n > 0``` and ```n <= array.length```) at index ```n - 1```.  Then traverse the array, if ```nums[index] != index + 1```, then we find the first miss positive number. \\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\twhile( nums[i] > 0 && nums[i] <= nums.length ) {\\n\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\tif( temp == nums[i] ) // If nums[nums[i] - 1] equals nums[i], then we don\\'t need to exchange them\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\tnums[i] = temp;\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < nums.length; i++) \\n\\t\\tif( nums[i] != i + 1 )\\n\\t\\t\\treturn i + 1;\\n\\treturn nums.length + 1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n```\n```n > 0```\n```n <= array.length```\n```n - 1```\n```nums[index] != index + 1```\n```\\npublic int firstMissingPositive(int[] nums) {\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\twhile( nums[i] > 0 && nums[i] <= nums.length ) {\\n\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\tif( temp == nums[i] ) // If nums[nums[i] - 1] equals nums[i], then we don\\'t need to exchange them\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\tnums[i] = temp;\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < nums.length; i++) \\n\\t\\tif( nums[i] != i + 1 )\\n\\t\\t\\treturn i + 1;\\n\\treturn nums.length + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17208,
                "title": "c-solution-no-extra-memory-using-pseudo-sort",
                "content": " The answer is between 1 and n, where n is the size of the vector and the trick is that you have to \"pseudo sort\", what I mean with that? Well, if the number nums[i] is between 1 and n you have to put it in the correct position swapping it with the number nums[nums[i]] if they are different.\\n  For example: [1,2,0] ->[1,2,0];\\n                        [3,4,-1,1] ->[1,-1,3,4];\\n                        [0,10,1,3,6,4]->[1,10,3,4,0,6].\\n You can do this in O(n), than it's easy to find the solution\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint p = 0;\\n\\tint expected = 1;\\n\\n\\t//pseudo sort\\n\\twhile (p < n) {\\n\\t\\tint pPos;\\n\\t\\tint aux;\\n\\t\\t\\n\\t\\tif (nums[p] > 0 && nums[p] <= n) {\\n\\t\\t\\tpPos = nums[p] - 1;\\n\\t\\t\\tif (nums[pPos] != nums[p]) {\\n\\t\\t\\t\\taux = nums[p];\\n\\t\\t\\t\\tnums[p] = nums[pPos];\\n\\t\\t\\t\\tnums[pPos] = aux;\\n\\t\\t\\t\\tp--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tp++;\\n\\t}\\n\\n\\t//Finding the answer\\n\\tfor (size_t i = 0; i < n && nums[i] == expected; i++, expected++);\\n\\n\\treturn expected;\\n}",
                "solutionTags": [],
                "code": " The answer is between 1 and n, where n is the size of the vector and the trick is that you have to \"pseudo sort\", what I mean with that? Well, if the number nums[i] is between 1 and n you have to put it in the correct position swapping it with the number nums[nums[i]] if they are different.\\n  For example: [1,2,0] ->[1,2,0];\\n                        [3,4,-1,1] ->[1,-1,3,4];\\n                        [0,10,1,3,6,4]->[1,10,3,4,0,6].\\n You can do this in O(n), than it's easy to find the solution\\n\\n    int firstMissingPositive(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint p = 0;\\n\\tint expected = 1;\\n\\n\\t//pseudo sort\\n\\twhile (p < n) {\\n\\t\\tint pPos;\\n\\t\\tint aux;\\n\\t\\t\\n\\t\\tif (nums[p] > 0 && nums[p] <= n) {\\n\\t\\t\\tpPos = nums[p] - 1;\\n\\t\\t\\tif (nums[pPos] != nums[p]) {\\n\\t\\t\\t\\taux = nums[p];\\n\\t\\t\\t\\tnums[p] = nums[pPos];\\n\\t\\t\\t\\tnums[pPos] = aux;\\n\\t\\t\\t\\tp--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tp++;\\n\\t}\\n\\n\\t//Finding the answer\\n\\tfor (size_t i = 0; i < n && nums[i] == expected; i++, expected++);\\n\\n\\treturn expected;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 17313,
                "title": "a-hashmap-based-solution-but-in-place",
                "content": "A[] is an array, but we can also treat it as an hashmap,\\nIf A[i] > 0, it mean i+1 exist,\\nIf A[i] < 0,  it mean i + 1 does not.\\nHere is the code\\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            /* first iteration: change all the value out of bound to (n + 1) */\\n        \\tconst int out_of_bound = n + 1;\\n        \\tfor (int i = 0; i < n; ++i)\\n        \\t\\tif (A[i] <= 0)\\n        \\t\\t\\tA[i] = out_of_bound;\\n    \\n    \\t\\t/* second iteration: construct a hash map. map<int, int>, first argument is index\\n    \\t\\t * second argument: if positive, it exist, else, it doesn't. e.g. A[0] = 4,\\n    \\t\\t * A[0] (i.e. 1) exist */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tint abs_i = abs(A[i]);\\n    \\t \\t\\tif (abs_i <= n)\\n    \\t \\t\\t\\tA[abs_i-1] = -abs(A[abs_i-1]);\\n    \\t \\t}\\n    \\n    \\t \\t/* third iteration: check the first positive value in A[] */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tif (A[i] > 0)\\n    \\t \\t\\t\\treturn i + 1; \\n    \\t \\t}\\n    \\t \\treturn n + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(int A[], int n) {\\n            /* first iteration: change all the value out of bound to (n + 1) */\\n        \\tconst int out_of_bound = n + 1;\\n        \\tfor (int i = 0; i < n; ++i)\\n        \\t\\tif (A[i] <= 0)\\n        \\t\\t\\tA[i] = out_of_bound;\\n    \\n    \\t\\t/* second iteration: construct a hash map. map<int, int>, first argument is index\\n    \\t\\t * second argument: if positive, it exist, else, it doesn't. e.g. A[0] = 4,\\n    \\t\\t * A[0] (i.e. 1) exist */\\n    \\t \\tfor (int i = 0; i < n; ++i) {\\n    \\t \\t\\tint abs_i = abs(A[i]);\\n    \\t \\t\\tif (abs_i <= n)\\n    \\t \\t\\t\\tA[abs_i-1] = -abs(A[abs_i-1]);\\n    \\t \\t}",
                "codeTag": "Java"
            },
            {
                "id": 17319,
                "title": "python-solution-with-bit-manipulation",
                "content": "One pass of the list, but still O(2n)\\n\\n    def firstMissingPositive(self, A):\\n        num = 0\\n        for i in A:\\n            if i > 0:\\n                num = num | (1 << i)\\n        x = 1\\n        while True:\\n            if (1 << x) & num == 0:\\n                return x\\n            x += 1\\n\\nUpdate: not sure why the down votes, Python int converts to long(which has no precision limits) automatically, which means no overflow for `num`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "One pass of the list, but still O(2n)\\n\\n    def firstMissingPositive(self, A):\\n        num = 0\\n        for i in A:\\n            if i > 0:\\n                num = num | (1 << i)\\n        x = 1\\n        while True:\\n            if (1 << x) & num == 0:\\n                return x\\n            x += 1\\n\\nUpdate: not sure why the down votes, Python int converts to long(which has no precision limits) automatically, which means no overflow for `num`.",
                "codeTag": "Python3"
            },
            {
                "id": 17140,
                "title": "c-and-python-modify-the-array-to-do-it-in-o-n-time-and-o-1-space",
                "content": "If there are queries after each insert operation, [disjoint-set][1] is able to answer each query in `O(log(alpha(n)))` time and `O(max(element in the array))` space,  but for this problem, only one query after all the insertion finished,  the time complexity should be `O(n)` and `O(1)` space, some simple method is in need.\\n\\nEven though it is not a good idea to modify the value of the origin array, this is the only space that is available, which means it must be made used of.  Then if it is possible to sort the element which is between `1...n`, then just loop over the sorted array, the job is done.\\n\\nComparison  sort is `O(n logn)`, it is too slow. So the `bucket sort` is the only way. As only the elements between 1...n are useful, each element `w` should be put into the `w th` position of the array. As it is possible there is some other element `v` in the `w th` position, take the `v` out before overwriting and then iteratively use the same logic on `v` and go on.\\n\\n    def firstMissingPositive(self, A):\\n      n = len(A)\\n      for index in xrange(n):\\n        element = A[index]\\n        while True:\\n          if element <= 0 or element > n or element == A[element - 1]:\\n            break\\n          A[element - 1], element = element, A[element - 1]\\n      for index in xrange(n):\\n        if A[index] != index + 1:\\n          return index + 1\\n      return n + 1\\n\\nTime complexity:  each element is looped 2 times and swapped 1 time, so the whole time compexity is `O(n)`\\n\\nSpace: `O(1)` apparently\\n\\n---\\n\\nA pure recursive `C` solution, which has the same time and space complexity.\\n\\n    void rotate(int A[], int n, int start){\\n      if(start <= 0 || start > n){\\n        return;\\n      }\\n      if(A[start - 1] == start){\\n        return;\\n      }\\n      int nxt = A[start - 1];\\n      A[start - 1] = start;\\n      rotate(A, n, nxt);\\n    }\\n    \\n    int firstMissingPositive(int A[], int n) {\\n      int i;\\n      for(i = 0; i < n; ++i){\\n        rotate(A, n, A[i]);\\n      }\\n      for(i = 0; i < n; ++i){\\n        if(A[i] != i + 1){\\n          return i + 1;\\n        }\\n      }\\n      return n + 1;\\n    }\\n\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Disjoint-set_data_structure",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "If there are queries after each insert operation, [disjoint-set][1] is able to answer each query in `O(log(alpha(n)))` time and `O(max(element in the array))` space,  but for this problem, only one query after all the insertion finished,  the time complexity should be `O(n)` and `O(1)` space, some simple method is in need.\\n\\nEven though it is not a good idea to modify the value of the origin array, this is the only space that is available, which means it must be made used of.  Then if it is possible to sort the element which is between `1...n`, then just loop over the sorted array, the job is done.\\n\\nComparison  sort is `O(n logn)`, it is too slow. So the `bucket sort` is the only way. As only the elements between 1...n are useful, each element `w` should be put into the `w th` position of the array. As it is possible there is some other element `v` in the `w th` position, take the `v` out before overwriting and then iteratively use the same logic on `v` and go on.\\n\\n    def firstMissingPositive(self, A):\\n      n = len(A)\\n      for index in xrange(n):\\n        element = A[index]\\n        while True:\\n          if element <= 0 or element > n or element == A[element - 1]:\\n            break\\n          A[element - 1], element = element, A[element - 1]\\n      for index in xrange(n):\\n        if A[index] != index + 1:\\n          return index + 1\\n      return n + 1\\n\\nTime complexity:  each element is looped 2 times and swapped 1 time, so the whole time compexity is `O(n)`\\n\\nSpace: `O(1)` apparently\\n\\n---\\n\\nA pure recursive `C` solution, which has the same time and space complexity.\\n\\n    void rotate(int A[], int n, int start){\\n      if(start <= 0 || start > n){\\n        return;\\n      }\\n      if(A[start - 1] == start){\\n        return;\\n      }\\n      int nxt = A[start - 1];\\n      A[start - 1] = start;\\n      rotate(A, n, nxt);\\n    }\\n    \\n    int firstMissingPositive(int A[], int n) {\\n      int i;\\n      for(i = 0; i < n; ++i){\\n        rotate(A, n, A[i]);\\n      }\\n      for(i = 0; i < n; ++i){\\n        if(A[i] != i + 1){\\n          return i + 1;\\n        }\\n      }\\n      return n + 1;\\n    }\\n\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Disjoint-set_data_structure",
                "codeTag": "Python3"
            },
            {
                "id": 2931346,
                "title": "simple-optimized-solution-in-o-1-space",
                "content": "# Approach\\nSteps:\\n1.remove all the elements having zero or negative value.\\n2.sort the new array and remove all the duplicates.\\n3.now, array has all the element are unique +ve & in increasing order.\\n4.run the loop & check the condition v[i]==i+1,if this fails,answer is i+1,return it.otherwise answer will be v.size()+1.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& v) {\\n        //erase all the elements having negative and zero value.\\n       for(int i=0;i<v.size();i++){\\n           if(v[i]<=0){\\n               v.erase(v.begin()+i);\\n               i--;\\n           }\\n       }\\n       sort(v.begin(),v.end()); //sort the array.\\n       //Now,remove all duplicates.This approach works in O(n) time\\n       for(int i=0;i<v.size();i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<v.size() && v[i]==com){\\n                freq++;\\n                if(freq>1){\\n                 v.erase(v.begin()+i);\\n                 i--;\\n                }\\n                i++;\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        int ans=v.size()+1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& v) {\\n        //erase all the elements having negative and zero value.\\n       for(int i=0;i<v.size();i++){\\n           if(v[i]<=0){\\n               v.erase(v.begin()+i);\\n               i--;\\n           }\\n       }\\n       sort(v.begin(),v.end()); //sort the array.\\n       //Now,remove all duplicates.This approach works in O(n) time\\n       for(int i=0;i<v.size();i++){\\n            int com=v[i];\\n            int freq=0;\\n            while(i<v.size() && v[i]==com){\\n                freq++;\\n                if(freq>1){\\n                 v.erase(v.begin()+i);\\n                 i--;\\n                }\\n                i++;\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        int ans=v.size()+1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924456,
                "title": "easy-c-solution",
                "content": "# Intuition\\nBrute Force Approach\\n\\n# Approach\\nStep 1: Sort the vector.\\nStep 2: Take the last element as max. Check if its negative, if it is negative, then return 1 as answer.\\nStep 3: Start a loop from 1 to max.\\nStep 4: Find the element in the vector using binary search and if not found return it.\\nStep 5: Repeat the process till we reach the end of vector.\\nStep 6: If we reach the end that means anything isn\\'t returned so now return max+1 (according to problem statement & examples).\\n\\n# Complexity\\n- Time complexity:\\nO(n logn)\\n\\n- Space complexity:\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = nums[nums.size()-1];\\n        if(m <= 0){\\n            return 1;\\n        }\\n        int s, e, mid;\\n        bool found;\\n        for(int key = 1; key < m; key++){\\n            s = 0, e = nums.size()-1;\\n            found = 0;\\n            while(s <= e){\\n                mid = s + (e - s)/2;\\n                if(nums[mid] == key){\\n                    found = 1;\\n                    break;\\n                }\\n                else if(nums[mid] > key){\\n                    e = mid-1;\\n                }\\n                else{\\n                    s = mid+1;\\n                }\\n            }\\n            if(!found){\\n                return key;\\n            }\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = nums[nums.size()-1];\\n        if(m <= 0){\\n            return 1;\\n        }\\n        int s, e, mid;\\n        bool found;\\n        for(int key = 1; key < m; key++){\\n            s = 0, e = nums.size()-1;\\n            found = 0;\\n            while(s <= e){\\n                mid = s + (e - s)/2;\\n                if(nums[mid] == key){\\n                    found = 1;\\n                    break;\\n                }\\n                else if(nums[mid] > key){\\n                    e = mid-1;\\n                }\\n                else{\\n                    s = mid+1;\\n                }\\n            }\\n            if(!found){\\n                return key;\\n            }\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670716,
                "title": "easiest-way-to-solve",
                "content": "class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        arr = set(nums)\\n        data=(i for i in range(1,len(arr)+2) if i not in arr)\\n        return min(data)\\n\\t**upvote if u found it useful**",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        arr = set(nums)\\n        data=(i for i in range(1,len(arr)+2) if i not in arr)\\n        return min(data)\\n\\t**upvote if u found it useful**",
                "codeTag": "Java"
            },
            {
                "id": 2576238,
                "title": "python-easy-solution",
                "content": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        i = 1\\n        for num in nums:\\n            if num == i:\\n                i += 1\\n            elif num > 0:\\n                return i\\n        return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef firstMissingPositive(self, nums: List[int]) -> int:\\n        nums = sorted(list(set(nums)))\\n        i = 1\\n        for num in nums:\\n            if num == i:\\n                i += 1\\n            elif num > 0:\\n                return i\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2083669,
                "title": "simple-hashmap-solution-o-n",
                "content": "Simple Solution using HashMap.\\n\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n        }\\n        int i;\\n        for (i = 1; i <= nums.length; i++) {\\n            if (!map.containsKey(i)) {\\n                return i;\\n            }\\n        }\\n        return i;\\n    }\\n}```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n        }\\n        int i;\\n        for (i = 1; i <= nums.length; i++) {\\n            if (!map.containsKey(i)) {\\n                return i;\\n            }\\n        }\\n        return i;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1866566,
                "title": "c-easy-and-understandable-approach-with-linear-time-and-constant-space",
                "content": "```\\nint firstMissingPositive(vector<int>& nums) {\\n        //case 1 : manage 1 and those who are out of bound;\\n        bool One = false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1) One = true;\\n            if(nums[i]>nums.size() or nums[i]<1){\\n                nums[i] = 1;\\n            }\\n        }\\n        if(One == false) return 1;\\n        \\n        //case 2 : map element with index\\n        for(int i=0;i<nums.size();i++){\\n            int idx = abs(nums[i]);\\n            nums[idx - 1] = -abs(nums[idx - 1]);\\n        }\\n        \\n        //case 3 : find positive number\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n```\\n**Guys if you got the concept then please give one upvote for me.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(vector<int>& nums) {\\n        //case 1 : manage 1 and those who are out of bound;\\n        bool One = false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1) One = true;\\n            if(nums[i]>nums.size() or nums[i]<1){\\n                nums[i] = 1;\\n            }\\n        }\\n        if(One == false) return 1;\\n        \\n        //case 2 : map element with index\\n        for(int i=0;i<nums.size();i++){\\n            int idx = abs(nums[i]);\\n            nums[idx - 1] = -abs(nums[idx - 1]);\\n        }\\n        \\n        //case 3 : find positive number\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008481,
                "title": "java-100-fast-simple-and-easy",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i = 0; i < nums.length;) {\\n            int curr = nums[i];\\n            //in place sorting 1 based index ignoring out of range numbers including 0\\n\\t\\t\\tif(curr > 0 && curr < nums.length && curr != nums[curr-1]) \\n                swap(nums, i, curr-1);\\n            else\\n                i++;\\n        }\\n        //check if the number on index i is equal to i + 1 (1 based idxs) if not we have our number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n\\t\\t//if the whole array have the correct numbers the next number is the last pos (nums.length) + 1\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i = 0; i < nums.length;) {\\n            int curr = nums[i];\\n            //in place sorting 1 based index ignoring out of range numbers including 0\\n\\t\\t\\tif(curr > 0 && curr < nums.length && curr != nums[curr-1]) \\n                swap(nums, i, curr-1);\\n            else\\n                i++;\\n        }\\n        //check if the number on index i is equal to i + 1 (1 based idxs) if not we have our number\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != i + 1) {\\n                return i + 1;\\n            }\\n        }\\n\\t\\t//if the whole array have the correct numbers the next number is the last pos (nums.length) + 1\\n        return nums.length + 1;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360518,
                "title": "my-cpp-solution-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int len = nums.size();\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j){\\n            if(nums[i]==i+1){\\n                ++i;\\n                continue;\\n            }\\n            // nums[i] looks for pos nums[i]-1\\n            else if(nums[i]>0 && nums[i]-1<=j && nums[nums[i]-1]!=nums[i]){\\n                swap(nums[nums[i]-1],nums[i]);\\n            }\\n\\t\\t\\t// put it at end of array as a \"junk\"\\n            else{\\n                swap(nums[j--],nums[i]);\\n            }\\n        }\\n        if(i==0){\\n            return 1;\\n        }\\n        else{\\n            return nums[i-1]+1;\\n        }\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046353.png)\\nFirst of all ,we know that , if nums looks like [1,2,3,4...] ,then num[i] should be at **pos** nums[i]-1.\\nnow we have 6 at pos i , which should be at pos 5.\\nHere is what we gonna do:\\n\\twe check if his **pos-to-put** is avavilable.\\n\\tsince pos 5 is an available pos , we swap them.\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046685.png)\\nnow we have -1 at pos i ,which should be at pos -2.\\nof course pos -2 is not available.\\nso we put it at **junk area** by swapping with pos j. (then j--);\\n![image](https://assets.leetcode.com/users/jellyzhang/image_1566046869.png)\\nthen we facing 20 now...\\nif we cant find a 5 for pos i ,then it will keep looping ,until j hits i.So TIme complexity is O(n).\\n(also ,if **pos-to-put** is already has his number, then nums[i] is regard as junk too,cause we dont need a number twice.)\\nand we dont have to go over the nums again to find the first missing spot. cause where i hit j is what we need.\\n\\nsorry for my bad painting.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int len = nums.size();\\n        int i = 0;\\n        int j = len-1;\\n        while(i<=j){\\n            if(nums[i]==i+1){\\n                ++i;\\n                continue;\\n            }\\n            // nums[i] looks for pos nums[i]-1\\n            else if(nums[i]>0 && nums[i]-1<=j && nums[nums[i]-1]!=nums[i]){\\n                swap(nums[nums[i]-1],nums[i]);\\n            }\\n\\t\\t\\t// put it at end of array as a \"junk\"\\n            else{\\n                swap(nums[j--],nums[i]);\\n            }\\n        }\\n        if(i==0){\\n            return 1;\\n        }\\n        else{\\n            return nums[i-1]+1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202584,
                "title": "javascript-52ms-beats-100-supposedly",
                "content": "Solving this in O(n) time was tricky, but solving it in O(1) space was arguably more difficult.\\n\\n**Constraints:**\\n1. Can\\'t use an object to store values because that would no longer be constant extra space (as the size of the object would be dependent on the number of values in the array).\\n2.   For the same reason, we can\\'t iniitalize another array.\\n\\n**Possible Scenarios:**\\n1: Array has negative and/or positive values but does not contain the integer 1.  In that case, result would be 1.\\n2: Array contains the integer 1 and has one or more missing integers within the array.  In that case, we need to be able to tell where that gap is.\\n3: Array contains only positive integers and contains 1 through the length of the array.  In that case, result would be array length + 1.\\n\\n**Observations:**\\n1. If there are no gaps, the largest value for an integer in the array is the length of the array.\\n2. That means that we don\\'t care about any values that are greater than the length of the array (because they wouldn\\'t affect the calculation of what the smallest integer missing would be as their inclusion would ensure a gap elsewhere)\\n3. If the lowest value we care about is 1 and the largest value we care about is the length of the array, we can iterate through the array and swap the value at the current index to the index of the value - 1 in order to track whether or not a given value exists in the array.  That is, given an array [3, 2, 1], swapping 3 with 1, not incrementing the iterator so that you are still looking at the array at index 0, seeing that 1 is in place, incrementing the index, seeing that 2 is in place, incrementing the index, and seeing that 3 is in place.  We would then loop through the array a second time in order to find the lowest value that isn\\'t at the index of its value - 1.\\n\\n**Big O Analysis:**\\nThis function goes through the array, swapping the value at the current index with the value at the index of one less than the value.  If the value is less than 0 or greater than the length of the array, the value at that index gets set to 0 to make it easier on the eyes during debugging of edge cases.\\n\\nWhile it\\'s employing a for loop and a while loop in the first pass, it\\'s not nested in the sense that two counters are going as it\\'s utilizing the same counter for both, so I believe that portion is still O(n), and tacking on the for loop at the end to determine whether or not an integer is present in the array wouldn\\'t be significant enough to affect the time complexity.\\n\\nAs we\\'re utilizing the original array and just changing pointer values and not actually moving the array in any way, this should still be O(1) space complexity.\\n\\n```\\nvar firstMissingPositive = function (nums) {\\n  let current;\\n  let indexForCurrent;\\n   for (let i = 0; i < nums.length;) {\\n    if (nums[i] < 0) {\\n      nums[i] = 0;\\n      i++;\\n    } else if (nums[i] > nums.length){\\n      i++;\\n    }\\n      current = nums[i];     \\n      indexForCurrent = current - 1\\n      while (nums[i] != nums[indexForCurrent]) {\\n        if (current > 0 && current <= nums.length) {\\n          let next = nums[indexForCurrent];\\n          nums[indexForCurrent] = current;\\n          nums[i] = next;\\n          current = nums[i];\\n          indexForCurrent = current - 1;\\n        } else {\\n          nums[i] = 0;\\n          i++;\\n          current = nums[i];\\n          indexForCurrent = current - 1;           \\n      }\\n    }\\n    i++;\\n  }\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== i + 1) {\\n      return i + 1;\\n    }\\n  }\\n  return nums.length + 1\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar firstMissingPositive = function (nums) {\\n  let current;\\n  let indexForCurrent;\\n   for (let i = 0; i < nums.length;) {\\n    if (nums[i] < 0) {\\n      nums[i] = 0;\\n      i++;\\n    } else if (nums[i] > nums.length){\\n      i++;\\n    }\\n      current = nums[i];     \\n      indexForCurrent = current - 1\\n      while (nums[i] != nums[indexForCurrent]) {\\n        if (current > 0 && current <= nums.length) {\\n          let next = nums[indexForCurrent];\\n          nums[indexForCurrent] = current;\\n          nums[i] = next;\\n          current = nums[i];\\n          indexForCurrent = current - 1;\\n        } else {\\n          nums[i] = 0;\\n          i++;\\n          current = nums[i];\\n          indexForCurrent = current - 1;           \\n      }\\n    }\\n    i++;\\n  }\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] !== i + 1) {\\n      return i + 1;\\n    }\\n  }\\n  return nums.length + 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17250,
                "title": "share-my-thoughts-4ms-soln",
                "content": "At beginning, I was thinking: \\n\\n 1. it requires O(n), means no sorting/binary searching. You should only go through the numbers then get the result.\\n 2. no extra memory, means you can not use bit vector to indicate if any number exists.\\n\\nSo, the first idea came into my mind is bit manipulation. But, after tried and thought it again, bit manipulation doesn't help here. Because the numbers can be duplicated. Re-visited the problem, I found one critical point: it's asking the smallest missing positive number. It means I can reorder the numbers to let the nums[0]=1, nums[1]=2... etc. Actually, I spent more than 30 minutes on bit manipulation direction. Once I found the solution, it only took about 10 minutes to code.\\n\\n    class Solution {\\n    public:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=0; i<size;){\\n            if(nums[i]>0 && nums[i]<=size && nums[i]!=nums[nums[i]-1]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                ++i;\\n            }\\n        }\\n        int i=0;\\n        for(; i<size && nums[i]==i+1; ++i);\\n        return i+1;\\n    }};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=0; i<size;){\\n            if(nums[i]>0 && nums[i]<=size && nums[i]!=nums[nums[i]-1]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17339,
                "title": "as-o-n-solution-and-o-1-space-is-must-only-way-is-to-sort-array-in-o-n-time-with-optimal-space-and-time-overheads",
                "content": "It is certain that to get **O(n) time complexity** and to do in **constant space**  O(n) time complexity sorting technique need to be used, any of the following sorts counting sort, radix sort, bucket sort can be used. \\n\\nAs the input array can contain **negative integers**  counting sort may not be applied here as  we use keys as index in counting sort and it has memory overhead too, but when the input array has many **duplicates** then counting sort performs better it's good to discuss such trade offs with interviewer.\\n\\nRadix sort is a specific type of bucket sort, It starts with the top n-bit or n-digits and may sort those buckets using a radix sort until every entry is sorted. So if the elements in the input array are single digit integers in the **range [-9,9]** then essentially  radix sort and bucket sort are similar.\\n\\nBucket sort is the best sorting technique that might be used here because when the **input is uniformly** **distributed over a range**(here the elements of the input array are in range [-9,9]) bucket sort performs in O(n) time complexity and O(1) space complexity.\\n\\n**Counting sort** -- simple buckets, simple processing, memory overhead, performs well when input has many duplicates.\\n\\n**Radix sort** -- simple buckets, sophisticated processing, speed overhead (and still need additional static memory)\\n\\n**Bucket sort** -- sophisticated buckets, simple processing, requires dynamic memory, good in average compared to counting and radix sorts.\\n\\n\\n     class Solution {\\n        public:\\n            int firstMissingPositive(int A[], int n) {\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    int digit = A[i];\\n                    while (digit <= n && digit > 0 && A[digit - 1] != digit)\\n                    {\\n                        swap(A[digit - 1], A[i]);\\n                        digit = A[i];\\n                    }\\n                }\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    if (A[i] != i + 1)\\n                    {\\n                        return i + 1;\\n                    }\\n                }\\n                return n + 1;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int firstMissingPositive(int A[], int n) {\\n                for (int i = 0; i < n; ++i)\\n                {\\n                    int digit = A[i];\\n                    while (digit <= n && digit > 0 && A[digit - 1] != digit)\\n                    {\\n                        swap(A[digit - 1], A[i]);\\n                        digit = A[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3669832,
                "title": "easiest-c-code-highly-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& a) {\\n        unordered_map<int,int>map;\\n        int i,j,k,c=0;\\n\\n        for(auto x:a){\\n            if(x>0)\\n            map[x]++;\\n        }\\n\\n        for(i=1;i<a.size()+1;i++){\\n            if(map.find(i)==map.end())\\n            return i;\\n\\n        }\\n        return a.size()+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& a) {\\n        unordered_map<int,int>map;\\n        int i,j,k,c=0;\\n\\n        for(auto x:a){\\n            if(x>0)\\n            map[x]++;\\n        }\\n\\n        for(i=1;i<a.size()+1;i++){\\n            if(map.find(i)==map.end())\\n            return i;\\n\\n        }\\n        return a.size()+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379018,
                "title": "time-o-n-space-o-1-using-cycle-sort-beats-99-96",
                "content": "# Intuition\\ncorrect position for each positive element should be its index+1\\n\\n# Approach\\nRun a simple cycle sort by putting elements in there correct position(i.e. index+1).\\nthen return the first element which is not in correct postion, if all are then length+1;\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i=0;\\n        while(i<nums.length){\\n            int correct=nums[i]-1;\\n          //check if its positive,in range and not in correct position\\n            if(nums[i]>0 && nums[i]<=nums.length && nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        for(int index=0;index<nums.length;index++){\\n            if(nums[index]!=index+1){\\n                return index+1;\\n            }\\n        }\\n        return nums.length+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i=0;\\n        while(i<nums.length){\\n            int correct=nums[i]-1;\\n          //check if its positive,in range and not in correct position\\n            if(nums[i]>0 && nums[i]<=nums.length && nums[i]!=nums[correct]){\\n                int temp=nums[i];\\n                nums[i]=nums[correct];\\n                nums[correct]=temp;\\n            }else{\\n                i++;\\n            }\\n        }\\n\\n        for(int index=0;index<nums.length;index++){\\n            if(nums[index]!=index+1){\\n                return index+1;\\n            }\\n        }\\n        return nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243937,
                "title": "java-1ms-easy-solution-with-explaination",
                "content": "\\n\\n# Approach\\nThe solution first moves all positive integers to the front of the array by swapping them with non-positive integers. It then marks indices that correspond to positive integers by negating the value at that index. Finally, it checks for the first positive integer that is not marked and returns its index + 1. If all positive integers are marked, it returns the length of the array + 1.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the length of the input array. \\n\\n- Space complexity:\\n The space complexity is O(1) because it modifies the input array in place. This solution is very efficient and should be able to handle very large input arrays.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Move all positive integers to the front of the array\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                j++;\\n            }\\n        }\\n        \\n        // Mark indices that correspond to positive integers\\n        for (int i = 0; i < j; i++) {\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (idx < j && nums[idx] > 0) {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n        \\n        // Find the first missing positive integer\\n        for (int i = 0; i < j; i++) {\\n            if (nums[i] > 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n = nums.length;\\n        \\n        // Move all positive integers to the front of the array\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                j++;\\n            }\\n        }\\n        \\n        // Mark indices that correspond to positive integers\\n        for (int i = 0; i < j; i++) {\\n            int idx = Math.abs(nums[i]) - 1;\\n            if (idx < j && nums[idx] > 0) {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n        \\n        // Find the first missing positive integer\\n        for (int i = 0; i < j; i++) {\\n            if (nums[i] > 0) {\\n                return i + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928138,
                "title": "javascript-solution-using-map-100-ms-array-map-includes",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\n```\\n/**\\n * \\n * @param {*} nums \\n * @param {*} map \\n * @returns \\n */\\nconst firstMissingPositive = (nums, map = new Map()) => {\\n    for (let i = 1; i <= nums.length + 1; i++) {\\n        map.set(i, 1);\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) map.delete(nums[i])\\n    }\\n    const [firstValue] = map.keys();\\n    return firstValue;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * \\n * @param {*} nums \\n * @param {*} map \\n * @returns \\n */\\nconst firstMissingPositive = (nums, map = new Map()) => {\\n    for (let i = 1; i <= nums.length + 1; i++) {\\n        map.set(i, 1);\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] > 0) map.delete(nums[i])\\n    }\\n    const [firstValue] = map.keys();\\n    return firstValue;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774190,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773300,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n   \\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] <= 0 || nums[i] > n) {\\n            nums[i] = n + 1;\\n        }\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = Math.abs(nums[i]);\\n        if (num > n) {\\n            continue;\\n        }\\n        num--; \\n        if (nums[num] > 0) { \\n            nums[num] = -1 * nums[num];\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return n + 1;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n   \\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] <= 0 || nums[i] > n) {\\n            nums[i] = n + 1;\\n        }\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        int num = Math.abs(nums[i]);\\n        if (num > n) {\\n            continue;\\n        }\\n        num--; \\n        if (nums[num] > 0) { \\n            nums[num] = -1 * nums[num];\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return n + 1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316294,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<1)\\n                continue;\\n            else{\\n                if(nums[i]==ans)\\n                    ans++;\\n                else if(nums[i]>ans)\\n                    return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<1)\\n                continue;\\n            else{\\n                if(nums[i]==ans)\\n                    ans++;\\n                else if(nums[i]>ans)\\n                    return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302936,
                "title": "cpp-two-different-approaches-with-o-1-space-fully-explained",
                "content": "Hello World ! \\nFirst Approach I used is pretty simple and it\\'s time complexity is O(n)\\n\\n**Steps**\\n1. Traverse the input array and replace all zeroes and negative number by INT_MAX\\n2. Traverse the input array again, and during this traversal we will find the correct position of each element by making value at that index negative.\\n3. During final traversal, return the  (index+1) where \"index\" is the first index at which element found is positive.\\n\\n```\\n\\tint n=v.size();\\n    int ans=0;\\n\\t\\n\\t// step 1 - Replacing zeroes and negative numbers with INT_MAX\\n    for(int i=0;i<n;i++)\\n    if(v[i]<1) v[i]=INT_MAX;\\n\\t\\n\\t// step 2 - Finding correct position of each element.\\n    for(int i=0;i<n;i++)\\n        if(abs(v[i])<=n)\\n        v[abs(v[i])-1] = min(v[abs(v[i])-1],-v[abs(v[i])-1]);\\n    \\n    // step 3 - Returning (index+1) , where \"index\" is the first index at which element found is positive\\n\\tfor(;ans<n;ans++)\\n        if(v[ans]>0) return ans+1;\\n    return ans+1;\\n```\\n\\n**Second Approach**\\n\\nAlthough the above approach was working very good in terms of space and time. But i still went on to look for some other way of solving it, the way through which no one has ever done this yet.\\nThen, the idea of **heap**  crossed my mind.\\n Overall Time complexity i guess would be approx - O(n*logn)\\n\\n1. By using heapify, i convert the same array into min heap.\\n2. Initialised ```ans=1```   \\n3. Now compare with the root of min heap (root of min heap is arr[0])\\n\\t* If the root of min heap (i.e arr[0]) is equal to ans, then ans is incremented.\\n\\t* If the root of min heap is greater than ans, the ans is returned.\\n\\nSee the code and its comments for better understanding.\\n\\n**Iterative Min Heapify Function**\\n```\\nvoid minheapify(vector<int>&a,int i,int n){\\n    while(i<=n){\\n    int l= 2*i+1;\\n    int r=2*i+2;\\n    int largest =i;\\n    if(l<n  && a[l]<a[largest])\\n    largest=l;\\n    if(r<n && a[r]<a[largest])\\n    largest=r;\\n     if(largest!=i){\\n        swap(a[i],a[largest]);\\n        i=largest;\\n    }\\n    else break;\\n    }\\n}\\n```\\n\\n**Driver Code**\\n```\\nint n=v.size();\\n       \\n        int ans=1;\\n\\t\\t\\n\\t\\t//Heapify the input array\\n        for(int i = (n/2)-1;i>-1;i--)\\n            minheapify(v,i,n); \\n  \\n    while(n>0){\\n\\t// Comparing root with the ans\\n        if(ans==v[0]) ans++;\\n        else if(ans<v[0]) break;\\n        v[0]=v[n-1];\\n        n--;\\n        minheapify(v,0,n);\\n    }\\n\\t\\n\\treturn ans;   // Final answer returned\\n```\\n\\nI know the first approach was way better. But you know, one should try to solve the question with other approaches too. \\n\\nOpen for suggestions, edits and improvements.\\nPlease **Upvote** if you like.\\nThanks,\\n**Aadi**\\n",
                "solutionTags": [],
                "code": "```\\n\\tint n=v.size();\\n    int ans=0;\\n\\t\\n\\t// step 1 - Replacing zeroes and negative numbers with INT_MAX\\n    for(int i=0;i<n;i++)\\n    if(v[i]<1) v[i]=INT_MAX;\\n\\t\\n\\t// step 2 - Finding correct position of each element.\\n    for(int i=0;i<n;i++)\\n        if(abs(v[i])<=n)\\n        v[abs(v[i])-1] = min(v[abs(v[i])-1],-v[abs(v[i])-1]);\\n    \\n    // step 3 - Returning (index+1) , where \"index\" is the first index at which element found is positive\\n\\tfor(;ans<n;ans++)\\n        if(v[ans]>0) return ans+1;\\n    return ans+1;\\n```\n```ans=1```\n```\\nvoid minheapify(vector<int>&a,int i,int n){\\n    while(i<=n){\\n    int l= 2*i+1;\\n    int r=2*i+2;\\n    int largest =i;\\n    if(l<n  && a[l]<a[largest])\\n    largest=l;\\n    if(r<n && a[r]<a[largest])\\n    largest=r;\\n     if(largest!=i){\\n        swap(a[i],a[largest]);\\n        i=largest;\\n    }\\n    else break;\\n    }\\n}\\n```\n```\\nint n=v.size();\\n       \\n        int ans=1;\\n\\t\\t\\n\\t\\t//Heapify the input array\\n        for(int i = (n/2)-1;i>-1;i--)\\n            minheapify(v,i,n); \\n  \\n    while(n>0){\\n\\t// Comparing root with the ans\\n        if(ans==v[0]) ans++;\\n        else if(ans<v[0]) break;\\n        v[0]=v[n-1];\\n        n--;\\n        minheapify(v,0,n);\\n    }\\n\\t\\n\\treturn ans;   // Final answer returned\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234110,
                "title": "c-o-n-time-and-o-1-space",
                "content": "The logic used is put each number in its right place. Example when we find 4, it is swapped with A[3]. At last, the first place where the number is not right, return (place + 1) as that would be the missing value.\\n\\n```\\n int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while (i < n)\\n        {\\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n            else\\n                i++;\\n        }\\n        \\n        for (i = 0; i < n; i++)\\n            if (nums[i] != (i + 1))\\n                return i + 1;\\n        \\n        return n + 1;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        while (i < n)\\n        {\\n            if (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\\n                swap(nums[i], nums[nums[i] - 1]);\\n            else\\n                i++;\\n        }\\n        \\n        for (i = 0; i < n; i++)\\n            if (nums[i] != (i + 1))\\n                return i + 1;\\n        \\n        return n + 1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059738,
                "title": "100-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_set<long long int>s;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n            s.insert(arr[i]);\\n                }\\n        }\\n  \\n        int i=1;\\n         while(1){\\n             if(s.find(i)==s.end()){\\n                 return i;\\n             }\\n             i++;\\n         }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_set<long long int>s;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]>0){\\n            s.insert(arr[i]);\\n                }\\n        }\\n  \\n        int i=1;\\n         while(1){\\n             if(s.find(i)==s.end()){\\n                 return i;\\n             }\\n             i++;\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980736,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i =0; i<n; i++)\\n        {\\n            while (nums[i]>= 1 && nums[i]<=n && nums[i] != nums[nums[i] - 1])\\n                swap(nums[i] , nums[nums[i] - 1]);          \\n        }\\n        for (int i =0; i<n; i++)\\n        {\\n            if (nums[i] != i +1)\\n                return i+1;\\n        }\\n        return n +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i =0; i<n; i++)\\n        {\\n            while (nums[i]>= 1 && nums[i]<=n && nums[i] != nums[nums[i] - 1])\\n                swap(nums[i] , nums[nums[i] - 1]);          \\n        }\\n        for (int i =0; i<n; i++)\\n        {\\n            if (nums[i] != i +1)\\n                return i+1;\\n        }\\n        return n +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872320,
                "title": "c-c-super-simple-short-solution-o-n-o-1-0-ms-faster-than-100",
                "content": "**C:**\\n```\\nint firstMissingPositive(int* nums, int numsSize){\\n    int i=0;\\n    while (i < numsSize) {\\n        if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n            i++;\\n        else {\\n            \\n            int temp = nums[i];\\n            nums[i] = nums[nums[i] - 1];\\n            nums[temp - 1] = temp;\\n        }\\n    }\\n    for (int i=0; i<numsSize; i++)\\n        if (nums[i]-1 != i)\\n            return i+1;\\n    return numsSize+1;\\n}\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int numsSize = nums.size();\\n        int i=0;\\n        while (i < numsSize) {\\n            if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n                i++;\\n            else {\\n                int temp = nums[i];\\n                nums[i] = nums[nums[i] - 1];\\n                nums[temp - 1] = temp;\\n            }\\n        }\\n        for (int i=0; i<numsSize; i++)\\n            if (nums[i]-1 != i)\\n                return i+1;\\n        return numsSize+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint firstMissingPositive(int* nums, int numsSize){\\n    int i=0;\\n    while (i < numsSize) {\\n        if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n            i++;\\n        else {\\n            \\n            int temp = nums[i];\\n            nums[i] = nums[nums[i] - 1];\\n            nums[temp - 1] = temp;\\n        }\\n    }\\n    for (int i=0; i<numsSize; i++)\\n        if (nums[i]-1 != i)\\n            return i+1;\\n    return numsSize+1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int numsSize = nums.size();\\n        int i=0;\\n        while (i < numsSize) {\\n            if ((nums[i] <= 0) || (nums[i] > numsSize) || (nums[i]-1 == i) || (nums[i] == nums[nums[i]-1]))\\n                i++;\\n            else {\\n                int temp = nums[i];\\n                nums[i] = nums[nums[i] - 1];\\n                nums[temp - 1] = temp;\\n            }\\n        }\\n        for (int i=0; i<numsSize; i++)\\n            if (nums[i]-1 != i)\\n                return i+1;\\n        return numsSize+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871621,
                "title": "first-missing-positive-solution-java-beat-100",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums == null || nums.length == 0) return 1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < 1 || nums[i] > nums.length || nums[i] == nums[nums[i] -1]) continue;\\n            // swap the element\\n            int temp = nums[nums[i] -1];\\n            nums[nums[i] -1] = nums[i]; \\n            nums[i] = temp;\\n            i--;\\n        }\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] != i+1) return i+1;\\n        }\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if (nums == null || nums.length == 0) return 1;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] < 1 || nums[i] > nums.length || nums[i] == nums[nums[i] -1]) continue;\\n            // swap the element\\n            int temp = nums[nums[i] -1];\\n            nums[nums[i] -1] = nums[i]; \\n            nums[i] = temp;\\n            i--;\\n        }\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] != i+1) return i+1;\\n        }\\n        return nums.length + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735695,
                "title": "java-time-o-n-constant-space-swap-approach",
                "content": "```\\n/* The goal is to bring the positive element to its place(index=value-1) by swapping...\\neg. [-1,3,1,4,5]....\\nafter swapping the array will look like [1,-1,3,4,5]  \\nAfter swapping we have to find the value which is not in its expected position which is 2 in this case.\\n*/\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if(nums.length==0) return 1;\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>nums.length || nums[i]<=0){           //only positive values\\n                i++;\\n              continue;    \\n            }else if(nums[nums[i]-1]==nums[i]){    //checking whether the element is at its position or not\\n                i++;\\n            } \\n\\t\\t// swapping the element to its desired position\\t\\n            else{\\n                \\n            int temp=nums[nums[i]-1];\\n            nums[nums[i]-1]=nums[i];\\n            nums[i]=temp;\\n            }\\n                         }\\n        // finding the smallest positive element out of its position\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) return i+1;\\n        }\\n        \\n        return nums[i-1]+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The goal is to bring the positive element to its place(index=value-1) by swapping...\\neg. [-1,3,1,4,5]....\\nafter swapping the array will look like [1,-1,3,4,5]  \\nAfter swapping we have to find the value which is not in its expected position which is 2 in this case.\\n*/\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        if(nums.length==0) return 1;\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>nums.length || nums[i]<=0){           //only positive values\\n                i++;\\n              continue;    \\n            }else if(nums[nums[i]-1]==nums[i]){    //checking whether the element is at its position or not\\n                i++;\\n            } \\n\\t\\t// swapping the element to its desired position\\t\\n            else{\\n                \\n            int temp=nums[nums[i]-1];\\n            nums[nums[i]-1]=nums[i];\\n            nums[i]=temp;\\n            }\\n                         }\\n        // finding the smallest positive element out of its position\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            if(nums[i]!=i+1) return i+1;\\n        }\\n        \\n        return nums[i-1]+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524319,
                "title": "brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums) {\\n            set.add(num);\\n        }\\n        int first = 1;\\n        while(set.contains(first)){\\n            first++;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums) {\\n            set.add(num);\\n        }\\n        int first = 1;\\n        while(set.contains(first)){\\n            first++;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17296,
                "title": "simple-method-with-a-little-trick",
                "content": "Firstly,the answer must be among [1..n+1]. so all numbers less than 0 or greater than n could be discared.(change them to 0).\\nThen, if \"i\" appeared, we modify a[i-1] to -a[i-1]-1. In this way, we could do it with constant extra space.\\n\\n    class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            vector<int> &a=nums;\\n            int n=a.size();\\n            if(n==0) return 1;\\n            for(int i=0;i<n;i++) if(a[i]<0||a[i]>n) a[i]=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]==0 || a[i]==-1) continue;\\n                int t=(a[i]>0)?(a[i]-1):(-a[i]-2);\\n                if(a[t]>=0) a[t]=-a[t]-1;\\n            }\\n            for(int i=0;i<n;i++) if(a[i]>=0) return i+1;\\n            return n+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstMissingPositive(vector<int>& nums) {\\n            vector<int> &a=nums;\\n            int n=a.size();\\n            if(n==0) return 1;\\n            for(int i=0;i<n;i++) if(a[i]<0||a[i]>n) a[i]=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(a[i]==0 || a[i]==-1) continue;\\n                int t=(a[i]>0)?(a[i]-1):(-a[i]-2);\\n                if(a[t]>=0) a[t]=-a[t]-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4067658,
                "title": "easy-3-for-loop-c-o-1-space-based-on-pigeonhole-principle-using-cyclic-sort-with-explanation",
                "content": "1. **Clean the array:** We want to ignore numbers that are not useful for us. So, we go through our list (nums) one by one.If a number is zero or negative, or if it\\'s greater than m (our total number of elements), we consider it not useful and replace it with zero. This simplifies our task because we only care about positive integers up to m.\\n\\n* 2. **Put numbers to their place using cyclic sort i.e swap until you find the number :** (This works because of **[Pigeonhole Principle](https://en.wikipedia.org/wiki/Pigeonhole_principle)**) : The Pigeonhole Principle states that if you have more \"pigeons\" than \"pigeonholes,\" at least one pigeonhole must contain more than one pigeon. In this context:\\n* \\n* The \"pigeons\" are the positive integers from 1 to m (where m is the size of the input array nums).\\n* The \"pigeonholes\" are the indices of the array nums.\\n* The goal in this problem is to find the first missing positive integer. If there are no missing positive integers in the range from 1 to m, then all the pigeons are already in their correct pigeonholes, and no pigeonhole contains more than one pigeon.\\n* * So Now, we want to arrange the remaining positive integers in the correct order from 1 to m. We do this using a technique called cyclic sort. \\n* * We go through our list again, and for each number: If it\\'s not zero (useful) and not already in the right place (not equal to i + 1), we swap it with the number in its rightful position, which is nums[i] - 1. We repeat this until we can\\'t swap anymore.\\n\\n3. **Finding the First Missing Positive:** \\n* * Once we\\'ve sorted our list, we go through it one more time to find the first number that\\'s not in its expected position.\\n* * The first missing positive integer is equal to i + 1 (because we\\'re looking for the number that should be in the i-th position of our sorted list).\\n* * If we don\\'t find any missing positive integers in the range from 1 to m, we return m + 1, indicating that all positive integers up to m are present in the list.\\n\\n**If you liked the solution. Please Vote Up. Thank you! Happy Coding! Keep Finding the pigeons\\uD83D\\uDE02**\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int m = size(nums);\\n        \\n        for(int i=0;i<m;i++)if(nums[i]<=0 || nums[i]>m) nums[i]=0; //replace non needed numbers with zero\\n        \\n        \\n        for(int i=0;i<m;i++)                                     //arrange the position with cyclic sort\\n        {\\n           while(nums[i]!=0 && nums[i]!=i+1)                    //while loop runs till correct number on its place or the necessary condition fails\\n           {\\n               if (nums[i] == nums[ (nums[i] - 1) ])break;      //if both are same then no need to run loop\\n               swap(nums[i],nums[nums[i]-1]);                   //swap till they are at their required place\\n           }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++)if(nums[i]!=i+1)                    //find the missing numbers as all the needed numbers are on its place\\n            return i+1;\\n        \\n        return m+1;\\n    }\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/48d3adef-77ff-41b1-92c6-b3b9c501d46c_1695198038.9110086.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int m = size(nums);\\n        \\n        for(int i=0;i<m;i++)if(nums[i]<=0 || nums[i]>m) nums[i]=0; //replace non needed numbers with zero\\n        \\n        \\n        for(int i=0;i<m;i++)                                     //arrange the position with cyclic sort\\n        {\\n           while(nums[i]!=0 && nums[i]!=i+1)                    //while loop runs till correct number on its place or the necessary condition fails\\n           {\\n               if (nums[i] == nums[ (nums[i] - 1) ])break;      //if both are same then no need to run loop\\n               swap(nums[i],nums[nums[i]-1]);                   //swap till they are at their required place\\n           }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++)if(nums[i]!=i+1)                    //find the missing numbers as all the needed numbers are on its place\\n            return i+1;\\n        \\n        return m+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668423,
                "title": "basic-approach-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        vector<int> sol(nums.size()+2,0);\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size())\\n                sol[nums[i]]=1;\\n        }\\n        for(int i=1;i<sol.size();i++)\\n        {\\n            if(sol[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        vector<int> sol(nums.size()+2,0);\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0 && nums[i]<=nums.size())\\n                sol[nums[i]]=1;\\n        }\\n        for(int i=1;i<sol.size();i++)\\n        {\\n            if(sol[i]==0)\\n            {\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591829,
                "title": "very-very-easy-java-soln-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==b)\\n            {\\n               b++;\\n            }\\n            \\n        }\\n        return b;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int b=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==b)\\n            {\\n               b++;\\n            }\\n            \\n        }\\n        return b;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587781,
                "title": "c-very-simple-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(auto &i: nums){\\n            if(i>n) i = n+1;\\n            if(i<=0)i = n+1;\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)-1<n && nums[abs(i)-1]>0)nums[abs(i)-1] *= -1;\\n        }\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(auto &i: nums){\\n            if(i>n) i = n+1;\\n            if(i<=0)i = n+1;\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)-1<n && nums[abs(i)-1]>0)nums[abs(i)-1] *= -1;\\n        }\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(nums[i]>0)return i+1;\\n        }\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388562,
                "title": "all-possible-solutions-include-hash-set-normal-sorting-and-cyclic-sort",
                "content": "The idea is that we `don\\'t care elements which less than 1 and and greater nums.count`. We try to `partly` sort the elements to build a final array like: `[1, 2, 3, ... out_of_bound_element ... ]`, which is calle `Cyclic Sorting`. Then just iterate from starting and return the fist missing number.\\n\\nOne thing to note that `nums[i] >= -2^31`, so have to compare `nums[i] with i + 1` but not `nums[i] - 1 with i` \\uD83D\\uDE02,\\n\\n# Code\\n```\\nclass Solution {\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        return firstMissingPositiveUsingCylicSort(nums)\\n        // return firstMissingPositiveUsingNormalSort(nums)\\n        // return firstMissingPositiveUsingSet(nums)\\n    }\\n\\n    // Cylic sort\\n    // Time: O(n)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingCylicSort(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var i = 0\\n        while i < nums.count {\\n            if nums[i] > 0, nums[i] <= nums.count, nums[i] != nums[nums[i] - 1] {\\n                nums.swapAt(i, nums[i] - 1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n        for (i, num) in nums.enumerated() {\\n            if num != i + 1 {\\n                return i + 1\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n\\n\\n    // Normal sort\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingNormalSort(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n\\n        if var minPositiveIndex = nums.firstIndex(where: { $0 > 0 }), nums[minPositiveIndex] == 1 {\\n            while minPositiveIndex + 1 < nums.count, nums[minPositiveIndex + 1] - nums[minPositiveIndex] <= 1 {\\n                minPositiveIndex += 1\\n            }\\n            return nums[minPositiveIndex] + 1\\n        } else {\\n            return 1\\n        }\\n    }\\n\\n    // Hash/Set\\n    // Time: O(n)\\n    // Space: O(n)\\n    func firstMissingPositiveUsingSet(_ nums: [Int]) -> Int {\\n        var set = Set<Int>()\\n        for num in nums {\\n            if num > 0, num <= nums.count {\\n                set.insert(num)\\n            }\\n        }\\n\\n        for i in 1...nums.count {\\n            if !set.contains(i) {\\n                return i\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n\\n    func firstMissingPositive(_ nums: [Int]) -> Int {\\n        return firstMissingPositiveUsingCylicSort(nums)\\n        // return firstMissingPositiveUsingNormalSort(nums)\\n        // return firstMissingPositiveUsingSet(nums)\\n    }\\n\\n    // Cylic sort\\n    // Time: O(n)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingCylicSort(_ nums: [Int]) -> Int {\\n        var nums = nums\\n        var i = 0\\n        while i < nums.count {\\n            if nums[i] > 0, nums[i] <= nums.count, nums[i] != nums[nums[i] - 1] {\\n                nums.swapAt(i, nums[i] - 1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n        for (i, num) in nums.enumerated() {\\n            if num != i + 1 {\\n                return i + 1\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n\\n\\n    // Normal sort\\n    // Time: O(nlogn)\\n    // Space: O(1)\\n    func firstMissingPositiveUsingNormalSort(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted()\\n\\n        if var minPositiveIndex = nums.firstIndex(where: { $0 > 0 }), nums[minPositiveIndex] == 1 {\\n            while minPositiveIndex + 1 < nums.count, nums[minPositiveIndex + 1] - nums[minPositiveIndex] <= 1 {\\n                minPositiveIndex += 1\\n            }\\n            return nums[minPositiveIndex] + 1\\n        } else {\\n            return 1\\n        }\\n    }\\n\\n    // Hash/Set\\n    // Time: O(n)\\n    // Space: O(n)\\n    func firstMissingPositiveUsingSet(_ nums: [Int]) -> Int {\\n        var set = Set<Int>()\\n        for num in nums {\\n            if num > 0, num <= nums.count {\\n                set.insert(num)\\n            }\\n        }\\n\\n        for i in 1...nums.count {\\n            if !set.contains(i) {\\n                return i\\n            }\\n        }\\n        return nums.count + 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263341,
                "title": "short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        for(auto &i: nums){\\n            if(i<=0||i>n){\\n                i = n+1;\\n            }\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)==n+1||nums[abs(i)-1]<0)continue;\\n            nums[abs(i)-1] *= -1;\\n        }\\n        for(i = 1; i <= n; i++){\\n            if(nums[i-1]>0)return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        for(auto &i: nums){\\n            if(i<=0||i>n){\\n                i = n+1;\\n            }\\n        }\\n        for(auto &i: nums){\\n            if(abs(i)==n+1||nums[abs(i)-1]<0)continue;\\n            nums[abs(i)-1] *= -1;\\n        }\\n        for(i = 1; i <= n; i++){\\n            if(nums[i-1]>0)return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160264,
                "title": "92-accepted-easy-solution-with-explanation",
                "content": "# Intuition\\n@first you think about to put ith value at its original position in sorted array (that is at i)\\n# Approach\\n@first you think about to put ith value at its original position in sorted array (that is at i)\\n@if the position is out of bound leave it as it is and move on this is done also in case of duplicate\\n@then re-iterate whole array find first time which is not at its original position return it \\n@ if all array is perfect after swap return size of array\\n# Complexity\\n- Time complexity:\\nTime complexity is O(n)  because for each element we find it original position or leave it on their position\\n\\n- Space complexity:\\nspace complexity is O(1)\\nbecause there is only 2 to 4 approx variable is taken\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // if(nums.)\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                if(nums[i]>nums.size()-1||nums[i]<0){\\n                    i++;\\n                }else{\\n                     int j=nums[i];\\n                     int temp=nums[j];\\n                     nums[i]=temp;\\n                     nums[j]=j;\\n                     if(temp==j){\\n                         i++;\\n                     }\\n                }\\n            }else{\\n            i++;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i&&i){\\n                return i;\\n            }\\n        }\\n        if(nums[0]==nums.size()){\\nreturn nums.size()+1;\\n        }else{\\n\\n        return nums.size();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // if(nums.)\\n        int i=0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                if(nums[i]>nums.size()-1||nums[i]<0){\\n                    i++;\\n                }else{\\n                     int j=nums[i];\\n                     int temp=nums[j];\\n                     nums[i]=temp;\\n                     nums[j]=j;\\n                     if(temp==j){\\n                         i++;\\n                     }\\n                }\\n            }else{\\n            i++;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i&&i){\\n                return i;\\n            }\\n        }\\n        if(nums[0]==nums.size()){\\nreturn nums.size()+1;\\n        }else{\\n\\n        return nums.size();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148746,
                "title": "4-line-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int traversal =1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==traversal)\\n            {\\n                traversal++;\\n            }\\n           \\n        }\\n        return traversal;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int traversal =1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==traversal)\\n            {\\n                traversal++;\\n            }\\n           \\n        }\\n        return traversal;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127620,
                "title": "easy-peasy-soln-to-hard-problem",
                "content": "# Intuition \\n    Simple Math Operation and Logic\\n\\n# Approach\\n\\n- Since they\\'ve asked us to find out the smallest positive integer, then there\\'s no point of having the negative numbers in array.\\n\\n- All the negative numbers in the array is replaced by 0.\\n\\n- Check if the number one(1) is present in array or not. If not then you\\'ve got the answer :-))),  just return 1.\\n\\n- Otherwise sort the array and find out for that first element whose difference is greater than 1. If found, then store the result in a variable and break the loop. \\n\\n- If the value of the variable is same even before and after the iteration, then return (last element + 1).\\n\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!--  -->\\n\\n- Space complexity: O(1)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 0)\\n              nums[i] = 0;\\n        }\\n\\n        int ones = 0;\\n        for(auto x: nums)\\n        {\\n            if(x == 1)\\n               ones++;  \\n        }\\n\\n        if(ones == 0)\\n            return 1;\\n\\n        sort(nums.begin(), nums.end());\\n        int ele = -1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - nums[i-1] > 1)\\n            {\\n                ele = nums[i-1] + 1;\\n                break;\\n            }\\n        } \\n\\n        return ele == -1 ? ++nums[n-1] : ele;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 0)\\n              nums[i] = 0;\\n        }\\n\\n        int ones = 0;\\n        for(auto x: nums)\\n        {\\n            if(x == 1)\\n               ones++;  \\n        }\\n\\n        if(ones == 0)\\n            return 1;\\n\\n        sort(nums.begin(), nums.end());\\n        int ele = -1;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - nums[i-1] > 1)\\n            {\\n                ele = nums[i-1] + 1;\\n                break;\\n            }\\n        } \\n\\n        return ele == -1 ? ++nums[n-1] : ele;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719139,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int first = 1;\\n        \\n        for (int num : nums) {\\n            if (num > 0) {\\n                set.add(num);\\n            }\\n            \\n            if (num == first) {\\n                first++;\\n                \\n                while (set.contains(first)) {\\n                    first++;\\n                }\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        int first = 1;\\n        \\n        for (int num : nums) {\\n            if (num > 0) {\\n                set.add(num);\\n            }\\n            \\n            if (num == first) {\\n                first++;\\n                \\n                while (set.contains(first)) {\\n                    first++;\\n                }\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623142,
                "title": "easy-beginners-solution-explained",
                "content": "nums.sort() # sort the given array of numbers \\n        ans=1  # set 1 as ans because 1 is the smallest positive integer#\\n        for i in range(len(nums)):\\n            if nums[i] == ans: # if during the iteration current index value and ans matches then increment ans, at any point it does not match return ans #\\n                ans += 1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "nums.sort() # sort the given array of numbers \\n        ans=1  # set 1 as ans because 1 is the smallest positive integer#\\n        for i in range(len(nums)):\\n            if nums[i] == ans: # if during the iteration current index value and ans matches then increment ans, at any point it does not match return ans #\\n                ans += 1\\n        return ans",
                "codeTag": "Unknown"
            },
            {
                "id": 2463829,
                "title": "python-4-approaches-summarized-with-o-n-o-1-solution",
                "content": "# Introduction\\nThis particular problem is much easier than it would usually be, as the problem\\u2019s description specifies the required time and space complexity, limiting the possible approaches.</br>\\nHowever, in the actual interview, you would likely be given a problem without specified constraints and solution time-space complexity. \\n* You should ask about input value constraints before proceeding to solve the problem. \\n* Optimal time-space complexity should be achieved in the solving process, starting with a brute-force solution and further seeking ways to optimize the process.</br>\\n\\n# Brute-Force solution\\nThe solution that comes to mind first consists of checking the presence in `nums` of every positive integer in ascending order, starting with *1*. The number of checks is limited by *N + 1*, because the lowest positive missing integer lies within the range *[1, \\u2026, N + 1]* for an array of length *N*, as the missing value would be *N + 1* if all values in *[1, \\u2026, n]* are present in `nums` once, and missing value would be in *[1, \\u2026, n]* otherwise.\\n## Code\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n\\t\\t# check presence of each value in [1, ..., N]\\n\\t\\t# missing value is N + 1 if every previous value is present\\n        for v in range(1, len(nums)):\\n\\n            if v not in nums:\\n                return v\\n\\n        return v + 1\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array, and *O(M)* be the time complexity of finding whether a certain number is present in the array.</br>\\nNote that linear search in an array takes *O(N)* time because it is conducted by iterating through the whole array until the number is found, meaning *O(M) = O(N)*\\n* Time Complexity: *O(N<sup>2</sup>)*\\nFor each number in *[1, \\u2026 N]*, we spend *O(M)* time to check whether it is present in `nums`</br>\\nIn total, we have *O(N \\\\* M) = O(N<sup>2</sup>))*</br>\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the currently processed number.\\n\\n# Sorting solution\\nAnother simple solution lies in sorting the array and iterating through it until we reach the last non-positive number and further checking that every positive number is present in the sorted array.\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # sort nums\\n        nums.sort()\\n        cur = 0\\n        \\n        for idx, val in enumerate(nums):\\n            # skip the negatives\\n            if val <= 0:\\n                continue\\n\\n            # check that next value in sorted nums contains\\n            # number that immeadiately follows it or is equal to it\\n            # set current lowest positive to one that we checked\\n            elif val == cur or val == cur + 1:\\n                cur = val\\n           \\n           # break cycle if there is a gap of more than 1 between two\\n           # neighbouring values in sorted nums\\n           else:\\n                break\\n\\n        return cur + 1\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array.\\n* Time Complexity: *O(N \\\\* logN)*\\nQuicksort is generally considered the fastest among the usual sorting algorithms since its time complexity is *O(N \\\\* logN)* on average for a randomly sampled array. However, most programming languages use some sort of hybrid, heavily optimized algorithm as their native sort. Usually, the native sorting algorithms are the fastest, but their average time complexity is *O(N \\\\* logN)*.\\nFor each in `nums[i]`, we check whether the value is positive and equal to the previous or bigger by one.</br>\\nIn total we have *O(N \\\\* logN + N \\\\* M) = O(N \\\\* logN + N) = O(N \\\\* logN)*</br>\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the current number we search for. Quicksort is an in-place sorting algorithm, meaning that it uses no extra space.</br>\\nHowever, if you use native to your preferred language sorting algorithm, it may use a linear extra space in a worst-case scenario.\\n# Hash-Table solution\\nThe pros of using a hash table are that hash tables are implemented in such a way that adding, searching for, and deleting a value is done within average and amortized *O(1)* time. The solution lies in iterating through `nums` and adding every positive integer to the hash table, and then checking for the presence in the hash table of every positive integer in ascending order.\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # create hash table\\n        present_values = set()\\n\\n        # add every value from nums to hash table\\n        for v in nums:\\n            if v > 0:\\n                present_values.add(v)\\n        \\n        # searching for lowest missing value, starting with 1\\n        cur = 1\\n        \\n        while cur in present_values:\\n            cur += 1\\n\\n        return cur\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array, and *O(M)* be the time complexity of finding whether a certain positive number is present in the hash table.\\n* Time Complexity: *O(N)*\\nFor each `nums[i]`, we add its value to the hash table in *O(1)* time. For values in the range *[1, \\u2026, N]*, we check whether they are present in the hash table in *O(M)* time.</br>\\nIn total we have *O(N \\\\* 1 + N \\\\* M) = O(N + N \\\\* 1) = O(N)*</br>\\n* Space Complexity: *O(N)*\\nWe use linear extra space to store the hash table (some of the values in `nums` are stored in the hash table). Not knowing the exact number of positive integers in `nums`, in the worst-case scenario, all values in `nums` will be positive), and thus hash table stores a certain percentage *P* of values in `nums`.</br>\\nNote that *O(P / 100 * N) = O(N)*\\n# Final solution\\nThere are a couple of constraints to the problem, which will help us find the right solution:\\n* We need to store somehow information about the existence of a certain positive number\\n* According to the problem\\u2019s formulation, we can not use additional space to store this information.\\n* We can not sort the `nums` array to store information in an intuitive ascending way because of the time complexity constraints which do not allow for sorting.\\n\\nThe only way to store all necessary information is in the `nums` array itself, and here is how we will do it. \\n1. We could use the cell at the index that corresponds to a specific value *v* to store information about the value *v* so that `nums[v]`, which contains some value *k*, will represent the existence of *v*, yet still containing information about the *k* value.\\n2. Since we only care about the positive numbers, upon reaching value *v*, we could make the value in `nums[v]` a negative value of the same power, `nums[v] = -nums[v]`. But you can already see some flaws in this approach:\\n\\n\\t* In case `nums[v] = 0`, then `-nums[v] = 0` as well, not reflecting the existence of *v*.\\n\\t* Negative integers could already be present in `nums`, confusing the algorithm, such as in the following case, say there is no value *v* in `nums`, but `nums[i] = -2`, then the algorithm would think that *v* was present in `nums`.\\n\\t* Large values greater than the highest index in `nums` can also be present in `nums`, calling for runtime errors.\\n3. Let us try to fix these issues:\\n\\t* In case `nums[v] = 0`: Since zero is not a positive integer, we do not care about its existence. We can replace it with any number that we know exists in `nums`, as adding a number already present in `nums` will not reflect on the lowest missing integer. The number that surely is the number *v* that we are processing at the moment `nums[v] = 0 => nums[v] = -v`.\\n\\t* Since the presence of negative values is irrelevant to us (we are looking for the lowest positive integer), we can replace all negatives with zeroes, especially since we have already solved the \\u2018zero\\u2019 problem.\\n\\t* As explained in the brute-force approach, missing values is in the range *[1, \\u2026, N + 1]* thus, we can ignore all values greater than *N* (if all values in *[1, \\u2026, N]* are present in `nums`, then *N + 1* is the lowest missing, thus no need to store information about *N + 1*), or perhaps more conveniently replace them with zeroes\\n4. And lastly, for convenience, to avoid messing with indices, we will add another zero value at the end of the array to represent the existence of value *N*; consequently, `nums[N]` will not present us with a runtime error.\\n![image](https://assets.leetcode.com/users/images/aefd3524-2345-4bbf-a834-5c4af0807abb_1661287627.2233372.gif)\\n## Code:\\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        # add zero value to the end to avoid messing with indices\\n        nums.append(0)\\n\\n        # nums preprocessing\\n        for idx, num in enumerate(nums):\\n            if nums[idx] <= 0 or nums[idx] >= len(nums):\\n                nums[idx] = 0\\n\\n        # getting nums to store information about the existence of processed positive integer\\n        for idx, num in enumerate(nums):\\n            i = abs(num)\\n\\n            if nums[i] == 0:\\n                nums[i] = -i\\n            else:\\n                nums[i] = -abs(nums[i])\\n\\n        idx = 1\\n\\n        # finding lowest positive integer that is missing from nums\\n        while idx < len(nums) and nums[idx] < 0:\\n            idx += 1\\n\\n        return idx\\n```\\n## Complexity analysis\\nLet *N* be the length of the `nums` array.\\n* Time Complexity: *O(N \\\\* logN)*\\nFor each `nums[i]`, we check whether it is negative or larger than *N* and replace it with zero if the condition is true in *O(N)* time. For each `nums[i] = v` we set `nums[|v|] = -|v|` in *O(N)* time. For each `nums[i] = v`, we check whether *v* is larger than zero, meaning that *v* was not present in `nums`, consequently *v* being the first missing positive in *O(N)* time</br>\\nIn total we have *O(N + N + N) = O(N)*\\n\\n* Space Complexity: *O(1)*\\nWe use constant extra space to store a fixed number of variables to account for the current number/index.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n\\t\\t# check presence of each value in [1, ..., N]\\n\\t\\t# missing value is N + 1 if every previous value is present\\n        for v in range(1, len(nums)):\\n\\n            if v not in nums:\\n                return v\\n\\n        return v + 1\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # sort nums\\n        nums.sort()\\n        cur = 0\\n        \\n        for idx, val in enumerate(nums):\\n            # skip the negatives\\n            if val <= 0:\\n                continue\\n\\n            # check that next value in sorted nums contains\\n            # number that immeadiately follows it or is equal to it\\n            # set current lowest positive to one that we checked\\n            elif val == cur or val == cur + 1:\\n                cur = val\\n           \\n           # break cycle if there is a gap of more than 1 between two\\n           # neighbouring values in sorted nums\\n           else:\\n                break\\n\\n        return cur + 1\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n\\n        # create hash table\\n        present_values = set()\\n\\n        # add every value from nums to hash table\\n        for v in nums:\\n            if v > 0:\\n                present_values.add(v)\\n        \\n        # searching for lowest missing value, starting with 1\\n        cur = 1\\n        \\n        while cur in present_values:\\n            cur += 1\\n\\n        return cur\\n```\n```python\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        # add zero value to the end to avoid messing with indices\\n        nums.append(0)\\n\\n        # nums preprocessing\\n        for idx, num in enumerate(nums):\\n            if nums[idx] <= 0 or nums[idx] >= len(nums):\\n                nums[idx] = 0\\n\\n        # getting nums to store information about the existence of processed positive integer\\n        for idx, num in enumerate(nums):\\n            i = abs(num)\\n\\n            if nums[i] == 0:\\n                nums[i] = -i\\n            else:\\n                nums[i] = -abs(nums[i])\\n\\n        idx = 1\\n\\n        # finding lowest positive integer that is missing from nums\\n        while idx < len(nums) and nums[idx] < 0:\\n            idx += 1\\n\\n        return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718735,
                "title": "c-o-1-space-and-o-n-time-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Algorithm- \\n    We will rearrange the array such that each `valid` element get its correct place and then search for the answer in rearranged array.\\n    \\n    Question-0: Why the thought of array rearrangement should click OR Why this method?\\n        We can easily solve this question using unordered_set but that will cost us O(n) space and we are expected to solve it in O(1) extra space hence\\n\\t\\twe have to somehow make use of existing space to get the answer and hence the thought of array rearrangment should click.\\n     \\n    Question-1: What is correct the place for an element in the rearranged array? \\n        For an element i its correct place is i-1 th index in the array.\\n        E.g. [5,3,4,1,2] -> [1,2,3,4,5] or [4,-2,5,3,0] -> [0,-2,3,4,5].\\n        \\n    Question-2: Which elements will not get its correct place OR which are `invalid` elements? \\n        1. Elements which are non-positive -> We do not have any index in the array to store them(Hence condition-1: nums[i] <= 0 then continue).\\n        2. If element is larger than array size -> We again do not have correct index to store such elements(Hence condition-2: nums[i] > sz then continue). \\n        3. Repeated elements -> As one index can hold only one correct element other repeated elements will have to be ignored (Hence condition-3: \\n\\t\\t   nums[nums[i]-1] == nums[i] means element with which we are swapping current element is already in its correct position so ignore).\\n        \\n    Question-3: How we will get the final answer?\\n        We will go through the modified array and find the first position(in or outside the array) which does not hold the correct element.\\n    */\\n    int firstMissingPositive(vector<int>& nums) {\\n        int sz = nums.size();\\n        for(int i=0;i<sz;i++) {\\n            while(nums[i] != i+1) {\\n                if(nums[i] <= 0 || nums[i] > sz || nums[nums[i]-1] == nums[i]) break;\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i=0;i<sz;i++) if(nums[i] != i+1) return i+1;\\n        return sz+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Algorithm- \\n    We will rearrange the array such that each `valid` element get its correct place and then search for the answer in rearranged array.\\n    \\n    Question-0: Why the thought of array rearrangement should click OR Why this method?\\n        We can easily solve this question using unordered_set but that will cost us O(n) space and we are expected to solve it in O(1) extra space hence\\n\\t\\twe have to somehow make use of existing space to get the answer and hence the thought of array rearrangment should click.\\n     \\n    Question-1: What is correct the place for an element in the rearranged array? \\n        For an element i its correct place is i-1 th index in the array.\\n        E.g. [5,3,4,1,2] -> [1,2,3,4,5] or [4,-2,5,3,0] -> [0,-2,3,4,5].\\n        \\n    Question-2: Which elements will not get its correct place OR which are `invalid` elements? \\n        1. Elements which are non-positive -> We do not have any index in the array to store them(Hence condition-1: nums[i] <= 0 then continue).\\n        2. If element is larger than array size -> We again do not have correct index to store such elements(Hence condition-2: nums[i] > sz then continue). \\n        3. Repeated elements -> As one index can hold only one correct element other repeated elements will have to be ignored (Hence condition-3: \\n\\t\\t   nums[nums[i]-1] == nums[i] means element with which we are swapping current element is already in its correct position so ignore).\\n        \\n    Question-3: How we will get the final answer?\\n        We will go through the modified array and find the first position(in or outside the array) which does not hold the correct element.\\n    */\\n    int firstMissingPositive(vector<int>& nums) {\\n        int sz = nums.size();\\n        for(int i=0;i<sz;i++) {\\n            while(nums[i] != i+1) {\\n                if(nums[i] <= 0 || nums[i] > sz || nums[nums[i]-1] == nums[i]) break;\\n                swap(nums[nums[i]-1], nums[i]);\\n            }\\n        }\\n        for(int i=0;i<sz;i++) if(nums[i] != i+1) return i+1;\\n        return sz+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371896,
                "title": "python-o-n-time-and-o-1-space-accepted-solution-with-explanation",
                "content": "**TECHNIQUE :**\\n\\nWhat we are going to use a simple trick that if we modify a element A as **A\\' =  A + (B * N)** (here A is smaller than N) then now we can obtain both the value A and B from this new A as : \\nA = A\\' % N and B = A\\' / N\\n\\nWe can use this technique here to use the current array as a hash array.\\n\\n**Approach :**\\n\\nIf we have an array of size say x then we can definitely say that our missing number will lie in range 1 to (x+1). So, we can modify the array so that ith number will get stored at ith cell. Then we can traverse through the array and the index at which arr[i] != i, will be our answer. In case, all are present, then we can check if n is present in original array or not, if yes then our answer will be (n+1) else our answer is n. \\n\\n**CODE :**\\n\\n```\\ndef missingNumber(self,arr,n):\\n\\t\\t/* variable to check if n is present in our array or not */\\n        hasN = False\\n        for i in range(0,n):\\n\\t\\t\\t# if n is present we update our boolean variable to True\\n            if arr[i] == n:\\n                hasN = True\\n\\t\\t\\t\\t\\n\\t\\t\\t# marking the useless elements as zero\\n            if arr[i]<=0 or arr[i]>=n:\\n                arr[i] = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        #using the above technique, we are updating the current array \\n\\t\\t\\t# so that arr[i] contains its original value as well as the desired value        \\n        for i in range(0,n):\\n            val = arr[i]%n\\n\\t\\t\\t\\n\\t\\t\\t# leaving the useless elements as well as\\n\\t\\t\\t# already updated elements\\n            if val==0 or arr[val]//n == val:\\n                continue\\n            arr[val] += val * n\\n        \\n        #simple check that updated arr[i] contains i or not\\n        for i in range(1,n):\\n            if arr[i]//n != i:\\n                return i\\n                \\n\\t\\t#in case 1 to n-1 are all present , we will check for n and n+1 using prev calculated hasN\\n        if hasN == True:\\n            return n+1\\n        else :\\n            return n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef missingNumber(self,arr,n):\\n\\t\\t/* variable to check if n is present in our array or not */\\n        hasN = False\\n        for i in range(0,n):\\n\\t\\t\\t# if n is present we update our boolean variable to True\\n            if arr[i] == n:\\n                hasN = True\\n\\t\\t\\t\\t\\n\\t\\t\\t# marking the useless elements as zero\\n            if arr[i]<=0 or arr[i]>=n:\\n                arr[i] = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        #using the above technique, we are updating the current array \\n\\t\\t\\t# so that arr[i] contains its original value as well as the desired value        \\n        for i in range(0,n):\\n            val = arr[i]%n\\n\\t\\t\\t\\n\\t\\t\\t# leaving the useless elements as well as\\n\\t\\t\\t# already updated elements\\n            if val==0 or arr[val]//n == val:\\n                continue\\n            arr[val] += val * n\\n        \\n        #simple check that updated arr[i] contains i or not\\n        for i in range(1,n):\\n            if arr[i]//n != i:\\n                return i\\n                \\n\\t\\t#in case 1 to n-1 are all present , we will check for n and n+1 using prev calculated hasN\\n        if hasN == True:\\n            return n+1\\n        else :\\n            return n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1291029,
                "title": "c-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n        \\n        Lets say the size of the array is n\\n        We need to find the first missing positive number\\n        The range of values for this required number should be ? \\n        If the array is strictly increasing and starts with 1 then the missing number would be n+1;\\n        but if thats not the case then the first positive number should be in the range[1,n];\\n        \\n        algo should be:\\n        we can discard the negative and numbers greater than n.\\n        For the remaining numbers we can use them as index and\\n        mark the number in index position. \\n         One way to mark would be first replace negative number and number greater than n with n+1\\n         Then using marking technique mentioned convert the value to negative.\\n         \\n        After that iterate the array and return the first unmarked poition +1 value as the result.\\n        */\\n        \\n        if(nums.size()==1 && nums[0]<=0)\\n            return 1;\\n            \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=0 || nums[i] > nums.size()+1)\\n                nums[i]=nums.size()+1;            \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]) > nums.size())continue;\\n            int idx = abs(nums[i])-1;\\n            \\n            if( nums[idx] > 0)\\n                nums[idx]=-nums[idx];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n        \\n        Lets say the size of the array is n\\n        We need to find the first missing positive number\\n        The range of values for this required number should be ? \\n        If the array is strictly increasing and starts with 1 then the missing number would be n+1;\\n        but if thats not the case then the first positive number should be in the range[1,n];\\n        \\n        algo should be:\\n        we can discard the negative and numbers greater than n.\\n        For the remaining numbers we can use them as index and\\n        mark the number in index position. \\n         One way to mark would be first replace negative number and number greater than n with n+1\\n         Then using marking technique mentioned convert the value to negative.\\n         \\n        After that iterate the array and return the first unmarked poition +1 value as the result.\\n        */\\n        \\n        if(nums.size()==1 && nums[0]<=0)\\n            return 1;\\n            \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=0 || nums[i] > nums.size()+1)\\n                nums[i]=nums.size()+1;            \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(abs(nums[i]) > nums.size())continue;\\n            int idx = abs(nums[i])-1;\\n            \\n            if( nums[idx] > 0)\\n                nums[idx]=-nums[idx];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                return i+1;\\n        }\\n        return nums.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060638,
                "title": "python-really-cool-solution-faster-than-99-32-o-n-time-o-1-memory",
                "content": "\\tclass Solution:\\n\\t\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\t\\tdef swap(nums: List[int], i: int, j: int):\\n\\t\\t\\t\\ttmp = nums[i]\\n\\t\\t\\t\\tnums[i] = nums[j]\\n\\t\\t\\t\\tnums[j] = tmp\\n\\t\\t\\t\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\twhile( nums[index] > 0 and nums[index] <= length and nums[nums[index] - 1] != nums[index]):\\n\\t\\t\\t\\t\\tswap(nums, index, nums[index] - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\tif nums[index] != index + 1: return index + 1\\n\\t\\t\\treturn length + 1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\t\\tdef swap(nums: List[int], i: int, j: int):\\n\\t\\t\\t\\ttmp = nums[i]\\n\\t\\t\\t\\tnums[i] = nums[j]\\n\\t\\t\\t\\tnums[j] = tmp\\n\\t\\t\\t\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\twhile( nums[index] > 0 and nums[index] <= length and nums[nums[index] - 1] != nums[index]):\\n\\t\\t\\t\\t\\tswap(nums, index, nums[index] - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor index in range(len(nums)):\\n\\t\\t\\t\\tif nums[index] != index + 1: return index + 1\\n\\t\\t\\treturn length + 1",
                "codeTag": "Java"
            },
            {
                "id": 914496,
                "title": "c-o-n-time-o-1-space",
                "content": "Answer may be in [1, n] or it may be n + 1\\nElement bound [1, n]\\nIf there a element whose value is out of bound the the answer is between [1, n], else the answer is n + 1\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Checking if the answer is 1\\n        bool f = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                f = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!f)\\n        {\\n            return 1;\\n        }\\n        // 1 is present so it doesn\\'t matter how many times it is present\\n        \\n\\t\\t// Making all the out of bound elements 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 1 || nums[i] > n)\\n            {\\n                nums[i] = 1;\\n            }\\n        }\\n        \\n\\t\\t// Hashing\\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = abs(nums[i]);\\n            nums[c - 1] = -1 * abs(nums[c - 1]);\\n        }\\n        \\n\\t\\t// Checking\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                return i + 1;\\n            }\\n        }\\n        \\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// Checking if the answer is 1\\n        bool f = false;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                f = true;\\n                break;\\n            }\\n        }\\n        \\n        if(!f)\\n        {\\n            return 1;\\n        }\\n        // 1 is present so it doesn\\'t matter how many times it is present\\n        \\n\\t\\t// Making all the out of bound elements 1\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] < 1 || nums[i] > n)\\n            {\\n                nums[i] = 1;\\n            }\\n        }\\n        \\n\\t\\t// Hashing\\n        for(int i = 0; i < n; i++)\\n        {\\n            int c = abs(nums[i]);\\n            nums[c - 1] = -1 * abs(nums[c - 1]);\\n        }\\n        \\n\\t\\t// Checking\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                return i + 1;\\n            }\\n        }\\n        \\n        \\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871583,
                "title": "c-two-pointers-o-n-with-swap",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r)\\n        {\\n            if(l + 1 == nums[l])\\n                l++;\\n            else if(r + 1 == nums[r] || nums[r] <= 0 || nums[r] >= nums.size() || nums[nums[r] - 1] == nums[r])\\n                r--;\\n            else \\n                swap(nums[r], nums[nums[r] - 1]);\\n        }\\n        while(l < nums.size() && l + 1 == nums[l])\\n            l++;\\n        return l + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r)\\n        {\\n            if(l + 1 == nums[l])\\n                l++;\\n            else if(r + 1 == nums[r] || nums[r] <= 0 || nums[r] >= nums.size() || nums[nums[r] - 1] == nums[r])\\n                r--;\\n            else \\n                swap(nums[r], nums[nums[r] - 1]);\\n        }\\n        while(l < nums.size() && l + 1 == nums[l])\\n            l++;\\n        return l + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725846,
                "title": "python-easy-solution-with-comments",
                "content": "```py\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # mark those elements who aren\\'t in the range of [1, n]\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        # mark visited elements as negative\\n        for i in range(n): \\n            if (abs(nums[i]) - 1 < n and nums[abs(nums[i]) - 1] > 0): \\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] \\n\\n        # find first positive/unmarked element and return its index\\n        for i in range(n): \\n            if (nums[i] > 0): \\n                return i + 1\\n        \\n        # if all elements are negative/marked means all elements are in the range of [1, n]\\n        return n + 1\\n```\\n\\nFor another approach, check out https://leetcode.com/problems/first-missing-positive/discuss/754516/O(1)-space-O(n)-time-Python-solution-by-placing-elements-to-their-right-position",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # mark those elements who aren\\'t in the range of [1, n]\\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        # mark visited elements as negative\\n        for i in range(n): \\n            if (abs(nums[i]) - 1 < n and nums[abs(nums[i]) - 1] > 0): \\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] \\n\\n        # find first positive/unmarked element and return its index\\n        for i in range(n): \\n            if (nums[i] > 0): \\n                return i + 1\\n        \\n        # if all elements are negative/marked means all elements are in the range of [1, n]\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364428,
                "title": "python-o-n-time-o-1-space-with-explanation",
                "content": "The key observation is that the smallest missing positive integer is NO MORE THAN n+1. Therefore, we can safely remove all the integers that are greater than n or less than 1, then all numbers in the list are less than or equal to n. By arranging each number in the new list to correspoding position(e.g. nums[0] = 1, nums[1] = 2 ...), we can spot the missing integer within O(n) time and O(1) space.\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        i = 0\\n        while i < n:\\n            while 0 < nums[i] <= n and nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:\\n                # termination conditions:\\n                # 1. current number is less than zero or greater than n, leave it and check the next position\\n                # 2. current number is the right number\\n                # 3. the position corresponds to current number has already contain the right number\\n                # Otherwise, exchange between current position and the position corresponds to current number\\n\\t\\t\\t\\t\\n                tmp = nums[i]\\n                nums[i], nums[tmp - 1] = nums[tmp - 1], nums[i]\\n            i += 1\\n\\n        for i in range(n):\\n            if nums[i] != i + 1:\\n                return i + 1\\n        return n + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        i = 0\\n        while i < n:\\n            while 0 < nums[i] <= n and nums[i] != i + 1 and nums[nums[i] - 1] != nums[i]:\\n                # termination conditions:\\n                # 1. current number is less than zero or greater than n, leave it and check the next position\\n                # 2. current number is the right number\\n                # 3. the position corresponds to current number has already contain the right number\\n                # Otherwise, exchange between current position and the position corresponds to current number\\n\\t\\t\\t\\t\\n                tmp = nums[i]\\n                nums[i], nums[tmp - 1] = nums[tmp - 1], nums[i]\\n            i += 1\\n\\n        for i in range(n):\\n            if nums[i] != i + 1:\\n                return i + 1\\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304741,
                "title": "cyclic-sort-o-n-runtime-0-ms-memory-usage-34-1-mb-java-with-comments",
                "content": "```\\nclass Solution {\\n    \\n\\tpublic int firstMissingPositive(int[] nums) {\\n       int i=0;\\n       // Convert the array to \"1 to n\" (example below) form using Cyclic Sort \\n       // and map +ve numbers to respective indices around negative numbers\\n       while(i < nums.length) {\\n         if(nums[i] > 0 // Skip negative numbers\\n         && nums[i] <= nums.length //Critical, so we do not want to go out of bound\\n         && nums[i] != nums[nums[i] - 1]) { // Cyclic Sort criteria\\n               swap (nums, i, nums[i] - 1);\\n         } else {\\n               ++i;\\n         }\\n       }\\n        \\n       // Example: For an input array [-3, 1, 5, 4, 2 ], the cyclic sorted \\n       // array after the above jumps will look like [1, 2, -3, 4, 5].\\n       // Looking at this we know the element after 2, i.e 3 is missing.\\n       for(i=0; i<nums.length; i++) {\\n           if(i+1 != nums[i]) {\\n               return i + 1;\\n           }\\n       }\\n        \\n       return i+1; // This will tc of all negative testcases like empty array etc\\n    }\\n\\t\\n\\tprivate static void swap (int [] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int firstMissingPositive(int[] nums) {\\n       int i=0;\\n       // Convert the array to \"1 to n\" (example below) form using Cyclic Sort \\n       // and map +ve numbers to respective indices around negative numbers\\n       while(i < nums.length) {\\n         if(nums[i] > 0 // Skip negative numbers\\n         && nums[i] <= nums.length //Critical, so we do not want to go out of bound\\n         && nums[i] != nums[nums[i] - 1]) { // Cyclic Sort criteria\\n               swap (nums, i, nums[i] - 1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 243173,
                "title": "java-solution-faster-than-100-o-1-space-and-o-n-time",
                "content": "We can assert the answer must be in [1, len + 1], the len is the length of input array. Because if the answer is greater than len + 1, then [1, 2, ...., len + 1] must be in the array, but the array of len length only can store [1, 2, ..., len]. \\nSo, first we can replace the zero or negative with len + 1, and that not change answer. then this problem similar with [find-all-numbers-disappeared-in-an-array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/), [find-all-duplicates-in-an-array](https://leetcode.com/problems/find-all-duplicates-in-an-array/) :)\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= 0) {\\n                nums[i] = len + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int n = Math.abs(nums[i]);\\n            if (n <= len && nums[n - 1] > 0) {\\n                nums[n - 1] *= -1;\\n            }\\n        }\\n        \\n        int first = len + 1;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] >= 0) {\\n                first = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= 0) {\\n                nums[i] = len + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int n = Math.abs(nums[i]);\\n            if (n <= len && nums[n - 1] > 0) {\\n                nums[n - 1] *= -1;\\n            }\\n        }\\n        \\n        int first = len + 1;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] >= 0) {\\n                first = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174383,
                "title": "o-n-time-o-1-space-without-swapping-with-explanation",
                "content": "## Idea:\\n1. Any element less than `0` or greater than `n` is useless, so change those to `0`\\n2. Track whether an element is present by making the element at the index negative\\n\\n## Steps:\\n1. Assign `0` to useless terms (`nums[i] < 0 || nums[i] > n`)\\n    - `[3,4,-1,1] -> [3,4,0,1]`\\n2. Treat each element as a pointer by making the element at that index negative (taking the absolute value to ignore whether we marked it as present). The one edge case is if the element is `0`: we point to itself since we assigned `0` to the useless elements.\\n\\t1. `nums[0] = 3: [3,4,0,1] -> [3,4,-3,1]` (the third element is 0 so we point to itself)\\n\\t2. `nums[1] = 4: [3,4,-3,1] -> [3,4,-3,-1]` (we negate the fourth element)\\n\\t3. `nums[2] = -3` (no change since the third element is already negative)\\n\\t4. `nums[3] = -1: [3,4,-3,-1] -> [-3,4,-3,-1]` (we negate the first element)\\n3. Return the correct index for the first element that is `>= 0`\\n\\n## Full solution:\\n```\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] < 0 || nums[i] > n) {\\n            nums[i] = 0;\\n        }\\n    }\\n\\n    for (int num : nums) {\\n        if (num != 0) {\\n            int index = Math.abs(num) - 1;\\n            if (nums[index] == 0) {\\n                nums[index] = -(index + 1);\\n            } else {\\n                nums[index] = -Math.abs(nums[index]);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    return n + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int firstMissingPositive(int[] nums) {\\n    int n = nums.length;\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] < 0 || nums[i] > n) {\\n            nums[i] = 0;\\n        }\\n    }\\n\\n    for (int num : nums) {\\n        if (num != 0) {\\n            int index = Math.abs(num) - 1;\\n            if (nums[index] == 0) {\\n                nums[index] = -(index + 1);\\n            } else {\\n                nums[index] = -Math.abs(nums[index]);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (nums[i] >= 0) {\\n            return i + 1;\\n        }\\n    }\\n    return n + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170370,
                "title": "python-o-n-time-o-1-space-beats-100-changes-the-original-list",
                "content": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        k = 0\\n        \\n        # remove 0, negatives, and too large numbers\\n        for i, num in enumerate(nums):\\n            if num > 0 and num <= length:\\n                # move the positive integers up front\\n                nums[k] = num \\n                k += 1 \\n        \\n        # We manipulate the list up to the k-th index\\n        # We don\\'t care about the elements from indices (k+1)-th to length.\\n        # Now the nums[:k+1] only contains integers in the range 1 to k+1.\\n        # We treat the elements as the next indices. \\n        # When an element is reached, it is changed to be negative.\\n        # If the element is never reached, it\\'s gonna stay positive.\\n        # That is the first missing positive integer.\\n        for i in range(k):\\n            num = abs(nums[i])\\n            \\n            if nums[num-1] > 0:\\n                nums[num-1] *= -1\\n        \\n        for i in range(k):\\n            if nums[i] >= 0:\\n                return i+1\\n        \\n        return k+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstMissingPositive(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        k = 0\\n        \\n        # remove 0, negatives, and too large numbers\\n        for i, num in enumerate(nums):\\n            if num > 0 and num <= length:\\n                # move the positive integers up front\\n                nums[k] = num \\n                k += 1 \\n        \\n        # We manipulate the list up to the k-th index\\n        # We don\\'t care about the elements from indices (k+1)-th to length.\\n        # Now the nums[:k+1] only contains integers in the range 1 to k+1.\\n        # We treat the elements as the next indices. \\n        # When an element is reached, it is changed to be negative.\\n        # If the element is never reached, it\\'s gonna stay positive.\\n        # That is the first missing positive integer.\\n        for i in range(k):\\n            num = abs(nums[i])\\n            \\n            if nums[num-1] > 0:\\n                nums[num-1] *= -1\\n        \\n        for i in range(k):\\n            if nums[i] >= 0:\\n                return i+1\\n        \\n        return k+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996341,
                "title": "solution-explained-with-example-o-n-time-o-1-space",
                "content": "# Bruteforce\\nMark all the integers of array in separate array of n elements by updating corresponding value to 1 and then from start find index at which value is not 1 to identify the smallest missing positive integer.\\n\\n# Optimal Approach\\nHere we can\\'t mark all the integers as we only have O(1) auxiliary space. So, we will use the same array to mark the numbers. But you\\'ll think that how can we mark? There will be some number at each index. So, we will do this in loop until we reach the free space or come at begining, this way no data will be lost.\\n\\n# Example\\nArray : [5, 6, 2, 1, 2] => N = 5\\nPre Processing : We will remove all negatives integers and numbers greater than N by replacing them with 0.\\n0 = Represents position free to be marked, no loss of data.\\n-1 = Position already marked, integer present in input array.\\n\\nArray (current state) : [6, 0, 2, 1, 2] \\n\\nStart with Index: 0\\nRead number 5 and free up position(index: 0) by marking it with 0. Mark number 5 by replacing arr[5 - 1] with -1. In order to avoid loss of data at index 4, we will keep it in temp variable. After marking, we will do the same process for temp variable which is 1.\\n\\nArray (current state) : [-1, 0, 2, -1, 2] \\nInsights - Integer 1 and 5 was present in input array because they are marked in above array.\\n\\nIndex : 1\\nAlready 0. It\\'s free space and we can ignore it.\\n\\nIndex : 2\\n2 will be marked at arr[2 - 1] which is already free so no further processing.\\nArray (current state) : [-1, -1, 0, -1, 2]\\n\\nIndex : 3\\nNo data present to mark because it\\'s -1.\\n\\nIndex : 4\\n2 will be marked at arr[2 - 1], it\\'s already marked so we can either ignore or remark it.\\n\\nFinal array : [-1, -1, 0, -1, 0]\\n\\nTraverse the array and stop at first non -1 number. Here it will be index 2, So Integer 3 is missing.\\n\\nIf we don\\'t find any non -1 number then N + 1 will be the answer.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) - Since we will come at every index only once.\\n\\n- Space complexity:\\nO(1) - No space is used other than few temporary variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // Remove negative and numbers greater than N, those are unwanted.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0 || nums[i] > n) nums[i] = 0;\\n        }\\n\\n        // Starting from index 0, we will start marking.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0 || nums[i] == -1) continue;\\n\\n            int index = nums[i] - 1; // index is the position of number which needs to be updated\\n            nums[i] = 0; \\n            int temp;\\n            while (nums[index] > 0) {\\n                temp = nums[index];\\n                nums[index] = -1;\\n                index = temp - 1;\\n            }\\n            nums[index] = -1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != -1) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // Remove negative and numbers greater than N, those are unwanted.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0 || nums[i] > n) nums[i] = 0;\\n        }\\n\\n        // Starting from index 0, we will start marking.\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0 || nums[i] == -1) continue;\\n\\n            int index = nums[i] - 1; // index is the position of number which needs to be updated\\n            nums[i] = 0; \\n            int temp;\\n            while (nums[index] > 0) {\\n                temp = nums[index];\\n                nums[index] = -1;\\n                index = temp - 1;\\n            }\\n            nums[index] = -1;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != -1) return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738172,
                "title": "java-solution-using-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    PriorityQueue <Integer> minHeap = new PriorityQueue<>();\\n    // Add all the positive numbers in the PriorityQueue\\n    for(int i = 0; i < nums.length; i ++) {\\n        if(nums[i] > 0) minHeap.add(nums[i]);\\n    }\\n    int minMissing = 1;\\n    // Check for all minimum missing positive number\\n    while(! minHeap.isEmpty()) {\\n        int element = minHeap.poll();\\n        if(element == minMissing) minMissing ++;\\n        else if(element > minMissing) break;\\n    }\\n    return minMissing;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n    PriorityQueue <Integer> minHeap = new PriorityQueue<>();\\n    // Add all the positive numbers in the PriorityQueue\\n    for(int i = 0; i < nums.length; i ++) {\\n        if(nums[i] > 0) minHeap.add(nums[i]);\\n    }\\n    int minMissing = 1;\\n    // Check for all minimum missing positive number\\n    while(! minHeap.isEmpty()) {\\n        int element = minHeap.poll();\\n        if(element == minMissing) minMissing ++;\\n        else if(element > minMissing) break;\\n    }\\n    return minMissing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718092,
                "title": "easy-detailed-c-o-n-time-complexity-o-1-space-complexity-solution-beats-100",
                "content": "# Intuition\\nHashmap\\n\\n# Approach\\n1. shift all the negative numbers to the rightmost side using two pointers\\n\\n2. Use index as hashmap to check which positive number is missing\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //Complexities - \\n        //time complexity O(n)\\n        //space complexity O(1)\\n        \\n        //Code improvement suggestion -\\n        //revert back the changes done to the array after getting the min missing positive number\\n\\n        //steps used - \\n        // 1. shift all the negative numbers to the rightmost side using two pointers\\n\\n\\n        //2. Use index as hashmap to check which positive number is missing\\n\\n        int maxElement = 0;\\n        int l = nums.size()-1;\\n        int r = nums.size() -1;\\n\\n        while(r>=0) {\\n            if(nums[r]<=0) {\\n                swap(nums[l], nums[r]);\\n                l--;\\n            }\\n            if(nums[r] > maxElement) {\\n                maxElement = nums[r];\\n            }\\n            r--;\\n        }\\n\\n          // l contains the location of last positive integer\\n          for(int i =0; i <=l; i++) {\\n              if( (abs(nums[i]) - 1) <=l && nums[abs(nums[i]) - 1] > 0) {\\n                  nums[abs(nums[i]) - 1] = 0 - nums[abs(nums[i]) - 1];\\n              }\\n          }\\n\\n          //any the number till l position if found postive the index value + 1 will be the first missing positive integer  \\n          for(int i =0; i <=l; i++) {\\n              if(nums[i] >0) {\\n                  return i+1;\\n              }\\n          }\\n\\n          // if we did not find out any missing number in seq that means whatever is the max positive integer till now + 1 will be the first missing posyive number  \\n          return maxElement+1;  \\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        //Complexities - \\n        //time complexity O(n)\\n        //space complexity O(1)\\n        \\n        //Code improvement suggestion -\\n        //revert back the changes done to the array after getting the min missing positive number\\n\\n        //steps used - \\n        // 1. shift all the negative numbers to the rightmost side using two pointers\\n\\n\\n        //2. Use index as hashmap to check which positive number is missing\\n\\n        int maxElement = 0;\\n        int l = nums.size()-1;\\n        int r = nums.size() -1;\\n\\n        while(r>=0) {\\n            if(nums[r]<=0) {\\n                swap(nums[l], nums[r]);\\n                l--;\\n            }\\n            if(nums[r] > maxElement) {\\n                maxElement = nums[r];\\n            }\\n            r--;\\n        }\\n\\n          // l contains the location of last positive integer\\n          for(int i =0; i <=l; i++) {\\n              if( (abs(nums[i]) - 1) <=l && nums[abs(nums[i]) - 1] > 0) {\\n                  nums[abs(nums[i]) - 1] = 0 - nums[abs(nums[i]) - 1];\\n              }\\n          }\\n\\n          //any the number till l position if found postive the index value + 1 will be the first missing positive integer  \\n          for(int i =0; i <=l; i++) {\\n              if(nums[i] >0) {\\n                  return i+1;\\n              }\\n          }\\n\\n          // if we did not find out any missing number in seq that means whatever is the max positive integer till now + 1 will be the first missing posyive number  \\n          return maxElement+1;  \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693801,
                "title": "first-missing-positive-using-c-with-time-o-n-memory-o-1",
                "content": "# Intuition\\nCan we solve this problem in-place or without using extra space? \\n# Approach\\nThe approach described is known as the \"Cyclic Sort\" algorithm, which is used to solve the problem of finding the first missing positive number in an array without using extra space. It involves rearranging the elements in the array by swapping them into their correct positions.\\n\\nThe algorithm works as follows:\\n1. Iterate through the array from the start.\\n2. Check if the current number, X[i], is within the range of 1 to n and if it is not already present at index X[i] - 1.\\n3. If the conditions are met, swap X[i] with the number present at the index X[i] - 1.\\n4. Continue the process until the array is fully traversed.\\n\\nAfter the sorting is done, the next step is to scan the modified array again to find the first index where X[i] is not equal to i + 1. This indicates the presence of a missing positive number. If such an index is found, return i + 1 as the first missing positive. If no such index is found, it means all numbers from 1 to n are present in the array, so return the value n + 1 as the first missing positive.\\n\\nThis algorithm solves the problem in-place, meaning it rearranges the elements within the original array without requiring additional space.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i]-1] != nums[i]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if(nums[i] != i+1){\\n                return i+1;\\n            }\\n        }\\n\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(nums[i] > 0 && nums[i] <= nums.size() && nums[nums[i]-1] != nums[i]){\\n                swap(nums[i], nums[nums[i]-1]);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            if(nums[i] != i+1){\\n                return i+1;\\n            }\\n        }\\n\\n        return nums.size() + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618414,
                "title": "easy-peasy-c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(auto x: nums) st.insert(x);\\n        for(int i=1; ;i++){\\n            if(st.find(i)==st.end()) return i;\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for(auto x: nums) st.insert(x);\\n        for(int i=1; ;i++){\\n            if(st.find(i)==st.end()) return i;\\n        }\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505754,
                "title": "beginner-friendly-approach-usinf-hashsets-basic-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nintuition was to solve the problem with the help of sets in one loops\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni stored the value in sets ,because sets automatically arrange it in increasing order making it very easy to solve.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        set<int> data;\\n        int n=nums.size();\\n        for(int x=0;x<n;x++)\\n        {\\n            data.insert(nums[x]);\\n        }\\n        int i=1;\\n        while(i<=n)\\n        {\\n            if(data.find(i)!=data.end()) i++;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        set<int> data;\\n        int n=nums.size();\\n        for(int x=0;x<n;x++)\\n        {\\n            data.insert(nums[x]);\\n        }\\n        int i=1;\\n        while(i<=n)\\n        {\\n            if(data.find(i)!=data.end()) i++;\\n            else return i;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447629,
                "title": "c-sorting-easy-10-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply sort the array and keep a current positive count , If you able to get it increment current positive else return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.) Set curPos i.e. count for current positive to 1.\\n2.) Now  sort the array \\n3.)Then simply iterate the array , If you find it increment curPos and search in remaining array\\n4.) If you don\\'t find it i.e. i reaches to n-1(size-1) simply return curPos because it is missing in the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN) -> sorting the array\\nO(N)->for searching \\n\\nTotal = O(NlogN + N) = O(N(logN+1))= O(N*logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) -> no extra space used \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end()); // to sort the array \\n\\n        int curPos=1; // sets current Positive to 1 \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==curPos) curPos++;\\n        }\\n\\n        return curPos;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end()); // to sort the array \\n\\n        int curPos=1; // sets current Positive to 1 \\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==curPos) curPos++;\\n        }\\n\\n        return curPos;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297321,
                "title": "first-missing-positive-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0 ; i<nums.length; ) {\\n\\t\\t\\tif(nums[i]<=0 || nums[i]>=nums.length || nums[i]-1== i || nums[i]==nums[nums[i]-1] )i++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint index= nums[i]-1; \\n\\t\\t\\t    int temp = nums[index]; \\n\\t\\t\\t\\tnums[index]= nums[i];\\n\\t\\t\\t\\tnums[i]= temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0 ; i<nums.length ; i++) {\\n\\t\\t\\tif(nums[i]-1!=i) {\\n\\t\\t\\t\\treturn i+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums.length+1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0 ; i<nums.length; ) {\\n\\t\\t\\tif(nums[i]<=0 || nums[i]>=nums.length || nums[i]-1== i || nums[i]==nums[nums[i]-1] )i++;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint index= nums[i]-1; \\n\\t\\t\\t    int temp = nums[index]; \\n\\t\\t\\t\\tnums[index]= nums[i];\\n\\t\\t\\t\\tnums[i]= temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0 ; i<nums.length ; i++) {\\n\\t\\t\\tif(nums[i]-1!=i) {\\n\\t\\t\\t\\treturn i+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums.length+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290473,
                "title": "fast-and-simple-python3-no-modification",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        visited = {n for n in nums if n > 0 and n < 100_001}\\n        smallest = 1\\n        while smallest in visited:\\n            smallest += 1\\n        return smallest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        visited = {n for n in nums if n > 0 and n < 100_001}\\n        smallest = 1\\n        while smallest in visited:\\n            smallest += 1\\n        return smallest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138111,
                "title": "c-beginner-friendly-small-and-readable-code-hard-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe used simple hash table to find it \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n    int p=nums.size()+1;\\n    vector<int> a(p,0);\\n    int i,j;\\n// to fill hashtable with 1\\n    for(i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>0 && nums[i]<nums.size()+1)\\n        a[nums[i]]++;\\n    }\\n    //to find the no.\\n    for(i=1;i<nums.size()+1;i++)\\n    {\\n        if(a[i]==0) return i;\\n    }\\n\\n    return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n    int p=nums.size()+1;\\n    vector<int> a(p,0);\\n    int i,j;\\n// to fill hashtable with 1\\n    for(i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>0 && nums[i]<nums.size()+1)\\n        a[nums[i]]++;\\n    }\\n    //to find the no.\\n    for(i=1;i<nums.size()+1;i++)\\n    {\\n        if(a[i]==0) return i;\\n    }\\n\\n    return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126783,
                "title": "c-solved-explained-with-o-n-time-and-uses-constant-extra-space",
                "content": "# Explanation\\nThe idea is to use the index of the array to store the value of the number in the array. For example, if the input array is [3, 4, -1, 1], we can use the index 0 to store 1, index 1 to store 2, index 2 to store 3 and so on.\\n\\nTo do this, we need to first separate the positive numbers from the negative numbers. Then, for each positive number, we use its value as the index to store its corresponding value in the array.\\n\\nAfter separating the positive numbers and rearranging the array, the first missing positive number will be the first position in the array that does not contain its corresponding value.\\n\\n# Use of Loops\\nIn the first loop, we separate the positive numbers from the negative numbers. We use while loop to swap the value of the current number with its corresponding value in the array until the current number is not in its correct position.\\n\\nIn the second loop, we find the first missing positive number. The first position in the array that does not contain its corresponding value is the first missing positive number. If all the positions contain their corresponding values, then the missing positive number is n+1.\\n\\nHere is the code in C++:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        // separate the positive numbers from the negative numbers\\n        for (int i=0;i<n;i++) \\n            while (nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i])\\n                swap(nums[i],nums[nums[i]-1]);\\n        // find the first missing positive number\\n        for (int i=0;i<n;i++)\\n            if (nums[i]!=i+1)\\n                return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        // separate the positive numbers from the negative numbers\\n        for (int i=0;i<n;i++) \\n            while (nums[i]>0 && nums[i]<=n && nums[nums[i]-1]!=nums[i])\\n                swap(nums[i],nums[nums[i]-1]);\\n        // find the first missing positive number\\n        for (int i=0;i<n;i++)\\n            if (nums[i]!=i+1)\\n                return i+1;\\n        return n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971735,
                "title": "java-1ms-o-n-100-50mb-o-1-85-10-code-with-full-explanation-using-bits",
                "content": "Please Upvote if it helps! \\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        // O(n) time, O(1) space;\\n        int n = nums.length, size = 0;\\n        // -> Since: max(min integer not in nums ) <= n+1\\n        // -> we find the number of bits i.e. (size) of n\\n        // -> we know that no number <= n will have (size)th bit to 1\\n        // therefore we set the (size)th bit of the i to 1 if there exists\\n        // nums[j] such that nums[j] = i.\\n        // -> this set bit will be used in the final iteration as the judging criteria\\n        // -> for all values <=0 && values > n, we first partition them \\n\\t\\t//and then we set them to zero so that there does not arrive any conflict of  (size)th bit = 1 beforehand.\\n        // -> I have used zero indexing so if we have nums[j] = 1,\\n        // (size)th bit of nums[0] will be set to 1 and not of nums[1]\\n\\n        \\n        // CODE:        \\n        \\n        //calculating the variable size:\\n        while(n > 0){\\n            n = n>>1;\\n            size++;\\n        }\\n        n = nums.length;\\n        int pivot = 0;\\n        \\n        // using partitioning to partition values not to be included in the array (negatives, zeros, and values > n):\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= 0 || nums[i] > n){\\n                int temp = nums[i];\\n                nums[i] = nums[pivot];\\n                nums[pivot] = temp;\\n                pivot++;\\n            }\\n        }\\n        // setting all bits to zero for values not in range 1 - n:\\n        for(int i= 0; i < pivot; i++)\\n            nums[i] = 0;\\n        //setting the (size)th bit to 1 for all values in range\\n        for(int i= pivot; i < n; i++){\\n            nums[(nums[i] - 1)&((1<<size) - 1)] |= (1<<size);\\n        }\\n        //final checking condition iteration\\n        for(int i= 0; i < n; i++)\\n            if((nums[i] & (1<<size)) == 0)\\n                return i+1;\\n        //if all 1-n are present, then we return n+1\\n        return n+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        // O(n) time, O(1) space;\\n        int n = nums.length, size = 0;\\n        // -> Since: max(min integer not in nums ) <= n+1\\n        // -> we find the number of bits i.e. (size) of n\\n        // -> we know that no number <= n will have (size)th bit to 1\\n        // therefore we set the (size)th bit of the i to 1 if there exists\\n        // nums[j] such that nums[j] = i.\\n        // -> this set bit will be used in the final iteration as the judging criteria\\n        // -> for all values <=0 && values > n, we first partition them \\n\\t\\t//and then we set them to zero so that there does not arrive any conflict of  (size)th bit = 1 beforehand.\\n        // -> I have used zero indexing so if we have nums[j] = 1,\\n        // (size)th bit of nums[0] will be set to 1 and not of nums[1]\\n\\n        \\n        // CODE:        \\n        \\n        //calculating the variable size:\\n        while(n > 0){\\n            n = n>>1;\\n            size++;\\n        }\\n        n = nums.length;\\n        int pivot = 0;\\n        \\n        // using partitioning to partition values not to be included in the array (negatives, zeros, and values > n):\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] <= 0 || nums[i] > n){\\n                int temp = nums[i];\\n                nums[i] = nums[pivot];\\n                nums[pivot] = temp;\\n                pivot++;\\n            }\\n        }\\n        // setting all bits to zero for values not in range 1 - n:\\n        for(int i= 0; i < pivot; i++)\\n            nums[i] = 0;\\n        //setting the (size)th bit to 1 for all values in range\\n        for(int i= pivot; i < n; i++){\\n            nums[(nums[i] - 1)&((1<<size) - 1)] |= (1<<size);\\n        }\\n        //final checking condition iteration\\n        for(int i= 0; i < n; i++)\\n            if((nums[i] & (1<<size)) == 0)\\n                return i+1;\\n        //if all 1-n are present, then we return n+1\\n        return n+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805417,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] <= 0 or nums[i] > n) {\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(abs(nums[i]) > n) continue;\\n            int id = abs(nums[i]);\\n            nums[id-1] = -1 * abs(nums[id-1]);\\n        }\\n        int ans = n + 1;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > 0) {\\n                ans = i+1;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792059,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n,,,\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\t\\tint k=1;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tif(k==nums[i]){\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\t\\tint k=1;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\t\\t\\tif(k==nums[i]){\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2649319,
                "title": "javascript-fully-explained-solution-with-o-1-space-and-o-n-time-and-faster-than-99-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar firstMissingPositive = function(nums) {\\n    // In this approach we will loop through array and if we find element is in\\n    // range (1 to n) then swap the elemnt with index equal to its value-1.\\n    // example--> if 2 is element then swap 2 with index 2-1 or(1)\\'s value . Notice that if \\n    //another duplicate 2 is already present at index then no need to swap.\\n    let n=nums.length;\\n    let index;\\n    let element;\\n    let temp;\\n    // run a loop through the given array\\n    for(let i=0;i<n;i++){\\n        // if element is from 1 to n.\\n        if(nums[i]>=1 && nums[i]<=n){\\n            element=nums[i];\\n            index=element-1;\\n            // if element is not at correct index swap it.\\n            if(nums[index]!=element){\\n                   temp=nums[index];\\n                   nums[index]=element;\\n                   nums[i]=temp;\\n                   i--;\\n            }\\n        }\\n    }\\n\\n    // run a loop and find if index i has value=i+1. if not return i+1(because it will\\n    // be the first missing positive number)\\n    for(let i=0;i<n;i++){\\n        if(nums[i]!=i+1){\\n            return i+1;\\n        }\\n    }\\n\\n    // if all elements are found till length of array then return length+1.\\n    return n+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar firstMissingPositive = function(nums) {\\n    // In this approach we will loop through array and if we find element is in\\n    // range (1 to n) then swap the elemnt with index equal to its value-1.\\n    // example--> if 2 is element then swap 2 with index 2-1 or(1)\\'s value . Notice that if \\n    //another duplicate 2 is already present at index then no need to swap.\\n    let n=nums.length;\\n    let index;\\n    let element;\\n    let temp;\\n    // run a loop through the given array\\n    for(let i=0;i<n;i++){\\n        // if element is from 1 to n.\\n        if(nums[i]>=1 && nums[i]<=n){\\n            element=nums[i];\\n            index=element-1;\\n            // if element is not at correct index swap it.\\n            if(nums[index]!=element){\\n                   temp=nums[index];\\n                   nums[index]=element;\\n                   nums[i]=temp;\\n                   i--;\\n            }\\n        }\\n    }\\n\\n    // run a loop and find if index i has value=i+1. if not return i+1(because it will\\n    // be the first missing positive number)\\n    for(let i=0;i<n;i++){\\n        if(nums[i]!=i+1){\\n            return i+1;\\n        }\\n    }\\n\\n    // if all elements are found till length of array then return length+1.\\n    return n+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391396,
                "title": "c-o-n-and-o-1-with-detail-explanation",
                "content": "\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n            1. reorder nums to keep 1 in index 1, 2 in index 2 ... \\n                 3,4,-1,1 -> 1,-1,3,4\\n                 1,2,0 -> 1,2,0\\n                 7,8,9,11,12 -> 7,8,9,11,12\\n                algorithm: keep swapping if num in [1, N], if the two nums doesn\\'t equal\\n            2. the one missing in expected place is the missing one\\n        */\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1] ) {\\n                swap(nums[nums[i] - 1], nums[i]);\\n            } \\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        // if it is already ordered, e.g. [1,2], [1], [1,2,3]\\n        return n + 1;\\n        \\n    }\\n};\\n```\\n\\nTime: O(n)\\n\\nSpace: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        /*\\n            1. reorder nums to keep 1 in index 1, 2 in index 2 ... \\n                 3,4,-1,1 -> 1,-1,3,4\\n                 1,2,0 -> 1,2,0\\n                 7,8,9,11,12 -> 7,8,9,11,12\\n                algorithm: keep swapping if num in [1, N], if the two nums doesn\\'t equal\\n            2. the one missing in expected place is the missing one\\n        */\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1] ) {\\n                swap(nums[nums[i] - 1], nums[i]);\\n            } \\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] != i + 1)\\n                return i + 1;\\n        }\\n        // if it is already ordered, e.g. [1,2], [1], [1,2,3]\\n        return n + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289046,
                "title": "explanation-for-o-n-time-and-o-1-space-complexity-solution-c",
                "content": "Firstly, we need to understand that **answer is going to lie among the first n + 1 positive integers**: \\nReason: \\nThe array can have at most n unique positive integers. Now if any of the positive numbers in the range [1, n] are missing in the array then our answer will be the smallest of those. In case all the integers in the range [1, n] are present, then the array has all its indices filled with the integers in the range[1, n] and so the answer will be n + 1.\\n\\nNow I think the easiest approach to come up with is to use a HashMap or HashSet to store the elements of the array and then check for the first n + 1 integers if they are present or not. Even though this approach is O(n) in time, it is pretty slow, because of the time it takes for the hashing operation. Also, the space complexity of the solution is O(n). As clearly mentioned in the problem statement, we can do better. \\n\\nThe main idea of the above approach was to somehow distinguish between the numbers that are present in the array vs the numbers that are not present in the array.\\n\\nWe can still use the same idea but implement it in a better way. \\n\\nFor every element in the array, if it is in not in the range[1, n] we can replace it with n + 2, since these numbers don\\'t really matter. \\nNow the array consists of elements that are either in the range [1, n] or n + 2.\\nFor every element in the array that is in the range [1, n], we can make the element in the array at (position = element - 1) negative\\ni.e. make sure that arr[arr[i] - 1] is negative for every i such that arr[i] belongs to [1, n].\\nthis way we would be able to distinguish between elements that are present in the array ( as for x, in range [1, n] if it is present in the array then arr[x - 1] would be negative, otherwise it will be positive), vs the numbers that are not present in the array. We can then loop from 1 to n, and then check if the corresponding index is negative or positive to check if the element exists in the array.\\n\\nMy Code:\\n```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] <= 0 || nums[i] > n)\\n                nums[i] = n + 2;\\n        for(int i = 0; i < n; ++i){\\n            if(abs(nums[i]) == n + 2)\\n                continue;\\n            if(nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] > 0)\\n                return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] <= 0 || nums[i] > n)\\n                nums[i] = n + 2;\\n        for(int i = 0; i < n; ++i){\\n            if(abs(nums[i]) == n + 2)\\n                continue;\\n            if(nums[abs(nums[i]) - 1] > 0)\\n                nums[abs(nums[i]) - 1] *= -1;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] > 0)\\n                return i + 1;\\n        }\\n        return n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232826,
                "title": "c-2-easiest-approaches-tc-o-n-space-o-1-easy-problem",
                "content": "**Approach 1**\\nTime complexity : **`O(N)`**\\nSpace Complexity : **`O(1)`**\\n\\n----\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Cyclic sort \\n    // Arr :      [1,2,3,4,5,6] \\n    // indices :  [0,1,2,3,4,5]   arr[i] == i+1               \\n    int firstMissingPositive(vector<int>&nums) \\n    {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        for(i=0;i<n;i++){\\n            if(nums[i] != i + 1){\\n                return (i + 1); // missing positive number \\n            }\\n        }\\n        return n + 1; // [1,2,3] , ans  = 4 (missing positive integers)\\n    }\\n    \\n    void swap(vector<int>&nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n};\\n```\\n\\n\\n**Approach 2** \\nTime complexity : **`O(N)`**\\nSpace Complexity : **`O(N)`**\\n\\n----\\n```\\nclass Solution {\\npublic:\\n    \\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<bool>res(n+1, 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n) // positive number inside the range 0 to n\\n            {\\n                res[nums[i]] = true;\\n            }   \\n        }\\n        \\n        // Indices start from 0 to n-1\\n        //  Number start from 1 to n\\n        for(int i=1;i<res.size();i++)\\n        {\\n            if(!res[i])  // first positive number that is false\\n                return i;\\n        }\\n        return (n+1);\\n    }\\n};\\n```\\n*Thanks for upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Cyclic sort \\n    // Arr :      [1,2,3,4,5,6] \\n    // indices :  [0,1,2,3,4,5]   arr[i] == i+1               \\n    int firstMissingPositive(vector<int>&nums) \\n    {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n && nums[i] != nums[nums[i] - 1]){\\n                swap(nums,i,nums[i] - 1);\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        for(i=0;i<n;i++){\\n            if(nums[i] != i + 1){\\n                return (i + 1); // missing positive number \\n            }\\n        }\\n        return n + 1; // [1,2,3] , ans  = 4 (missing positive integers)\\n    }\\n    \\n    void swap(vector<int>&nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int firstMissingPositive(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<bool>res(n+1, 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] > 0 and nums[i] <= n) // positive number inside the range 0 to n\\n            {\\n                res[nums[i]] = true;\\n            }   \\n        }\\n        \\n        // Indices start from 0 to n-1\\n        //  Number start from 1 to n\\n        for(int i=1;i<res.size();i++)\\n        {\\n            if(!res[i])  // first positive number that is false\\n                return i;\\n        }\\n        return (n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075835,
                "title": "cpp-fully-explained-o-1-space-o-n-time-70-faster-solution",
                "content": "```\\nEXPLANATION :\\n    \\n1) I just tried to put every number num: from 1-N, in the (num-1)th position.\\n2) So I just stored the arr[i] in the variable \\'in\\' and swapped arr[in-1] with arr[i].\\n3) Swapped it until I got repetations or arr[i]<=0 or arr[i]>n.\\n4) Did this for every number in the array.\\n5) After that just checked for the number which is not in the (num-1)th position\\n6) If no such number found that simply mean that Every number from 1-N are present in it\\'s position, so return N+1\\n\\nCOMPLEXITY ANALYSIS:\\nTIME: O(N) ,  SPACE: O(1)\\n    \\n    \\nKINDLY DO UPVOTE IF YOU UNDERSTAND MY SOLUTION\\nCOMMENT DOWN IF YOU HAVE ANY DOUBT\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int firstMissingPositive(vector<int>& arr) {\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++){\\n            ll in=-1;\\n            while(1){\\n                if((ll)arr[i]-1==in || arr[i]>n || arr[i]<=0) break;\\n                in=arr[i]-1;\\n                swap(arr[i],arr[in]);\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            if((ll)arr[i]-1!=i) return (int)i+1;\\n        }\\n        return (int)n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nEXPLANATION :\\n    \\n1) I just tried to put every number num: from 1-N, in the (num-1)th position.\\n2) So I just stored the arr[i] in the variable \\'in\\' and swapped arr[in-1] with arr[i].\\n3) Swapped it until I got repetations or arr[i]<=0 or arr[i]>n.\\n4) Did this for every number in the array.\\n5) After that just checked for the number which is not in the (num-1)th position\\n6) If no such number found that simply mean that Every number from 1-N are present in it\\'s position, so return N+1\\n\\nCOMPLEXITY ANALYSIS:\\nTIME: O(N) ,  SPACE: O(1)\\n    \\n    \\nKINDLY DO UPVOTE IF YOU UNDERSTAND MY SOLUTION\\nCOMMENT DOWN IF YOU HAVE ANY DOUBT\\n\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int firstMissingPositive(vector<int>& arr) {\\n        ll n=arr.size();\\n        for(ll i=0;i<n;i++){\\n            ll in=-1;\\n            while(1){\\n                if((ll)arr[i]-1==in || arr[i]>n || arr[i]<=0) break;\\n                in=arr[i]-1;\\n                swap(arr[i],arr[in]);\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            if((ll)arr[i]-1!=i) return (int)i+1;\\n        }\\n        return (int)n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014426,
                "title": "very-clearly-explained-solution-in-python-easy-to-understand",
                "content": "A problem requiring O(n) time and constant extra space, **really hard**!\\n\\nUse the original **input list to work as a hashmap**!\\nWe will let:\\n**mark the value of that index as negative** <=> **mark that index as visited**\\n\\nI will **explain step by step** using an example:\\n[3 4 -1 1]\\n\\n**1. First**, we should know that the first missing positive should be **at most len(list) + 1**,\\n(for example, input list:[1 2 3 4], first missing positive is 5).\\n\\n**2. In the first loop** of the array list, we let number that are not in the range 1:n be n + 1.\\nIn the example:\\n[3 4 -1 1] -> [3 4 5 1]\\n\\n**3. In the second loop**, for every number, if its original value is not equal to n + 1, make it opposite.\\nIn the example:\\n[3 4 5 1]\\n-> [3 4 -5 1] (integer 3 exists, value of index 2 negative)\\n-> [3 4 -5 -1] (integer 4 exists, value of index 3 negative)\\n-> [3 4 -5 -1] (integer 5 equals n + 1, continue)\\n-> [-3 4 -5 -1] (integer 1 exists, value of index 0 negative)\\n\\n**4. In the last loop**, find the first index whose value is positive.\\n\\n**TIme:** O(n)\\n**Space:** O(1)\\n\\n```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        for i in range(n): \\n            a = abs(nums[i])\\n\\n            if a == n + 1:\\n                continue\\n            \\n            nums[a - 1] = - abs(nums[a - 1])\\n            \\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n            \\n        return n + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] <= 0 or nums[i] > n:\\n                nums[i] = n + 1\\n        \\n        for i in range(n): \\n            a = abs(nums[i])\\n\\n            if a == n + 1:\\n                continue\\n            \\n            nums[a - 1] = - abs(nums[a - 1])\\n            \\n        for i in range(n):\\n            if nums[i] > 0:\\n                return i + 1\\n            \\n        return n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903797,
                "title": "java-solution-with-comment",
                "content": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i =0 ;\\n       int i =0 ;\\n        while(i<nums.length)\\n        //nums[i] <nums.length with this we ignore arrayIndexBound error\\n            //nums[i] != nums[nums[i]-1] with this duplicacy is removed\\n        {\\n            if (nums[i] > 0 && nums[i] <nums.length && nums[i] != nums[nums[i]-1] )\\n                swap(nums, i , nums[i]-1);\\n            else\\n                i++;\\n        }\\n        for( i =0; i<nums.length; i++)\\n        {\\n            if (nums[i] != i+1 )\\n               return i+1;\\n        }\\n        return nums.length+1;\\n    }\\n    public  void swap (int nums[], int i , int j){\\n      int  temp =  nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int i =0 ;\\n       int i =0 ;\\n        while(i<nums.length)\\n        //nums[i] <nums.length with this we ignore arrayIndexBound error\\n            //nums[i] != nums[nums[i]-1] with this duplicacy is removed\\n        {\\n            if (nums[i] > 0 && nums[i] <nums.length && nums[i] != nums[nums[i]-1] )\\n                swap(nums, i , nums[i]-1);\\n            else\\n                i++;\\n        }\\n        for( i =0; i<nums.length; i++)\\n        {\\n            if (nums[i] != i+1 )\\n               return i+1;\\n        }\\n        return nums.length+1;\\n    }\\n    public  void swap (int nums[], int i , int j){\\n      int  temp =  nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789620,
                "title": "java-cyclic-sorting-easy-understanding",
                "content": "## **Please upvote if you understood it (\\u301C\\uFFE3\\u25BD\\uFFE3)\\u301C**\\n----\\n-----\\n```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>0 && nums[i]<nums.length && nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else i++;\\n        }\\n        \\n        if(nums[0]>1) return 1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        \\n        return nums.length+1;\\n    }\\n    \\n    \\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        for(int i=0;i<nums.length;){\\n            if(nums[i]>0 && nums[i]<nums.length && nums[i]!=nums[nums[i]-1]){\\n                swap(nums,i,nums[i]-1);\\n            }\\n            else i++;\\n        }\\n        \\n        if(nums[0]>1) return 1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=i+1){\\n                return i+1;\\n            }\\n        }\\n        \\n        return nums.length+1;\\n    }\\n    \\n    \\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692023,
                "title": "c-o-n-time-o-1-space-solution-with-explanation",
                "content": "Not correct solution but for understanding the concept\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // intution\\n        // create a visited array of size n = nums.size()\\n        // mark whatever has been seen\\n        // once whole array is marked iterate and check\\n        // what is absent\\n        // return that\\n        // if nothing is absent return n+1\\n        // this will take O(n) space in extra\\n        // we will obtimise it later\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        \\n        //marking the exisitng numbers\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] > 0 && nums[i] <= n) {\\n                // numbers are from 1 to ..\\n                // indexes to mark are from 0\\n                // so mark number i at i-1 \\n                // e.g mark 5 at index 4\\n                visited[i-1] = true;\\n            }\\n        }\\n        \\n        // cheking what was not present\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) \\n                return i+1;\\n        }\\n        \\n        // everything was present\\n        return n+1;\\n    }\\n};\\n```\\n\\nCorrect solution\\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // now we cant use viisited array\\n        // so we need to mark that we have seen a number between 1 to n in nums itself\\n        // we have to do this without distroying any needed info in nums\\n        \\n        // idea\\n        // we dont need any negative number or 0\\n        // convert them to any number which we are sure will not be out answer\\n        // say intmax\\n        \\n        // now wenever we get any number betwen 1 to n\\n        // we can change the number at that index to its negative\\n        // this will help us store both info\\n        // the value will give us the value in the array\\n        // while the -ve sign will say that the idx+1 was present in the array\\n        int n = nums.size();\\n        \\n        \\n        \\n        //chnage all non positive to intmax or anything greater than n\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] <= 0 ) {\\n               nums[i] = INT_MAX;\\n            }\\n        }\\n        \\n        //mark\\n        for (int i = 0; i < n; i++){\\n            // retrive the number\\n            // convert is to positive if it was negative\\n            // as negative was only used for marking\\n            int val = nums[i] > 0 ? nums[i] : -nums[i];\\n            if(val > 0 && val <= n){\\n                // got a number between 1 to n\\n                \\n                // check if it is already marked at index val-1\\n                // if its negative its marked\\n                // if its postive mark by changing it to negative\\n                if(nums[val-1] > 0) nums[val-1] *= -1;\\n                \\n            }\\n        }\\n        \\n        // check what was absent\\n        for (int i = 0; i < n; i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        \\n        // everything was marked\\n        return n+1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // intution\\n        // create a visited array of size n = nums.size()\\n        // mark whatever has been seen\\n        // once whole array is marked iterate and check\\n        // what is absent\\n        // return that\\n        // if nothing is absent return n+1\\n        // this will take O(n) space in extra\\n        // we will obtimise it later\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        \\n        //marking the exisitng numbers\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] > 0 && nums[i] <= n) {\\n                // numbers are from 1 to ..\\n                // indexes to mark are from 0\\n                // so mark number i at i-1 \\n                // e.g mark 5 at index 4\\n                visited[i-1] = true;\\n            }\\n        }\\n        \\n        // cheking what was not present\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) \\n                return i+1;\\n        }\\n        \\n        // everything was present\\n        return n+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // now we cant use viisited array\\n        // so we need to mark that we have seen a number between 1 to n in nums itself\\n        // we have to do this without distroying any needed info in nums\\n        \\n        // idea\\n        // we dont need any negative number or 0\\n        // convert them to any number which we are sure will not be out answer\\n        // say intmax\\n        \\n        // now wenever we get any number betwen 1 to n\\n        // we can change the number at that index to its negative\\n        // this will help us store both info\\n        // the value will give us the value in the array\\n        // while the -ve sign will say that the idx+1 was present in the array\\n        int n = nums.size();\\n        \\n        \\n        \\n        //chnage all non positive to intmax or anything greater than n\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] <= 0 ) {\\n               nums[i] = INT_MAX;\\n            }\\n        }\\n        \\n        //mark\\n        for (int i = 0; i < n; i++){\\n            // retrive the number\\n            // convert is to positive if it was negative\\n            // as negative was only used for marking\\n            int val = nums[i] > 0 ? nums[i] : -nums[i];\\n            if(val > 0 && val <= n){\\n                // got a number between 1 to n\\n                \\n                // check if it is already marked at index val-1\\n                // if its negative its marked\\n                // if its postive mark by changing it to negative\\n                if(nums[val-1] > 0) nums[val-1] *= -1;\\n                \\n            }\\n        }\\n        \\n        // check what was absent\\n        for (int i = 0; i < n; i++){\\n            if(nums[i] > 0) return i+1;\\n        }\\n        \\n        // everything was marked\\n        return n+1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669736,
                "title": "solution-with-explaination",
                "content": "Solution Approach- Try placing the number at position where index and value can be equal. such that i= nums[i]-1 (zero based index)\\n```\\n// Time-O(N), Space-O(1)\\n\\tpublic static int firstMissingPositive(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < n) {\\n\\t\\t\\t// if number is either less than 1 or already at the right position skip it\\n\\t\\t\\tif (nums[i] < 1 || nums[i] == i + 1) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// don\\'t increment i here, we can compare again after its value is updated\\n\\t\\t\\t\\t// if number is beyond array size then change to out of range (-1)\\n\\t\\t\\t\\tif (nums[i] > n) {\\n\\t\\t\\t\\t\\tnums[i] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// number being swapped already matches, don\\'t swap to avoid infinite loops [1,1]\\n\\t\\t\\t\\t\\tif (nums[i] == nums[nums[i] - 1]) {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// swap to make sure value of nums[i] can be placed to its desired position (if value is 4, place it at the 4th index- i=3)\\n\\t\\t\\t\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\t\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// scan to see if number is not at its desired position, that position is the result\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (nums[j] != j + 1) {\\n\\t\\t\\t\\treturn j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// if every number is at its desired position then size+1 is the answer\\n\\t\\treturn n + 1;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n// Time-O(N), Space-O(1)\\n\\tpublic static int firstMissingPositive(int[] nums) {\\n\\t\\tif (nums == null || nums.length == 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < n) {\\n\\t\\t\\t// if number is either less than 1 or already at the right position skip it\\n\\t\\t\\tif (nums[i] < 1 || nums[i] == i + 1) {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// don\\'t increment i here, we can compare again after its value is updated\\n\\t\\t\\t\\t// if number is beyond array size then change to out of range (-1)\\n\\t\\t\\t\\tif (nums[i] > n) {\\n\\t\\t\\t\\t\\tnums[i] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// number being swapped already matches, don\\'t swap to avoid infinite loops [1,1]\\n\\t\\t\\t\\t\\tif (nums[i] == nums[nums[i] - 1]) {\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// swap to make sure value of nums[i] can be placed to its desired position (if value is 4, place it at the 4th index- i=3)\\n\\t\\t\\t\\t\\t\\tint temp = nums[nums[i] - 1];\\n\\t\\t\\t\\t\\t\\tnums[nums[i] - 1] = nums[i];\\n\\t\\t\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// scan to see if number is not at its desired position, that position is the result\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (nums[j] != j + 1) {\\n\\t\\t\\t\\treturn j + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// if every number is at its desired position then size+1 is the answer\\n\\t\\treturn n + 1;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631318,
                "title": "optimal-and-intuitive-solution-with-explanation-tc-o-n-sc-o-1",
                "content": "Ignore all the elements not in the range 1 to size (include only 1<= element <= size )\\nPlace the element at it\\'s index value ( arr[arr[i] - 1] = arr[i]) ( in zero based index)\\nfor instance  index for 1 is 0, 2 is 1, 3 is 2 and so on.\\n\\n``` arr = [3, 4, -1, 1, 7] ```\\n```\\n\\tplace 3 at index (3 - 1) = 2 i.e at index 2\\n    place 4 at index (4 - 1) = 3\\n    place 1 at index (1 - 1) = 0 \\n\\t\\n\\tsince -1 and 7 are not in the range 1 to size \\n\\tso ignore these elements\\n```\\nIf duplicate elements exist, then no need to place the duplicate element at its correct index as the  elements is already placed at its correct index.\\n\\n\\n\\n```\\n\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int size = nums.length;\\n        for(int i = 0; i < size; i++){\\n            while((nums[i] >= 1 && nums[i] <= size) && (nums[nums[i] - 1] != nums[i])){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size; i++){\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        }\\n     return size + 1;   \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "``` arr = [3, 4, -1, 1, 7] ```\n```\\n\\tplace 3 at index (3 - 1) = 2 i.e at index 2\\n    place 4 at index (4 - 1) = 3\\n    place 1 at index (1 - 1) = 0 \\n\\t\\n\\tsince -1 and 7 are not in the range 1 to size \\n\\tso ignore these elements\\n```\n```\\n\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        int size = nums.length;\\n        for(int i = 0; i < size; i++){\\n            while((nums[i] >= 1 && nums[i] <= size) && (nums[nums[i] - 1] != nums[i])){\\n                int temp = nums[nums[i] - 1];\\n                nums[nums[i] - 1] = nums[i];\\n                nums[i] = temp;\\n            }\\n        }\\n        \\n        for(int i = 0; i < size; i++){\\n            if(nums[i] != i + 1)\\n                return i + 1;\\n        }\\n     return size + 1;   \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606058,
                "title": "c-index-marking-fast-easy-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // we convert all the numbers except 1to n into n+1 as they won\\'t give potential answer.\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]<=0){\\n                nums[i] = n+1;\\n            }\\n        }\\n        for(int i=0; i<n;i++){\\n            int temp = abs(nums[i]);\\n            //if there is any number in ranger 1to n , its index in 0 based array will get marked negative. \\n            if(temp<n+1){\\n                nums[temp-1] = -abs(nums[temp-1]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            // the first positive index+1 will give us result(if there was any element in array was not present\\n            //in the range of 1ton, otherwise we return n+1)\\n            if(nums[i]>0){\\n                return i+1;\\n            }\\n        }\\n        return n+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        // we convert all the numbers except 1to n into n+1 as they won\\'t give potential answer.\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            if(nums[i]<=0){\\n                nums[i] = n+1;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564577,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568115,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565259,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565425,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1567177,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1570529,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565938,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568865,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1571103,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1778745,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1564577,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568115,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565259,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565425,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1567177,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1570529,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1565938,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1568865,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1571103,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1778745,
                "content": [
                    {
                        "username": "totsubo",
                        "content": "The basic idea is that we have an array with n cells (n is the length of the array). The problem description first missing ***positive integer***. If a positive integer is not in the given array it, the missing integer *must* be in the range `[1..n]`. This is the crucial observation we use to deduce the algorithm.\\n\\nSo, If an integer is missing it must be in the range `[1..n]`, if an integer is not missing then the answer is `n+1`.\\n\\nI\\'ll try my best to explain why.\\n\\nLet\\'s picture the only two possibilities:\\n\\n1. There is no missing integer in the array\\n2. There is a missing integer in the array.\\n\\nIf there is *no* missing integers, this means that the array has all number from 1 to n. This must mean that the array is full. Why, because in the range [1..n] there are exactly n numbers, and if you place n numbers in an array of length n, the array is by definition full. (in this case the solution is to return n+1 which is the first smallest integer).\\n\\nOnce you understand the first case above understanding the second is easy. If there *is* a missing integer (or more than one), the missing integer(s), let\\'s call it X, must be in the range 1..n. Why, because if the missing integer X is *not* in the range [1..n] that would imply that all integers [1..n] are in the array, which would mean that the array is full, leaving no space to place X (since X is not in the range [1..n]).\\n\\nThen the algorithm becomes:\\n\\n1. Ignore all numbers <=0 and >n since they are outside the range of possible answers (which we proved was [1..n]). We do this by replacing them with the value n+1.\\n1. For all other integers <n+1, mark their bucket (cell) to indicate the integer exists. (\\\\*see below)\\n1. Find the first cell not marked, that is the first missing integer. If you did not find an unmarked cell, there was no missing integer, so return n+1.\\n\\n\\\\*I recommend looking at this solution for a very smart way to mark the cells:\\n\\nhttps://leetcode.com/problems/first-missing-positive/discuss/17214/Java-simple-solution-with-documentation\\n\\n[**Note**: I find the use of the words *first missing integer* misleading. For example in the array [0,1,2] there is no *missing* integer. What the question really asks is to return the smallest positive integer that is not in the array]\\n"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "Thanks a lot for your comment friend! \\n\\nAnd for those the above approach is brand new:\\nI believe doing problem [287. Find the Duplicate](https://leetcode.com/problems/find-the-duplicate-number/) with the same concept as shown in the solution will better help others to understand it, i.e. the concept to map elements with the index they represent in the array by marking negative."
                    },
                    {
                        "username": "Ultron03",
                        "content": "it will be 1 because we have to find min positive irresptive of from where array input elements are starting .."
                    },
                    {
                        "username": "jenox",
                        "content": "Thanks for the explanation! Note that marking the cells may not be possible in certain languages (such as Swift) without incurring the cost of a copy-on-write of the input array which wouldn\\'t make it O(1)."
                    },
                    {
                        "username": "Dirk41",
                        "content": "why in the test case:Input: [7,8,9,11,12] Output: is 1 not  10????"
                    },
                    {
                        "username": "SanjitKumar49",
                        "content": "bro becouse he need  First Missing Positive that is 1 not 10.\\n"
                    },
                    {
                        "username": "mayur1710hanwate",
                        "content": "WE ALWAYS START CHECKING NUMBER FROM 1 IF NUMBER IS NOT PRESENT THEN RETURN THAT NUMBER"
                    },
                    {
                        "username": "Anik0071",
                        "content": "[@Kurama0263](/Kurama0263) Zero is neither positive nor negative. It is the only number that is neither positive nor negative. Positive numbers are greater than zero, and negative numbers are less than zero. Zero is neither greater than zero nor less than zero."
                    },
                    {
                        "username": "21bcar0242",
                        "content": "10 - 1  ithink bcz its smallest number evan i m confuse ..]"
                    },
                    {
                        "username": "yoon_seri",
                        "content": "Well we need a smallest possible positive integer that is not 0 , here it should not be 10 but 1, as positive interger range is from one and that it needs smallest possible which may or may not be in the array similarly if the array was [1,3,33,34] then the smallest possible integer would be 2 not 32 (but here the range is mattering)"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "[@Kurama0263](/Kurama0263) It is not positive integer "
                    },
                    {
                        "username": "Kurama0263",
                        "content": "[@droningNM](/droningNM) why its not 0\\n"
                    },
                    {
                        "username": "RegexSage",
                        "content": "because we need the least positive number irrespective of elements in an array"
                    },
                    {
                        "username": "hgscoder",
                        "content": "I wish it were written like this:  you are given an unsorted integer array, from which you can infer the value range is [1, n] inclusively, where n is the length of the array, find the very first one not in that range. The current statement is very much misleading: when you are talking about missing, you\\'d better let problem takers know what is expected!"
                    },
                    {
                        "username": "Sufi-san",
                        "content": "But how can the range be [1, n] when the may contain zero and other negative integers?"
                    },
                    {
                        "username": "stackpop",
                        "content": "I find that most solutions online assume that array A itself as a hashtable.\\n\\nMy question is how can you guarantee all element in A is not greater than n,which is the array's size.\\n\\n??????\\n\\nfor example\\n\\nA = { 7, 8 , 9,  11,12 }, n = 5\\n\\nall A[i] is greater than n"
                    },
                    {
                        "username": "enderlord36",
                        "content": "Pigeonhole principle. We don\\'t care about the largest number, we care about the largest number in a sequence that goes 1, 2, 3, 4, .... So we have n elements, the best we can do is 1, 2, 3, ... ,n - 1, n. If we have a number bigger than n, there\\'ll be a gap in the sequence and our answer will be less than n."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "because size  dosen\\'t indicate the largest element  "
                    },
                    {
                        "username": "souravTomar",
                        "content": "if all the elements in array in greater than we simply dont mark anything.... \\nso then the first unmarked element will be 1.. which is the answer"
                    },
                    {
                        "username": "esrujan",
                        "content": "The name of the problem and the description is incomplete and very confusing. First missing positive number does not directly indicate that we are looking for smallest missing positive number. That should be made clear by the problem. It took me few minutes and a peep into the discussion forum to know what the problem is expecting me to do."
                    },
                    {
                        "username": "GXSC",
                        "content": "There are a few key observations:\\n\\n**1 The missing positive integer cannot be bigger than the \"length of the array\" + 1.**\\nSay your array has a length of 5, if the missing integer is 6, that is possible, since you could have 1,2,3,4,5. However, having the missing integer being 7 is impossible, since that would imply that we have from 1 to 6 all in an array of length 5.\\n\\nAs a side note, this condition is generalizable if you want to turn the problem into finding the minimum positive integer while having the positive numbers starting from an arbitrary min (instead of 1). In that case, the max cannot exceed the \"length of the array\" + min. I accidentally solved for that initially - which makes my code and comments pretty aweful.\\n\\n**2 We can ignore any number that is not a possible candidate.**\\nAny number that doesn\\'t fit into our range, we don\\'t care. It would not cause us to mistaken it as the missing number, since it is beyond the range of possible missing numbers. So 0s? negatives? numbers beyond \"length of the array\" + 1? All can be ignored, and their array slot set to some random non-positive number to indicate emptiness.\\n\\n**3 We now know exactly where to put each number.** \\nSince we ignore all numbers not in range, we know that we only have to consider exactly n numbers, where n is the length of the array. And, we know that these numbers range from 1 to n. So, if a number is 3, we put it the slot with index of 3-1 = 2. If the number is 12, we put it in slot 11, etc. Any number beyond range, we set its slot to -1.\\n\\nSo this is just a circular sort. For each number not in a their slot, just swap it with a number in their slot. Do this until the current slot is either having a number in the right place or empty. Look up cycle sort/circle sort/circular sort for more details on this part.\\n\\nThe only thing to watch out is duplicates: they tend to get you infinite loop since you will be keep trying to swap into the same position. Treatment for duplicates are simple: set current slot to empty, since the destination slot already have someone with the right index.\\n\\nOnce this is done, a simple loop to find the first slot with a -1 would give us the first missing positive. And if all slots are filled? Just return the length of the array.\\n\\n**Complexity**\\nFor Big O analysis, you will note that generalized circular sort takes O(N^2). This is due to the fact that in the general algorithm, each step to figure out the correct index takes O(N) by scanning the array. Here we know the right index instantly, so it is O(N). To derive it, think about how many steps did we perform to insert the right element into the right index: each element took exactly 1 step to be inserted to the right place or emptied."
                    },
                    {
                        "username": "mjfuller",
                        "content": "I can't think of a way to do this problem without modifying the array. The swift template code gives an [Int] argument, which is an immutable 'let' constant. I would suggest adding an 'inout' keyword but this might be too much of a hint."
                    },
                    {
                        "username": "farter",
                        "content": "shouldn't we consider manipulating the input array as \"using\" that space?\\nsay \"extra space\" to be more strict.\\ni was just considering streamed algorithm without modifying the source array like reading 1TB numbers from backup tapes.\\n\\nalso, as implemented in some solutions, adding / multiplying by N can be considered extending the number's length in bits, as you are restricted only to use the source array's elements, it may cause overflow error when the number is close to the range of that data type. consider what if you get a char array?"
                    },
                    {
                        "username": "ZGeng",
                        "content": "My solution uses a boolean array which has a size of A.length. So it's a O(n) space solution. The time complexity is also O(n).\\n\\nI didn't expect it to be accepted, but it was.\\n\\nAny comment?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Any explanation on how to make it O(1) in space complexity?"
                    },
                    {
                        "username": "sourashis140",
                        "content": "[@throwkh](/throwkh) actually they just don\\'t "
                    },
                    {
                        "username": "throwkh",
                        "content": "They dont check complexity I believe"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Why expected output to  `nums = [1]` is  `2` ?"
                    },
                    {
                        "username": "JohnTan213",
                        "content": "1 is the smallest positive integer here. The next smallest positive integer that is missing is 2"
                    },
                    {
                        "username": "updownuper",
                        "content": "Tests like this make me angry.\\nI refuse to participate in this nonsense.\\nIn an array of numbers N of length 1, by definition there is no room for a positive number.\\nThere is no range for it!"
                    }
                ]
            },
            {
                "id": 1572795,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1571099,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 2041972,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1899816,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1576134,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1574477,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1569200,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1571100,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1568866,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 2047614,
                "content": [
                    {
                        "username": "isgulkov",
                        "content": "So I\\'ve just wasted a good couple of hours trying to find a solution that would, and I quote, \"*run in O(n) time and use constant extra space*\".\\n\\nThe *no negatives* case of this is itself not too obvious: you just use the signs (basically, unused bits) to store what you need, then clean up after yourself \\u2014 pretty neat. How do you do this with negative numbers, though? I don\\'t know! Maybe there *is* some clever way to do this, but it doesn\\'t seem likely.\\n\\nOne way ot the other, none of the solutions I\\'ve found to this \\u2014 neither on this forum nor through Google \\u2014 actually solve the problem as stated. They just leave the array modified in one way or another!\\n\\nSee, unless you\\'re using some quite peculiar definition of space complexity, if the input array is left modified modified, you\\'re actually **using** it as extra space for your algorithm, which makes its space complexity O(n). You might as well allocate a second array of booleans like any sane person would in this case.\\n\\nOr is there an actual O(1) space solution for this? If so, I\\'d really like to see it!"
                    },
                    {
                        "username": "0ca6ra",
                        "content": "nowhere in the description of the problem it is mentioned that the positive integers in the integer array should be >= 1 and <= n. it seems that all solutions provided made that assumption. if this is the case, the description should be updated."
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "My second hard which I solved on my own without looking at hints or solution ! <33"
                    },
                    {
                        "username": "piyushmorey626",
                        "content": "The first missing number always lies between the range of [1, n+1], where \\'n\\' represents the length of the array. This observation simplifies the problem-solving process. "
                    },
                    {
                        "username": "tunstals",
                        "content": "Some of the solutions I\\'ve seen posted here are using sets or lists to sort the unsorted array parameter, then iterating through the sorted result.\\n\\nSurely this can\\'t be O(N) as the sort algorithm implementation will use a loop itself, then the solution code will use a loop to find the smallest value?  So this would be O(N*2)\\n\\nAm I missing something here?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "That sorting can also get completed in O(n log n)\\n"
                    },
                    {
                        "username": "m13d",
                        "content": "So pretty quickliy I came up with a solution similiar to many of the others here, using a set, or hashmap, to keep track of the numebrs seen. But that\\'s not using constant space. After a bit, I gave in, and looked at the solution. With out giving to much away, it suggests doing something you should never do in real code: modifing the input array!"
                    },
                    {
                        "username": "XuWang77",
                        "content": "\\'\\'\\'\\nreturn(sorted(list(set(range(1,max(nums)+2)) - set(nums)))[0] if nums else 1)\\n\\'\\'\\'"
                    },
                    {
                        "username": "garyfu",
                        "content": "Sorting the array makes the runtime at least O(n*log(n)).\nAlso, creating a extra sets violates the constant extra memory constraint."
                    },
                    {
                        "username": "pilch",
                        "content": "I find the wording confusing, since usually constant space does mean that your algorithm is not allowed to use space quantity that depends on the size of the input. When modifying the input, we allow the algorithm to use up to O(n) space.\\nI suggest the wording should precise that we are allowed to modify the input array."
                    },
                    {
                        "username": "makeittrue",
                        "content": "like putting interger into the i-th element of the array"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "This is a hard question because of the space constraint. Otherwise, it is an easy."
                    },
                    {
                        "username": "Husoski",
                        "content": "The hard part for me was ignoring (what used to be?) good software engineering practice and treating a reference argument as working storage."
                    }
                ]
            },
            {
                "id": 1997280,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1576234,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1576131,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1575308,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1574430,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1573760,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1571956,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1571102,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1570792,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1826191,
                "content": [
                    {
                        "username": "ShashankChaturvedi",
                        "content": "I will give a simple hint, think of indexes, because indexes can be used to compare as they are increasing integers , either your answer will be from the indexes or length + 1."
                    },
                    {
                        "username": "sadmanrizwan",
                        "content": "Easiest solution is to use an extra marking array and mark index **(i - 1)** of that array if **i** is in the given array.\\nThis takes **O(N)** extra memory.\\n\\nTo do it without extra space, we have to use the given array itself as the marking array.\\n\\nHow do we do that?\\n\\nAt first we can get rid of all the numbers less than **0** and greater than **n** (length of the array). We can make them zero, since we don\\'t need them to find the answer.\\n\\nNow, for each positive number **i** in the array, we can mark the index **(i - 1)** just by making **nums[i - 1]** negative.\\nIf **nums[i - 1]** is zero, we can just put **-i** there.\\n\\nThis way value of **nums[i - 1]** will remain intact. Our marking will only make it negative and won\\'t change it\\'s absolute value.\\n\\nAt the end, we can find the lowest missing positive number by finding the lowest index that doesn\\'t have a negative number."
                    },
                    {
                        "username": "user6208QR",
                        "content": "If you are really stuck, please just read one hint at a time, then think about it before reading the next one:\\n\\n1)  Look at the boundary values -2\\u02C632 <= num[i] <= 2\\u02C632-1  and 0 <= n <= 5*10\\u02C65...\\n2) What if we had a huge number in the list?\\n3) Does that huge number really matters in a small list?\\n4) If we only care about values in a small range, can we do something clever?\\n5) Maybe sort the vector faster than O(n log n)?\\n6) Sorting it in place... O(1) space"
                    },
                    {
                        "username": "vaccum",
                        "content": "**Indices are sorted in non-decreasing order and are continuous starting from 1.**"
                    },
                    {
                        "username": "dana-n",
                        "content": "It is bad practice to modify an input parameter as a side effect. In this case, we are being asked to find the first missing positive and in order to do it in \"constant space\" you have to modify the input array. I understand there is a bit of a challenge here, \"can you solve this without allocating extra memory\", however in practice this is generally a bad idea.\\n\\n* https://softwareengineering.stackexchange.com/q/245767/17270\\n* https://softwareengineering.stackexchange.com/q/208828/17270\\n\\nThe exception here would be if the purpose of your function is to modify an input parameter. For example, sort the input array in-place.\\n\\n"
                    },
                    {
                        "username": "Kostya_Kostya",
                        "content": "\\t0. This solution modifies the source array. But since there is no constraint for us not to do that, that\\'s ok.\\n\\t1. The idea is to mark array indexes that correspond to positive numbers in the array.\\n\\t2. We\\'ll mark the index by storing a negative value there.\\n\\t3. But what if there\\'s already negative value there?\\n\\t4. To remedy this we\\'ll first find whatever positive number there exists in array\\n\\t        and substitute all negatives and zeroes with that value.\\n\\t        This way we will not introduce a NEW positive number.\\n\\t        Obviously, if there is no positive number found at this step, the result will be 1.\\n\\t5. After getting rid of negatives and zeroes we\\'ll run thru array and for every number in the array\\n\\t        we will make the number at the corresponding index (number-1) a negative one.\\n\\t        Should check that this index is valid for the array.\\n\\t6. If we hit a position where the number is already negative, that would mean there was a number before\\n\\t       that corresponds to that position. But we know that me made all numbers in the array to be positive.\\n\\t       So we just ignore the minus sign and execute step 5 on this position as though the number was positive.\\n\\t7. In the end we\\'ll have one of two cases:\\n\\t7a. All numbers in the array are negative.\\n\\t        That means that we have numbers in the array corresponding to all indexes.\\n\\t        Obviously that means that we have ALL the numbers from 1 to nums.length (both inclusive).\\n\\t        Obviously we can have more numbers in this case, so the result is nums.length+1\\n\\t7b. Some numbers are negative, some are positive in the array.\\n\\t        The first index with the positive number is our result - because there no such number that would\\n\\t        correspond to this index.\\n\\t8. Mind the fact that array indexes are zero based\\n\\t9. If there were a explicitly stated constraint that nums.length<Integer.MAX_VALUE\\n\\t        (or whatever equivalent is there for this in your preferred language)\\n\\t        we could have simply changed all negatives and zeroes to nums.length+1.\\n\\t        This way they couldn\\'t have meddle at step 5.\\n"
                    },
                    {
                        "username": "zhenxu92",
                        "content": "It indeed has no non-trivial difference between missing number. And it was marked as hard. LeetCode need to fix it."
                    },
                    {
                        "username": "liaoht",
                        "content": "I read a lot of the answers they all get O(n) solution that base on a pre condition , then the bucket sort can be applied, So anyone can tell me where can get this from the question statement ? I can't fingure out where I missed."
                    },
                    {
                        "username": "JUNYUANGO",
                        "content": "![image](https://assets.leetcode.com/users/images/1768d89c-4b76-48d2-9ada-5400a2ca2597_1644363950.9340327.png)\\n"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "first off, solutions shouldn\\'t be posted here, next, that is O(n) space which is outside the requirements"
                    },
                    {
                        "username": "updownuper",
                        "content": "nums = [1,1]\nExpected = 2\n\nThis task is full of nonsense.\nFor the author of this task to draw up a loan agreement at the bank on the same conditions.\n\nSo that he ran around the bank and asked.\n- Why did I take \\$100 from you, but I owe \\$5000?!"
                    }
                ]
            },
            {
                "id": 1575849,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 1571101,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2073255,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2064610,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2064595,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2061616,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2060767,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2057780,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2055998,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2053416,
                "content": [
                    {
                        "username": "topensite",
                        "content": "![image](https://assets.leetcode.com/users/images/00b86e58-5852-42de-9a89-cf5582c9f750_1634063008.47816.png)\\n"
                    },
                    {
                        "username": "allanruin",
                        "content": "when considering the problem, I write several cases to test before submit. After some trying, finally I gave up, and decided to see other peoples' idea. Then I see some claimed AC program, yes, they did got AC on leetcode, and I understand the algorithm behind them. But could you guys tell why the following cases won't pass.\\n\\n    {120,121,119,117,116,115}, // expect 118\\n    {8,7,5,4,9,12,11,10}       // expect 6\\n\\n\\nthe problem itself just stated `unsorted integer array`, and I think the two cases I list above is valid?\\n\\nThe program I tested including these:\\n\\n[\"my c solution 4ms\"][1]\\n\\n[\"my short c solution o(1) space and o(n) time\"][2]\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/42098/my-c-solution-4-ms\\n  [2]: https://leetcode.com/discuss/24013/my-short-c-solution-o-1-space-and-o-n-time"
                    },
                    {
                        "username": "Husoski",
                        "content": "In both of those cases, the first missing positive integer is 1."
                    },
                    {
                        "username": "vamsam61",
                        "content": "Is it real hard?\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "uses O(1) auxiliary space How much is this space precisely? 1 int ? and thus we have to use Binary for Status  "
                    },
                    {
                        "username": "Husoski",
                        "content": "O(1) is a shorthand for \"constant\".  That means that the memory required is the same (or very nearly so) for all input sizes.  Technically, any program that achieves this has \"O(1) space complexity\", provided of course that the program runs at all.\\n\\nSo, \"big O\" notation is not really a good description of how well a program performs.  It\\'s really a description of how that performance will scale with larger inputs.  \\n  "
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public int firstMissingPositive(int[] nums) {\\n        nums=mergesort(nums);\\n        int ans=1;\\n        int i=0;\\n        while(i<nums.length && nums[i]!=1){\\n            i++;\\n        }\\n        if(i==nums.length){\\n            return ans;\\n        }\\n        while(i<nums.length-1 && nums[i]>=nums[i+1]-1){\\n            i++;\\n        }\\n        return nums[i]+1;\\n    }\\n}"
                    },
                    {
                        "username": "snehal_elkiwar",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        \\n        if(nums.length==1){\\n            if(nums[0]==1){\\n                return 2;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();    \\n        HashSet<Integer>uni=new HashSet<>();\\n\\n        for(int i:nums){\\n            uni.add(i);\\n        }\\n\\n        for(int i=1;i<=nums.length+1;i++){\\n            if(uni.contains(i)){\\n                continue;\\n            }\\n            else{\\n                return i;\\n            }\\n        }\\n\\n\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "shift2023",
                        "content": "[2147483647]\\n\\nSeriously??? Why is this even a valid TC? Those of you who are wondering i.e. equivalent to [ INT_MAX ]"
                    },
                    {
                        "username": "agraavi786",
                        "content": "class Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        Map<Integer, Integer> m= new HashMap<>();\\n        Arrays.sort(nums);\\n\\n        for(int n: nums){\\n            if(n>0){\\n                 m.put(n,m.getOrDefault(m, 0)+1);\\n            }\\n        }\\n        for(int i=1;i<=m.size();i++){\\n            if(!m.containsKey(i)){\\n                return i;\\n\\n            }\\n        }\\n        return m.size()+1;\\n        \\n    }\\n}\\n\\n\\n\\n\\nwhat is the wrong with my code? can anyone tell me?"
                    },
                    {
                        "username": "cnml",
                        "content": "This one was weird, I expected it to be hard. Sometimes for hard puzzles I struggle a lot, but this one I immediately got right and my solution beats 98.8% in runtime and average in memory (O(1)). That was unexpected, but good, i guess. Time to struggle for hours on the next hard problem."
                    },
                    {
                        "username": "yush_2001",
                        "content": "It should be a medium not hard. "
                    }
                ]
            },
            {
                "id": 2049691,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 2020252,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1988682,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1979497,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1979486,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1978604,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1967926,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1940061,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1939535,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1935217,
                "content": [
                    {
                        "username": "bashyal",
                        "content": "using O(n) space makes this problem easy or at best medium "
                    },
                    {
                        "username": "Husoski",
                        "content": "I haven\\'t seen a submission in Python or C that *doesn\\'t* use O(n) auxiliary space.  Most \"cheat\" and overwrite the input array/list for that purpose."
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "I am not getting the question itself\\uD83D\\uDE12"
                    },
                    {
                        "username": "amit_9899",
                        "content": " Try solving this question first \\uD83D\\uDC47 \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\n\\nThis problem is similar to above mentioned with only difference that above problem do not contain non - positive numbers and numbers > n.\\n                                             So the Logic will be similar if we somehow succeed to ignore the numbers not in the range [1, n]."
                    },
                    {
                        "username": "erumster",
                        "content": "I don\\'t get why i\\'m getting Runtime Error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\n`\\ni\\'m returning an integer..."
                    },
                    {
                        "username": "erumster",
                        "content": "i\\'m getting `\\n\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");`\\n\\nbut i\\'m literally returning an integer...."
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "people using hashmaps and sorting array knowing that question is asking O(N) time and O(1) space. if you use these things then question will lose its purpose"
                    },
                    {
                        "username": "sangameshMath",
                        "content": "What happens if there are duplicate elements in the array?\\nCan we still produce a O(n) t.c and const space solution?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "yes. a duplicate has no effect on the n in o(n) but then it also depends on what your code does."
                    },
                    {
                        "username": "user2325D",
                        "content": "I\\'m confused with 3rd test case y it is 1 not 10.\\nSo came to check discussions\\nIf it is only have to find minimum positive integer irrespective of numbers in a array\\nI will start comparing my array.\\nIll compare 1 if it is absent its the output\\nIf not will compare  2,3 so on\\nIf 4 is missing, 4 is the output. \\nIs that\\'s it? "
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Are we allowed to change given array nums?\\nIn this case we actually have additional space to store results. \\n\\nDo anyone know solution with \"const vector<int>& nums\" and 0(1) extra space?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) No. Hashset does not allow O(1) extra space condition."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "U can use hashset to do this"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hello,\\n\\nI have a doubt, what does it mean by \"uses constant extra space\"? \\nCan someone please explain me this with respect to the code that I have written.\\n\\n class Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        all_positive_nums = set()\\n        for i in nums:\\n            if i > 0 and i not in all_positive_nums:\\n                all_positive_nums.add(i)\\n\\n        current = 1\\n\\n        while current <= len(all_positive_nums):\\n            if current in all_positive_nums:\\n                current += 1\\n                continue\\n            else:\\n                return current\\n        \\n        return current"
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "[@Anik0071](/Anik0071) ok got it, thank you so much for your valuable response. :) "
                    },
                    {
                        "username": "Anik0071",
                        "content": "constant extra space means you shouldn't use variable with n elements. suppose question has [1,2,3,4,5,6] (assuming they gave without duplicate element)  in a list and you are creating a set with the same elements here all_positive_nums {1,2,3,4,5,6} which has element  6 element. So you are creating another variable with same elements which has space complexity of O(n). what you have to do, solve this problem without this extra variable where space complexity will be O(1). [@Akshay Gole](/AKSHAY_GOLE)"
                    }
                ]
            },
            {
                "id": 1931668,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1928904,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1922112,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1920360,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1915754,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1914993,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1904716,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1890475,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1887475,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1863876,
                "content": [
                    {
                        "username": "johnnychang",
                        "content": "This is a very interesting problem that can be solved with cyclic sort. I found this article very helpful for understanding the pattern: https://leetcode.com/discuss/study-guide/2958275/cyclic-sort-important-pattern"
                    },
                    {
                        "username": "its_shubhamjha__",
                        "content": "counting sort\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "It is interesting comparing algorithms. I also hit on the idea of moving each element in the array into its correct position then finding the first position where the element is out of place.\\n\\nThe problem is that some elements need more than 1 jump to get into the correct position and that created all sorts of edge cases that I had to come up with logic for it.\\n\\nIt didn\\'t occur to me that I could mark each position as negative to indicate a found index. It would have simplified the logic if it did."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why say constant space, but related topics is hash table? "
                    },
                    {
                        "username": "Lakshman_11",
                        "content": "can the elements be repeating"
                    },
                    {
                        "username": "dheeraj3859",
                        "content": "For a linear algorithm we need to sort it using bucket sort and then do a linear search for the missing positive number"
                    },
                    {
                        "username": "charanarc3",
                        "content": "can anyone provide me the proof of time complexity of searching in dictionaries in python"
                    },
                    {
                        "username": "Anik0071",
                        "content": "what is the time complexity of this code?\\n`    for i in range(index, len(nums)):\\n            # print(nums,data,nums[i])\\n            if data not in nums:\\n                return data\\n            data = data +1\\n        return data`\\n\\nfirst for loop is looping through n number and on the 1st if used \"in\" operator this operation also has O(n) complexity. but the chatgpt and bard says this code time complexity is O(n), but my understanding is it may be O(n^2).\\n\\nPasting the chatgpt response \\n<<<-------------------->>>\\nThe time complexity of the provided code is O(n), where n is the number of elements in the nums list.\\n\\nThe for loop iterates over the elements in nums starting from the index variable until the end of the list. In the worst-case scenario, where index is 0, the loop will iterate through all n elements of the nums list.\\n\\nInside the loop, the code checks if data is not in the nums list using the in operator. This operation has a time complexity of O(n) since it potentially needs to compare data with each element of nums.\\n\\nIf the data is not in nums, the code returns data immediately, terminating the loop. Otherwise, if the loop completes without returning, data is incremented by 1 and the loop continues.\\n\\nSince the loop iterates through all n elements of the nums list, the time complexity of the code is O(n).\\n\\nIt\\'s worth noting that the actual time complexity may be lower if the loop is terminated early when data is not found in nums. However, in the worst-case scenario where data is larger than all elements in nums, the code will iterate through all n elements. Therefore, the overall time complexity is O(n).\\n<<<-------------------------->>>\\n\\n "
                    },
                    {
                        "username": "atul1503",
                        "content": "What kind of witchcraft is going on in python with the swap algorithm?"
                    },
                    {
                        "username": "Konada_sunita",
                        "content": "Hi,\\n\\ni have doubt that why my program is exceeding the time limit but the some what similar program is not exceeding the time limit . Could anyone please help me with this ?Please let me know what is wrong with my program as my program is passing for all test case except the below one for which is giving as time limit exceeding \\n\\nBelow Test case is getting failed for my program:\\n__________________________________________________\\n[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99988,99987,99986,99985,99984,99983,99982,99981,99980,99979,99978,99977,99976,99975,99974,99973,99972,99971,99970,99969,99968,99967,99966,99965,99964,99963,99962,99961,99960,99959,99958,99957,99956,99955,99954,99953,99952,99951,99950,99949,99948,99947,99946,99945,99944,99943,99942,99941,99940,99939,99938,99937,99936,99935,99934,99933,99932,99931,99930,99929,99928,99927,99926,99925,99924,99923,99922--------,4,3,2,1]\\n\\n\\n______________________________________________________________________\\nBelow is my program which is exceeding time limit :\\n_____________________________________________________\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        for(int x:nums){\\n            list.add(x);\\n        }\\n        for(int i=1;i<=nums.length;i++){\\n           if(list.contains(i)){\\n               continue;\\n           }else{\\n                return i;\\n               \\n           }\\n        }\\n        return nums.length+1;\\n    } \\n    \\n}\\n_________________________________________________________________________\\n\\n. Below is similar program but with different interface :\\nclass Solution {\\n    public int firstMissingPositive(int[] nums) {\\nHashSet<Integer> set = new HashSet<>();\\n        //Adding all the values to set\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n        }\\n\\n        //Looking for missing integer in ranger 1 to length of array \\n        int i=1;\\n        while(i<=nums.length)\\n        {\\n            if(set.contains(i))\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //If not found returning the length+1 value\\n        return nums.length+1;\\n    }\\n}\\n_______________________________________________________________________________"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "you are performing O(n^n) contains is iterating through the array internally"
                    }
                ]
            },
            {
                "id": 1861489,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845980,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845880,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837770,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1826178,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1817599,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1815654,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1811624,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810839,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810250,
                "content": [
                    {
                        "username": "RajYuvaraj",
                        "content": "for this testcase [3,4,-1,1], both 0 and 2 is missing. Am I correct ?"
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "0 is not positive"
                    },
                    {
                        "username": "Ultron03",
                        "content": "CAN SOMEONE PLEASE HELP ME FINDING THE ERROR IN CODE ..\nIT IS GIVING TLE FOR  [1,2,2147483647] INPUT..\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n \n        int n=nums.size();\n       long long   int min=nums[0];\n         int max=nums[0];\n        for(int i=0;i<n;i++){\n         if(nums[i]>max){\n             max=nums[i];\n             \n         }\n         if(nums[i]<min){\n             min=nums[i];\n         }\n        }\n\n        if(min>1||max<=0){\n            return 1;\n        }\n      \n      map<long long int, int>m;\n  \n      for(int i=min;i<=max;i++){\n          m[i]=0;\n      }\n      for(int i=0;i<n;i++){\n          m[nums[i]]++;\n      }\n\n      for(int i=min;i<=max;i++){\n          if(m[i]==0 && i>0){\n              return i;\n          }\n      }\n\n      return max+1;\n\n    }\n};\n"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "What I don\\'t get is, the condition doesn\\'t specify that the `nums` is from 1 to n. Hence, I don\\'t understand why it doesn\\'t return 10 in the sample `7, 8, 9, 11, 12`. I have to think more on this."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Because positive integer starts at 1."
                    },
                    {
                        "username": "shoyebmd424",
                        "content": "i have used hashtable but showing TLE just i have used O(n) space and O(n) time complexity"
                    },
                    {
                        "username": "AdeebHaider",
                        "content": "Should not be in Hard Category "
                    },
                    {
                        "username": "mmcnitt358",
                        "content": "your solution is more than O(1) space complexity, so technically you don\\'t meet the requirements"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "isn't a while loop(less or equal to len(nums)) without any nested loops O(n)? Then why am I getting a TLE error on case 171, which i think is no.s from 1-100k"
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem may not be the number of times through your loop, but it might be the amount of computation in each iteration.  My solution goes the the array 3 times with no TLE error."
                    },
                    {
                        "username": "kenhaley",
                        "content": "The problem states \"You must implement an algorithm that runs in O(n) time and uses constant extra space.\"  Yet, when I look at accepted solutions that supposedly ran faster than mine, I see that they sort the array using O(n log n) time, and/or they copy the array to a set using O(n) memory.  Why state a restriction if you don\\'t test to be sure the restriction is met?"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "Guys, could you tell me why the output of [1] should be 2 instead  of None?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "because 2 is the next position number. likewise ignoring duplicates if the array was [1,1] the answer would be 2 as well. "
                    },
                    {
                        "username": "bugsbunny99",
                        "content": "Anyone else who is puzzled about why this is a LeetCode \\'Hard\\' problem?"
                    },
                    {
                        "username": "akuthiala",
                        "content": "Why is this C++ code not working?\\nGives runtime error.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v(n,-1);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                v[nums[i]-1]=nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==-1){\\n                return i+1;\\n            }\\n        }\\n        return v.size();\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809806,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1808741,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1807844,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1807475,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1799190,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1793774,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1792234,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1777029,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1773895,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1768444,
                "content": [
                    {
                        "username": "jatinchoubey_19",
                        "content": "Can we not sort the Vector before solving ?"
                    },
                    {
                        "username": "shinedark",
                        "content": "Time Limit Exceeded ??? what does that mean  `var firstMissingPositive = function(nums) {\\n    let low = 1;\\n    while(nums.includes(low)){\\n        low++\\n    }\\n    return low\\n};`\\n\\nit works but I get the Time Limit Exceeded "
                    },
                    {
                        "username": "aqf00221",
                        "content": " `\ndef firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        hash_set = set(nums)\n        \n        for i in range(1, n+1):\n            if i not in hash_set:\n                return i \n        return n+1\n`\n\nidea behind this: \nThe first missing positive cannot be greater than len(nums) + 1."
                    },
                    {
                        "username": "cheesebread",
                        "content": "Why is a hard? Are we assuming we can\\'t modify the input array...?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "im confused why are people asking why it\\'s hard?"
                    },
                    {
                        "username": "im_rish97",
                        "content": "WHY TLE in my code? \\nclass Solution {\\npublic:\\n    int firstMissingPositive(vector<int>& nums) {\\n        int n=nums.size();\\n        int curr_ind;\\n        for(int i=0;i<n;++i)\\n        {\\n            curr_ind=nums[i]-1;\\n            while(nums[i]>=1 && nums[i]<=n && nums[i]!=nums[curr_ind])\\n                swap(nums[i],nums[curr_ind]);\\n\\n        }\\n         for(int i=0;i<n;++i)\\n         {\\n             if(nums[i]!=i+1)\\n                return i+1;\\n         }\\n    return n+1;\\n    }\\n};"
                    },
                    {
                        "username": "zloig",
                        "content": "These \"problem\" is bullsh*t.\\n1. Absolutely no problem-solving skill is exposed. You either know this trick or not. And again, it\\'s just a trick.\\n2. Nobody mentioned that we can change the given array. It was said we can use only O(1) memory, but as soon as we are able to touch the original array it\\'s not O(1) anymore but O(n). Because we are using an array.\\n\\n"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The First Missing Positive problem is a hard level question that asks you to find the smallest missing positive integer in an unsorted integer array. The solution must have a time complexity of O(n) and use constant extra space.\\n\\nOne way to solve this problem is to use the index of the array to store the positive integers in their correct position. For example, if we have a number x, we should put it in the position nums[x-1]. We need to iterate the array and for each number, swap it to its correct position until the array has all positive integers in their correct position. After that, we can iterate the array again to find the first missing positive integer by checking if the number in position i is not equal to i+1.\\n\\nFor example, in the case of [3, 4, -1, 1], after swapping, the array becomes [1, -1, 3, 4], and the first missing positive integer is 2, which is the first missing number in the sequence [1, 2, 3, ...].\\n\\nIn summary, the solution involves two steps:\\n\\nSwapping the numbers in the array to their correct position.\\nFinding the first missing positive integer by checking the sequence."
                    },
                    {
                        "username": "jkig",
                        "content": "bit of spoilers!!\\n\\nTrying to do this question in given bounds, and am pretty sure many of the solutions are wrong.\\nFirst question, does folowing python code:\\n\\nnums = set(nums)\\n\\nnot use O(n) space, because if not, then the answer is ez, but i would think while building the nums we need more than constant extra space. Would love to find out I\\'m wrong on this.\\nif this is allowed, then converting to a set and looping through, with iterator starting at 1 and returning for the first not to be found will def work in expected O(n), and the conversion to a set is also O(n), so that solution is fine."
                    },
                    {
                        "username": "adwi11",
                        "content": "Is this an O(n) solution, will appreciate the feedback !!\\n\\nclass Solution:\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n      sn=1\\n      trav=set()\\n      for i in range(len(nums)):\\n        trav.add(nums[i])\\n        if sn==nums[i]:\\n            sn+=1\\n      while sn in trav:\\n           sn+=1\\n      return sn"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1755671,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1754856,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1752617,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1751311,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1743368,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1742391,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1733008,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1732948,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1729717,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1728888,
                "content": [
                    {
                        "username": "kBrostoff",
                        "content": "I have a solution that is using a single for loop, but getting stuck on `#40/173` test case. It has an input of `[1]` and it expects an output of `2`. i\\'m a bit confused.\\n\\n```python\\nfrom typing import List\\n\\nclass Solution:\\n\\tdef firstMissingPositive(self, nums: List[int]) -> int:\\n\\t\\tn: int = 1\\n\\t\\ttotal: int = 0\\n\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num > 0 and num < len(nums):\\n\\t\\t\\t\\tn += 1\\n\\t\\t\\t\\ttotal += num\\n\\t\\texpected: int = int((n * (n + 1)) / 2)\\n\\t\\treturn expected - total\\n```"
                    },
                    {
                        "username": "alph-mephesto",
                        "content": "The description strictly says that the answer has to be in O(n) time. Well I sorted the array and solved the problem, but not only it didn\\'t fail because of the insufficient complexity but also it was faster than the vast majority of the submitted solutions.\\nI am really looking for a solution that doesn\\'t require to modify the input. If any one here has a suggestion please help me, because I wasn\\'t able to find any solution satisfying this criteria among the submitted solutions."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "1ncu804u",
                        "content": "should this be a hard \\uD83E\\uDD74 ?"
                    },
                    {
                        "username": "wey53l",
                        "content": "what is the time limit exceeded problem with my code ?\\n    def firstMissingPositive(self, nums: List[int]) -> int:\\n        if max(nums) < 0 or min(nums) > 1:\\n            return 1\\n        for i in range(1,max(nums)):\\n            if i not in set(nums):\\n                return i\\n        return max(nums) + 1"
                    },
                    {
                        "username": "karthik87",
                        "content": "Another way to solve the problem\n\ns = startIndex, e = endIndex\npartition the array around(s+e)/2 and keep count on both sides\nrecurse on the half with less than expected count\n\nThis is O(n) not O(nlogn)"
                    },
                    {
                        "username": "nivi77",
                        "content": "Why did Leetcode not throw a TLE in a nlog n solution?"
                    },
                    {
                        "username": "nivi77",
                        "content": "I solved using O(n log n) time still my solution was accepted.\\nShouldn\\'t it deny because of TLE?"
                    },
                    {
                        "username": "RaktimChowdhury",
                        "content": "I solved this problem using O(n) time complexity but LeetCode is actually terrible in implementing the time complexities that are mentioned in the problem description. The number of times I have seen that the descripted time complexity is O(n) but users have submitted their code successfully using O(n log n) is absolutely funny. Its a problem from their side."
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "Going to join the choir to say that the solution expected here (utilizing O(1)) space is a completely impractical solution that you should almost never use in production code, and even if by some rare case you need something like it for something to work under severe resource constraints, you would practically need to put bright flashing lights around the screen every time a future developer goes to use the function to remind them that the function destroys/consumes the input data.\\n\\nSome languages make consuming the input a normal part of operation, forcing you to copy the input if it\\'s something you want to reuse, but if you\\'re going to use the memory to copy the input, then you might as well use an algorithmically simpler solution utilizing O(n) space."
                    },
                    {
                        "username": "generalkernel",
                        "content": "At first I thought the solution utilized some \"trick\" with summing the elements or counting the number of elements that aren\\'t part of the solution.  But instead, try to think of the O(n) space answer, and utilize the space already provided to try and match the data structure of the O(n) answer"
                    }
                ]
            },
            {
                "id": 1725223,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1722682,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1718319,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1710782,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1705887,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1703683,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1698023,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1693402,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1690886,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            },
            {
                "id": 1672177,
                "content": [
                    {
                        "username": "sakshambhalla11",
                        "content": "Why is this rated hard? It\\'s an easy Set question"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "Do anybody have ideas how can I speed up my code? It executes correctly 171/173 test cases, then dies because of the time limit.\n\n `\n\n      nums = sorted(nums) \n      number = 1  # minimum possible positive number\n      if not len(nums):\n          return 1\n\n      while number <= nums[-1]:\n            if number not in nums and number > 0:\n                   break\n            number += 1\n      return number\n\n`"
                    },
                    {
                        "username": "smartmath",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n\\nhow to resolve this ?\\n "
                    },
                    {
                        "username": "one_djenty_boi",
                        "content": "Great edge cases!!"
                    },
                    {
                        "username": "2001zhaozhao",
                        "content": "The closest i have gotten so far is the observation that the missing element must be no more than 1 greater than the array size. So I can remove all elements out of range, and the array size also decreases, and so on, until i can't reduce the size anymore then i just write out the remaining array size plus one.\n\nBut this requires deduplicating the array in O(n) time and O(1) space, since the problem does not state that the arrays can't contain duplicate elements. I could do it with a hash table in O(n) but I don't know how to without extra space.\n\nI also don't think this actually shaves off an exponential amount of array size every time which would be required to make it a O(n) time solution. Bad solutions exist (like if 1 is the only missing element, resulting in only 1 element being removed at a time) that make this a O(n^2) worst case. If there's a better way, it still eludes me right now.\n\nEdit: Nvm! I figured this out. \n\nThe trick is to store a \"seen\" array INSIDE the original array by flipping a number to negative to indicate that it has been seen. This results in O(1) space complexity.\nThe \"seen\" array fits in the original array this way because of the observation that the missing element value is bounded by the size of the array."
                    },
                    {
                        "username": "Abhishek0001",
                        "content": "sort the array first \\nthen make a integer variable a=1\\nand use for loop (0,array.length)\\nafter the for loop use if condition \\nif(arr[i]==a) then a++\\nand return a"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[1,2,3,4,5,6,7,8,9,20]\\nIn this case n=10(size of an array) \\nwhy the answer is 21 not 10?\\ni guess 10 is positive number\\n \\n"
                    },
                    {
                        "username": "shawshalini",
                        "content": "[@patelhet050603](/patelhet050603) yeah got the answer\\n"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "It\\'s 10 only"
                    },
                    {
                        "username": "woppi123",
                        "content": "cannot use only constant space without modifying the array, can you?"
                    },
                    {
                        "username": "I_am_Het_Patel",
                        "content": "What is another possible way instead of using a while loop?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-first-missing-positive-problem-solution.html)"
                    }
                ]
            }
        ]
    }
]