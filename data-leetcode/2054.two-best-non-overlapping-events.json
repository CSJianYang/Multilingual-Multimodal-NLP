[
    {
        "title": "Two Best Non-Overlapping Events",
        "question_content": "You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.\nReturn this maximum sum.\nNote that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1.\n&nbsp;\nExample 1:\n\nInput: events = [[1,3,2],[4,5,2],[2,4,3]]\nOutput: 4\nExplanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\nExample 2:\n\nInput: events = [[1,3,2],[4,5,2],[1,5,5]]\nOutput: 5\nExplanation: Choose event 2 for a sum of 5.\n\nExample 3:\n\nInput: events = [[1,5,3],[1,5,1],[6,6,5]]\nOutput: 8\nExplanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.\n&nbsp;\nConstraints:\n\n\t2 <= events.length <= 105\n\tevents[i].length == 3\n\t1 <= startTimei <= endTimei <= 109\n\t1 <= valuei <= 106",
        "solutions": [
            {
                "id": 1548965,
                "title": "c-with-explanation-concise-dp",
                "content": "**Idea:-**\\n1. Sort the events according to ```startTime``` and iterate from last.\\n2. ```maxi``` will store maximum value from events whose ```startTime>= current event\\'s startTime```.\\n3. So when we are iterating over events we check the map to find an event whose ```startTime``` is greater than current event\\'s endTime.\\n4. Update the ```maxi and ans``` accordingly.\\n\\n**Similar problem:-** [Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)\\n**Time Complexity :-** O(nlog(n)).\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        int size=e.size(),ans=0,maxi=0;\\n        sort(e.begin(),e.end());\\n        map<int,int>mp;\\n        while(size--){\\n            auto it=mp.upper_bound(e[size][1]);\\n            maxi=max(maxi,e[size][2]);\\n              mp[e[size][0]]=maxi;\\n            if(it==mp.end())\\n                ans=max(ans,maxi);\\n            else\\n                ans=max(ans,e[size][2]+it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```startTime```\n```maxi```\n```startTime>= current event\\'s startTime```\n```startTime```\n```maxi and ans```\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        int size=e.size(),ans=0,maxi=0;\\n        sort(e.begin(),e.end());\\n        map<int,int>mp;\\n        while(size--){\\n            auto it=mp.upper_bound(e[size][1]);\\n            maxi=max(maxi,e[size][2]);\\n              mp[e[size][0]]=maxi;\\n            if(it==mp.end())\\n                ans=max(ans,maxi);\\n            else\\n                ans=max(ans,e[size][2]+it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549340,
                "title": "c-recursion-memoization-easy-understanding",
                "content": "```\\n// Basically my intuition is sort of similar like Knapsack picking.\\n// We have two options : Pick Event or Don\\'t Pick an event.\\n// If we \"Pick event\", we\\'ll just add to our sum, then we\\'ll find out an event whose starting time > ending time of the event that we picked and \\n// we\\'ll keep progressing like this until we hit 2. (as we can only pick at most two events)\\n// If we \"Don\\'t Pick the event\" we\\'ll move on\\n// And basically our maxvalue would be max outcome of (\"Pick Event\", \"Don\\'t Pick Event\")\\n\\nclass Solution {\\npublic:\\n    \\n    //Main Function\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n=events.size();\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        \\n        //Sorting because since we need to find an event that has starting time > ending time \\n        //of previous event selected, so applying binary search would help there.\\n        sort(events.begin(),events.end());\\n        \\n        return solve(events,0,0,dp);\\n    }\\n    \\n    //Helper function\\n    int solve(vector<vector<int>>&nums,int idx,int k,vector<vector<int>>&dp)\\n    {\\n        // Base case\\n        if(k==2)\\n        {\\n            return 0;\\n        }\\n        if(idx>=nums.size())\\n        {\\n            return 0;\\n        }\\n        \\n        // Memoization check\\n        if(dp[idx][k]!=-1)\\n        {\\n            return dp[idx][k];\\n        }\\n        \\n        //Basically ending times of the events\\n        vector<int>ans={nums[idx][1],INT_MAX,INT_MAX};\\n        \\n        //Searching the event whose starting time > ending time of previous event selected\\n        int nextindex=upper_bound(begin(nums),end(nums),ans)-begin(nums);\\n        \\n        //Pick event\\n        int include=nums[idx][2]+solve(nums,nextindex,k+1,dp);\\n        \\n        //Don\\'t Pick event\\n        int exclude=solve(nums,idx+1,k,dp);\\n        \\n        return dp[idx][k]=max(include,exclude); //Max of(Pick, Not Pick)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n// Basically my intuition is sort of similar like Knapsack picking.\\n// We have two options : Pick Event or Don\\'t Pick an event.\\n// If we \"Pick event\", we\\'ll just add to our sum, then we\\'ll find out an event whose starting time > ending time of the event that we picked and \\n// we\\'ll keep progressing like this until we hit 2. (as we can only pick at most two events)\\n// If we \"Don\\'t Pick the event\" we\\'ll move on\\n// And basically our maxvalue would be max outcome of (\"Pick Event\", \"Don\\'t Pick Event\")\\n\\nclass Solution {\\npublic:\\n    \\n    //Main Function\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n=events.size();\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        \\n        //Sorting because since we need to find an event that has starting time > ending time \\n        //of previous event selected, so applying binary search would help there.\\n        sort(events.begin(),events.end());\\n        \\n        return solve(events,0,0,dp);\\n    }\\n    \\n    //Helper function\\n    int solve(vector<vector<int>>&nums,int idx,int k,vector<vector<int>>&dp)\\n    {\\n        // Base case\\n        if(k==2)\\n        {\\n            return 0;\\n        }\\n        if(idx>=nums.size())\\n        {\\n            return 0;\\n        }\\n        \\n        // Memoization check\\n        if(dp[idx][k]!=-1)\\n        {\\n            return dp[idx][k];\\n        }\\n        \\n        //Basically ending times of the events\\n        vector<int>ans={nums[idx][1],INT_MAX,INT_MAX};\\n        \\n        //Searching the event whose starting time > ending time of previous event selected\\n        int nextindex=upper_bound(begin(nums),end(nums),ans)-begin(nums);\\n        \\n        //Pick event\\n        int include=nums[idx][2]+solve(nums,nextindex,k+1,dp);\\n        \\n        //Don\\'t Pick event\\n        int exclude=solve(nums,idx+1,k,dp);\\n        \\n        return dp[idx][k]=max(include,exclude); //Max of(Pick, Not Pick)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552570,
                "title": "very-simple-sort-greedy-no-dp-no-binary-search-no-heap-pq-bst",
                "content": "Split events into separate start & end, keep track of best event that has ended so far.\\n\\n```\\n# super clean, no need for DP or BST.\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        proc = []\\n        ans = m = 0  # m represents max value of finished event so far\\n        for s,e,v in events:\\n            proc.append( (s, True, v) )     # time, is_start, val\\n            proc.append( (e+1, False, v) )  # use e+1 (inclusive)\\n        proc.sort()  # sort by time\\n        \\n        for time, is_start, val in proc:\\n            if is_start:\\n                ans = max(ans, m+val)\\n            else:\\n                m = max(m, val)\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# super clean, no need for DP or BST.\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        proc = []\\n        ans = m = 0  # m represents max value of finished event so far\\n        for s,e,v in events:\\n            proc.append( (s, True, v) )     # time, is_start, val\\n            proc.append( (e+1, False, v) )  # use e+1 (inclusive)\\n        proc.sort()  # sort by time\\n        \\n        for time, is_start, val in proc:\\n            if is_start:\\n                ans = max(ans, m+val)\\n            else:\\n                m = max(m, val)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549288,
                "title": "sort-min-heap",
                "content": "We sort events by the start date, and then go left to right. We also track end times and values in a min heap.\\n\\nWhen we process an event, we remove past events from the min heap, and track the `max_val` so far.\\n\\n**C++**\\nPriority queue is a max heap by default; we can just store end times as negative instead of providing a custom comparator.\\n\\n```cpp\\nint maxTwoEvents(vector<vector<int>>& events) {\\n    int res = 0, max_val = 0;\\n    priority_queue<pair<int, int>> pq;\\n    sort(begin(events), end(events));\\n    for (auto &e : events) {\\n        for(; !pq.empty() && -pq.top().first < e[0]; pq.pop())\\n            max_val = max(max_val, pq.top().second);\\n        res = max(res, max_val + e[2]);\\n        pq.push({-e[1], e[2]});\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maxTwoEvents(vector<vector<int>>& events) {\\n    int res = 0, max_val = 0;\\n    priority_queue<pair<int, int>> pq;\\n    sort(begin(events), end(events));\\n    for (auto &e : events) {\\n        for(; !pq.empty() && -pq.top().first < e[0]; pq.pop())\\n            max_val = max(max_val, pq.top().second);\\n        res = max(res, max_val + e[2]);\\n        pq.push({-e[1], e[2]});\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548966,
                "title": "simple-java-solution-with-explanation-sort-heap",
                "content": "This problem can be solved with the help of `heap`.\\n\\n- First sort all events by start time. If start time of two events are equal, sort them by end time.\\n- Then take a priority queue that takes an array containing `[endtime, value]`. Priority queue will sort elements on the basis of `end time`.\\n- Iterate through events, for each event `e`, calculate maximum value from all events that ends before `e[0]` (i.e. start time). Let\\'s store this value in `maxVal` variable.\\n- Now answer will be `ans = max(ans, e[2] + maxVal)`.\\n\\n```java\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\\n        \\n        int maxVal = 0, ans = 0;\\n        for(int[] e : events){            \\n            int start = e[0];\\n            while(!queue.isEmpty()){\\n                if(queue.peek()[0] >= start)\\n                    break;\\n                int[] eve = queue.remove();\\n                maxVal = Math.max(maxVal, eve[1]);\\n            }\\n            ans = Math.max(ans, e[2] + maxVal);\\n            queue.add(new int[]{e[1], e[2]});\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**Note: If you have any doubt, please ask question, I\\'ll be happpy to answer.\\nIf you like solution, please upvote**",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\\n        \\n        int maxVal = 0, ans = 0;\\n        for(int[] e : events){            \\n            int start = e[0];\\n            while(!queue.isEmpty()){\\n                if(queue.peek()[0] >= start)\\n                    break;\\n                int[] eve = queue.remove();\\n                maxVal = Math.max(maxVal, eve[1]);\\n            }\\n            ans = Math.max(ans, e[2] + maxVal);\\n            queue.add(new int[]{e[1], e[2]});\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549128,
                "title": "python-actually-simple-with-heap",
                "content": "So, notice that if we sort events, then we always have the left bound increasing. Therefore, we can keep a heap of (right_bound, value) tuples from events that we have seen so far. Whenever the current left bound becomes larger than the right_bound on the stack, that means we can start poppping from the heap to look for the next possible interval pairing. We simply record the best value seen so far, and since every next event has a larger left, we can always pair with the values that have popped off the heap.\\n\\nPlease upvote if helpful!\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        res = 0\\n        best_value_to_the_left_of_all_intervals = 0\\n        intervals_seen_so_far = []\\n        for left, r, v in events:\\n            heappush(intervals_seen_so_far, (r, v))\\n            while intervals_seen_so_far and intervals_seen_so_far[0][0] < left:\\n                R, V = heappop(intervals_seen_so_far)\\n                best_value_to_the_left_of_all_intervals = max(best_value_to_the_left_of_all_intervals, V)\\n            res = max(res, best_value_to_the_left_of_all_intervals + v)\\n        return res",
                "solutionTags": [],
                "code": "So, notice that if we sort events, then we always have the left bound increasing. Therefore, we can keep a heap of (right_bound, value) tuples from events that we have seen so far. Whenever the current left bound becomes larger than the right_bound on the stack, that means we can start poppping from the heap to look for the next possible interval pairing. We simply record the best value seen so far, and since every next event has a larger left, we can always pair with the values that have popped off the heap.\\n\\nPlease upvote if helpful!\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        res = 0\\n        best_value_to_the_left_of_all_intervals = 0\\n        intervals_seen_so_far = []\\n        for left, r, v in events:\\n            heappush(intervals_seen_so_far, (r, v))\\n            while intervals_seen_so_far and intervals_seen_so_far[0][0] < left:\\n                R, V = heappop(intervals_seen_so_far)\\n                best_value_to_the_left_of_all_intervals = max(best_value_to_the_left_of_all_intervals, V)\\n            res = max(res, best_value_to_the_left_of_all_intervals + v)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1603930,
                "title": "c-sorting-priority-queue-dp-binary-search",
                "content": "### Solution 1: Sorting + Priority Queue\\n\\n**Steps:**\\n1. First sort the events on basis of their starting time .\\n2. We will use priority queue to store events that have started before the current event.\\n3. Elements in priority queue are of type vector {minus of endTime , startTime , value} (ordered by endTime i.e element that finishes first is at top).\\n4. Instead of using min heap, I have stored minus of endTime.\\n5. We will use a variable maxVal to store maximum value so far.\\n\\n```\\nint maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int maxVal = 0;\\n        \\n        priority_queue<vector<int>> pq;\\n        int ans = 0;\\n        \\n        for(auto e : events){\\n            while(!pq.empty() and ((-pq.top()[0]) < e[0])){\\n                maxVal = max(maxVal , pq.top()[2]);\\n                pq.pop();\\n            }\\n            ans = max(ans , e[2]+maxVal);\\n            pq.push({(-e[1]) , e[0] , e[2]});\\n        }\\n        return ans;\\n    }\\n```\\n\\nTime Complexity : O(nlogn), as each element will be pushed and poped only once in priority queue.\\nSpace Complexity: O(n)\\n\\n### Solution 2: Recursion + Binary Search\\nWe have 2 choices : Either attend a particular event or don\\'t attend.\\n```\\nclass Solution {\\n    int func(int ind , int eventsAttended , vector<vector<int>>& events){\\n        //base case\\n        if(ind == events.size() || eventsAttended == 2){\\n            return 0;\\n        }\\n        \\n        //Choice 1 : attend this event\\n        vector<int> tempVec = {events[ind][1] , INT_MAX , INT_MAX};\\n        int nextInd = upper_bound(events.begin() , events.end() , tempVec) - events.begin(); //find index of next event whose start time is greater than ending time of current event\\n        int val1 = events[ind][2] + func(nextInd , eventsAttended+1 , events);\\n        \\n        //Choice 2: don\\'t attend\\n        int val2 = func(ind+1 , eventsAttended , events);\\n        \\n        return max(val1 , val2);\\n    }\\n    \\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin() , events.end());\\n        \\n        return func(0,0,events);\\n    }\\n};\\n```\\n\\nThis solution will lead to TLE.\\n\\n### Solution 3: Recursion + Memoization\\n\\n```\\nclass Solution {\\n    int func(int ind , int eventsAttended , vector<vector<int>>& events , vector<vector<int>>& dp){\\n        //base case\\n        if(ind == events.size() || eventsAttended == 2){\\n            return 0;\\n        }\\n        \\n        if(dp[ind][eventsAttended] != -1)\\n            return dp[ind][eventsAttended];\\n        \\n        //Choice 1 : attend this event\\n        vector<int> tempVec = {events[ind][1] , INT_MAX , INT_MAX};\\n        int nextInd = upper_bound(events.begin() , events.end() , tempVec) - events.begin();\\n        int val1 = events[ind][2] + func(nextInd , eventsAttended+1 , events,dp);\\n        \\n        //Choice 2: don\\'t attend\\n        int val2 = func(ind+1 , eventsAttended , events,dp);\\n        \\n        return dp[ind][eventsAttended] = max(val1 , val2);\\n    }\\n    \\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin() , events.end());\\n        int n = events.size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(2 , -1));\\n        return func(0,0,events,dp);\\n    }\\n};\\n```\\n\\n***Do Upvote if you find the solution helpful!***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nint maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int maxVal = 0;\\n        \\n        priority_queue<vector<int>> pq;\\n        int ans = 0;\\n        \\n        for(auto e : events){\\n            while(!pq.empty() and ((-pq.top()[0]) < e[0])){\\n                maxVal = max(maxVal , pq.top()[2]);\\n                pq.pop();\\n            }\\n            ans = max(ans , e[2]+maxVal);\\n            pq.push({(-e[1]) , e[0] , e[2]});\\n        }\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\n    int func(int ind , int eventsAttended , vector<vector<int>>& events){\\n        //base case\\n        if(ind == events.size() || eventsAttended == 2){\\n            return 0;\\n        }\\n        \\n        //Choice 1 : attend this event\\n        vector<int> tempVec = {events[ind][1] , INT_MAX , INT_MAX};\\n        int nextInd = upper_bound(events.begin() , events.end() , tempVec) - events.begin(); //find index of next event whose start time is greater than ending time of current event\\n        int val1 = events[ind][2] + func(nextInd , eventsAttended+1 , events);\\n        \\n        //Choice 2: don\\'t attend\\n        int val2 = func(ind+1 , eventsAttended , events);\\n        \\n        return max(val1 , val2);\\n    }\\n    \\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin() , events.end());\\n        \\n        return func(0,0,events);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int func(int ind , int eventsAttended , vector<vector<int>>& events , vector<vector<int>>& dp){\\n        //base case\\n        if(ind == events.size() || eventsAttended == 2){\\n            return 0;\\n        }\\n        \\n        if(dp[ind][eventsAttended] != -1)\\n            return dp[ind][eventsAttended];\\n        \\n        //Choice 1 : attend this event\\n        vector<int> tempVec = {events[ind][1] , INT_MAX , INT_MAX};\\n        int nextInd = upper_bound(events.begin() , events.end() , tempVec) - events.begin();\\n        int val1 = events[ind][2] + func(nextInd , eventsAttended+1 , events,dp);\\n        \\n        //Choice 2: don\\'t attend\\n        int val2 = func(ind+1 , eventsAttended , events,dp);\\n        \\n        return dp[ind][eventsAttended] = max(val1 , val2);\\n    }\\n    \\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin() , events.end());\\n        int n = events.size();\\n        \\n        vector<vector<int>> dp(n , vector<int>(2 , -1));\\n        return func(0,0,events,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548967,
                "title": "java-sorting-10-liner",
                "content": "```\\npublic int maxTwoEvents(int[][] events) {\\n\\tint result = 0, maxOfCompletedEvents = 0;\\n\\tArrays.sort(events, (x,y)->x[0]-y[0]);   // Sort by Start time\\n\\tPriorityQueue<int[]> inProgressQueue = new PriorityQueue<>((x,y)->x[1]-y[1]); // sorted by end time\\n\\tfor(int[] currentEvent : events) {\\n\\t\\twhile(!inProgressQueue.isEmpty() && inProgressQueue.peek()[1] < currentEvent[0])\\n\\t\\t\\tmaxOfCompletedEvents = Math.max(maxOfCompletedEvents, inProgressQueue.poll()[2]);\\n\\t\\tresult = Math.max(result, maxOfCompletedEvents + currentEvent[2]);\\n\\t\\tinProgressQueue.offer(currentEvent);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxTwoEvents(int[][] events) {\\n\\tint result = 0, maxOfCompletedEvents = 0;\\n\\tArrays.sort(events, (x,y)->x[0]-y[0]);   // Sort by Start time\\n\\tPriorityQueue<int[]> inProgressQueue = new PriorityQueue<>((x,y)->x[1]-y[1]); // sorted by end time\\n\\tfor(int[] currentEvent : events) {\\n\\t\\twhile(!inProgressQueue.isEmpty() && inProgressQueue.peek()[1] < currentEvent[0])\\n\\t\\t\\tmaxOfCompletedEvents = Math.max(maxOfCompletedEvents, inProgressQueue.poll()[2]);\\n\\t\\tresult = Math.max(result, maxOfCompletedEvents + currentEvent[2]);\\n\\t\\tinProgressQueue.offer(currentEvent);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1583776,
                "title": "multiple-approaches-heap-based-dp-binary-search-c-clean-code",
                "content": "**Approach 1: Sorting + Priority Queue**\\n\\nThis approach is best suited when we have just **\"at most 2\"** events to attend.\\n\\n# Code : \\n\\n```\\nint maxTwoEvents(vector<vector<int>>& events) {\\n        \\n\\tint n = events.size();\\n\\n\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;  //  <endTime, value>\\n\\n\\tsort(events.begin(), events.end());\\n\\n\\tint maxVal = 0, maxSum = 0;\\n\\n\\tfor(auto& event : events) {\\n\\t\\twhile(pq.size() && pq.top().first < event[0]) {\\n\\t\\t\\tmaxVal = max(maxVal, pq.top().second);\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\n\\t\\tmaxSum = max(maxSum, maxVal + event[2]);\\n\\n\\t\\tpq.push({event[1], event[2]});\\n\\t}\\n\\n\\treturn maxSum;\\n}\\n```\\n\\n**Complexity:**\\n\\n* **Time** : `O(N log N + 2N)` ,\\n\\t* `N log N` : Sorting and Priority Queue\\n\\t* `2N` : Since we are poping events from heap to process, so each events is processed twice.\\n\\t\\n* **Space** : `O(N)`, storing events into heap\\n\\n----------------------------------------------------------------------------------------------------------------------------\\n\\n**Follow Up Question** : How will you solve this problem when you can attend **at most K** events? \\n\\nWe cannot use previous approach if we have K events to attend. So how we will solve this? \\nLets look at another approach !!\\n\\n----------------------------------------------------------------------------------------------------------------------------\\n\\n**Approach 2: DP(Memoization) + Binary Search**\\n\\n\\n# Code: \\n\\n```\\nclass Solution {\\npublic:\\n        \\n    int getNextIndex(vector<vector<int>>& events, int idx, const int& n) {\\n        \\n        int endTime = events[idx][1];\\n        \\n        int lo = idx+1, hi = n-1;\\n        \\n        int ans = n;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + hi) >> 1;\\n            \\n            if(events[mid][0] > endTime) {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int attendEvents(vector<vector<int>>& events, vector<vector<int>>& dp, int idx, int k, const int& n) {\\n        if(k == 0 || idx == n) return 0;\\n        \\n        if(dp[idx][k] != -1) return dp[idx][k];\\n        \\n        // Include : attend current event\\n        int nextIdx = getNextIndex(events, idx, n); \\n\\n        int incl = events[idx][2] + attendEvents(events, dp, nextIdx, k-1, n);\\n        \\n        // Exclude : skip current event\\n        int excl = attendEvents(events, dp, idx+1, k, n);\\n        \\n        return dp[idx][k] = max(incl, excl);\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        int n = events.size(), k = 2;\\n        sort(events.begin(), events.end());\\n        \\n        \\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n    \\n        return attendEvents(events, dp, 0, k, n);\\n    }\\n};\\n```\\n**Complexity:**\\n\\n* **Time** : `O(N log N)` , sorting , attending events and searching for next nearest event\\n* **Space** : `O(N * k)`, for memoization \\n\\n\\n----------------------------------------------------------------------------------------------------------------------------\\n\\n**Similar Problems :**\\n\\n* [Maximum Earnings from Taxi](https://leetcode.com/problems/maximum-earnings-from-taxi/)\\n* [Maximum Profit Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)\\n\\n***If you find this post helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nint maxTwoEvents(vector<vector<int>>& events) {\\n        \\n\\tint n = events.size();\\n\\n\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;  //  <endTime, value>\\n\\n\\tsort(events.begin(), events.end());\\n\\n\\tint maxVal = 0, maxSum = 0;\\n\\n\\tfor(auto& event : events) {\\n\\t\\twhile(pq.size() && pq.top().first < event[0]) {\\n\\t\\t\\tmaxVal = max(maxVal, pq.top().second);\\n\\t\\t\\tpq.pop();\\n\\t\\t}\\n\\n\\t\\tmaxSum = max(maxSum, maxVal + event[2]);\\n\\n\\t\\tpq.push({event[1], event[2]});\\n\\t}\\n\\n\\treturn maxSum;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n        \\n    int getNextIndex(vector<vector<int>>& events, int idx, const int& n) {\\n        \\n        int endTime = events[idx][1];\\n        \\n        int lo = idx+1, hi = n-1;\\n        \\n        int ans = n;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + hi) >> 1;\\n            \\n            if(events[mid][0] > endTime) {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int attendEvents(vector<vector<int>>& events, vector<vector<int>>& dp, int idx, int k, const int& n) {\\n        if(k == 0 || idx == n) return 0;\\n        \\n        if(dp[idx][k] != -1) return dp[idx][k];\\n        \\n        // Include : attend current event\\n        int nextIdx = getNextIndex(events, idx, n); \\n\\n        int incl = events[idx][2] + attendEvents(events, dp, nextIdx, k-1, n);\\n        \\n        // Exclude : skip current event\\n        int excl = attendEvents(events, dp, idx+1, k, n);\\n        \\n        return dp[idx][k] = max(incl, excl);\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        int n = events.size(), k = 2;\\n        sort(events.begin(), events.end());\\n        \\n        \\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n    \\n        return attendEvents(events, dp, 0, k, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549074,
                "title": "python3-binary-search",
                "content": "\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        time = []\\n        vals = []\\n        ans = prefix = 0\\n        for st, et, val in sorted(events, key=lambda x: x[1]): \\n            prefix = max(prefix, val)\\n            k = bisect_left(time, st)-1\\n            if k >= 0: val += vals[k]\\n            ans = max(ans, val)\\n            time.append(et)\\n            vals.append(prefix)\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        ans = most = 0 \\n        pq = []\\n        for st, et, val in sorted(events): \\n            heappush(pq, (et, val))\\n            while pq and pq[0][0] < st: \\n                _, vv = heappop(pq)\\n                most = max(most, vv)\\n            ans = max(ans, most + val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        time = []\\n        vals = []\\n        ans = prefix = 0\\n        for st, et, val in sorted(events, key=lambda x: x[1]): \\n            prefix = max(prefix, val)\\n            k = bisect_left(time, st)-1\\n            if k >= 0: val += vals[k]\\n            ans = max(ans, val)\\n            time.append(et)\\n            vals.append(prefix)\\n        return ans \\n```\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        ans = most = 0 \\n        pq = []\\n        for st, et, val in sorted(events): \\n            heappush(pq, (et, val))\\n            while pq and pq[0][0] < st: \\n                _, vv = heappop(pq)\\n                most = max(most, vv)\\n            ans = max(ans, most + val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549284,
                "title": "heap-very-easy-well-explained",
                "content": "## IDEA:\\n**This question is same as https://leetcode.com/problems/maximum-profit-in-job-scheduling/ .**\\n\\n* In this we have to consider atmost two events. So we will only put the cureent profit in heap.\\n\\n* Maintain one variable res1 for storing the maximum value among all the events ending before the current event gets start.\\n* Another variable res2 store the maximum profit according the given condition.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        \\n        events.sort()\\n        heap = []\\n        res2,res1 = 0,0\\n        for s,e,p in events:\\n            while heap and heap[0][0]<s:\\n                res1 = max(res1,heapq.heappop(heap)[1])\\n            \\n            res2 = max(res2,res1+p)\\n            heapq.heappush(heap,(e,p))\\n        \\n        return res2\\n\\n### Thanks and Upvote If you like the Idea !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "## IDEA:\\n**This question is same as https://leetcode.com/problems/maximum-profit-in-job-scheduling/ .**\\n\\n* In this we have to consider atmost two events. So we will only put the cureent profit in heap.\\n\\n* Maintain one variable res1 for storing the maximum value among all the events ending before the current event gets start.\\n* Another variable res2 store the maximum profit according the given condition.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        \\n        events.sort()\\n        heap = []\\n        res2,res1 = 0,0\\n        for s,e,p in events:\\n            while heap and heap[0][0]<s:\\n                res1 = max(res1,heapq.heappop(heap)[1])\\n            \\n            res2 = max(res2,res1+p)\\n            heapq.heappush(heap,(e,p))\\n        \\n        return res2\\n\\n### Thanks and Upvote If you like the Idea !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 2028285,
                "title": "java-sorting-priorityqueue-o-nlogn",
                "content": "This problem can be solved with the help of Sorting and Heap - \\n\\nFirst sort all events by start time. If start time of two events are equal, sort them by end time.\\nThen take a priority queue that takes an array containing [endtime, value]. Priority queue will sort elements on the basis of end time.\\nIterate through events, for each event, calculate maximum value from all events that ends before current events start time and store this value in max variable.\\n\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) \\n    {\\n        Arrays.sort(events , (a,b)-> a[0]!=b[0]?a[0]-b[0]:a[1]-b[1]);\\n        PriorityQueue<int []> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        int max = 0 , ans = 0;\\n        pq.add(new int[]{events[0][1] , events[0][2]});\\n        \\n        for(int i=1 ; i<events.length ; i++)\\n        {\\n            while(!pq.isEmpty() && pq.peek()[0]<events[i][0])\\n            {\\n                int a[] = pq.poll();\\n                max = Math.max(max , a[1]);\\n            }\\n            ans = Math.max(ans , max + events[i][2]);\\n            pq.add(new int[]{events[i][1] , events[i][2]});\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            ans = Math.max(ans , pq.poll()[1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Do Upvote if u like the solution!**",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) \\n    {\\n        Arrays.sort(events , (a,b)-> a[0]!=b[0]?a[0]-b[0]:a[1]-b[1]);\\n        PriorityQueue<int []> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        int max = 0 , ans = 0;\\n        pq.add(new int[]{events[0][1] , events[0][2]});\\n        \\n        for(int i=1 ; i<events.length ; i++)\\n        {\\n            while(!pq.isEmpty() && pq.peek()[0]<events[i][0])\\n            {\\n                int a[] = pq.poll();\\n                max = Math.max(max , a[1]);\\n            }\\n            ans = Math.max(ans , max + events[i][2]);\\n            pq.add(new int[]{events[i][1] , events[i][2]});\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            ans = Math.max(ans , pq.poll()[1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549021,
                "title": "c-o-nlogn-binary-search-dp-sorting",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n\\n1.Sorting array on basis of smallest end time.\\n2.Apply binary search to get 1st non-conflicting interval event w.r.t current event\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(vector<int> &a, vector<int> &b){\\n        return a[1]<b[1];\\n    }\\n    \\n    int search(vector<vector<int>>& a, int idx){\\n        int s=0, e=idx-1;\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            if(a[m][1]<a[idx][0]){\\n                if(a[m+1][1]<a[idx][0]){\\n                    s=m+1;\\n                }else{\\n                    return m;\\n                }\\n            }else{\\n                e=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& a) {\\n        int n=a.size();\\n        \\n        sort(a.begin(),a.end(),compare);\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,a[i][2]); // considering only single event \\n        }\\n        \\n        int dp[n]; // maximum profit that can be earned till ith index considering 1 event\\n        dp[0]=a[0][2];\\n        for(int i=1;i<n;i++){\\n            dp[i]=a[i][2];\\n            int idx=search(a,i);\\n            \\n            if(idx!=-1){\\n                ans=max(ans,dp[i]+dp[idx]); // max profit for at most 2 events\\n                dp[i]=max(dp[i],dp[idx]);\\n            }\\n            dp[i]=max(dp[i],dp[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(vector<int> &a, vector<int> &b){\\n        return a[1]<b[1];\\n    }\\n    \\n    int search(vector<vector<int>>& a, int idx){\\n        int s=0, e=idx-1;\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            if(a[m][1]<a[idx][0]){\\n                if(a[m+1][1]<a[idx][0]){\\n                    s=m+1;\\n                }else{\\n                    return m;\\n                }\\n            }else{\\n                e=m-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& a) {\\n        int n=a.size();\\n        \\n        sort(a.begin(),a.end(),compare);\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,a[i][2]); // considering only single event \\n        }\\n        \\n        int dp[n]; // maximum profit that can be earned till ith index considering 1 event\\n        dp[0]=a[0][2];\\n        for(int i=1;i<n;i++){\\n            dp[i]=a[i][2];\\n            int idx=search(a,i);\\n            \\n            if(idx!=-1){\\n                ans=max(ans,dp[i]+dp[idx]); // max profit for at most 2 events\\n                dp[i]=max(dp[i],dp[idx]);\\n            }\\n            dp[i]=max(dp[i],dp[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548999,
                "title": "simple-java-solution-with-comments-left-max-right-max",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        // for any timestamp - find max of values to left and max of values to right\\n\\n        Arrays.sort(events, (a,b)->a[1]-b[1]);// Sort by end time - to know what events happened previously\\n        TreeMap<Integer, Integer> maxSeenMapOnLeft = new TreeMap<>();\\n        int result = 0;\\n        int maxSeenValue = 0;\\n        for(int[] event: events){\\n            int eventVal = event[2];\\n            if(eventVal>=maxSeenValue){\\n                maxSeenValue= eventVal;\\n                maxSeenMapOnLeft.put(event[1],maxSeenValue); // save max value event seen so far at end timestamp\\n            }\\n        }\\n        \\n        Arrays.sort(events, (a,b)->b[0]-a[0]);// Sort by start time but in descending order - as we parse events and store max value of future events to current event start timestamp\\n        int maxSeenRight = 0;\\n        for(int[] event: events){\\n            int eventVal = event[2];\\n            if(eventVal>=maxSeenRight){\\n                maxSeenRight= eventVal;\\n                Integer maxOnLeftKey = (maxSeenMapOnLeft.floorKey(event[0]-1));//skip one timestamp unit as start and end can\\'t be same\\n                if(maxOnLeftKey!=null){\\n                    result = Math.max(result, maxSeenMapOnLeft.get(maxOnLeftKey) + maxSeenRight);\\n                }\\n            }\\n        }\\n        return Math.max(maxSeenValue,result);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        // for any timestamp - find max of values to left and max of values to right\\n\\n        Arrays.sort(events, (a,b)->a[1]-b[1]);// Sort by end time - to know what events happened previously\\n        TreeMap<Integer, Integer> maxSeenMapOnLeft = new TreeMap<>();\\n        int result = 0;\\n        int maxSeenValue = 0;\\n        for(int[] event: events){\\n            int eventVal = event[2];\\n            if(eventVal>=maxSeenValue){\\n                maxSeenValue= eventVal;\\n                maxSeenMapOnLeft.put(event[1],maxSeenValue); // save max value event seen so far at end timestamp\\n            }\\n        }\\n        \\n        Arrays.sort(events, (a,b)->b[0]-a[0]);// Sort by start time but in descending order - as we parse events and store max value of future events to current event start timestamp\\n        int maxSeenRight = 0;\\n        for(int[] event: events){\\n            int eventVal = event[2];\\n            if(eventVal>=maxSeenRight){\\n                maxSeenRight= eventVal;\\n                Integer maxOnLeftKey = (maxSeenMapOnLeft.floorKey(event[0]-1));//skip one timestamp unit as start and end can\\'t be same\\n                if(maxOnLeftKey!=null){\\n                    result = Math.max(result, maxSeenMapOnLeft.get(maxOnLeftKey) + maxSeenRight);\\n                }\\n            }\\n        }\\n        return Math.max(maxSeenValue,result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563289,
                "title": "c-97-faster-99-26-memory-binary-search-explained",
                "content": "**Steps are explained in comments** (If any doubt or any modification please comment)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        ios::sync_with_stdio(false);cin.tie(NULL);\\n        \\n        //sort the events according to their start time\\n        sort(events.begin(),events.end());\\n        \\n        int n=events.size();\\n        //store the maxvalue till that element from right.\\n        vector<int>R(n,events[n-1][2]);\\n        for(int i=n-2;i>=0;i--){\\n            R[i]=max(R[i+1],events[i][2]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int l=i+1, r=n-1;\\n            int idx = -1;\\n            //find first index whose start-time is greater than current event\\'s end-time\\n            while(l <= r){\\n                int m=(l+r)/2;\\n                if(events[m][0]>events[i][1]){\\n                    idx=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            if(idx!=-1){\\n                ans=max(ans,R[idx]+events[i][2]);\\n            }\\n           \\n            \\n        }\\n        //check if there is any single event whose value is greater than the sum of two event\\'s value.\\n        return max(ans,R[0]);\\n    }\\n};\\n\\n/*\\n * Time Complexity - O(nlogn)\\n * Space Complexity - O(n)\\n * \\n*/\\n```\\n**Do Upvote if you like the solution**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        ios::sync_with_stdio(false);cin.tie(NULL);\\n        \\n        //sort the events according to their start time\\n        sort(events.begin(),events.end());\\n        \\n        int n=events.size();\\n        //store the maxvalue till that element from right.\\n        vector<int>R(n,events[n-1][2]);\\n        for(int i=n-2;i>=0;i--){\\n            R[i]=max(R[i+1],events[i][2]);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int l=i+1, r=n-1;\\n            int idx = -1;\\n            //find first index whose start-time is greater than current event\\'s end-time\\n            while(l <= r){\\n                int m=(l+r)/2;\\n                if(events[m][0]>events[i][1]){\\n                    idx=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            if(idx!=-1){\\n                ans=max(ans,R[idx]+events[i][2]);\\n            }\\n           \\n            \\n        }\\n        //check if there is any single event whose value is greater than the sum of two event\\'s value.\\n        return max(ans,R[0]);\\n    }\\n};\\n\\n/*\\n * Time Complexity - O(nlogn)\\n * Space Complexity - O(n)\\n * \\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475494,
                "title": "understanding-the-pattern-java-solution-recursion-memoization",
                "content": "I wanted to solve binary search + dp problems and was looking for similar patterns.\\nAfter few hours of grilling and understanding patterns  between \\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/\\nhttps://leetcode.com/problems/two-best-non-overlapping-events/\\nhttps://leetcode.com/problems/maximum-profit-in-job-scheduling/\\nWill add more problems to this template\\n\\nI came up with following template -\\nSolution for https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        //here k is optional maximum capacity of like knapsack \\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nFor https://leetcode.com/problems/two-best-non-overlapping-events/ k=2\\n\\n```\\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nThere may be condition when no k boundation is required for example in question https://leetcode.com/problems/maximum-profit-in-job-scheduling/\\n\\n```\\nclass Solution {\\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\\n        int n=startTime.length;\\n        int[][] events=new int[n][3];\\n        for(int i=0;i<n;i++){\\n            events[i][0]=startTime[i];\\n            events[i][1]=endTime[i];\\n            events[i][2]=profit[i];\\n        }\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0], b[0]));\\n        Integer[] dp=new Integer[n];\\n        return dfs(events,0,n,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx, int n,Integer[] dp){\\n        if(idx==n)return 0;\\n        if(dp[idx]!=null)return dp[idx];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx, n,dp);\\n        int notPick=dfs(events, idx+1, n,dp);\\n        return dp[idx]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=(l+r)>>1;\\n            if(events[idx][1]<=events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        //here k is optional maximum capacity of like knapsack \\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\\n        int n=startTime.length;\\n        int[][] events=new int[n][3];\\n        for(int i=0;i<n;i++){\\n            events[i][0]=startTime[i];\\n            events[i][1]=endTime[i];\\n            events[i][2]=profit[i];\\n        }\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0], b[0]));\\n        Integer[] dp=new Integer[n];\\n        return dfs(events,0,n,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx, int n,Integer[] dp){\\n        if(idx==n)return 0;\\n        if(dp[idx]!=null)return dp[idx];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx, n,dp);\\n        int notPick=dfs(events, idx+1, n,dp);\\n        return dp[idx]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=(l+r)>>1;\\n            if(events[idx][1]<=events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592524,
                "title": "c-memoization-binary-search-explaination",
                "content": "# Solution-Memoization + Binary Search\\n\\n*Thought Process*\\n1. For every event, I\\'ve two options. Whether I choose that event or not.\\n2. If choose, then I add its value to my answer. If not choosen I move forward to the next event.\\n3. Now if I select a event, my next event has to have `start time > end time of choosen event`. Also of all the possible next events I should choose the one with `max value`\\n4.  To select the next event with `start time > end time of choosen event`, I can do a Binary search.\\n5.  What to select the `Max value` I can find the value of all legal subsets possible, and select the maximum of all the values.\\n\\n```\\n    vector<int> start;\\n    int dp[100002][2];\\n    \\n    int solve(vector<vector<int>>& events, int i, int choose){\\n        if(i>=events.size()){\\n            return 0; \\n        }       \\n        \\n        if(choose>=2){    // since I cannot chose more than two elemnts.\\n            return 0;\\n        }\\n        \\n        if(dp[i][choose]!=-1){\\n            return dp[i][choose];\\n        }\\n        \\n        int idx = upper_bound(start.begin(),start.end(),events[i][1])-start.begin(); // binary search to find the next event\\'s index\\n            \\n        return dp[i][choose]=max(events[i][2]+solve(events,idx,choose+1),solve(events,i+1,choose)); //either I select an event, or I dont\\n        \\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        for(int i=0;i<100002;i++){\\n            for(int j=0;j<2;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int n = events.size();\\n\\t\\t//sort elemts acc to start time\\n        sort(events.begin(),events.end());\\n\\t\\t\\n        start.clear();\\n        for(int i=0;i<n;i++){\\n            start.push_back(events[i][0]);            \\n        }\\n        \\n        return solve(events,0,0);\\n    }\\n```\\n\\n**Time Complexity - O[n*log(n)]**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n    vector<int> start;\\n    int dp[100002][2];\\n    \\n    int solve(vector<vector<int>>& events, int i, int choose){\\n        if(i>=events.size()){\\n            return 0; \\n        }       \\n        \\n        if(choose>=2){    // since I cannot chose more than two elemnts.\\n            return 0;\\n        }\\n        \\n        if(dp[i][choose]!=-1){\\n            return dp[i][choose];\\n        }\\n        \\n        int idx = upper_bound(start.begin(),start.end(),events[i][1])-start.begin(); // binary search to find the next event\\'s index\\n            \\n        return dp[i][choose]=max(events[i][2]+solve(events,idx,choose+1),solve(events,i+1,choose)); //either I select an event, or I dont\\n        \\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        for(int i=0;i<100002;i++){\\n            for(int j=0;j<2;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int n = events.size();\\n\\t\\t//sort elemts acc to start time\\n        sort(events.begin(),events.end());\\n\\t\\t\\n        start.clear();\\n        for(int i=0;i<n;i++){\\n            start.push_back(events[i][0]);            \\n        }\\n        \\n        return solve(events,0,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550658,
                "title": "c-brute-force-to-binary-search-tc-o-nlogn-sc-o-n-commented",
                "content": "```\\n//Brute Force\\nYou must have to undernstand brute force ,if you want to fully get the observation of my binary search solution.\\noptimize one will become very easy ,so get idea about brute fce and jump to optimized one.\\n\\nint maxTwoEvents(vector<vector<int>>&a) {\\n         \\n       int n=a.size();\\n        int res=INT_MIN;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>x=a[i];\\n            int s1=x[0];\\n            int e1=x[1];\\n            int val1=x[2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j!=i)\\n                {\\n                    vector<int>v1=a[j];\\n                    int s2=v1[0];\\n                    int e2=v1[1];\\n                    int val2=v1[2];\\n                    if(s2>e1)\\n                    {\\n                        \\n                        res=max(res,val1+val2);\\n                        \\n                    }\\n                }\\n               \\n            }\\n            mx=max(mx,val1);\\n        }\\n        return max(mx,res);\\n    }\\n\\tNow think to optimise the above aproach,just we want to remove the repetetive work\\n\\twe know if we want to get in a range of values in sorted array,we can use binary search\\n\\tso below is the idea\\n\\t\\n//https://leetcode.com/problems/two-best-non-overlapping-events/\\n//sorting based on start time\\n//starting time is equal than we will keep the smaller end time first\\nstatic bool comp(vector<int>&a,vector<int>&b)\\n{\\n   if(a[0]==b[0])\\n   return a[1]<b[1];\\n   return a[0]<b[0];\\n}\\nint maxTwoEvents(vector<vector<int>>&a)\\n{\\n         \\n        int n=a.size();\\n        int res=INT_MIN;\\n        int mx=INT_MIN;\\n        sort(a.begin(),a.end(),comp);\\n//here I am using maxright to store the max valuefrom the right\\n//suppose we landup at middle value and found the starting point greater than end point,so according to logic we want to move our right to mid+1 but \\n//There may be the case that we have some starting point after mid which is having value greater than the current mid index\\n//so to avoid this conflicts we will store mid max value from the right\\n//because we know that after mid all the starting point is going to be greater right\\n        \\n        vector<int>maxfromright(n);\\n        maxfromright[n-1]=a[n-1][2];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            maxfromright[i]=max(a[i][2],maxfromright[i+1]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            //keep all three values\\n            vector<int>x=a[i];\\n            int s1=x[0];\\n            int e1=x[1];\\n            int val1=x[2];\\n            //start of binary search\\n            int l=i+1;\\n            int r=n-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                vector<int>v1=a[mid];\\n                //keep all three values\\n                 int s2=v1[0];\\n                 int e2=v1[1];\\n                 int val2=v1[2];\\n                 //start dividing array to get the ans\\n                 int idx=-1;\\n                if(s2>e1)\\n                {\\n                    idx=mid;\\n                    r=mid-1;\\n                  \\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n                if(idx!=-1)\\n                {\\n                    res=max(res,val1+maxfromright[idx]);\\n                }\\n              \\n            }\\n//why this,this is because we can take only one events also \\n//supose tow events are not giving max but signle events may be max so will keep track of that also\\n\\n            mx=max(mx,val1);\\n        }\\n        return max(mx,res);\\n}\\nTime complexity->O(nlogn)\\nSpace complexity->O(n)\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n//Brute Force\\nYou must have to undernstand brute force ,if you want to fully get the observation of my binary search solution.\\noptimize one will become very easy ,so get idea about brute fce and jump to optimized one.\\n\\nint maxTwoEvents(vector<vector<int>>&a) {\\n         \\n       int n=a.size();\\n        int res=INT_MIN;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>x=a[i];\\n            int s1=x[0];\\n            int e1=x[1];\\n            int val1=x[2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j!=i)\\n                {\\n                    vector<int>v1=a[j];\\n                    int s2=v1[0];\\n                    int e2=v1[1];\\n                    int val2=v1[2];\\n                    if(s2>e1)\\n                    {\\n                        \\n                        res=max(res,val1+val2);\\n                        \\n                    }\\n                }\\n               \\n            }\\n            mx=max(mx,val1);\\n        }\\n        return max(mx,res);\\n    }\\n\\tNow think to optimise the above aproach,just we want to remove the repetetive work\\n\\twe know if we want to get in a range of values in sorted array,we can use binary search\\n\\tso below is the idea\\n\\t\\n//https://leetcode.com/problems/two-best-non-overlapping-events/\\n//sorting based on start time\\n//starting time is equal than we will keep the smaller end time first\\nstatic bool comp(vector<int>&a,vector<int>&b)\\n{\\n   if(a[0]==b[0])\\n   return a[1]<b[1];\\n   return a[0]<b[0];\\n}\\nint maxTwoEvents(vector<vector<int>>&a)\\n{\\n         \\n        int n=a.size();\\n        int res=INT_MIN;\\n        int mx=INT_MIN;\\n        sort(a.begin(),a.end(),comp);\\n//here I am using maxright to store the max valuefrom the right\\n//suppose we landup at middle value and found the starting point greater than end point,so according to logic we want to move our right to mid+1 but \\n//There may be the case that we have some starting point after mid which is having value greater than the current mid index\\n//so to avoid this conflicts we will store mid max value from the right\\n//because we know that after mid all the starting point is going to be greater right\\n        \\n        vector<int>maxfromright(n);\\n        maxfromright[n-1]=a[n-1][2];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            maxfromright[i]=max(a[i][2],maxfromright[i+1]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            //keep all three values\\n            vector<int>x=a[i];\\n            int s1=x[0];\\n            int e1=x[1];\\n            int val1=x[2];\\n            //start of binary search\\n            int l=i+1;\\n            int r=n-1;\\n            while(l<=r)\\n            {\\n                int mid=l+(r-l)/2;\\n                vector<int>v1=a[mid];\\n                //keep all three values\\n                 int s2=v1[0];\\n                 int e2=v1[1];\\n                 int val2=v1[2];\\n                 //start dividing array to get the ans\\n                 int idx=-1;\\n                if(s2>e1)\\n                {\\n                    idx=mid;\\n                    r=mid-1;\\n                  \\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n                if(idx!=-1)\\n                {\\n                    res=max(res,val1+maxfromright[idx]);\\n                }\\n              \\n            }\\n//why this,this is because we can take only one events also \\n//supose tow events are not giving max but signle events may be max so will keep track of that also\\n\\n            mx=max(mx,val1);\\n        }\\n        return max(mx,res);\\n}\\nTime complexity->O(nlogn)\\nSpace complexity->O(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549085,
                "title": "java-o-nlogn-binary-search-maximum-caching",
                "content": "We only need to find a pair of non-overlapping events. Therefore, given one fixed event, we need to find the other event with non-overlapping to form a pair. For each pair, we calculate the maximum. However, the complexity will be O(n^2).\\n\\nTo reduce the complexity, we use binary search to find the other event without overlapping. We first sort the events array based on the starting time. Given a fixed event, once the starting time is sorted, we can use binary search to find the non-overlapping event to form the pair. Moreover, we need an array maxArr to record the maximum value of every event so that we only need O(1) to index.\\n\\nThe codes are as follows:\\n```\\n\\nclass Solution {\\n\\n    public int maxTwoEvents(int[][] events) {\\n        if(events == null || events.length < 1) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Sort the event array based on the starting time\\n        Arrays.sort(events, (a, b) -> a[0] == b[0] ? b[2] - a[2] : a[0] - b[0]);\\n        \\n\\t\\t// Use an array to record the maximum value\\n        int[] maxArr = new int[events.length];\\n        \\n        maxArr[events.length - 1] = events[events.length - 1][2];\\n        for(int i = events.length - 2; i >= 0; i--) {\\n            maxArr[i] = Math.max(maxArr[i + 1], events[i][2]);\\n        }\\n        \\n\\t\\t// The current maximum value is the last event\\n        int ans = events[events.length - 1][2];\\n        \\n        for(int i = 0; i < events.length - 1; i++) {\\n            int index = find(events, events[i][1], i + 1);\\n            \\n            if(index == -1) {\\n\\t\\t\\t// If we cannot find a non-overlapping event, the maximum so far is the current event value\\n                ans = Math.max(ans, events[i][2]);\\n            } else {\\n\\t\\t\\t// The maximum is the current event value plus the nonoverlapping event value\\n                ans = Math.max(ans, events[i][2] + maxArr[index]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int find(int[][] events, int target, int left) {\\n\\t// Binary search to find the first nonoverlapping event\\n        int right = events.length - 1;\\n        \\n        while(left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(events[mid][0] <= target) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        if(events[left][0] > target) {\\n            return left;\\n        }\\n        \\n        if(events[right][0] > target) {\\n            return right;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n\\n    public int maxTwoEvents(int[][] events) {\\n        if(events == null || events.length < 1) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Sort the event array based on the starting time\\n        Arrays.sort(events, (a, b) -> a[0] == b[0] ? b[2] - a[2] : a[0] - b[0]);\\n        \\n\\t\\t// Use an array to record the maximum value\\n        int[] maxArr = new int[events.length];\\n        \\n        maxArr[events.length - 1] = events[events.length - 1][2];\\n        for(int i = events.length - 2; i >= 0; i--) {\\n            maxArr[i] = Math.max(maxArr[i + 1], events[i][2]);\\n        }\\n        \\n\\t\\t// The current maximum value is the last event\\n        int ans = events[events.length - 1][2];\\n        \\n        for(int i = 0; i < events.length - 1; i++) {\\n            int index = find(events, events[i][1], i + 1);\\n            \\n            if(index == -1) {\\n\\t\\t\\t// If we cannot find a non-overlapping event, the maximum so far is the current event value\\n                ans = Math.max(ans, events[i][2]);\\n            } else {\\n\\t\\t\\t// The maximum is the current event value plus the nonoverlapping event value\\n                ans = Math.max(ans, events[i][2] + maxArr[index]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int find(int[][] events, int target, int left) {\\n\\t// Binary search to find the first nonoverlapping event\\n        int right = events.length - 1;\\n        \\n        while(left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(events[mid][0] <= target) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        if(events[left][0] > target) {\\n            return left;\\n        }\\n        \\n        if(events[right][0] > target) {\\n            return right;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768559,
                "title": "complete-detailed-explanation-most-intuitive-linear-dp-binary-search-solution-c",
                "content": "# Intuition\\nFirst Thing WE can understand from the problem is to sort the events first for getting **non-overlapping** two events. \\nThen we can calculate the upperbound for current event ending time for choosing next event.\\n\\n# Approach\\nAs mentioned in the intuition we first sort the array.\\nThen Here we can observe nonlinearity in the **values** associated with the events.\\nExample : events = [[1,3,2],[4,5,2],[1,5,5]]\\nAfter Sorting the events became\\nevents=[[1,3,2],[1,5,5],[4,5,2]]\\nThe Values of Events are in non monotonic nature [2,5,2]\\n**Important Observation :**\\nconsider the events = [[1,3,2],[4,5,2],[6,7,3],[8,10,100],[11,12,1],[13,20,5]] (arranged in sorted order)\\nConsider If we Select the first event now sum=2\\nthen what is the next possible event that we can choose OR what are the options we have to choose\\n- we can choose event 2 with value 2\\n- we can choose event 3 with value 3\\n- **we can choose event 4 with value 100**\\n- we can choose event 5 with value 1\\n- we can choose event 5 with value 5\\nWhat is Best Option to choose for getting maximum Sum?\\nwe have to choose event 4 .\\nwhat can we understand from above example ,\\nafter selecting event-1 =[1,3,2]\\nthe next should start after ending time of event -1 \\nhence events are sorted we can apply upperbound on ending time for getting next event .\\nHere for event 1 ending time=3\\nupperbound(events,3) = index 1\\nwhich form index 1 to n-1 we can select any one event which result maximum sum.\\nfor getting that particular event we can precompute the maximum values from the r.h.s **because we don\\'t care about which event it was , we just need the maximum value of the event**\\nlets compute the maxvalues from the right hand side\\ndeclare a maxValues/(u can declare as dp if you wish to) array of size =events.size.\\nRun the loop from n-1 to 0\\nuse currentMax Variable initialize with zero\\n1. at index = 5 ,  events value = 5 && currentMax=0 \\nhence currentMax is less than event value assign \\n currentMax=events[index][2] and then \\nmaxValues[index]=currentMax\\n2.at index = 4 ,  events value = 1 && currentMax=5 \\nhence currentMax is greater than event value we don\\'t change currentMax value just assign \\nmaxValues[index]=currentMax\\n3. at index = 3 ,  events value = 100 && currentMax=5\\nhence currentMax is less than event value assign \\n currentMax=events[index][2] and then \\nmaxValues[index]=currentMax\\nFrom here onwards currentMax value will not get changed \\nafter completion for maxValues Computation \\nthe maxValues/DP array = [100,100,100,100,5,5]\\nNow After Selecting the first event sum=2\\nand upperbound(events,endtime) = index 1\\nand maxValue[1]=100\\nHence For event 1 maximum sum = 102\\nLike we can compute maximum sum for every event and return the maximum sum among them.\\n**I WISH YOU UNDERSTOOD MY EXPLANATION \\n  PLEASE UPVOTE IF YOU LIKE MY SOLUTION**\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/48e5d6ec-7d8f-4ae9-80c1-2017bec466dc_1689422474.1885724.jpeg)\\n# Complexity\\n- Time complexity:\\n O(NLOGN) for sorting the events \\nand we run a loop which for calculating maximum sum runs **n** times in which we use upperbound everytime the loop runs which tooks **logn** time \\nhence its results in overall  O(nlogn) time complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for storing the precomputed maximum values\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int upper_bound(vector<vector<int>>& events,int key,int size)\\n    {\\n        int low=0,high=size-1,mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(events[mid][0]>key) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return low;\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int size=events.size(),currMax=0;\\n        vector<int>maxValue(size,0); //you can declare it as dp\\n        //now precompute the maximum values\\n\\n        for(int i=size-1;i>=0;i--)\\n        {\\n            currMax=max(currMax,events[i][2]);\\n            maxValue[i]=currMax;\\n        }\\n        int maxTwoEventss=0,currTwoEvents=0,nextInd;\\n        for(int i=0;i<size;i++)\\n        {\\n             currTwoEvents=events[i][2];\\n             nextInd=upper_bound(events,events[i][1],size);\\n             if(nextInd<size) currTwoEvents+=maxValue[nextInd];\\n             maxTwoEventss=max(maxTwoEventss,currTwoEvents);\\n        }\\n           return maxTwoEventss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int upper_bound(vector<vector<int>>& events,int key,int size)\\n    {\\n        int low=0,high=size-1,mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(events[mid][0]>key) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return low;\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int size=events.size(),currMax=0;\\n        vector<int>maxValue(size,0); //you can declare it as dp\\n        //now precompute the maximum values\\n\\n        for(int i=size-1;i>=0;i--)\\n        {\\n            currMax=max(currMax,events[i][2]);\\n            maxValue[i]=currMax;\\n        }\\n        int maxTwoEventss=0,currTwoEvents=0,nextInd;\\n        for(int i=0;i<size;i++)\\n        {\\n             currTwoEvents=events[i][2];\\n             nextInd=upper_bound(events,events[i][1],size);\\n             if(nextInd<size) currTwoEvents+=maxValue[nextInd];\\n             maxTwoEventss=max(maxTwoEventss,currTwoEvents);\\n        }\\n           return maxTwoEventss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645906,
                "title": "c-recursion-memoization-tabulation-01-knapsack",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/f4931dd3-0490-45f9-b03d-477b5e9d4210_1664628217.7387586.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\nclass Solution {\\npublic:\\n    int f(int i,int count,vector<int>& st,vector<vector<int>>& eve,int n){\\n        if(i>=n || count==2) return 0;\\n        int ind=lower_bound(st.begin(),st.end(),eve[i][1]+1)-st.begin();\\n        int pick = eve[i][2] + f(ind,count+1,st,eve,n);\\n        int notpick = f(i+1,count,st,eve,n);\\n        return max(pick,notpick);\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& eve) {\\n        int n=eve.size();\\n        sort(eve.begin(),eve.end());\\n        vector<int> st;\\n        for(auto i: eve) st.push_back(i[0]);\\n        return f(0,0,st,eve,n);\\n    }\\n};\\n\\n# Method - 1 [Memoization]\\n![image](https://assets.leetcode.com/users/images/cd7e9a79-dfd4-4f12-a3e4-7c97e528f8f6_1664628746.6609268.png)\\n\\n**T->O(3n) && S->O(3n) + O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int count,vector<int>& st,vector<vector<int>>& eve,int n,vector<vector<int>>& dp){\\n\\t\\t\\tif(i>=n || count==2) return 0;\\n\\t\\t\\tif(dp[i][count]!=-1) return dp[i][count];\\n\\t\\t\\tint ind=upper_bound(st.begin(),st.end(),eve[i][1])-st.begin();\\n\\t\\t\\tint pick = eve[i][2] + f(ind,count+1,st,eve,n,dp);\\n\\t\\t\\tint notpick = f(i+1,count,st,eve,n,dp);\\n\\t\\t\\treturn dp[i][count]=max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint maxTwoEvents(vector<vector<int>>& eve) {\\n\\t\\t\\tint n=eve.size();\\n\\t\\t\\tsort(eve.begin(),eve.end());\\n\\t\\t\\tvector<int> st;\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(3,-1));\\n\\t\\t\\tfor(auto i: eve) st.push_back(i[0]);\\n\\t\\t\\treturn f(0,0,st,eve,n,dp);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -3 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/64abbcad-9ecb-4e51-8ed1-e2e0533a30a4_1664629043.2080193.png)\\n\\n\\n**T->O(3n) && S->O(3n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxTwoEvents(vector<vector<int>>& eve) {\\n\\t\\t\\tint n=eve.size();\\n\\t\\t\\tsort(eve.begin(),eve.end());\\n\\t\\t\\tvector<int> st;\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(3,0));\\n\\t\\t\\tfor(auto i: eve) st.push_back(i[0]);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int count=1;count>=0;count--){\\n\\t\\t\\t\\t\\tint ind=upper_bound(st.begin(),st.end(),eve[i][1])-st.begin();\\n\\t\\t\\t\\t\\tint pick = eve[i][2] + dp[ind][count+1];\\n\\t\\t\\t\\t\\tint notpick = dp[i+1][count];\\n\\t\\t\\t\\t\\tdp[i][count]=max(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int f(int i,int count,vector<int>& st,vector<vector<int>>& eve,int n){\\n        if(i>=n || count==2) return 0;\\n        int ind=lower_bound(st.begin(),st.end(),eve[i][1]+1)-st.begin();\\n        int pick = eve[i][2] + f(ind,count+1,st,eve,n);\\n        int notpick = f(i+1,count,st,eve,n);\\n        return max(pick,notpick);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1549347,
                "title": "c-dynamic-programming",
                "content": "**Starting from first day, each day has three possible works in this problem:**\\n\\n1. **End the first event** (Case 1)\\n2. **Start the second event** (Case 2)\\n3. **Do nothing (or in event)** (Case 3)\\n\\n\\n**And their relationship:**\\n\\n1. **`firstEnd = iValEnd`** (Case 1)\\n2. **`secondBegin = max(old_firstEnd + iValBegin, secondBegin)`** (Case 2)\\n3. **`old_firstEnd = max(old_firstEnd,  firstEnd)`**  (Case 3)\\n\\n#### variables:\\n* **`iValEnd`** stands for the maximum value of the events which ends at day i\\n* **`iValBegin`** stands for the maximum value of the events which begins at day i\\n* **`firstEnd`** stands for the maximum value at day i if you just choose one event to attend\\n* **`old_firstEnd`** stands for the yesterday\\'s maximum value if you just choose one event to attend\\n* **`secondBegin`** stands for the maximum value at day i if you choose the second event to attend\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int maxDay = 0;\\n        // Dynamic Programming\\n        \\n        unordered_map<int, vector<int>> endDay; // end Day with its value\\n        unordered_map<int, vector<int>> begDay; // begin Day with its value\\n        set<int> days;\\n        \\n        for (auto event : events) {\\n            if (event[1] > maxDay) maxDay = event[1];\\n            endDay[event[1]].push_back(event[2]);\\n            begDay[event[0]].push_back(event[2]);\\n            \\n            days.insert(event[1]);\\n            days.insert(event[0]);\\n        }\\n        int ret = 0;\\n        \\n        // Start\\n        int fee = 0; // first event end\\n        int seb = 0; // second event begin\\n        for (auto i : days) {\\n            int prefee = fee;\\n            int preseb = seb;\\n            for (int value : endDay[i]) {\\n                // first event end today\\n                fee = max(fee, value);\\n            }\\n            \\n            fee = max(prefee, fee); // do nothing\\n            \\n            for (int value : begDay[i]) {\\n                // second event start today\\n                seb = max(prefee + value, seb);\\n            }\\n            ret = max(ret, max(seb, fee));\\n        }\\n        return ret;\\n    }\\n};\\n\\n   \\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int maxDay = 0;\\n        // Dynamic Programming\\n        \\n        unordered_map<int, vector<int>> endDay; // end Day with its value\\n        unordered_map<int, vector<int>> begDay; // begin Day with its value\\n        set<int> days;\\n        \\n        for (auto event : events) {\\n            if (event[1] > maxDay) maxDay = event[1];\\n            endDay[event[1]].push_back(event[2]);\\n            begDay[event[0]].push_back(event[2]);\\n            \\n            days.insert(event[1]);\\n            days.insert(event[0]);\\n        }\\n        int ret = 0;\\n        \\n        // Start\\n        int fee = 0; // first event end\\n        int seb = 0; // second event begin\\n        for (auto i : days) {\\n            int prefee = fee;\\n            int preseb = seb;\\n            for (int value : endDay[i]) {\\n                // first event end today\\n                fee = max(fee, value);\\n            }\\n            \\n            fee = max(prefee, fee); // do nothing\\n            \\n            for (int value : begDay[i]) {\\n                // second event start today\\n                seb = max(prefee + value, seb);\\n            }\\n            ret = max(ret, max(seb, fee));\\n        }\\n        return ret;\\n    }\\n};\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549104,
                "title": "easy-understood-java-solution-with-sort-and-postfix-array",
                "content": "1. sort the events by the starting time\\n2. create a postfix array to record the largest value after current starting time `events[i][0]`\\n3. use binary search to find the first event that starting later than the one at current iteration \\n\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int onRight = 0, maxOne = 0, n = events.length;\\n        int[] rightMax = new int[n+1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int start = events[i][0], end = events[i][1], val = events[i][2];\\n            maxOne = Math.max(val, maxOne);\\n            rightMax[i] = Math.max(rightMax[i+1], val);\\n        }\\n        int two = 0;\\n        for (int i = 0; i < n; i++) {\\n            int start = events[i][0], end = events[i][1], val = events[i][2];\\n            int idx = binarySearch(end, events);\\n            if (idx < n) {\\n                two = Math.max(rightMax[idx] + val, two);\\n            }\\n        }\\n        return Math.max(two, maxOne);\\n    }\\n    \\n    public int binarySearch(int end, int[][] arr) {\\n        int left = 0, right = arr.length;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid][0] > end) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int onRight = 0, maxOne = 0, n = events.length;\\n        int[] rightMax = new int[n+1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int start = events[i][0], end = events[i][1], val = events[i][2];\\n            maxOne = Math.max(val, maxOne);\\n            rightMax[i] = Math.max(rightMax[i+1], val);\\n        }\\n        int two = 0;\\n        for (int i = 0; i < n; i++) {\\n            int start = events[i][0], end = events[i][1], val = events[i][2];\\n            int idx = binarySearch(end, events);\\n            if (idx < n) {\\n                two = Math.max(rightMax[idx] + val, two);\\n            }\\n        }\\n        return Math.max(two, maxOne);\\n    }\\n    \\n    public int binarySearch(int end, int[][] arr) {\\n        int left = 0, right = arr.length;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (arr[mid][0] > end) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549065,
                "title": "python-binary-search-dp",
                "content": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        def binarySearch(low, high, key):\\n            if low <= high:\\n                mid = (low+high)//2\\n                if events[mid][1] >= key:\\n                    return binarySearch(low, mid-1, key)\\n                else:\\n                    return binarySearch(mid+1, high, key)\\n            return high\\n        \\n        events.sort(key=lambda x: x[1])\\n        dp = [0 for _ in range(len(events))]\\n        dp[0] = events[0][2]\\n        for i in range(1, len(events)):\\n            dp[i] = max(dp[i-1], events[i][2]) # maximum values if only one selection was allowed         \\n        \\n        maxi = events[0][2]\\n        \\n        for i in range(1, len(events)):\\n            cur = events[i][2]\\n            prev =  binarySearch(0, len(events), events[i][0]) # previos non-overlapping index\\n            maxi = max(maxi, cur+dp[prev]) if prev != -1 else max(maxi, cur)\\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        def binarySearch(low, high, key):\\n            if low <= high:\\n                mid = (low+high)//2\\n                if events[mid][1] >= key:\\n                    return binarySearch(low, mid-1, key)\\n                else:\\n                    return binarySearch(mid+1, high, key)\\n            return high\\n        \\n        events.sort(key=lambda x: x[1])\\n        dp = [0 for _ in range(len(events))]\\n        dp[0] = events[0][2]\\n        for i in range(1, len(events)):\\n            dp[i] = max(dp[i-1], events[i][2]) # maximum values if only one selection was allowed         \\n        \\n        maxi = events[0][2]\\n        \\n        for i in range(1, len(events)):\\n            cur = events[i][2]\\n            prev =  binarySearch(0, len(events), events[i][0]) # previos non-overlapping index\\n            maxi = max(maxi, cur+dp[prev]) if prev != -1 else max(maxi, cur)\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592647,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        // priority queue minheap --> to store endtime and values of the events\\n        sort(events.begin(),events.end()); // sort according to start time\\n        \\n        int result = 0;\\n        int maxval = 0; // maxvalue stores the maximum value of the values encountered so far and \\n        // whose ending time is less than the start time of the current event\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n            {\\n                maxval = max(maxval,pq.top().second);\\n                pq.pop();\\n            }\\n            result = max(result, maxval + events[i][2]);\\n            pq.push({events[i][1],events[i][2]});\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        // priority queue minheap --> to store endtime and values of the events\\n        sort(events.begin(),events.end()); // sort according to start time\\n        \\n        int result = 0;\\n        int maxval = 0; // maxvalue stores the maximum value of the values encountered so far and \\n        // whose ending time is less than the start time of the current event\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n            {\\n                maxval = max(maxval,pq.top().second);\\n                pq.pop();\\n            }\\n            result = max(result, maxval + events[i][2]);\\n            pq.push({events[i][1],events[i][2]});\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667405,
                "title": "java-concise-with-explanation",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        // -sort the events by start time\\n        // -rely on the fact that for any event events[i], all events after events[i] start at a time\\n        // after events[i] and so do not overlap with any previous events not overlapping with events[i].\\n        // hence, we can maintain a PQ of end times for events to keep track of which events don\\'t overlap with\\n        // the current event,\\n        // and maintain a maximum-valued previous event to combine with curr events[i]\\n        // answer will either be using two or one event sine value is nonnegative\\n        \\n        // sort events by start time\\n        Arrays.sort(events, (event1, event2) -> Integer.compare(event1[0], event2[0]));\\n        \\n        // maintaining the end times of previous events to use for checking overlap\\n        PriorityQueue<int[]> endTimes = new PriorityQueue<>((event1, event2) -> Integer.compare(event1[1], event2[1]));\\n        \\n        // finally, max-valued event we\\'ve seen thus far\\n        int maxValuedEvent = 0;\\n        int ans = 0;\\n        \\n        // now start the iterative process\\n        for (int[] event : events) {\\n            while (!endTimes.isEmpty() && endTimes.peek()[1] < event[0]) {\\n                maxValuedEvent = Math.max(maxValuedEvent, endTimes.poll()[2]);\\n            }\\n            ans = Math.max(ans, maxValuedEvent + event[2]);\\n            endTimes.offer(event);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        // -sort the events by start time\\n        // -rely on the fact that for any event events[i], all events after events[i] start at a time\\n        // after events[i] and so do not overlap with any previous events not overlapping with events[i].\\n        // hence, we can maintain a PQ of end times for events to keep track of which events don\\'t overlap with\\n        // the current event,\\n        // and maintain a maximum-valued previous event to combine with curr events[i]\\n        // answer will either be using two or one event sine value is nonnegative\\n        \\n        // sort events by start time\\n        Arrays.sort(events, (event1, event2) -> Integer.compare(event1[0], event2[0]));\\n        \\n        // maintaining the end times of previous events to use for checking overlap\\n        PriorityQueue<int[]> endTimes = new PriorityQueue<>((event1, event2) -> Integer.compare(event1[1], event2[1]));\\n        \\n        // finally, max-valued event we\\'ve seen thus far\\n        int maxValuedEvent = 0;\\n        int ans = 0;\\n        \\n        // now start the iterative process\\n        for (int[] event : events) {\\n            while (!endTimes.isEmpty() && endTimes.peek()[1] < event[0]) {\\n                maxValuedEvent = Math.max(maxValuedEvent, endTimes.poll()[2]);\\n            }\\n            ans = Math.max(ans, maxValuedEvent + event[2]);\\n            endTimes.offer(event);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556757,
                "title": "explained-c-min-heap-solution",
                "content": "1. Sort all the intervals in the events vector based on start time. The reason to sort this using start time will help when we check whether my current interval is non-overlapping with the interval at the top of min-heap(priority queue).\\n\\n2. You have to maintain a `min-heap`  which will make sure you can have the interval with least ending time at the top/front so that you will have better chances that your current interval can get a match.\\n3. If the current interval\\'s start time > end time of interval at top of priority queue, you get a match as they would be non-overlapping. So you maintain  a `Max` of the value of intervals from the min-heap. And after getting the ultimate match for every current interval, you maintain a `ans` and update it with `Max + curVal`.\\n4. At the end, you push the current interval in the min-heap for that will be checked for pairing for further intervals.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        sort(events.begin(),events.end());\\n        \\n        priority_queue<tuple<int,int,int>> pq;\\n        int Max = 0, ans = 0;\\n        for(int i=0;i<events.size();i++) {\\n        \\n            while(!pq.empty()) {\\n                \\n                auto top = pq.top();\\n                if(events[i][0] > -get<0>(top)) {\\n                    Max = max(Max,get<2>(top));\\n                    pq.pop();\\n                    continue;\\n                }\\n                break;\\n            }\\n            \\n            ans = max(ans, Max + events[i][2]);\\n            pq.push(make_tuple(-1*events[i][1],events[i][0],events[i][2]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        sort(events.begin(),events.end());\\n        \\n        priority_queue<tuple<int,int,int>> pq;\\n        int Max = 0, ans = 0;\\n        for(int i=0;i<events.size();i++) {\\n        \\n            while(!pq.empty()) {\\n                \\n                auto top = pq.top();\\n                if(events[i][0] > -get<0>(top)) {\\n                    Max = max(Max,get<2>(top));\\n                    pq.pop();\\n                    continue;\\n                }\\n                break;\\n            }\\n            \\n            ans = max(ans, Max + events[i][2]);\\n            pq.push(make_tuple(-1*events[i][1],events[i][0],events[i][2]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549006,
                "title": "c-solution-using-binary-search-not-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n    int maxTwoEvents(vector<vector<int>>&nums) \\n    {\\n        int n=nums.size();\\n        // vector<int>dp(n+10,0);\\n        sort(nums.begin(),nums.end(),cmp);\\n        // dp[0]=nums[0][2];\\n        int ans=nums[0][2];\\n        for(int i=1;i<n;i++)\\n        {\\n            int s=nums[i][0];\\n            int e=nums[i][1];\\n            int cost=nums[i][2];\\n            nums[i][2]=max(nums[i][2],nums[i-1][2]);\\n            int l=0;\\n            int r=i-1;\\n            int index=-1;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(nums[mid][1]<s)\\n                {\\n                    index=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    r=mid-1;\\n                }\\n            }\\n            if(index!=-1)\\n            {\\n                cost+=nums[index][2];\\n            }\\n            ans=max(ans,cost);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n    int maxTwoEvents(vector<vector<int>>&nums) \\n    {\\n        int n=nums.size();\\n        // vector<int>dp(n+10,0);\\n        sort(nums.begin(),nums.end(),cmp);\\n        // dp[0]=nums[0][2];\\n        int ans=nums[0][2];\\n        for(int i=1;i<n;i++)\\n        {\\n            int s=nums[i][0];\\n            int e=nums[i][1];\\n            int cost=nums[i][2];\\n            nums[i][2]=max(nums[i][2],nums[i-1][2]);\\n            int l=0;\\n            int r=i-1;\\n            int index=-1;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(nums[mid][1]<s)\\n                {\\n                    index=mid;\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    r=mid-1;\\n                }\\n            }\\n            if(index!=-1)\\n            {\\n                cost+=nums[index][2];\\n            }\\n            ans=max(ans,cost);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693097,
                "title": "python-minheap-solution-leetcode-1477",
                "content": "```\\ndef maxTwoEvents(self, events: List[List[int]]) -> int:\\n\\tq, cur, ans = [], 0, 0\\n\\tfor s, e, v in sorted(events):\\n\\t\\twhile(q and q[0][0]<s):\\n\\t\\t\\tcur = max(cur, heappop(q)[1])\\n\\t\\tans = max(ans, cur+v)\\n\\t\\theappush(q, (e, v))\\n\\treturn ans\\n```\\nSimilar problem:\\n[1477. Find Two Non-overlapping Sub-arrays Each With Target Sum](https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/discuss/2697518/Python-prefix-sum-solution-or-min_heap-or-Leetcode-2054)",
                "solutionTags": [],
                "code": "```\\ndef maxTwoEvents(self, events: List[List[int]]) -> int:\\n\\tq, cur, ans = [], 0, 0\\n\\tfor s, e, v in sorted(events):\\n\\t\\twhile(q and q[0][0]<s):\\n\\t\\t\\tcur = max(cur, heappop(q)[1])\\n\\t\\tans = max(ans, cur+v)\\n\\t\\theappush(q, (e, v))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2340498,
                "title": "c-dp-memorization-binary-search-60-fast-easy-to-follow-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size(),vector<int>(2,-1));\\n        return fun(events,dp,0,0);\\n    }\\n    int fun(vector<vector<int>>& v,vector<vector<int>>& dp,int i,int t)\\n    {\\n        if(t==2 || i>=v.size())\\n            return 0;\\n        \\n        if(dp[i][t]!=-1)\\n            return dp[i][t];\\n        \\n        int res=fun(v,dp,i+1,t);\\n        int next=search(v,v[i][1],i);\\n        res=max(res,v[i][2]+fun(v,dp,next,t+1));\\n        \\n        return dp[i][t]=res;\\n    }\\n    int search(vector<vector<int>>& v,int val,int i)\\n    {\\n        int l=i+1;\\n        int r=v.size()-1;\\n        int res=v.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(v[mid][0]>val)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size(),vector<int>(2,-1));\\n        return fun(events,dp,0,0);\\n    }\\n    int fun(vector<vector<int>>& v,vector<vector<int>>& dp,int i,int t)\\n    {\\n        if(t==2 || i>=v.size())\\n            return 0;\\n        \\n        if(dp[i][t]!=-1)\\n            return dp[i][t];\\n        \\n        int res=fun(v,dp,i+1,t);\\n        int next=search(v,v[i][1],i);\\n        res=max(res,v[i][2]+fun(v,dp,next,t+1));\\n        \\n        return dp[i][t]=res;\\n    }\\n    int search(vector<vector<int>>& v,int val,int i)\\n    {\\n        int l=i+1;\\n        int r=v.size()-1;\\n        int res=v.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(v[mid][0]>val)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692425,
                "title": "c-sort-suffix-max-binary-search-very-clean-code-detailed-explanation",
                "content": "**We solve the problem in 3 steps:**\\n***Step 1*** - Sort the events based on starting time.\\n\\n***Step 2*** - For every event (Starting from the last event), we find the maximum value we can get if we go to any event starting after that (Including the current event). \\nWe store that value in a map, where, Key -> Start time and Value -> Maximum value we can get after attending any event scheduled on or after the start time (key).\\n\\n***Step 3***  - Now, for every event (say \\'curr\\'), we find the upper_bound of the end time of curr in the map (which stores the start times as keys). We can attend any event scheduled on/after that time (say \\'t\\'). Therefore, the current maximum possible score would be m[t] + value of curr.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n\\t\\t//Step 1\\n        sort(events.begin(), events.end());\\n        map<int, int> m;\\n       \\n\\t    //Step 2\\n        m[events[n-1][0]] = events[n-1][2];\\n        int curr = events[n-1][2];\\n        for(int i = n-2; i>=0; i--) {\\n            curr = max(curr, events[i][2]);\\n            m[events[i][0]] = curr;\\n        }\\n       \\n\\t   //Step 3\\n        int res = 0;\\n        for(int i = 0; i<n; i++) {\\n            auto it = m.upper_bound(events[i][1]);\\n            res = max(res, events[i][2]);\\n            if(it != m.end()) {\\n                res = max(res, events[i][2] + it -> second);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n````",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n\\t\\t//Step 1\\n        sort(events.begin(), events.end());\\n        map<int, int> m;\\n       \\n\\t    //Step 2\\n        m[events[n-1][0]] = events[n-1][2];\\n        int curr = events[n-1][2];\\n        for(int i = n-2; i>=0; i--) {\\n            curr = max(curr, events[i][2]);\\n            m[events[i][0]] = curr;\\n        }\\n       \\n\\t   //Step 3\\n        int res = 0;\\n        for(int i = 0; i<n; i++) {\\n            auto it = m.upper_bound(events[i][1]);\\n            res = max(res, events[i][2]);\\n            if(it != m.end()) {\\n                res = max(res, events[i][2] + it -> second);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606716,
                "title": "c-binary-search-max-value-caching",
                "content": "```\\npublic class Solution {\\n    public int MaxTwoEvents(int[][] events) {\\n        Array.Sort(events, (x,y) => x[0].CompareTo(y[0]));\\n        int[] cache = new int[events.Length];\\n        cache[cache.Length-1] = events[events.Length-1][2];\\n        for(int i = events.Length-2; i >= 0; i--) {\\n               cache[i] = Math.Max(events[i][2], cache[i+1]); \\n\\t    }\\n        int res = 0;\\n        foreach(int[] ev in events)\\n        {\\n            int val = ev[2];\\n            int i = search(ev[1], events);\\n            if(i != -1) val += cache[i];\\n            res = Math.Max(res, val);\\n        }\\n        return res;\\n    }\\n    \\n    private int search(int target, int[][] events)\\n    {\\n        int lo = 0, hi = events.Length-1;\\n        while(lo < hi)\\n        {\\n            int mid = lo + (hi-lo)/2;\\n            if(events[mid][0] > target)\\n                hi = mid;\\n            else\\n                lo = mid+1;\\n        }        \\n        return events[lo][0] > target ? lo : -1;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxTwoEvents(int[][] events) {\\n        Array.Sort(events, (x,y) => x[0].CompareTo(y[0]));\\n        int[] cache = new int[events.Length];\\n        cache[cache.Length-1] = events[events.Length-1][2];\\n        for(int i = events.Length-2; i >= 0; i--) {\\n               cache[i] = Math.Max(events[i][2], cache[i+1]); \\n\\t    }\\n        int res = 0;\\n        foreach(int[] ev in events)\\n        {\\n            int val = ev[2];\\n            int i = search(ev[1], events);\\n            if(i != -1) val += cache[i];\\n            res = Math.Max(res, val);\\n        }\\n        return res;\\n    }\\n    \\n    private int search(int target, int[][] events)\\n    {\\n        int lo = 0, hi = events.Length-1;\\n        while(lo < hi)\\n        {\\n            int mid = lo + (hi-lo)/2;\\n            if(events[mid][0] > target)\\n                hi = mid;\\n            else\\n                lo = mid+1;\\n        }        \\n        return events[lo][0] > target ? lo : -1;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562711,
                "title": "different-position-of-comparator-function-gives-timeout-anyone-explain",
                "content": "First I place comparotor function inside the Solution class in public scope by making the comparator function static, it is giving TLE.\\nThen I go through the other solutions and put the comparator function in different structure now code is working fine. Can anyone please explain?\\n\\n```\\nstruct cmp {\\n    bool operator()(vector<int>& node1, vector<int>& node2) {\\n        if(node1[1]==node2[1])\\n            return node1[0] < node2[0]; \\n        return node1[1] < node2[1];    \\n    }\\n};\\n\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    // static bool comp(vector<int> a, vector<int> b) {\\n    //     if (a[1] == b[1])\\n    //     {\\n    //         return a[0] < b[0];\\n    //     }\\n    //     return a[1] < b[1];\\n    // }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        sort(events.begin(), events.end(), cmp());\\n        vector<int> maxTill(events.size());\\n        \\n        int maxVar = 0;\\n        \\n        for(int i=0; i<events.size(); i++)\\n        {\\n            maxVar = max(events[i][2], maxVar);\\n            maxTill[i] = maxVar;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<events.size(); i++)\\n        {\\n            \\n            int index = binarySearch(events, 0, i-1, events[i][0]) ; \\n            if(index>=0)\\n            {\\n                ans = max(ans, events[i][2] + maxTill[index]);\\n            }\\n            else\\n                ans = max(ans, events[i][2]);\\n                \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int binarySearch(vector<vector<int>>& events, int left, int right, int target)\\n    {\\n        while(left<=right)\\n        {\\n            int middle = left + (right - left)/2; \\n            if(events[middle][1]>=target)\\n            {\\n                right = middle-1; \\n            }\\n            else\\n            {\\n                left = middle+1; \\n            }\\n        }\\n        return right; \\n        \\n    }\\n};\\n```\\n\\nHere when I use the commented function` static bool comp ` in sort function as `sort(events.begin(), events.end(), comp)` it gives TLE.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nstruct cmp {\\n    bool operator()(vector<int>& node1, vector<int>& node2) {\\n        if(node1[1]==node2[1])\\n            return node1[0] < node2[0]; \\n        return node1[1] < node2[1];    \\n    }\\n};\\n\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    // static bool comp(vector<int> a, vector<int> b) {\\n    //     if (a[1] == b[1])\\n    //     {\\n    //         return a[0] < b[0];\\n    //     }\\n    //     return a[1] < b[1];\\n    // }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        sort(events.begin(), events.end(), cmp());\\n        vector<int> maxTill(events.size());\\n        \\n        int maxVar = 0;\\n        \\n        for(int i=0; i<events.size(); i++)\\n        {\\n            maxVar = max(events[i][2], maxVar);\\n            maxTill[i] = maxVar;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<events.size(); i++)\\n        {\\n            \\n            int index = binarySearch(events, 0, i-1, events[i][0]) ; \\n            if(index>=0)\\n            {\\n                ans = max(ans, events[i][2] + maxTill[index]);\\n            }\\n            else\\n                ans = max(ans, events[i][2]);\\n                \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int binarySearch(vector<vector<int>>& events, int left, int right, int target)\\n    {\\n        while(left<=right)\\n        {\\n            int middle = left + (right - left)/2; \\n            if(events[middle][1]>=target)\\n            {\\n                right = middle-1; \\n            }\\n            else\\n            {\\n                left = middle+1; \\n            }\\n        }\\n        return right; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561948,
                "title": "c-simple-o-n-logn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end(),[](auto& a, auto& b) {\\n           return a[0] < b[0];\\n        });\\n        int v = events.back()[2];\\n        map<int,int> m; \\n        for(int i = events.size()-1;i>=0;i--) {\\n            v = max(v,events[i][2]);\\n            m[events[i][0]] = v; \\n        }\\n        sort(events.begin(),events.end(),[](auto& a, auto& b) {\\n           return a[1] < b[1];\\n        });\\n        int ret = 0; \\n        for(int i = 0;i<events.size();i++) {\\n            ret = max(ret,events[i][2]);\\n            auto ptr = m.upper_bound(events[i][1]);\\n            if(ptr != m.end()) {\\n                ret = max(ret, events[i][2] + ptr->second);\\n            }\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end(),[](auto& a, auto& b) {\\n           return a[0] < b[0];\\n        });\\n        int v = events.back()[2];\\n        map<int,int> m; \\n        for(int i = events.size()-1;i>=0;i--) {\\n            v = max(v,events[i][2]);\\n            m[events[i][0]] = v; \\n        }\\n        sort(events.begin(),events.end(),[](auto& a, auto& b) {\\n           return a[1] < b[1];\\n        });\\n        int ret = 0; \\n        for(int i = 0;i<events.size();i++) {\\n            ret = max(ret,events[i][2]);\\n            auto ptr = m.upper_bound(events[i][1]);\\n            if(ptr != m.end()) {\\n                ret = max(ret, events[i][2] + ptr->second);\\n            }\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561655,
                "title": "treemap-sortedmap-solution",
                "content": "```\\nimport java.util.Optional;\\n\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        // 1. sort by starting time. O(nlogn)\\n        // 2. map of x -> y meaning for all events starting >=x, y=max value . O(n)\\n        // 3. iterate again, for each end position, find map.get(end+1).\\n        Arrays.sort(events, (int[] e1, int[] e2) ->{\\n            return Integer.compare(e1[0],e2[0]);\\n        });\\n        TreeMap<Integer, Integer> navMap = \\n            new TreeMap<Integer, Integer>();\\n        int max = Integer.MIN_VALUE;\\n        for (int i=events.length-1; i>=0; i--) {\\n            max = Integer.max(max, events[i][2]);\\n            navMap.put(events[i][0], max);\\n        }\\n        \\n        // 3.\\n        int res = 0;\\n        for (int[] event : events) {\\n            res = Integer.max(res, event[2] + Optional.ofNullable(navMap.ceilingEntry(event[1] +1)) \\n                              .map(e->e.getValue() ).orElse(0)  );\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Optional;\\n\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        // 1. sort by starting time. O(nlogn)\\n        // 2. map of x -> y meaning for all events starting >=x, y=max value . O(n)\\n        // 3. iterate again, for each end position, find map.get(end+1).\\n        Arrays.sort(events, (int[] e1, int[] e2) ->{\\n            return Integer.compare(e1[0],e2[0]);\\n        });\\n        TreeMap<Integer, Integer> navMap = \\n            new TreeMap<Integer, Integer>();\\n        int max = Integer.MIN_VALUE;\\n        for (int i=events.length-1; i>=0; i--) {\\n            max = Integer.max(max, events[i][2]);\\n            navMap.put(events[i][0], max);\\n        }\\n        \\n        // 3.\\n        int res = 0;\\n        for (int[] event : events) {\\n            res = Integer.max(res, event[2] + Optional.ofNullable(navMap.ceilingEntry(event[1] +1)) \\n                              .map(e->e.getValue() ).orElse(0)  );\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556410,
                "title": "very-easy-c-solution-check-it",
                "content": "# New method to use max-heap queue to min heap \\n**  int maxTwoEvents**(vector<vector<int>>& events) {\\n        int n = events.size();\\n        int maxValue = 0;\\n        int ans = 0;\\n        // take pq (max heap)\\n        priority_queue<pair<int, pair<int,int>>> pq;\\n         sort(events.begin() , events.end());\\n      // store passion -> in queue ->> {endTime , {startTime , value}}\\n      \\n      for(int i = 0 ; i< n ; i++){\\n        // (-1)* value makes max heap to min heap \\n        // we want min heap for first event that end earlier\\n        while(!pq.empty() && (-1* pq.top().first) < events[i][0])\\n        {\\n          // take what fist event given me maxValue\\n          maxValue = max(maxValue , pq.top().second.second);\\n          pq.pop();\\n          \\n        }\\n        \\n        // push the first event taking this value as ans\\n        ans = max(ans , maxValue+events[i][2]);\\n        pq.push({-1*events[i][1] , {events[i][0], events[i][2]}});\\n      }\\n       return ans; \\n    }",
                "solutionTags": [],
                "code": "# New method to use max-heap queue to min heap \\n**  int maxTwoEvents**(vector<vector<int>>& events) {\\n        int n = events.size();\\n        int maxValue = 0;\\n        int ans = 0;\\n        // take pq (max heap)\\n        priority_queue<pair<int, pair<int,int>>> pq;\\n         sort(events.begin() , events.end());\\n      // store passion -> in queue ->> {endTime , {startTime , value}}\\n      \\n      for(int i = 0 ; i< n ; i++){\\n        // (-1)* value makes max heap to min heap \\n        // we want min heap for first event that end earlier\\n        while(!pq.empty() && (-1* pq.top().first) < events[i][0])\\n        {\\n          // take what fist event given me maxValue\\n          maxValue = max(maxValue , pq.top().second.second);\\n          pq.pop();\\n          \\n        }\\n        \\n        // push the first event taking this value as ans\\n        ans = max(ans , maxValue+events[i][2]);\\n        pq.push({-1*events[i][1] , {events[i][0], events[i][2]}});\\n      }\\n       return ans; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1555571,
                "title": "java-sort-sweep-line-no-dp-or-bst-or-treemap",
                "content": "Solution 1 --  sweep line\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0; i < events.length; ++i) {\\n            int[] arrStart = new int[]{events[i][0], 1, events[i][2]};           //  {startTime, 1, value}\\n            int[] arrEnd = new int[]{events[i][1] + 1, 0, events[i][2]};         //  {endTime + 1, 0, value}  (+1 for exclusive)\\n            list.add(arrStart);\\n            list.add(arrEnd);\\n        }\\n        \\n        Collections.sort(list, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);   //sort by timstamp. if same, put startTime before endTime..\\n        \\n        int maxSoFar = 0, maxRes = 0;\\n        for(int j = 0; j < list.size(); ++j) {\\n            if(list.get(j)[1] == 1)    //startTime\\n                maxRes = Math.max(maxRes, maxSoFar + list.get(j)[2]);\\n            else      //endTime\\n                maxSoFar = Math.max(maxSoFar, list.get(j)[2]);\\n        }\\n        return maxRes;\\n    }\\n}\\n```\\n\\nsolution2 --  TreeMap\\n\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> a[1] - b[1]);\\n        TreeMap<Integer, Integer> map = new TreeMap<>(){{put(0, 0);}};\\n        \\n        int maxP = 0;\\n        for(int[] event : events) {\\n            maxP = Math.max(maxP, event[2] + map.lowerEntry(event[0]).getValue());\\n            \\n            int hi = Math.max(event[2], map.lastEntry().getValue());\\n            map.put(event[1], hi);\\n        }\\n        \\n        return maxP;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0; i < events.length; ++i) {\\n            int[] arrStart = new int[]{events[i][0], 1, events[i][2]};           //  {startTime, 1, value}\\n            int[] arrEnd = new int[]{events[i][1] + 1, 0, events[i][2]};         //  {endTime + 1, 0, value}  (+1 for exclusive)\\n            list.add(arrStart);\\n            list.add(arrEnd);\\n        }\\n        \\n        Collections.sort(list, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);   //sort by timstamp. if same, put startTime before endTime..\\n        \\n        int maxSoFar = 0, maxRes = 0;\\n        for(int j = 0; j < list.size(); ++j) {\\n            if(list.get(j)[1] == 1)    //startTime\\n                maxRes = Math.max(maxRes, maxSoFar + list.get(j)[2]);\\n            else      //endTime\\n                maxSoFar = Math.max(maxSoFar, list.get(j)[2]);\\n        }\\n        return maxRes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550463,
                "title": "c-with-comments-easy-explanation-map-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        \\n        map<int,int>startTimeAndMaxi ;  \\n        \\n        int maximum = 0 ; \\n        int answer = 0 ; \\n        \\n        sort(e.begin() , e.end())  ; // Sorted acc. to StartTime\\n        \\n        int size = e.size()  ; \\n        \\n        while(size--){\\n            \\n            auto itr = startTimeAndMaxi.upper_bound(e[size][1])  ;  // itr points to startTime which is next greater than current Endtime (e[size][1]) --> it removes overlapping\\n            \\n            maximum = max(maximum, e[size][2]) ;  // assuming that curr is the only possible max value\\n            \\n            startTimeAndMaxi[e[size][0]] = maximum ;  // mapping curr start time with maximum value\\n            \\n            if(itr == startTimeAndMaxi.end()){\\n                answer = max(answer , maximum)  ;  // itr not able to find the next startTime\\n            }\\n            else{\\n                answer = max(answer , itr->second + e[size][2]) ;   // itr found next startTime . Now it will add currVal + maximum value till now\\n            }\\n              // answer and maximum keep getting updated\\n        }\\n        \\n        return answer; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        \\n        map<int,int>startTimeAndMaxi ;  \\n        \\n        int maximum = 0 ; \\n        int answer = 0 ; \\n        \\n        sort(e.begin() , e.end())  ; // Sorted acc. to StartTime\\n        \\n        int size = e.size()  ; \\n        \\n        while(size--){\\n            \\n            auto itr = startTimeAndMaxi.upper_bound(e[size][1])  ;  // itr points to startTime which is next greater than current Endtime (e[size][1]) --> it removes overlapping\\n            \\n            maximum = max(maximum, e[size][2]) ;  // assuming that curr is the only possible max value\\n            \\n            startTimeAndMaxi[e[size][0]] = maximum ;  // mapping curr start time with maximum value\\n            \\n            if(itr == startTimeAndMaxi.end()){\\n                answer = max(answer , maximum)  ;  // itr not able to find the next startTime\\n            }\\n            else{\\n                answer = max(answer , itr->second + e[size][2]) ;   // itr found next startTime . Now it will add currVal + maximum value till now\\n            }\\n              // answer and maximum keep getting updated\\n        }\\n        \\n        return answer; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550123,
                "title": "simple-code-with-explanation-and-analysis-binary-search",
                "content": "<br>\\n\\n**Approach:**\\n* Sort events by startTime and traverse from event with highest startTime\\n* While traversing If we can find an event whose startTime > endTime of current event then it means we can take these two in our answer set and we will update the answer accordingly\\nelse we can only take the current event and update the answer accordingly\\n\\n<br>\\n\\n**Will it always give optimal answer ?**\\n\\nYes, because we are sorting events by startTime and traversing from event with highest startTime, so we will always have the later starting event in our map and apply binary search for endTime of current event on it, \\nso we will not miss any two non - overlapping events and also all the events are getting traversed so the case where taking only events is optimal will not be missed.\\n\\n**Example:** If we currently have [s, e, p] then in map there are events with [s + x, e\\', p\\'] and only those can be non - overlapping\\n<br>\\n\\n**Time complexity:**\\n\\nO(n * logn) [sort] + n * (O(logn) [binary search] + O(logn) [insert in map])\\n \\n = O(n * logn) + n * (2 * O(logn))\\n \\n = O(n * logn) + 2 * O(n * logn)\\n \\n ~ **O(n * logn)**\\n<br>\\n\\n**C++ Code:**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        \\n        int n = e.size();\\n        int ans = 0, curMax = 0;\\n        \\n        // sort events by startTime\\n        sort(begin(e), end(e));\\n        \\n        // mp[i] = j denotes event started at i will give profit of j\\n        map<int, int> mp;\\n        \\n        // start traversing from event with max startTime\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            // seach for startTime > current endTime\\n            auto start = mp.upper_bound(e[i][1]);\\n            \\n            // current max profit possible (for one event)\\n            curMax = max(curMax, e[i][2]);\\n            \\n            mp[e[i][0]] = curMax;\\n            \\n            // if there was no startTime > endTime, we will update answer by taking only current event\\n            // if we found that, then we will take that event and add current event to it\\n            if(start == mp.end())\\n                ans = max(ans, curMax);\\n            else\\n                ans = max(ans, e[i][2] + start->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        \\n        int n = e.size();\\n        int ans = 0, curMax = 0;\\n        \\n        // sort events by startTime\\n        sort(begin(e), end(e));\\n        \\n        // mp[i] = j denotes event started at i will give profit of j\\n        map<int, int> mp;\\n        \\n        // start traversing from event with max startTime\\n        for(int i = n-1; i >= 0; i--) {\\n            \\n            // seach for startTime > current endTime\\n            auto start = mp.upper_bound(e[i][1]);\\n            \\n            // current max profit possible (for one event)\\n            curMax = max(curMax, e[i][2]);\\n            \\n            mp[e[i][0]] = curMax;\\n            \\n            // if there was no startTime > endTime, we will update answer by taking only current event\\n            // if we found that, then we will take that event and add current event to it\\n            if(start == mp.end())\\n                ans = max(ans, curMax);\\n            else\\n                ans = max(ans, e[i][2] + start->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549770,
                "title": "c-using-sorting-technique-simple",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int res=0;\\n        int emax=0;\\n        vector<pair<int,int>> start;\\n        vector<pair<int,int>> end;\\n        for(int i=0;i<events.size();++i)\\n            start.push_back({events[i][0],events[i][2]});\\n        for(int i=0;i<events.size();++i)\\n            end.push_back({events[i][1],events[i][2]});\\n        sort(start.begin(),start.end());\\n        sort(end.begin(),end.end());\\n        int j=0;\\n        for(int i=0;i<start.size();++i){\\n            res = max(res,start[i].second);\\n                while(end[j].first < start[i].first){\\n                    emax = max(emax,end[j].second);\\n                    j++;\\n                }\\n            res = max(res,start[i].second + emax);\\n            \\n        }\\n        return res;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int res=0;\\n        int emax=0;\\n        vector<pair<int,int>> start;\\n        vector<pair<int,int>> end;\\n        for(int i=0;i<events.size();++i)\\n            start.push_back({events[i][0],events[i][2]}",
                "codeTag": "Java"
            },
            {
                "id": 1549193,
                "title": "javascript-sort-pre-max-sum-876ms",
                "content": "```\\nconst maxTwoEvents = (a) => {\\n    let d = [], res = 0, maxPreSum = 0;\\n    for (const [start, end, sum] of a) {\\n        d.push([start, sum, 1]);\\n        d.push([end, sum, -1])\\n    }\\n    d.sort((x, y) => {\\n        if (x[0] != y[0]) return x[0] - y[0];\\n        return y[2] - x[2];\\n    });\\n    for (const [, sum, flag] of d) {\\n        if (flag == -1) {\\n            maxPreSum = Math.max(maxPreSum, sum);\\n        } else {\\n            res = Math.max(res, maxPreSum + sum);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nconst maxTwoEvents = (a) => {\\n    let d = [], res = 0, maxPreSum = 0;\\n    for (const [start, end, sum] of a) {\\n        d.push([start, sum, 1]);\\n        d.push([end, sum, -1])\\n    }\\n    d.sort((x, y) => {\\n        if (x[0] != y[0]) return x[0] - y[0];\\n        return y[2] - x[2];\\n    });\\n    for (const [, sum, flag] of d) {\\n        if (flag == -1) {\\n            maxPreSum = Math.max(maxPreSum, sum);\\n        } else {\\n            res = Math.max(res, maxPreSum + sum);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549177,
                "title": "python-heap-for-end-val-o-nlogn",
                "content": "O(NlogN) | O(N)\\n1. Sort by start time\\n2. Clean all elements from the heap with end < start and keep max V as res1\\n3. Calculate max sum for at most two as res2, where res1 is largest v with end < current start\\n3. Populate the heap at each event with (end, val) to consider it later, after we\\'ll reach first start > this end\\n\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        heap = [] # (end, val)\\n        res1 = res2 = 0 # res1 - max for one, res2 - max sum of at most two\\n        for s, e, v in events:\\n            while heap and heap[0][0] < s:\\n                res1 = max(res1, heapq.heappop(heap)[1])\\n            res2 = max(res2, res1 + v)            \\n            heapq.heappush(heap, (e, v))\\n        return res2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        heap = [] # (end, val)\\n        res1 = res2 = 0 # res1 - max for one, res2 - max sum of at most two\\n        for s, e, v in events:\\n            while heap and heap[0][0] < s:\\n                res1 = max(res1, heapq.heappop(heap)[1])\\n            res2 = max(res2, res1 + v)            \\n            heapq.heappush(heap, (e, v))\\n        return res2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549060,
                "title": "java-simple-solution-using-treemap-binary-search-storing-past-max-profit-for-the-exit-time",
                "content": "**Simple Steps:**\\n1. Split each event into 2 sub events - start and  end (identify by -ve value of profit)\\n2. If new start sub event comes see if the maxProfit present in an end sub event which was before current start using TreeMap lowerEntry function.\\n3. When end sub event comes store maxRemoved and make an entry for that end event time in a TreeMap.\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        int[][] inout = new int[2*n][2];\\n        for(int i=0;i<n;i++) {\\n            int[] event = events[i];\\n            inout[i*2] = new int[]{event[0], event[2]};\\n            inout[i*2 +1] = new int[]{event[1], -event[2]};\\n        }\\n        Arrays.sort(inout, (a,b)-> a[0]-b[0]);\\n        int max = 0, maxRemoved = 0;\\n        TreeMap<Integer, Integer> maxUntil = new TreeMap<>();\\n        for(int[] eve : inout) {\\n            if(eve[1] > 0 ) { //  identifying if it is start of event or end of event by -ve value or +ve value\\n                Map.Entry<Integer, Integer> lower = maxUntil.lowerEntry(eve[0]);\\n                int lowerProfit = (lower==null? 0 : lower.getValue());\\n                max = Math.max(max, lowerProfit+eve[1]);\\n            } else {\\n                maxRemoved = Math.max(-eve[1], maxRemoved);\\n                maxUntil.put(eve[0], maxRemoved);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        int[][] inout = new int[2*n][2];\\n        for(int i=0;i<n;i++) {\\n            int[] event = events[i];\\n            inout[i*2] = new int[]{event[0], event[2]};\\n            inout[i*2 +1] = new int[]{event[1], -event[2]};\\n        }\\n        Arrays.sort(inout, (a,b)-> a[0]-b[0]);\\n        int max = 0, maxRemoved = 0;\\n        TreeMap<Integer, Integer> maxUntil = new TreeMap<>();\\n        for(int[] eve : inout) {\\n            if(eve[1] > 0 ) { //  identifying if it is start of event or end of event by -ve value or +ve value\\n                Map.Entry<Integer, Integer> lower = maxUntil.lowerEntry(eve[0]);\\n                int lowerProfit = (lower==null? 0 : lower.getValue());\\n                max = Math.max(max, lowerProfit+eve[1]);\\n            } else {\\n                maxRemoved = Math.max(-eve[1], maxRemoved);\\n                maxUntil.put(eve[0], maxRemoved);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600367,
                "title": "priority-queue-and-multiset-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n      int n=events.size();\\n      sort(events.begin(),events.end()); \\n      multiset<int> s;\\n      vector<int> maxi(n+1,INT_MIN);\\n      maxi[n]=0;\\n      s.insert(events[n-1][2]);\\n      maxi[n-1]=events[n-1][2];\\n      vector<int> next(n,-1);\\n      priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n      for(int i=0;i<n;i++)\\n      {\\n          while(pq.size())\\n          {\\n              auto pr=pq.top();\\n              if(pr.first<events[i][0])\\n              {\\n                  pq.pop();\\n                  next[pr.second]=i;\\n              }\\n              else\\n                break;\\n          }\\n          pq.push({events[i][1],i});\\n      }\\n      int ans=events[n-1][2];\\n      while(pq.size())\\n      {\\n        auto pr=pq.top();\\n        pq.pop();\\n        next[pr.second]=n;   \\n      }\\n      for(int i=n-2;i>=0;i--)\\n      {\\n          int index=next[i];\\n          ans=max(ans,events[i][2]+maxi[index]);\\n          maxi[i]=max(events[i][2],*(--s.end()));\\n          s.insert(events[i][2]);\\n      }\\n      return ans;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n      int n=events.size();\\n      sort(events.begin(),events.end()); \\n      multiset<int> s;\\n      vector<int> maxi(n+1,INT_MIN);\\n      maxi[n]=0;\\n      s.insert(events[n-1][2]);\\n      maxi[n-1]=events[n-1][2];\\n      vector<int> next(n,-1);\\n      priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n      for(int i=0;i<n;i++)\\n      {\\n          while(pq.size())\\n          {\\n              auto pr=pq.top();\\n              if(pr.first<events[i][0])\\n              {\\n                  pq.pop();\\n                  next[pr.second]=i;\\n              }\\n              else\\n                break;\\n          }\\n          pq.push({events[i][1],i});\\n      }\\n      int ans=events[n-1][2];\\n      while(pq.size())\\n      {\\n        auto pr=pq.top();\\n        pq.pop();\\n        next[pr.second]=n;   \\n      }\\n      for(int i=n-2;i>=0;i--)\\n      {\\n          int index=next[i];\\n          ans=max(ans,events[i][2]+maxi[index]);\\n          maxi[i]=max(events[i][2],*(--s.end()));\\n          s.insert(events[i][2]);\\n      }\\n      return ans;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440162,
                "title": "c-easy-to-understand-using-set",
                "content": "In this first lets see the importance of every variable that we used:\\n\\n- s: Set s will be storing the every unique startTime and endTime of every event in sorted manner.\\n-  st[i] will store the values for startTime \\'i\\'.\\n- en[i] will store the value for endTime \\'i\\'.\\n- ended will store the greatest value of a event that has already ended.\\n\\nI think this should probably sum up intuition and code part to make it understandable.\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        set<int> s;\\n        map<int,vector<int>> st,en;\\n        for(int i=0;i<events.size();i++)\\n        {\\n            s.insert(events[i][0]);\\n            s.insert(events[i][1]);\\n            st[events[i][0]].push_back(events[i][2]);\\n            en[events[i][1]].push_back(events[i][2]);\\n        }\\n        int ended=0,ans=0;\\n        auto it=s.begin();\\n        while(it!=s.end())\\n        {\\n            int a=*it;\\n            for(int i=0;i<st[a].size();i++)\\n            {\\n                ans=max(ans,ended+st[a][i]);\\n            }\\n            for(int i=0;i<en[a].size();i++)\\n            {\\n                ended=max(ended,en[a][i]);\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        set<int> s;\\n        map<int,vector<int>> st,en;\\n        for(int i=0;i<events.size();i++)\\n        {\\n            s.insert(events[i][0]);\\n            s.insert(events[i][1]);\\n            st[events[i][0]].push_back(events[i][2]);\\n            en[events[i][1]].push_back(events[i][2]);\\n        }\\n        int ended=0,ans=0;\\n        auto it=s.begin();\\n        while(it!=s.end())\\n        {\\n            int a=*it;\\n            for(int i=0;i<st[a].size();i++)\\n            {\\n                ans=max(ans,ended+st[a][i]);\\n            }\\n            for(int i=0;i<en[a].size();i++)\\n            {\\n                ended=max(ended,en[a][i]);\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155057,
                "title": "java-priorityqueue-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int res = 0, maxVal = 0;\\n        //Min heap by ending time\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        //Sort the array by start time\\n        Arrays.sort(events, Comparator.comparingInt(a -> a[0]));\\n        for (int[] e : events) {\\n            //Pop all the finished events and maintain maximum value till now\\n            while (!pq.isEmpty() && pq.peek()[0] < e[0]) {\\n                maxVal = Math.max(maxVal, pq.poll()[1]);\\n            }\\n            //Check for max value\\n            res = Math.max(res, maxVal + e[2]);\\n            pq.offer(new int[]{e[1], e[2]});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int res = 0, maxVal = 0;\\n        //Min heap by ending time\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        //Sort the array by start time\\n        Arrays.sort(events, Comparator.comparingInt(a -> a[0]));\\n        for (int[] e : events) {\\n            //Pop all the finished events and maintain maximum value till now\\n            while (!pq.isEmpty() && pq.peek()[0] < e[0]) {\\n                maxVal = Math.max(maxVal, pq.poll()[1]);\\n            }\\n            //Check for max value\\n            res = Math.max(res, maxVal + e[2]);\\n            pq.offer(new int[]{e[1], e[2]});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148628,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int dp[][] = new int[events.length][3],output = 0;\\n        for(int row[]:dp) Arrays.fill(row,-1);\\n        Arrays.sort(events,(a,b)->(a[0]-b[0]));\\n        int out =  find(dp,events,0,2);\\n        for(int row[]:events) output = Math.max(output,row[2]);\\n        return Math.max(out,output);\\n    }\\n    public int find(int dp[][],int events[][],int n,int count){\\n        if(count==0) return 0;\\n        if(n>=events.length||n==-1) return Integer.MIN_VALUE;\\n        if(dp[n][count]!=-1) return dp[n][count];\\n        int op = find(dp,events,n+1,count);\\n        int upper = bisearch(events,events[n][1]);\\n        int yo = events[n][2]+find(dp,events,upper,count-1);\\n        return dp[n][count] = Math.max(op,yo);\\n    }\\n    public int bisearch(int events[][],int val){\\n        int top=0,bot=events.length-1;\\n        while(top<bot){\\n            int mid = (bot-top)/2+top;\\n            if(events[mid][0]>val) bot=mid;\\n            else top = mid+1;\\n        }\\n        if(events[bot][0]<=val) return -1;\\n        return bot;\\n    }\\n}\\n//similar question \\n//2555. Maximize Win From Two Segments\\n//prob. same code\\n//answer mentioned in comment in java\\n//https://leetcode.com/problems/maximize-win-from-two-segments/discuss/3144297/C%2B%2B-or-or-DP%2BBS-or-or-Memoization-or-or-Well-Explained-Code",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int dp[][] = new int[events.length][3],output = 0;\\n        for(int row[]:dp) Arrays.fill(row,-1);\\n        Arrays.sort(events,(a,b)->(a[0]-b[0]));\\n        int out =  find(dp,events,0,2);\\n        for(int row[]:events) output = Math.max(output,row[2]);\\n        return Math.max(out,output);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2759972,
                "title": "python-o-n-2-o-nlogn-explained",
                "content": "## **1. BRUTE FORCE APPROACH - O(N^2)**\\n\\nIn Brute Force approach, we just do what the problem asks us to do. We don\\'t care about how efficient this solution is. But if you are able to write a Brute Force Approach, you can think of an Optimized Solution easily.\\n\\nSince we are asked to find two non overlapping events, we can check for that by making sure that the second event starts after the first has finished. Since it is possible that for any ith event, an event with start time greater than end time of ith event can be before it in the list, we have to traverse the whole array from beginning for every event to find a valid event to pair. \\n\\nHence, this approach has an O(N^2) complexity. It will not work for large inputs and we will get TLE.\\n\\n\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        maxSum = 0\\n        \\n        # For each event\\n        for i in range(len(events)): \\n            sum = events[i][2]\\n            \\n            # Try to find the event that can be paired with it to get a maximum sum\\n            for j in range(len(events)):\\n                if i != j and events[j][0] > events[i][1]:\\n                    maxSum = max(maxSum, sum + events[j][2])            \\n            \\n            # This is for the cases when we cannot find any other event with which this event can be paired\\n            # It is also possible that a single event has a higher value than any other valid pair combined\\n            maxSum = max(maxSum, sum)\\n        return maxSum\\n\\t\\t\\n## **2. BINARY SEARCH APPROACH - O(N^2)**\\n\\nWe know that if an algorithm has O(N^2) time complexity and it is not working for large inputs, a better approach is to try to make it at least O(NLogN). \\n\\nConverting that N to LogN complexity means instead of Linear Search in the second for loop, we need to use Binary Search. But to use Binary Search, our array needs to be sorted. \\n \\nNotice that in Brute Force, one issue is that for each event, we have to traverse the list from the beginning to find an event whose start time is greater than the end time of ith event.\\n\\n\\tNow, just think about it - What if our events list is already sorted based on start time?\\n\\n\\tIn that case, if we can find an event that is valid, then all the events after it are also valid because array is sorted. \\n\\t\\n\\tConsider this example ->\\n\\t\\n\\t\\t\\tevents = [[1,3,2],[4,7,3],[5,8,5], [6,4,10]]\\n\\t\\t\\t\\n\\t\\t\\tIf we take the first event => [1,3,2]\\n\\t\\t\\t\\n\\t\\t\\tFor it, start time = 1 and end time = 3\\n\\t\\t\\t\\n\\t\\t\\tIt means, any event that has start time > 3 can be paired with this event.\\n\\t\\t\\t\\n\\t\\t\\tAnd we see that [4,7,3] is a valid event since its start time is 4 and 4 > 3\\n\\t\\t\\t\\n\\t\\t\\tBut since our list is already sorted based on start times, \\n\\t\\t\\tit also means, all events after [4,7,3] are also valid and can be paired with [1,3,2]\\n\\t\\t\\t\\n\\t\\t\\tNow you got the idea, right?\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tSo, all that we need to find is this leftmost event that is valid \\n\\tbecause we know all events after it will be valid as well.\\n\\nOnce we can find such an index, then all that is left to find is what is the maximum possible value in [leftmostindex, end of list] subarray.\\n\\nBut if we try to find that for each event, that again results in an O(N^2) complexity because to find that max value in a certain interval, we again have to do linear scan as values are not sorted.\\n\\nHence, the only option is to find a way to precompute this maximum possible value on the right side of each index such that we can find the maximum value in any range [leftmostindex, end of list] in O(1) time.\\n\\nTherefore, before we even start with Binary Search, we have to precompute the maximum value on the right side for each event.\\n\\n```\\ndef maxTwoEvents(self, events: List[List[int]]) -> int:\\n        maxSum = 0\\n        \\n        n = len(events)\\n        \\n        # For Binary Search, we need Sorting first\\n        # If we apply sort method to events, it will sort the events based on start time\\n        events.sort()\\n        \\n        # Pre compute the maximum value on the right for each event\\n        maxOnRight = [0] * n\\n        \\n        # For last event, there is no event on its right\\n        # So for it, maximum is its value only\\n        maxOnRight[- 1] = events[-1][2]\\n        \\n        for i in range(n - 2, -1, -1): maxOnRight[i] = max(events[i][2], maxOnRight[i + 1])\\n        \\n        # For each event\\n        for i in range(n): \\n            sum = events[i][2]\\n            maxVal = 0\\n\\n            # Now, we can use Binary Search to find the leftmost valid event for ith event\\n            # Because if we can find such an index, then all events after that index are also valid\\n            # Because array is sorted based on start time \\n            # so all events after that index will also have a start time greater than end time of ith event\\n            start = i + 1\\n            end = n - 1\\n            leftmostValid = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # IF mid is a valid event that we can consider pairing\\n                # We can store this index as it may be the leftmost valid index\\n                # But we keep searching on left of mid to find the leftmost if there is any other valid event on left\\n                if events[mid][0] > events[i][1]:\\n                    leftmostValid = mid\\n                    end = mid - 1\\n                    \\n                # If mid itself is not valid, how can any event before mid can be valid?\\n                else: start = mid + 1      \\n                    \\n            # Now, all that we want is what is the maximum value in the [leftmostValid, n - 1] subarray\\n            # No need to find that again because we have precomputed that in the beginning\\n            \\n            if leftmostValid != -1: maxVal = maxOnRight[leftmostValid]\\n                \\n            maxSum = max(maxSum, sum + maxVal)\\n        \\n        return maxSum\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef maxTwoEvents(self, events: List[List[int]]) -> int:\\n        maxSum = 0\\n        \\n        n = len(events)\\n        \\n        # For Binary Search, we need Sorting first\\n        # If we apply sort method to events, it will sort the events based on start time\\n        events.sort()\\n        \\n        # Pre compute the maximum value on the right for each event\\n        maxOnRight = [0] * n\\n        \\n        # For last event, there is no event on its right\\n        # So for it, maximum is its value only\\n        maxOnRight[- 1] = events[-1][2]\\n        \\n        for i in range(n - 2, -1, -1): maxOnRight[i] = max(events[i][2], maxOnRight[i + 1])\\n        \\n        # For each event\\n        for i in range(n): \\n            sum = events[i][2]\\n            maxVal = 0\\n\\n            # Now, we can use Binary Search to find the leftmost valid event for ith event\\n            # Because if we can find such an index, then all events after that index are also valid\\n            # Because array is sorted based on start time \\n            # so all events after that index will also have a start time greater than end time of ith event\\n            start = i + 1\\n            end = n - 1\\n            leftmostValid = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # IF mid is a valid event that we can consider pairing\\n                # We can store this index as it may be the leftmost valid index\\n                # But we keep searching on left of mid to find the leftmost if there is any other valid event on left\\n                if events[mid][0] > events[i][1]:\\n                    leftmostValid = mid\\n                    end = mid - 1\\n                    \\n                # If mid itself is not valid, how can any event before mid can be valid?\\n                else: start = mid + 1      \\n                    \\n            # Now, all that we want is what is the maximum value in the [leftmostValid, n - 1] subarray\\n            # No need to find that again because we have precomputed that in the beginning\\n            \\n            if leftmostValid != -1: maxVal = maxOnRight[leftmostValid]\\n                \\n            maxSum = max(maxSum, sum + maxVal)\\n        \\n        return maxSum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2295748,
                "title": "super-duper-easy-binary-search",
                "content": "int maxTwoEvents(vector<vector<int>>& a) {\\n         map<int,int >mp;\\n        sort(a.begin(),a.end(),greater<vector<int>>());\\n        int mx=0,ans=0;\\n        for(auto &r:a)\\n        {\\n            auto j=mp.lower_bound(r[1]+1);\\n            int v=(j==mp.end()?0:j->second);\\n            mx=max(mx,r[2]);\\n            ans=max(ans,r[2]+v);\\n            mp[r[0]]=mx;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "int maxTwoEvents(vector<vector<int>>& a) {\\n         map<int,int >mp;\\n        sort(a.begin(),a.end(),greater<vector<int>>());\\n        int mx=0,ans=0;\\n        for(auto &r:a)\\n        {\\n            auto j=mp.lower_bound(r[1]+1);\\n            int v=(j==mp.end()?0:j->second);\\n            mx=max(mx,r[2]);\\n            ans=max(ans,r[2]+v);\\n            mp[r[0]]=mx;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2174036,
                "title": "python-solution-dp-o-nlogn",
                "content": "**Dynamic Programming**\\n\\n```Time``` : ```O(nLogn)```\\n```Space``` : ```O(n)```\\n\\n```\\nclass Solution:\\n    def maxTwoEvents(self, A):\\n        A.sort(key = lambda x:x[1])\\n        ans, dp = 0, [(0,0)]\\n        for s,e,v in A:\\n            i = bisect.bisect_left(dp,s,key = lambda x:x[0]) - 1\\n            ans = max(ans, dp[i][1] + v)\\n            if dp[-1][1] < v: dp.append((e,v))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```Time```\n```O(nLogn)```\n```Space```\n```O(n)```\n```\\nclass Solution:\\n    def maxTwoEvents(self, A):\\n        A.sort(key = lambda x:x[1])\\n        ans, dp = 0, [(0,0)]\\n        for s,e,v in A:\\n            i = bisect.bisect_left(dp,s,key = lambda x:x[0]) - 1\\n            ans = max(ans, dp[i][1] + v)\\n            if dp[-1][1] < v: dp.append((e,v))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058327,
                "title": "c-sort-priority-queue",
                "content": "```\\npublic class Solution {\\n    public int MaxTwoEvents(int[][] events) {\\n        var myEvents = events.Select(e => new Event(e[0], e[1], e[2]))\\n            .OrderBy(e => e.start)\\n            .ThenBy(e => e.end);\\n        \\n        var queue = new PriorityQueue<Event, int>(Comparer<int>.Create((x, y) => x - y));\\n        \\n        var res = 0;\\n        var max = 0;\\n        \\n        foreach (var @event in myEvents) {\\n            while(queue.TryPeek(out var nextEvent, out _) && nextEvent.end < @event.start) {\\n                queue.Dequeue();\\n                max = Math.Max(max, nextEvent.value);\\n            }\\n            \\n            res = Math.Max(res, @event.value + max);\\n            queue.Enqueue(@event, @event.end);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\npublic record Event(int start, int end, int value);\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxTwoEvents(int[][] events) {\\n        var myEvents = events.Select(e => new Event(e[0], e[1], e[2]))\\n            .OrderBy(e => e.start)\\n            .ThenBy(e => e.end);\\n        \\n        var queue = new PriorityQueue<Event, int>(Comparer<int>.Create((x, y) => x - y));\\n        \\n        var res = 0;\\n        var max = 0;\\n        \\n        foreach (var @event in myEvents) {\\n            while(queue.TryPeek(out var nextEvent, out _) && nextEvent.end < @event.start) {\\n                queue.Dequeue();\\n                max = Math.Max(max, nextEvent.value);\\n            }\\n            \\n            res = Math.Max(res, @event.value + max);\\n            queue.Enqueue(@event, @event.end);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\npublic record Event(int start, int end, int value);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952278,
                "title": "java-prioirty-queue-beats-98",
                "content": "![image](https://assets.leetcode.com/users/images/7ee02b28-1327-4ea0-8c94-be6b40dd7ad6_1650092045.6712117.png)\\n\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, new Comparator<>() {\\n            @Override\\n            public int compare(int[] event1, int[] event2) {\\n                return Integer.compare(event1[0], event2[0]);\\n            }\\n        });\\n        PriorityQueue<int[]> endPQ = new PriorityQueue<>(new Comparator<>() {\\n            @Override\\n            public int compare(int[] event1, int[] event2) {\\n                return Integer.compare(event1[1], event2[1]);\\n            }\\n        });\\n        int max = 0, answer = 0;\\n        for(int[] event: events) {\\n            while(!endPQ.isEmpty() && endPQ.peek()[1] < event[0]) {\\n                max = Math.max(max, endPQ.poll()[2]);\\n            }\\n            answer = Math.max(answer, max + event[2]);\\n            endPQ.offer(event);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, new Comparator<>() {\\n            @Override\\n            public int compare(int[] event1, int[] event2) {\\n                return Integer.compare(event1[0], event2[0]);\\n            }\\n        });\\n        PriorityQueue<int[]> endPQ = new PriorityQueue<>(new Comparator<>() {\\n            @Override\\n            public int compare(int[] event1, int[] event2) {\\n                return Integer.compare(event1[1], event2[1]);\\n            }\\n        });\\n        int max = 0, answer = 0;\\n        for(int[] event: events) {\\n            while(!endPQ.isEmpty() && endPQ.peek()[1] < event[0]) {\\n                max = Math.max(max, endPQ.poll()[2]);\\n            }\\n            answer = Math.max(answer, max + event[2]);\\n            endPQ.offer(event);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882782,
                "title": "c-memoization-code-using-simple-upper-bound-function-easy-understanding",
                "content": "```\\nint dp[100005][3];\\n    vector<int> vec;\\n    \\n    int func( vector<vector<int>> &events , int i , int choose , int n)\\n    {\\n        if(i==n)\\n        {\\n            return 0;\\n        }\\n        \\n        if(choose>=2)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[i][choose]!=-1)\\n        {\\n            return dp[i][choose];\\n        }\\n        \\n        int val1= func(events , i+1 , choose , n);\\n        \\n        int idx=upper_bound(vec.begin(),vec.end() , events[i][1])-vec.begin();\\n\\t\\t\\n        // upper bound will be implemented in sorted array only \\n        // as we have to calculate the starting index of that events[i][1] \\n        // so we will make the vec array \\n\\t\\t\\n        int val2= events[i][2] + func(events , idx , choose + 1 , n);\\n\\t\\t\\n        // This is simple knapsack , take it or not take it \\n        // as we need only at max 2 takes , so we make a choose variable \\n        // intially choose = 0 , if ( choose >=2)  return 0\\n\\t\\t\\n      return  dp[i][choose]=max(val1 , val2);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n         \\n        int n=events.size();\\n        \\n        sort(events.begin(),events.end());\\n        \\n        for(int i=0;i<events.size();i++)\\n        {\\n            vec.push_back(events[i][0]);\\n        }\\n        \\n         memset( dp , -1 , sizeof(dp));\\n        \\n        return func(events ,0 , 0,n);\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nint dp[100005][3];\\n    vector<int> vec;\\n    \\n    int func( vector<vector<int>> &events , int i , int choose , int n)\\n    {\\n        if(i==n)\\n        {\\n            return 0;\\n        }\\n        \\n        if(choose>=2)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[i][choose]!=-1)\\n        {\\n            return dp[i][choose];\\n        }\\n        \\n        int val1= func(events , i+1 , choose , n);\\n        \\n        int idx=upper_bound(vec.begin(),vec.end() , events[i][1])-vec.begin();\\n\\t\\t\\n        // upper bound will be implemented in sorted array only \\n        // as we have to calculate the starting index of that events[i][1] \\n        // so we will make the vec array \\n\\t\\t\\n        int val2= events[i][2] + func(events , idx , choose + 1 , n);\\n\\t\\t\\n        // This is simple knapsack , take it or not take it \\n        // as we need only at max 2 takes , so we make a choose variable \\n        // intially choose = 0 , if ( choose >=2)  return 0\\n\\t\\t\\n      return  dp[i][choose]=max(val1 , val2);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n         \\n        int n=events.size();\\n        \\n        sort(events.begin(),events.end());\\n        \\n        for(int i=0;i<events.size();i++)\\n        {\\n            vec.push_back(events[i][0]);\\n        }\\n        \\n         memset( dp , -1 , sizeof(dp));\\n        \\n        return func(events ,0 , 0,n);\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827656,
                "title": "simple-solution-in-java-binary-search",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n        \\n        int ans = 0;\\n        int n = events.length;\\n        int[] dp = new int[n];\\n        for(int i=0; i<n; i++){\\n            dp[i] = events[i][2];\\n            ans = Math.max(ans, events[i][2]);\\n            \\n            int prevPosIndex = findPrevPosIndex(i - 1, events);\\n            if(prevPosIndex != -1){\\n                ans = Math.max(ans, dp[i] + dp[prevPosIndex]);\\n            }\\n            \\n            // Update \\n            dp[i] = Math.max(dp[i], i >= 1 ? dp[i-1] : 0);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findPrevPosIndex(int index, int[][] events){\\n        if(index == -1) return -1;\\n        \\n        int ans = -1;\\n        \\n        int limit = events[index+1][0];\\n        int s = 0;\\n        int e = index;\\n        while(s <= e){\\n            int m = s + (e-s)/2;\\n            if(events[m][1] < limit){\\n                ans = m;\\n                s = m+1;\\n            }else{\\n                e = m-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n        \\n        int ans = 0;\\n        int n = events.length;\\n        int[] dp = new int[n];\\n        for(int i=0; i<n; i++){\\n            dp[i] = events[i][2];\\n            ans = Math.max(ans, events[i][2]);\\n            \\n            int prevPosIndex = findPrevPosIndex(i - 1, events);\\n            if(prevPosIndex != -1){\\n                ans = Math.max(ans, dp[i] + dp[prevPosIndex]);\\n            }\\n            \\n            // Update \\n            dp[i] = Math.max(dp[i], i >= 1 ? dp[i-1] : 0);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int findPrevPosIndex(int index, int[][] events){\\n        if(index == -1) return -1;\\n        \\n        int ans = -1;\\n        \\n        int limit = events[index+1][0];\\n        int s = 0;\\n        int e = index;\\n        while(s <= e){\\n            int m = s + (e-s)/2;\\n            if(events[m][1] < limit){\\n                ans = m;\\n                s = m+1;\\n            }else{\\n                e = m-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816813,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int binarySearch(int lo, int hi, int key, vector<vector<int>>& events){\\n           int idx = -1;\\n           while(lo <= hi){\\n               int mid = lo + (hi - lo) / 2;\\n               if(events[mid][0] > key){\\n                   idx = mid;\\n                   hi = mid - 1;\\n               }\\n               else lo = mid + 1;\\n           }\\n        return idx;\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n         int n = events.size();\\n         sort(events.begin(), events.end());\\n         // its not actually dp, its just used to store the pre-computed maximum values\\n         int dp[n];\\n         dp[n-1] = events[n-1][2];\\n         for(int i=n-2 ; i>=0 ; i--){\\n             dp[i] = max(dp[i+1], events[i][2]);\\n         }\\n        \\n         int mx_sum = 0;\\n         for(int i = 0; i<n; i++){\\n             int idx = binarySearch(i,n-1,events[i][1], events);\\n             if(idx != -1) {\\n                 mx_sum = max(mx_sum, events[i][2] + dp[idx]);\\n             }\\n             mx_sum = max(mx_sum, events[i][2]);\\n         }\\n        return mx_sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int binarySearch(int lo, int hi, int key, vector<vector<int>>& events){\\n           int idx = -1;\\n           while(lo <= hi){\\n               int mid = lo + (hi - lo) / 2;\\n               if(events[mid][0] > key){\\n                   idx = mid;\\n                   hi = mid - 1;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1642280,
                "title": "java-easy-to-understand-min-pq-sort",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        //First sort all events by start time. If start time of two events are equal, sort them by end time.\\n        Arrays.sort(events, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        // Then take a priority queue that takes an array containing [endtime, value]. Priority queue will sort elements on the basis of end time.\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int result = 0;\\n        int maxValue = 0;\\n        \\n        // Iterate through events, for each event e, \\n        for(int i = 0; i < events.length; i++) {\\n            int startTime = events[i][0];\\n            \\n            // calculate maximum value from all events that ends before e[0] (i.e. start time). Let\\'s store this value in maxVal variable.\\n            while(!queue.isEmpty() && queue.peek()[1] < startTime) {\\n                int []current = queue.poll();\\n                maxValue = Math.max(maxValue, current[2]);\\n            }\\n            \\n            // Now answer will be ans = max(ans, e[2] + maxVal)\\n            result = Math.max(result, maxValue + events[i][2]);\\n            queue.add(events[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        //First sort all events by start time. If start time of two events are equal, sort them by end time.\\n        Arrays.sort(events, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        // Then take a priority queue that takes an array containing [endtime, value]. Priority queue will sort elements on the basis of end time.\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int result = 0;\\n        int maxValue = 0;\\n        \\n        // Iterate through events, for each event e, \\n        for(int i = 0; i < events.length; i++) {\\n            int startTime = events[i][0];\\n            \\n            // calculate maximum value from all events that ends before e[0] (i.e. start time). Let\\'s store this value in maxVal variable.\\n            while(!queue.isEmpty() && queue.peek()[1] < startTime) {\\n                int []current = queue.poll();\\n                maxValue = Math.max(maxValue, current[2]);\\n            }\\n            \\n            // Now answer will be ans = max(ans, e[2] + maxVal)\\n            result = Math.max(result, maxValue + events[i][2]);\\n            queue.add(events[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640920,
                "title": "c-sorting-binary-search",
                "content": "```\\n\\nint binary_search(vector<vector<int>>& events, int index)\\n{\\n    int  i = index+1;\\n    int  j = events.size()-1;\\n    while(i<j)\\n    {\\n        int mid  = i+(j-i)/2;\\n        \\n        int x1= events[index][0];\\n        int y1 = events[index][1];\\n        int x2 = events[mid][0];\\n        int y2 =events[mid][1];\\n        if( x2>y1)\\n          j = mid;\\n       else\\n           i = mid+1;\\n    }\\n    return j;\\n}\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events)\\n    {\\n       sort(events.begin(),events.end()); \\n    \\n       int n= events.size();\\n       vector<int>right(n,0);\\n        right[n-1] = events[n-1][2];\\n       for(int i=n-2;i>=0;i--)\\n       {\\n           \\n         right[i] = max(right[i+1], events[i][2]);   \\n       }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           int ii = binary_search(events, i);     \\n            if(events[ii][0]>events[i][0] && events[ii][1]> events[i][1] && events[ii][0]>events[i][1])\\n            {\\n                ans = max(ans, events[i][2]+ right[ii]);\\n            }\\n            else\\n                ans = max(ans, events[i][2]);            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint binary_search(vector<vector<int>>& events, int index)\\n{\\n    int  i = index+1;\\n    int  j = events.size()-1;\\n    while(i<j)\\n    {\\n        int mid  = i+(j-i)/2;\\n        \\n        int x1= events[index][0];\\n        int y1 = events[index][1];\\n        int x2 = events[mid][0];\\n        int y2 =events[mid][1];\\n        if( x2>y1)\\n          j = mid;\\n       else\\n           i = mid+1;\\n    }\\n    return j;\\n}\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events)\\n    {\\n       sort(events.begin(),events.end()); \\n    \\n       int n= events.size();\\n       vector<int>right(n,0);\\n        right[n-1] = events[n-1][2];\\n       for(int i=n-2;i>=0;i--)\\n       {\\n           \\n         right[i] = max(right[i+1], events[i][2]);   \\n       }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           int ii = binary_search(events, i);     \\n            if(events[ii][0]>events[i][0] && events[ii][1]> events[i][1] && events[ii][0]>events[i][1])\\n            {\\n                ans = max(ans, events[i][2]+ right[ii]);\\n            }\\n            else\\n                ans = max(ans, events[i][2]);            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573639,
                "title": "c-binarysearch",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& n ,int t)\\n    {\\n        int l=0 ,h= n.size();\\n        int m;\\n        while (l<h)\\n        {\\n            m=(l+h)/2;\\n            if (n[m][0]>t)h=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int arr[events.size()];\\n        int v=0;\\n        for (int i=events.size()-1;i>-1;i--)\\n        {\\n            v=max(v,events[i][2]);\\n            arr[i]=v;\\n        }\\n        int b=0;\\n        for (int i=0;i<events.size();i++)\\n        {\\n            int z=find(events,events[i][1]);\\n            if (z<events.size())b=max(b,events[i][2]+arr[z]);\\n            else b=max(b,events[i][2]);\\n        }\\n    return b;}\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& n ,int t)\\n    {\\n        int l=0 ,h= n.size();\\n        int m;\\n        while (l<h)\\n        {\\n            m=(l+h)/2;\\n            if (n[m][0]>t)h=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int arr[events.size()];\\n        int v=0;\\n        for (int i=events.size()-1;i>-1;i--)\\n        {\\n            v=max(v,events[i][2]);\\n            arr[i]=v;\\n        }\\n        int b=0;\\n        for (int i=0;i<events.size();i++)\\n        {\\n            int z=find(events,events[i][1]);\\n            if (z<events.size())b=max(b,events[i][2]+arr[z]);\\n            else b=max(b,events[i][2]);\\n        }\\n    return b;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571119,
                "title": "js",
                "content": "```\\nvar maxTwoEvents = function(a) {\\n    var dp = []\\n    a.forEach(([f,t,val])=>{\\n        dp.push({\\n            time:f,\\n            val,\\n            att:1\\n        })\\n        dp.push({\\n            time:t,\\n            val,\\n            att:2\\n        })\\n    })\\n    dp.sort((a,b)=>{\\n        return a.time==b.time? a.att-b.att:a.time-b.time\\n    })\\n    var preMax = 0, res = 0\\n    dp.forEach(e=>{\\n        if(e.att==2) {\\n            preMax = Math.max(preMax, e.val)\\n        } else {\\n            res = Math.max(res, e.val+preMax)\\n        }\\n    })\\n    return res\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxTwoEvents = function(a) {\\n    var dp = []\\n    a.forEach(([f,t,val])=>{\\n        dp.push({\\n            time:f,\\n            val,\\n            att:1\\n        })\\n        dp.push({\\n            time:t,\\n            val,\\n            att:2\\n        })\\n    })\\n    dp.sort((a,b)=>{\\n        return a.time==b.time? a.att-b.att:a.time-b.time\\n    })\\n    var preMax = 0, res = 0\\n    dp.forEach(e=>{\\n        if(e.att==2) {\\n            preMax = Math.max(preMax, e.val)\\n        } else {\\n            res = Math.max(res, e.val+preMax)\\n        }\\n    })\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557005,
                "title": "python-easy-with-deque-no-heap-96",
                "content": "```\\nclass Solution:\\n    def maxTwoEvents(self, events):\\n        q = deque()\\n        events.sort(key=lambda x:x[0])\\n        tmp = sorted(events, key=lambda x:x[1])    # we\\'re sorting it with ending time, because we want event with smallest ending time in the queue\\n        mx = 0\\n        ans = 0\\n\\t\\t\\n        for i in range(len(events)):\\n            k = i                        # so we know which one to add to the queue\\n\\t\\t\\t\\n            while q and events[i][0] > q[0][1]:\\n                mx = max(mx, q[0][2])\\n                q.popleft()\\n\\t\\t\\t\\t\\n            ans = max(ans, mx+events[i][2])\\n            q.append(tmp[k]) # maintaining top event with smallest ending time ( by appending right )\\n\\t\\t\\t\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events):\\n        q = deque()\\n        events.sort(key=lambda x:x[0])\\n        tmp = sorted(events, key=lambda x:x[1])    # we\\'re sorting it with ending time, because we want event with smallest ending time in the queue\\n        mx = 0\\n        ans = 0\\n\\t\\t\\n        for i in range(len(events)):\\n            k = i                        # so we know which one to add to the queue\\n\\t\\t\\t\\n            while q and events[i][0] > q[0][1]:\\n                mx = max(mx, q[0][2])\\n                q.popleft()\\n\\t\\t\\t\\t\\n            ans = max(ans, mx+events[i][2])\\n            q.append(tmp[k]) # maintaining top event with smallest ending time ( by appending right )\\n\\t\\t\\t\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1555579,
                "title": "c-easy-to-understand-priority-queue-min-heap",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass comp{\\n    public:\\n  bool operator()(pair<int,int> &a,pair<int,int> &b)\\n  {\\n      return a.first>b.first;\\n  }\\n};\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int ans=0;\\n        int max_till_before=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp > pq; // this will store the ending time and the value respectively\\n        sort(events.begin(),events.end());\\n        for(int i=0;i<events.size();i++)\\n        {\\n         while(!pq.empty()&&events[i][0]>pq.top().first) \\n         {\\n             max_till_before=max(max_till_before,pq.top().second);\\n             pq.pop();\\n         }\\n             ans=max(ans,events[i][2]+max_till_before);\\n           pq.push({events[i][1],events[i][2]}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass comp{\\n    public:\\n  bool operator()(pair<int,int> &a,pair<int,int> &b)\\n  {\\n      return a.first>b.first;\\n  }\\n};\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int ans=0;\\n        int max_till_before=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp > pq; // this will store the ending time and the value respectively\\n        sort(events.begin(),events.end());\\n        for(int i=0;i<events.size();i++)\\n        {\\n         while(!pq.empty()&&events[i][0]>pq.top().first) \\n         {\\n             max_till_before=max(max_till_before,pq.top().second);\\n             pq.pop();\\n         }\\n             ans=max(ans,events[i][2]+max_till_before);\\n           pq.push({events[i][1],events[i][2]}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551139,
                "title": "java-sort-prefix-suffix-max-treemap-vs-priorityqueue-o-nlogn",
                "content": "Two O(NlogN) approaches 1(a/b) using prefix/suffix max tree map, 2. using priority queue\\n\\nApproach 1a. **prefix max**\\n1. create a Prefix Max value tree map, so that we can look up the max value for events that ended before a certain start time\\n2. iterate through events  and look up the complementary, max event that fits before the current event from the tree map (using floorKey, essentially binary search)\\n```\\nstatic int START=0, END=1, VALUE=2;\\npublic int maxTwoEvents(int[][] events) {\\n\\t// sorted by end time\\n\\tArrays.sort(events, (a,b)->a[END]-b[END]);\\n\\t// iterate forward and calculate prefix max value: the most valuable event ending <= the given end time\\n\\tint maxValue= 0;\\n\\tTreeMap<Integer,Integer> pMax= new TreeMap<>();\\n\\tfor(int[] e:events)\\n\\t\\tif(e[VALUE]>maxValue) pMax.put(e[END], maxValue= e[VALUE]);\\n\\t//iterate all events and look up the max value for 2nd event which can fit *before* the current event using the prefixMax map\\n\\tint maxTwo= 0;\\n\\tfor(int[] e:events){\\n\\t\\tInteger pKey= pMax.floorKey(e[START]-1);\\n\\t\\tmaxTwo= Math.max(maxTwo, e[VALUE] + (pKey!=null ? pMax.get(pKey) : 0));\\n\\t}\\n\\treturn maxTwo;\\n}\\n```\\nApproach 1b. **suffix max**\\nEssentially same as 1a, except now we\\'re looking up the second event that fits after the current one.\\n```\\npublic int maxTwoEvents(int[][] events) {\\n\\tArrays.sort(events, (a,b)->a[START]-b[START]);\\n\\tint maxValue= 0, n= events.length;\\n\\tTreeMap<Integer,Integer> sMax= new TreeMap<>();\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t\\tif(events[i][VALUE]>maxValue) sMax.put(events[i][START], maxValue= events[i][VALUE]);\\n\\tint maxTwo= 0;\\n\\tfor(int[] e:events){\\n\\t\\tInteger sKey= sMax.ceilingKey(e[END]+1);\\n\\t\\tmaxTwo= Math.max(maxTwo, e[VALUE] + (sKey!=null ? sMax.get(sKey) : 0));\\n\\t}\\n\\treturn maxTwo;\\n}\\n```\\nApproach 2. **priority queue**\\nWe iterate over all events sorted by start time, and we are keeping track of max value for events that already ended - using a priority queue in the meantime to order events that are in progress by earliest end time.\\n```\\npublic int maxTwoEvents(int[][] events) {\\n\\t// events sorted by start time\\n\\tArrays.sort(events, (a,b)->a[START]-b[START]);\\n\\t// priority queue of already started events sorted by end time\\n\\tPriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->a[END]-b[END]);\\n\\t// max value of an already completed event, and of up-to two events\\n\\tint maxOne= 0, maxTwo= 0;\\n\\tfor(int[] e:events){\\n\\t\\twhile(!pq.isEmpty() && pq.peek()[END]<e[START])\\n\\t\\t\\tmaxOne= Math.max(maxOne, pq.poll()[VALUE]);\\n\\t\\tmaxTwo= Math.max(maxTwo, maxOne + e[VALUE]);\\n\\t\\tpq.add(e);\\n\\t}\\n\\treturn maxTwo;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int START=0, END=1, VALUE=2;\\npublic int maxTwoEvents(int[][] events) {\\n\\t// sorted by end time\\n\\tArrays.sort(events, (a,b)->a[END]-b[END]);\\n\\t// iterate forward and calculate prefix max value: the most valuable event ending <= the given end time\\n\\tint maxValue= 0;\\n\\tTreeMap<Integer,Integer> pMax= new TreeMap<>();\\n\\tfor(int[] e:events)\\n\\t\\tif(e[VALUE]>maxValue) pMax.put(e[END], maxValue= e[VALUE]);\\n\\t//iterate all events and look up the max value for 2nd event which can fit *before* the current event using the prefixMax map\\n\\tint maxTwo= 0;\\n\\tfor(int[] e:events){\\n\\t\\tInteger pKey= pMax.floorKey(e[START]-1);\\n\\t\\tmaxTwo= Math.max(maxTwo, e[VALUE] + (pKey!=null ? pMax.get(pKey) : 0));\\n\\t}\\n\\treturn maxTwo;\\n}\\n```\n```\\npublic int maxTwoEvents(int[][] events) {\\n\\tArrays.sort(events, (a,b)->a[START]-b[START]);\\n\\tint maxValue= 0, n= events.length;\\n\\tTreeMap<Integer,Integer> sMax= new TreeMap<>();\\n\\tfor(int i=n-1; i>=0; i--)\\n\\t\\tif(events[i][VALUE]>maxValue) sMax.put(events[i][START], maxValue= events[i][VALUE]);\\n\\tint maxTwo= 0;\\n\\tfor(int[] e:events){\\n\\t\\tInteger sKey= sMax.ceilingKey(e[END]+1);\\n\\t\\tmaxTwo= Math.max(maxTwo, e[VALUE] + (sKey!=null ? sMax.get(sKey) : 0));\\n\\t}\\n\\treturn maxTwo;\\n}\\n```\n```\\npublic int maxTwoEvents(int[][] events) {\\n\\t// events sorted by start time\\n\\tArrays.sort(events, (a,b)->a[START]-b[START]);\\n\\t// priority queue of already started events sorted by end time\\n\\tPriorityQueue<int[]> pq= new PriorityQueue<>((a,b)->a[END]-b[END]);\\n\\t// max value of an already completed event, and of up-to two events\\n\\tint maxOne= 0, maxTwo= 0;\\n\\tfor(int[] e:events){\\n\\t\\twhile(!pq.isEmpty() && pq.peek()[END]<e[START])\\n\\t\\t\\tmaxOne= Math.max(maxOne, pq.poll()[VALUE]);\\n\\t\\tmaxTwo= Math.max(maxTwo, maxOne + e[VALUE]);\\n\\t\\tpq.add(e);\\n\\t}\\n\\treturn maxTwo;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549550,
                "title": "c-with-explanation-sort-binary-search",
                "content": "Sort end time. Then loop all event. And record maxValue. Next loop all event. Using binary search to find the lagest index end time < current event first time. For current event, including current event, maxValue = maxValue[largest index] + current event value.  Time  o(nlogn)  Space o(n) \\n```\\nstruct cmp\\n{\\n    bool operator()(vector<int>& node1, vector<int>& node2)\\n    {\\n        if(node1[1]==node2[1])\\n            return node1[0] < node2[0]; \\n        return node1[1] < node2[1];    \\n    }\\n    \\n}; \\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        // \\n        // first sort end time. \\n        // loop all. record maxVal. \\n        // loop all. check event first. And find max end time that less than first time. And check maxVal \\n        // ret = currentEvent + maxVal.\\n        sort(events.begin(), events.end(), cmp()); \\n        vector<int> maxVal(events.size());\\n        int maxValue =0;    \\n        for(int i=0; i< events.size(); i++)\\n        {\\n            maxValue = max(maxValue, events[i][2]);\\n            maxVal[i] = maxValue; \\n        }\\n        int ret =0; \\n        for(int i=0; i<  events.size(); i++)\\n        {\\n           int index = binarySearch(events, 0, i-1, events[i][0]) ; \\n            if(index>=0)\\n            {\\n                ret = max(ret, events[i][2] + maxVal[index]);\\n            }\\n            else\\n                ret = max(ret, events[i][2]); \\n        } \\n        \\n        return ret; \\n    }\\n    ///  Find maxValue<target  \\n    int binarySearch(vector<vector<int>>& events, int left, int right, int target)\\n    {\\n        while(left<=right)\\n        {\\n            int middle = left + (right - left)/2; \\n            if(events[middle][1]>=target)\\n            {\\n                right = middle-1; \\n            }\\n            else\\n            {\\n                left = middle+1; \\n            }\\n        }\\n        // [right left]    left>=target right<target\\n        return right; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct cmp\\n{\\n    bool operator()(vector<int>& node1, vector<int>& node2)\\n    {\\n        if(node1[1]==node2[1])\\n            return node1[0] < node2[0]; \\n        return node1[1] < node2[1];    \\n    }\\n    \\n}; \\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        // \\n        // first sort end time. \\n        // loop all. record maxVal. \\n        // loop all. check event first. And find max end time that less than first time. And check maxVal \\n        // ret = currentEvent + maxVal.\\n        sort(events.begin(), events.end(), cmp()); \\n        vector<int> maxVal(events.size());\\n        int maxValue =0;    \\n        for(int i=0; i< events.size(); i++)\\n        {\\n            maxValue = max(maxValue, events[i][2]);\\n            maxVal[i] = maxValue; \\n        }\\n        int ret =0; \\n        for(int i=0; i<  events.size(); i++)\\n        {\\n           int index = binarySearch(events, 0, i-1, events[i][0]) ; \\n            if(index>=0)\\n            {\\n                ret = max(ret, events[i][2] + maxVal[index]);\\n            }\\n            else\\n                ret = max(ret, events[i][2]); \\n        } \\n        \\n        return ret; \\n    }\\n    ///  Find maxValue<target  \\n    int binarySearch(vector<vector<int>>& events, int left, int right, int target)\\n    {\\n        while(left<=right)\\n        {\\n            int middle = left + (right - left)/2; \\n            if(events[middle][1]>=target)\\n            {\\n                right = middle-1; \\n            }\\n            else\\n            {\\n                left = middle+1; \\n            }\\n        }\\n        // [right left]    left>=target right<target\\n        return right; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549446,
                "title": "c-2054-two-best-non-overlapping-events",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(), events.end(), [&](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];}); \\n        int ans = 0, prefix = 0; \\n        map<int, int> mp; \\n        for (auto& event : events) {\\n            int t = event[0], tt = event[1], val = event[2]; \\n            prefix = max(prefix, val); \\n            mp[tt] = prefix; \\n            auto it = mp.lower_bound(t); \\n            if (it != mp.begin()) val += prev(it)->second; \\n            ans = max(ans, val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(), events.end(), [&](auto& lhs, auto& rhs) {return lhs[1] < rhs[1];}); \\n        int ans = 0, prefix = 0; \\n        map<int, int> mp; \\n        for (auto& event : events) {\\n            int t = event[0], tt = event[1], val = event[2]; \\n            prefix = max(prefix, val); \\n            mp[tt] = prefix; \\n            auto it = mp.lower_bound(t); \\n            if (it != mp.begin()) val += prev(it)->second; \\n            ans = max(ans, val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549443,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can use a concept similar to [Kadane\\'s algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem), ie. keep track of the `last` maximum non-overlapping interval\\'s `cost` which we can append onto the next interval\\'s `cost` by preprocessing the input array `A` to be sorted as events `E` by index (and in case of index tie, we sort by end first, begin second to process the end of the previous non-overlapping interval before the current interval).\\n\\n* At each begin index, we track the `best` maximum solution as the `last` maximum non-overlapping interval\\'s `cost` plus the current inverval\\'s `cost`.\\n* At each end index, we track the `last` maximum non-overlapping interval\\'s `cost`.\\n\\nNote: during preprocessing transformation of `A` into `E`, we track each interval `i..j` as `i..j + 1` in order for adjacent intervals to be non-inclusive (ie. the begin of the next interval cannot start at the end of the previous interval)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxTwoEvents(A: Array<IntArray>): Int {\\n        var E = mutableListOf<Triple<Int, Int, Int>>() // index, isEnd (0/1), value\\n        for ((i, j, k) in A) {  // interval i..j of value k\\n            E.add(Triple(i, 1, k))       // 1 == beg at i\\n            E.add(Triple(j + 1, 0, k))   // 0 == end at j + 1 ->  to process end of previous before start of current\\n        }\\n        E.sortWith(Comparator{ a: Triple<Int, Int, Int>, b: Triple<Int, Int, Int> -> if (a.first != b.first) a.first.compareTo(b.first) else a.second.compareTo(b.second) }) // sort by index i,j and break ties by end first beg second\\n        var (last, best) = listOf(0, 0)\\n        for ((_, isStart, cost) in E)\\n            if (isStart == 1)\\n                best = Math.max(best, last + cost)\\n            else\\n                last = Math.max(last, cost)\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxTwoEvents = (A, last = 0, best = 0) => {\\n    let E = [];\\n    for (let [i, j, k] of A) {\\n        E.push([i, 1, k]);      // 1 == beg at i\\n        E.push([j + 1, 0, k]);  // 0 == end at j + 1\\n    }\\n    E.sort((a, b) => a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]); // sort first by index, break ties as end first beg second\\n    for (let [_, isStart, cost] of E) {\\n        if (isStart)\\n            best = Math.max(best, last + cost);\\n        else\\n            last = Math.max(last, cost);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxTwoEvents(self, A: List[List[int]], last = 0, best = 0) -> int:\\n        E = []\\n        for i, j, k in A:\\n            E.append([i, 1, k])      # 1 == beg at i\\n            E.append([j + 1, 0, k])  # 0 == end at j + 1\\n        E.sort(key = cmp_to_key(lambda a, b: a[0] - b[0] if a[0] != b[0] else a[1] - b[1]))  # sort by index, break ties end first, beg second\\n        for _, isStart, cost in E:\\n            if isStart:\\n                best = max(best, last + cost)\\n            else:\\n                last = max(last, cost)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Event = tuple<int, int, int>;\\n    using Events = vector<Event>;\\n    int maxTwoEvents(VVI& A, int last = 0, int best = 0, Events E = {}) {\\n        for (auto& ev: A) {\\n            auto [i, j, k] = tie(ev[0], ev[1], ev[2]);\\n            E.emplace_back(i, 1, k);      // 1 == beg at index i\\n            E.emplace_back(j + 1, 0, k);  // 0 == end at index j + 1\\n        }\\n        sort(E.begin(), E.end(), [](auto& a, auto& b) {\\n            auto [i1, isStart1, _1] = a;\\n            auto [i2, isStart2, _2] = b;\\n            return i1 != i2 ? i1 < i2 : isStart2 < isStart1;  // sort by index, break ties by end first, beg second\\n        });\\n        for (auto [_, isStart, cost]: E)\\n            if (isStart)\\n                best = max(best, last + cost);\\n            else\\n                last = max(last, cost);\\n        return best;\\n    }\\n};\\n```\\n\\n---\\n\\nSame idea as above, but instead of transforming all interval endpoints into an array `E`, we can store the begin and end of each interval separately.  Then for each i<sup>th</sup> index, we can process the end of the previous interval before the begin of the current interval.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxTwoEvents(A: Array<IntArray>): Int {\\n        var (beg, end) = listOf(mutableMapOf<Int, MutableList<Int>>(), mutableMapOf<Int, MutableList<Int>>())\\n        var P = mutableSetOf<Int>()\\n        for ((i, j_, k) in A) {\\n            var j = j_ + 1  // \\u2B50\\uFE0F i..j cannot overlap\\n            if (!beg.contains(i)) beg[i] = mutableListOf<Int>()\\n            if (!beg.contains(j)) beg[j] = mutableListOf<Int>()\\n            if (!end.contains(i)) end[i] = mutableListOf<Int>()\\n            if (!end.contains(j)) end[j] = mutableListOf<Int>()\\n            beg[i]!!.add(k)\\n            end[j]!!.add(k)\\n            P.add(i)\\n            P.add(j)\\n        }\\n        var order = P.toMutableList();\\n        order.sort()\\n        var (pre, best) = listOf(0, 0)\\n        for (i in order) {\\n            for (cur in end[i]!!)\\n                pre = Math.max(pre, cur)\\n            for (cur in beg[i]!!)\\n                best = Math.max(best, pre + cur)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxTwoEvents = (A, beg = new Map(), end = new Map(), P = new Set()) => {\\n    for (let [i, j, k] of A) {\\n        ++j;  // \\u2B50\\uFE0F i..j cannot overlap\\n        if (!beg.has(i)) beg.set(i, []);\\n        if (!beg.has(j)) beg.set(j, []);\\n        if (!end.has(i)) end.set(i, []);\\n        if (!end.has(j)) end.set(j, []);\\n        beg.get(i).push(k);\\n        end.get(j).push(k);\\n        P.add(i);\\n        P.add(j);\\n    }\\n    P = [...P].sort((a, b) => a - b);\\n    let [pre, best] = [0, 0];\\n    for (let i of P) {\\n        for (let cur of end.get(i))\\n            pre = Math.max(pre, cur);\\n        for (let cur of beg.get(i))\\n            best = Math.max(best, pre + cur);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxTwoEvents(self, A: List[List[int]]) -> int:\\n        beg, end = {}, {}\\n        P = set()\\n        for i, j, k in A:\\n            j += 1 # \\u2B50\\uFE0F i..j cannot overlap\\n            if i not in beg: beg[i] = []\\n            if j not in beg: beg[j] = []\\n            if i not in end: end[i] = []\\n            if j not in end: end[j] = []\\n            beg[i].append(k)\\n            end[j].append(k)\\n            P.add(i)\\n            P.add(j)\\n        pre, best = 0, 0\\n        for i in sorted(list(P)):\\n            for cur in end[i]:\\n                pre = max(pre, cur)\\n            for cur in beg[i]:\\n                best = max(best, pre + cur)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Points = set<int>;\\n    using Map = unordered_map<int, VI>;\\n    int maxTwoEvents(VVI& A, Points P = {}, Map beg = {}, Map end = {}) {\\n        for (auto& e: A) {\\n            auto [i, j, k] = tie(e[0], e[1], e[2]);\\n            ++j; // \\u2B50\\uFE0F i..j cannot overlap\\n            beg[i].push_back(k);\\n            end[j].push_back(k);\\n            P.insert(i);\\n            P.insert(j);\\n        }\\n        auto [pre, best] = make_tuple(0, 0);\\n        for (auto i: P) {\\n            for (auto cur: end[i])\\n                pre = max(pre, cur);\\n            for (auto cur: beg[i])\\n                best = max(best, pre + cur);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxTwoEvents(A: Array<IntArray>): Int {\\n        var E = mutableListOf<Triple<Int, Int, Int>>() // index, isEnd (0/1), value\\n        for ((i, j, k) in A) {  // interval i..j of value k\\n            E.add(Triple(i, 1, k))       // 1 == beg at i\\n            E.add(Triple(j + 1, 0, k))   // 0 == end at j + 1 ->  to process end of previous before start of current\\n        }\\n        E.sortWith(Comparator{ a: Triple<Int, Int, Int>, b: Triple<Int, Int, Int> -> if (a.first != b.first) a.first.compareTo(b.first) else a.second.compareTo(b.second) }) // sort by index i,j and break ties by end first beg second\\n        var (last, best) = listOf(0, 0)\\n        for ((_, isStart, cost) in E)\\n            if (isStart == 1)\\n                best = Math.max(best, last + cost)\\n            else\\n                last = Math.max(last, cost)\\n        return best\\n    }\\n}\\n```\n```\\nlet maxTwoEvents = (A, last = 0, best = 0) => {\\n    let E = [];\\n    for (let [i, j, k] of A) {\\n        E.push([i, 1, k]);      // 1 == beg at i\\n        E.push([j + 1, 0, k]);  // 0 == end at j + 1\\n    }\\n    E.sort((a, b) => a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]); // sort first by index, break ties as end first beg second\\n    for (let [_, isStart, cost] of E) {\\n        if (isStart)\\n            best = Math.max(best, last + cost);\\n        else\\n            last = Math.max(last, cost);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def maxTwoEvents(self, A: List[List[int]], last = 0, best = 0) -> int:\\n        E = []\\n        for i, j, k in A:\\n            E.append([i, 1, k])      # 1 == beg at i\\n            E.append([j + 1, 0, k])  # 0 == end at j + 1\\n        E.sort(key = cmp_to_key(lambda a, b: a[0] - b[0] if a[0] != b[0] else a[1] - b[1]))  # sort by index, break ties end first, beg second\\n        for _, isStart, cost in E:\\n            if isStart:\\n                best = max(best, last + cost)\\n            else:\\n                last = max(last, cost)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Event = tuple<int, int, int>;\\n    using Events = vector<Event>;\\n    int maxTwoEvents(VVI& A, int last = 0, int best = 0, Events E = {}) {\\n        for (auto& ev: A) {\\n            auto [i, j, k] = tie(ev[0], ev[1], ev[2]);\\n            E.emplace_back(i, 1, k);      // 1 == beg at index i\\n            E.emplace_back(j + 1, 0, k);  // 0 == end at index j + 1\\n        }\\n        sort(E.begin(), E.end(), [](auto& a, auto& b) {\\n            auto [i1, isStart1, _1] = a;\\n            auto [i2, isStart2, _2] = b;\\n            return i1 != i2 ? i1 < i2 : isStart2 < isStart1;  // sort by index, break ties by end first, beg second\\n        });\\n        for (auto [_, isStart, cost]: E)\\n            if (isStart)\\n                best = max(best, last + cost);\\n            else\\n                last = max(last, cost);\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun maxTwoEvents(A: Array<IntArray>): Int {\\n        var (beg, end) = listOf(mutableMapOf<Int, MutableList<Int>>(), mutableMapOf<Int, MutableList<Int>>())\\n        var P = mutableSetOf<Int>()\\n        for ((i, j_, k) in A) {\\n            var j = j_ + 1  // \\u2B50\\uFE0F i..j cannot overlap\\n            if (!beg.contains(i)) beg[i] = mutableListOf<Int>()\\n            if (!beg.contains(j)) beg[j] = mutableListOf<Int>()\\n            if (!end.contains(i)) end[i] = mutableListOf<Int>()\\n            if (!end.contains(j)) end[j] = mutableListOf<Int>()\\n            beg[i]!!.add(k)\\n            end[j]!!.add(k)\\n            P.add(i)\\n            P.add(j)\\n        }\\n        var order = P.toMutableList();\\n        order.sort()\\n        var (pre, best) = listOf(0, 0)\\n        for (i in order) {\\n            for (cur in end[i]!!)\\n                pre = Math.max(pre, cur)\\n            for (cur in beg[i]!!)\\n                best = Math.max(best, pre + cur)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet maxTwoEvents = (A, beg = new Map(), end = new Map(), P = new Set()) => {\\n    for (let [i, j, k] of A) {\\n        ++j;  // \\u2B50\\uFE0F i..j cannot overlap\\n        if (!beg.has(i)) beg.set(i, []);\\n        if (!beg.has(j)) beg.set(j, []);\\n        if (!end.has(i)) end.set(i, []);\\n        if (!end.has(j)) end.set(j, []);\\n        beg.get(i).push(k);\\n        end.get(j).push(k);\\n        P.add(i);\\n        P.add(j);\\n    }\\n    P = [...P].sort((a, b) => a - b);\\n    let [pre, best] = [0, 0];\\n    for (let i of P) {\\n        for (let cur of end.get(i))\\n            pre = Math.max(pre, cur);\\n        for (let cur of beg.get(i))\\n            best = Math.max(best, pre + cur);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def maxTwoEvents(self, A: List[List[int]]) -> int:\\n        beg, end = {}, {}\\n        P = set()\\n        for i, j, k in A:\\n            j += 1 # \\u2B50\\uFE0F i..j cannot overlap\\n            if i not in beg: beg[i] = []\\n            if j not in beg: beg[j] = []\\n            if i not in end: end[i] = []\\n            if j not in end: end[j] = []\\n            beg[i].append(k)\\n            end[j].append(k)\\n            P.add(i)\\n            P.add(j)\\n        pre, best = 0, 0\\n        for i in sorted(list(P)):\\n            for cur in end[i]:\\n                pre = max(pre, cur)\\n            for cur in beg[i]:\\n                best = max(best, pre + cur)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Points = set<int>;\\n    using Map = unordered_map<int, VI>;\\n    int maxTwoEvents(VVI& A, Points P = {}, Map beg = {}, Map end = {}) {\\n        for (auto& e: A) {\\n            auto [i, j, k] = tie(e[0], e[1], e[2]);\\n            ++j; // \\u2B50\\uFE0F i..j cannot overlap\\n            beg[i].push_back(k);\\n            end[j].push_back(k);\\n            P.insert(i);\\n            P.insert(j);\\n        }\\n        auto [pre, best] = make_tuple(0, 0);\\n        for (auto i: P) {\\n            for (auto cur: end[i])\\n                pre = max(pre, cur);\\n            for (auto cur: beg[i])\\n                best = max(best, pre + cur);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549213,
                "title": "kotlin-o-nlogn-binary-search-caching-explained",
                "content": "The logic is as follows:\\n\\n1. We sort all events by their start time\\n2. We iterate through all events\\n2.1 For each event in the loop we find all the events starting after this event has ended (using binary search) and pick the best one among them\\n2.2 We cache the results from the previous step to avoid exra searching\\n\\n```\\nclass Solution {\\n\\t//Searching for the best event in [idx, end) range and caching the result\\n\\t//The events array is supposed to be sorted by start time\\n    fun findBest(idx: Int, events: Array<IntArray>, cache: IntArray): Int {\\n        if (idx >= events.size) {\\n            return 0\\n        }\\n        \\n        if (idx == events.size-1) {\\n            return events[idx][2]\\n        }\\n                \\n        if (cache[idx] > 0) {\\n            return cache[idx]\\n        }\\n            \\n        val result = maxOf(events[idx][2], findBest(idx+1, events, cache))\\n        cache[idx] = result\\n        return result\\n    }\\n    \\n    fun maxTwoEvents(events: Array<IntArray>): Int {\\n        val cache = IntArray(events.size){-1}\\n        events.sortWith(CompareArrays) \\n        \\n        var result = 0\\n        \\n        //Going through all the events...\\n        for (i in 0 until events.size) {\\n            val e = events[i]\\n\\t\\t\\t\\n\\t\\t\\t//...finding the index of the first event starting after this one using binary search...\\n            var idx = events.binarySearch(intArrayOf(e[1]+1,0), CompareArrays)\\n            if (idx < 0) {\\n                idx = -idx-1\\n            }\\n            \\n\\t\\t\\t//...and looking for the best option among them\\n            result = maxOf(result, e[2] + findBest(idx, events, cache))\\n        }\\n        \\n        return result\\n    }\\n    \\n    class CompareArrays {\\n        companion object : Comparator<IntArray> {\\n            override fun compare(o1: IntArray, o2: IntArray): Int {\\n                return (o1[0] - o2[0])\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t//Searching for the best event in [idx, end) range and caching the result\\n\\t//The events array is supposed to be sorted by start time\\n    fun findBest(idx: Int, events: Array<IntArray>, cache: IntArray): Int {\\n        if (idx >= events.size) {\\n            return 0\\n        }\\n        \\n        if (idx == events.size-1) {\\n            return events[idx][2]\\n        }\\n                \\n        if (cache[idx] > 0) {\\n            return cache[idx]\\n        }\\n            \\n        val result = maxOf(events[idx][2], findBest(idx+1, events, cache))\\n        cache[idx] = result\\n        return result\\n    }\\n    \\n    fun maxTwoEvents(events: Array<IntArray>): Int {\\n        val cache = IntArray(events.size){-1}\\n        events.sortWith(CompareArrays) \\n        \\n        var result = 0\\n        \\n        //Going through all the events...\\n        for (i in 0 until events.size) {\\n            val e = events[i]\\n\\t\\t\\t\\n\\t\\t\\t//...finding the index of the first event starting after this one using binary search...\\n            var idx = events.binarySearch(intArrayOf(e[1]+1,0), CompareArrays)\\n            if (idx < 0) {\\n                idx = -idx-1\\n            }\\n            \\n\\t\\t\\t//...and looking for the best option among them\\n            result = maxOf(result, e[2] + findBest(idx, events, cache))\\n        }\\n        \\n        return result\\n    }\\n    \\n    class CompareArrays {\\n        companion object : Comparator<IntArray> {\\n            override fun compare(o1: IntArray, o2: IntArray): Int {\\n                return (o1[0] - o2[0])\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549198,
                "title": "python-solution",
                "content": "The question requires only two intervals. So we can sort the whole queries and loop it. We can also use:\\n1. one heap to store the overlap intervals\\n2. one variable to store the maximum value of previous intervals\\n\\nFor every loop, we have start_index, end_index and value. Just remove all intervals in heap that the end_index is less than current start_index. \\n```\\nfrom heapq import *\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        pre_max=0\\n        heap=[]\\n        events.sort()\\n        out=0\\n        for l,r,v in events:\\n            while heap:\\n                end,v2=heappop(heap)\\n                if end>=l:\\n                    heappush(heap,(end,v2))\\n                    break\\n                pre_max=max(pre_max,v2)\\n            out=max(out,v+pre_max)\\n            heappush(heap,(r,v))\\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom heapq import *\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        pre_max=0\\n        heap=[]\\n        events.sort()\\n        out=0\\n        for l,r,v in events:\\n            while heap:\\n                end,v2=heappop(heap)\\n                if end>=l:\\n                    heappush(heap,(end,v2))\\n                    break\\n                pre_max=max(pre_max,v2)\\n            out=max(out,v+pre_max)\\n            heappush(heap,(r,v))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549180,
                "title": "python-o-nlogn-solution-sort-binary-search",
                "content": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        N = len(events)\\n\\n        start, end, vals = [], [], []\\n        for s,e,v in events:\\n            start.append(s)\\n            end.append(e)\\n            vals.append(v)\\n        \\n        max_at_index = {}\\n        curr = float(\"-inf\")\\n        for i in range(N-1,-1,-1):\\n            curr = max(vals[i], curr)\\n            max_at_index[i] = curr\\n        \\n        ans = float(\\'-inf\\')\\n        for i,s in enumerate(start):\\n            second = bisect.bisect(start, end[i])\\n            if second < N:\\n                ans = max(ans, vals[i] + max_at_index[second])\\n            else:\\n                ans = max(ans,vals[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        N = len(events)\\n\\n        start, end, vals = [], [], []\\n        for s,e,v in events:\\n            start.append(s)\\n            end.append(e)\\n            vals.append(v)\\n        \\n        max_at_index = {}\\n        curr = float(\"-inf\")\\n        for i in range(N-1,-1,-1):\\n            curr = max(vals[i], curr)\\n            max_at_index[i] = curr\\n        \\n        ans = float(\\'-inf\\')\\n        for i,s in enumerate(start):\\n            second = bisect.bisect(start, end[i])\\n            if second < N:\\n                ans = max(ans, vals[i] + max_at_index[second])\\n            else:\\n                ans = max(ans,vals[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549174,
                "title": "java-easy-solution",
                "content": "Precompute map that will give you the most valuable interval of the right side.\\n\\nIterate over all intervals and keep track of the most valuable on the left side `MaxLeft`.\\nFind corresponding non-overlapping interval on the right side `MaxRight`.\\n\\n```\\npublic int maxTwoEvents(int[][] events) {\\n\\t// precompute map that will give you the most valuable interval of the right side\\n\\tArrays.sort(events, (a, b) -> a[0] - b[0]);\\n\\t// <Strart, Value>\\n\\tvar maxRightToLeft = new TreeMap<Integer, Integer>();\\n\\tint maxRight = 0;\\n\\tfor (int i = events.length - 1; i >= 0; i--) {\\n\\t\\tmaxRight = Math.max(maxRight, events[i][2]);\\n\\t\\tmaxRightToLeft.put(events[i][0], maxRight);\\n\\t}\\n\\n\\tArrays.sort(events, (a, b) -> a[1] - b[1]);\\n\\tint res = 0;\\n\\tint maxLeft = 0;\\n\\tfor (int i = 0; i < events.length; i++) {\\n\\t\\tmaxLeft = Math.max(maxLeft, events[i][2]);\\n\\t\\t// Find corresponding non-overlapping interval on the right side\\n\\t\\tvar e = maxRightToLeft.ceilingEntry(events[i][1] + 1);\\n\\t\\tres = Math.max(res, maxLeft + (e != null ? e.getValue() : 0));\\n\\t}\\n\\treturn res;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxTwoEvents(int[][] events) {\\n\\t// precompute map that will give you the most valuable interval of the right side\\n\\tArrays.sort(events, (a, b) -> a[0] - b[0]);\\n\\t// <Strart, Value>\\n\\tvar maxRightToLeft = new TreeMap<Integer, Integer>();\\n\\tint maxRight = 0;\\n\\tfor (int i = events.length - 1; i >= 0; i--) {\\n\\t\\tmaxRight = Math.max(maxRight, events[i][2]);\\n\\t\\tmaxRightToLeft.put(events[i][0], maxRight);\\n\\t}\\n\\n\\tArrays.sort(events, (a, b) -> a[1] - b[1]);\\n\\tint res = 0;\\n\\tint maxLeft = 0;\\n\\tfor (int i = 0; i < events.length; i++) {\\n\\t\\tmaxLeft = Math.max(maxLeft, events[i][2]);\\n\\t\\t// Find corresponding non-overlapping interval on the right side\\n\\t\\tvar e = maxRightToLeft.ceilingEntry(events[i][1] + 1);\\n\\t\\tres = Math.max(res, maxLeft + (e != null ? e.getValue() : 0));\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549075,
                "title": "python-dfs-memoization-binary-search-o-nlogn",
                "content": "sort the events by starting times, do regular dfs with memo, to find the next event use binary search.\\n```\\n    def maxTwoEvents(self, events):\\n        events = sorted(events, key=lambda x: x[0])\\n        memo = {}\\n        def dfs(count, idx):\\n            if count == 2 or idx >= len(events):\\n                return 0\\n            if (count, idx) in memo:\\n                return memo[(count, idx)]\\n            take = events[idx][2] + dfs(count + 1, findNextEvent(idx))\\n            skip = dfs(count, idx + 1)\\n            memo[(count, idx)] = max(take, skip)\\n            return max(take, skip)\\n\\n        def findNextEvent(idx):\\n            left = idx + 1\\n            right = len(events) - 1\\n            while left <= right:\\n                mid = (left + right)//2\\n                if events[mid][0] > events[idx][1]:\\n                    if events[mid - 1][0] > events[idx][1]:\\n                        right = mid - 1\\n                    else:\\n                        return mid\\n                else:\\n                    left = mid + 1\\n            return len(events) + 1\\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n    def maxTwoEvents(self, events):\\n        events = sorted(events, key=lambda x: x[0])\\n        memo = {}\\n        def dfs(count, idx):\\n            if count == 2 or idx >= len(events):\\n                return 0\\n            if (count, idx) in memo:\\n                return memo[(count, idx)]\\n            take = events[idx][2] + dfs(count + 1, findNextEvent(idx))\\n            skip = dfs(count, idx + 1)\\n            memo[(count, idx)] = max(take, skip)\\n            return max(take, skip)\\n\\n        def findNextEvent(idx):\\n            left = idx + 1\\n            right = len(events) - 1\\n            while left <= right:\\n                mid = (left + right)//2\\n                if events[mid][0] > events[idx][1]:\\n                    if events[mid - 1][0] > events[idx][1]:\\n                        right = mid - 1\\n                    else:\\n                        return mid\\n                else:\\n                    left = mid + 1\\n            return len(events) + 1\\n        return dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1549059,
                "title": "java-solution-using-treemap-explained",
                "content": "In map we are storing the max value till current, which means if we were at the current end time what max value we can have if we have the power of choosing a single event. We don\\'t even require a map for it. Assume a single array and we are storing the max from 0 -> ith index. Now we chose TreeMap (lower key) just to set the \"res\" variable, which means if we choose the current event what max we can have before its start time. Please let me know if it\\'s still not clear, and upvote if it gets cleared :P\\n\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> a[1]-b[1]);\\n        \\n        int res = 0;\\n        \\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for(int i = 0; i < events.length; i++){\\n            int start = events[i][0];\\n            int end = events[i][1];\\n            int pow = events[i][2];\\n            \\n            Integer key = map.lowerKey(start);\\n            \\n            if(key == null) key = 0;\\n            \\n            int val = map.get(key);\\n            \\n            res = Math.max(res, val + pow);\\n            \\n            map.put(end, Math.max(map.get(map.lowerKey(end+1)), pow));\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> a[1]-b[1]);\\n        \\n        int res = 0;\\n        \\n        TreeMap<Integer,Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for(int i = 0; i < events.length; i++){\\n            int start = events[i][0];\\n            int end = events[i][1];\\n            int pow = events[i][2];\\n            \\n            Integer key = map.lowerKey(start);\\n            \\n            if(key == null) key = 0;\\n            \\n            int val = map.get(key);\\n            \\n            res = Math.max(res, val + pow);\\n            \\n            map.put(end, Math.max(map.get(map.lowerKey(end+1)), pow));\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548972,
                "title": "algorithm-sort-dp-binary-search-c",
                "content": "**Algorithm**\\n1. We will first sort the given input.\\n2. We search through all events.\\n2. At each position we can either choose to attend the event like this: ```int choose = a[pos][2] + help(a, jumpPos, k+1)```. While choosing we make use of binary search to find out ```jumpPos``` which indicates the first event that can be considered after our chosen event\\'s endtime.\\n3. Or choose to skip the event like this: ```int notchoose = help(a, pos+1, k)```\\n3. Base cases are when we have attended 2 events or searched all events.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[100000][2];\\n    int maxTwoEvents(vector<vector<int>>& a) {\\n        n = a.size();\\n        for(int i = 0 ; i < n ; i++) dp[i][0] = dp[i][1] = -1;\\n        sort(begin(a), end(a));\\n        int ans = help(a, 0, 0);\\n        return ans;\\n    }\\n    \\n    int help(vector<vector<int>>& a, int pos, int k){\\n        if(k == 2) return 0;\\n        if(pos >= n) return 0;\\n        if(dp[pos][k] != -1) return dp[pos][k];\\n        \\n        vector<int> val = {a[pos][1], INT_MAX, INT_MAX};\\n        int jumpPos = upper_bound(begin(a)+pos, end(a), val) - begin(a);\\n        int choose = a[pos][2] + help(a, jumpPos, k+1);\\n        int notchoose = help(a, pos+1, k);\\n        return dp[pos][k] = max(choose, notchoose);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```int choose = a[pos][2] + help(a, jumpPos, k+1)```\n```jumpPos```\n```int notchoose = help(a, pos+1, k)```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[100000][2];\\n    int maxTwoEvents(vector<vector<int>>& a) {\\n        n = a.size();\\n        for(int i = 0 ; i < n ; i++) dp[i][0] = dp[i][1] = -1;\\n        sort(begin(a), end(a));\\n        int ans = help(a, 0, 0);\\n        return ans;\\n    }\\n    \\n    int help(vector<vector<int>>& a, int pos, int k){\\n        if(k == 2) return 0;\\n        if(pos >= n) return 0;\\n        if(dp[pos][k] != -1) return dp[pos][k];\\n        \\n        vector<int> val = {a[pos][1], INT_MAX, INT_MAX};\\n        int jumpPos = upper_bound(begin(a)+pos, end(a), val) - begin(a);\\n        int choose = a[pos][2] + help(a, jumpPos, k+1);\\n        int notchoose = help(a, pos+1, k);\\n        return dp[pos][k] = max(choose, notchoose);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064793,
                "title": "super-easy-solution-for-solving-any-type-of-interval-maximisation-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem uses same concept as used in the problem : 1235. Maximum Profit in Job Scheduling.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nat each interval variable \\'ans\\' stores the maximum value of the non overlapping interval with the current interval, \\nthen we update the value of result, \\nand also push the maximum of these two interaval values,\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& intervals) {\\n        int ans = 0;\\n        int result = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>que;\\n        sort(intervals.begin(),intervals.end());\\n        for (auto a : intervals){\\n            while (!que.empty() && que.top().first<a[0]){\\n                ans = max(ans,que.top().second);\\n                que.pop();\\n            }\\n            result = max(result,ans+a[2]);\\n            que.push({a[1],max(ans,a[2])});\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& intervals) {\\n        int ans = 0;\\n        int result = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>que;\\n        sort(intervals.begin(),intervals.end());\\n        for (auto a : intervals){\\n            while (!que.empty() && que.top().first<a[0]){\\n                ans = max(ans,que.top().second);\\n                que.pop();\\n            }\\n            result = max(result,ans+a[2]);\\n            que.push({a[1],max(ans,a[2])});\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003458,
                "title": "2d-dp-and-binary-search",
                "content": "# Intuition\\nThis is a 2D DP problem. We look at each event and we can either not use it or we can use it. If we don\\'t use it, we look at the next event in sequence. If we use it then we decrease the number of used intervals by one and look into next event in the sequence with regards to the start times that is non-overlapping with the current event. Value of the choice is maximum between value of not choosing event and choosing the event:\\n\\ndp[i][j] = max { dp[i+1][j], dp[m][j-1] }\\n\\ndp is the maximum value of choosing any j intervals between 0 and i, m is first non-overlapping interval after i if intervals are ordered by the start time.\\n\\n# Approach\\nTo make this approach optimal we need to use 2D DP to organize values dp that reprsent maximum value of choosing k=2 intervals. We also order intervals by the start time. In order to find next non-overlapping interval we can use binary search modified to find upper bound of the given target element in a sorted array (regular binary search will find exact match).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$ to store dp 2D array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin(), events.end(),\\n            [](vector<int>& l, vector<int>& r) {\\n                return l[0] < r[0];\\n            });\\n\\n        int k = 2;\\n        vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));\\n        \\n        for (int i = 1; i <= k; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                dp[i][j] = dp[i][j+1];\\n                \\n                int s = j;\\n                int e = n-1;\\n                int target = events[j][1];\\n                int m = n;\\n\\n                while (s <= e) {\\n                   int mid = s + (e - s) / 2;\\n\\n                   if (target < events[mid][0]) {\\n                       m = mid;\\n                       e = mid - 1;\\n                   } else {\\n                       s = mid + 1;\\n                   }\\n                }\\n\\n                dp[i][j] = max(dp[i][j], dp[i-1][m] + events[j][2]);\\n            }\\n        }\\n\\n        return dp[k][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin(), events.end(),\\n            [](vector<int>& l, vector<int>& r) {\\n                return l[0] < r[0];\\n            });\\n\\n        int k = 2;\\n        vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));\\n        \\n        for (int i = 1; i <= k; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                dp[i][j] = dp[i][j+1];\\n                \\n                int s = j;\\n                int e = n-1;\\n                int target = events[j][1];\\n                int m = n;\\n\\n                while (s <= e) {\\n                   int mid = s + (e - s) / 2;\\n\\n                   if (target < events[mid][0]) {\\n                       m = mid;\\n                       e = mid - 1;\\n                   } else {\\n                       s = mid + 1;\\n                   }\\n                }\\n\\n                dp[i][j] = max(dp[i][j], dp[i-1][m] + events[j][2]);\\n            }\\n        }\\n\\n        return dp[k][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975314,
                "title": "c-easy-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int> p; \\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        sort(e.begin(),e.end());\\n        int n=e.size();\\n        vector<int> ans(n+1,-1);\\n        int l=0;\\n\\n        int mx=e[n-1][2];\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mx=max(mx,e[i][2]);\\n            p[i]=mx;\\n        }\\n        for(int i=0;i<n;i++)\\n         {\\n         int tg=lower_bound(r.begin(),r.end(),e[i][1]+1)-r.begin();\\n         ans[i]=p[tg]+e[i][2];\\n         }\\n\\n        for(int i=0;i<n;i++)\\n        l=max(l,ans[i]);\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> p; \\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        sort(e.begin(),e.end());\\n        int n=e.size();\\n        vector<int> ans(n+1,-1);\\n        int l=0;\\n\\n        int mx=e[n-1][2];\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mx=max(mx,e[i][2]);\\n            p[i]=mx;\\n        }\\n        for(int i=0;i<n;i++)\\n         {\\n         int tg=lower_bound(r.begin(),r.end(),e[i][1]+1)-r.begin();\\n         ans[i]=p[tg]+e[i][2];\\n         }\\n\\n        for(int i=0;i<n;i++)\\n        l=max(l,ans[i]);\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941582,
                "title": "fast-upperbound-2d-dp-25-lines-solution-topdown-recursion-memoization",
                "content": "# Intuition\\nThis is a weighted interval scheduling problem\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int rec(vector<vector<int>>& events,vector<int>& start,\\n    int i,int k){\\n        if (i==events.size() || k==0)\\n            return 0;\\n        if (dp[i][k]!=-1)\\n            return dp[i][k];\\n        int nt = rec(events,start,i+1,k);\\n        auto x = upper_bound(start.begin(),start.end(),\\n        events[i][1]) - start.begin();\\n        int t = events[i][2] + rec(events,start,x,k-1);\\n        return dp[i][k] = max(t,nt);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        dp.resize(events.size()+1,vector<int>(3,-1));\\n        vector<int> start;\\n        sort(events.begin(),events.end());\\n        for (int i=0;i<events.size();i++){\\n            start.push_back(events[i][0]);\\n        }\\n        return rec(events,start,0,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int rec(vector<vector<int>>& events,vector<int>& start,\\n    int i,int k){\\n        if (i==events.size() || k==0)\\n            return 0;\\n        if (dp[i][k]!=-1)\\n            return dp[i][k];\\n        int nt = rec(events,start,i+1,k);\\n        auto x = upper_bound(start.begin(),start.end(),\\n        events[i][1]) - start.begin();\\n        int t = events[i][2] + rec(events,start,x,k-1);\\n        return dp[i][k] = max(t,nt);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        dp.resize(events.size()+1,vector<int>(3,-1));\\n        vector<int> start;\\n        sort(events.begin(),events.end());\\n        for (int i=0;i<events.size();i++){\\n            start.push_back(events[i][0]);\\n        }\\n        return rec(events,start,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938588,
                "title": "dp-binary-search-classic-pick-not-pick",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n\\n        def bs(endtime):\\n            ans = len(events)+1\\n\\n            l = 0\\n            r = len(events) -1\\n            while l<=r:\\n                mid = l + (r-l)//2\\n                if events[mid][0]>endtime:\\n                    ans = mid\\n                    r = mid-1\\n                else:\\n                    l = mid+1\\n            return ans\\n\\n\\n        events.append([-100,-100,0])\\n        events = sorted(events)\\n\\n\\n        @cache\\n        def dfs(i , events_attended):\\n            if i >= len(events) or events_attended == 2:\\n                return 0\\n                \\n            next_possible_idx = bs(events[i][1])\\n            attend = dfs(next_possible_idx,events_attended+1) + events[i][2] \\n            dont_attend = dfs(i+1,events_attended)\\n\\n            return max(dont_attend,attend)\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n\\n        def bs(endtime):\\n            ans = len(events)+1\\n\\n            l = 0\\n            r = len(events) -1\\n            while l<=r:\\n                mid = l + (r-l)//2\\n                if events[mid][0]>endtime:\\n                    ans = mid\\n                    r = mid-1\\n                else:\\n                    l = mid+1\\n            return ans\\n\\n\\n        events.append([-100,-100,0])\\n        events = sorted(events)\\n\\n\\n        @cache\\n        def dfs(i , events_attended):\\n            if i >= len(events) or events_attended == 2:\\n                return 0\\n                \\n            next_possible_idx = bs(events[i][1])\\n            attend = dfs(next_possible_idx,events_attended+1) + events[i][2] \\n            dont_attend = dfs(i+1,events_attended)\\n\\n            return max(dont_attend,attend)\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933875,
                "title": "optimal-solution-using-pq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a priority queue (heap) to efficiently keep track of events that could potentially contribute to the maximum sum of values. The idea is to sort the events by their starting times and process them in ascending order. At each step, you consider the current event and determine if it could be part of the optimal solution.\\n\\nThe code uses a priority queue (heap) to efficiently keep track of events that could potentially contribute to the maximum sum of values. The idea is to sort the events by their starting times and process them in ascending order. At each step, you consider the current event and determine if it could be part of the optimal solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1. Sorting:**\\nThe events are sorted based on their starting times in ascending order. This sorting helps in processing events in chronological order.\\n\\n**2. Priority Queue:**\\nA max heap (priority_queue) is used to keep track of events that have the potential to contribute to the maximum sum of values. The priority queue is structured in a way that the event with the maximum ending time comes at the top. The priority queue holds elements in the form of pairs: {-end_time, {start_time, value}}.\\n\\n**3. Processing Events:**\\nFor each event, the code does the following:\\n\\n    1. It checks the events present in the priority queue that have ending times less than the starting time of the current event. This is done using a while loop. While doing this, it updates the maxValue with the maximum value encountered so far.\\n\\n    2. After the loop, the current event can be combined with the events in the priority queue. The potential sum of values for the current event and the events in the priority queue is calculated and updated in the ans variable.\\n\\n    3. Finally, the current event is added to the priority queue.\\n\\n**4. Updating Answer:**\\nAt each step, the ans variable is updated with the maximum of its current value and the potential sum of values calculated in step 3.\\n\\n**5. Final Answer:**\\nAfter processing all events, the final ans value will hold the maximum sum of values from at most two non-overlapping events.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        int maxValue = 0;\\n        int ans = 0;\\n\\n        sort(events.begin(),events.end());\\n\\n        priority_queue<pair<int, pair<int,int>>> pq;\\n\\n        for(int i=0;i<n;i++) {\\n\\n            while(!pq.empty() && (-1*pq.top().first) < events[i][0]) {\\n                maxValue = max(maxValue,pq.top().second.second);\\n                pq.pop();\\n            }\\n\\n            ans = max(ans,maxValue + events[i][2]);\\n\\n            pq.push({-1*events[i][1],{events[i][0],events[i][2]}});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        int maxValue = 0;\\n        int ans = 0;\\n\\n        sort(events.begin(),events.end());\\n\\n        priority_queue<pair<int, pair<int,int>>> pq;\\n\\n        for(int i=0;i<n;i++) {\\n\\n            while(!pq.empty() && (-1*pq.top().first) < events[i][0]) {\\n                maxValue = max(maxValue,pq.top().second.second);\\n                pq.pop();\\n            }\\n\\n            ans = max(ans,maxValue + events[i][2]);\\n\\n            pq.push({-1*events[i][1],{events[i][0],events[i][2]}});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908408,
                "title": "priority-queue-striver-solution-in-python",
                "content": "# STRIVER ( TAKE U FORWARD) SOLUTION IN PYTHON USING PRIORITY QUEUE\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        \\n        events.sort()\\n        pq=[]\\n        heapq.heapify(pq)\\n        ans=0\\n        max_value=0\\n        for i in range(len(events)):\\n            while pq and pq[0][0]<events[i][0]:\\n                max_value=max(max_value,pq[0][2])\\n                heapq.heappop(pq)\\n                \\n            ans=max(ans,events[i][2]+max_value)\\n            \\n            heapq.heappush(pq,[events[i][1],events[i][0],events[i][2]])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        \\n        events.sort()\\n        pq=[]\\n        heapq.heapify(pq)\\n        ans=0\\n        max_value=0\\n        for i in range(len(events)):\\n            while pq and pq[0][0]<events[i][0]:\\n                max_value=max(max_value,pq[0][2])\\n                heapq.heappop(pq)\\n                \\n            ans=max(ans,events[i][2]+max_value)\\n            \\n            heapq.heappush(pq,[events[i][1],events[i][0],events[i][2]])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884333,
                "title": "why-does-the-standard-pick-not-pick-does-not-work",
                "content": "okay so if i try this question with standard pick not pick which taking the endtime of the previous state and in the pick of current state if i check like if(prev < events[i][0]) and then calling pick function then how it is missing out on stuff... how to we need to do a upper bound on which index should be picked next\\n",
                "solutionTags": [],
                "code": "okay so if i try this question with standard pick not pick which taking the endtime of the previous state and in the pick of current state if i check like if(prev < events[i][0]) and then calling pick function then how it is missing out on stuff... how to we need to do a upper bound on which index should be picked next\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3856752,
                "title": "most-intuitive-and-easy-c-solution-100-complexity",
                "content": "https://www.linkedin.com/in/yash-jaiswal-0391691b9/\\n**connect if you like!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int ans=0;\\n        int n=events.size();\\n        vector<int> dp(n+1,0);  //store maximum single profit from behind\\n        for(int i=n-1;i>-1;i--){\\n            vector<int> v={events[i][1]+1,0,0};\\n            auto it=lower_bound(events.begin(),events.end(),v)-events.begin();\\n            ans=max(ans,events[i][2]+dp[it]);\\n            dp[i]=max(dp[i+1],events[i][2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int ans=0;\\n        int n=events.size();\\n        vector<int> dp(n+1,0);  //store maximum single profit from behind\\n        for(int i=n-1;i>-1;i--){\\n            vector<int> v={events[i][1]+1,0,0};\\n            auto it=lower_bound(events.begin(),events.end(),v)-events.begin();\\n            ans=max(ans,events[i][2]+dp[it]);\\n            dp[i]=max(dp[i+1],events[i][2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816813,
                "title": "easy-2-understand-treemap-short-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nLogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a,b)->(a[1]-b[1]));\\n        TreeMap<Integer, Integer> dp=new TreeMap<>();\\n        dp.put(0, 0);\\n        int max=0;\\n        for(int i=0; i<events.length; i++){\\n            int currProfit = dp.lowerEntry(events[i][0]).getValue()+events[i][2];\\n            if(events[i][2]>dp.lastEntry().getValue()){\\n                dp.put(events[i][1], events[i][2]);\\n            }\\n            max=Math.max(max, currProfit);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a,b)->(a[1]-b[1]));\\n        TreeMap<Integer, Integer> dp=new TreeMap<>();\\n        dp.put(0, 0);\\n        int max=0;\\n        for(int i=0; i<events.length; i++){\\n            int currProfit = dp.lowerEntry(events[i][0]).getValue()+events[i][2];\\n            if(events[i][2]>dp.lastEntry().getValue()){\\n                dp.put(events[i][1], events[i][2]);\\n            }\\n            max=Math.max(max, currProfit);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778273,
                "title": "java-recursive-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    Integer[][] memo;\\n\\n    int helperBinarySearch(int[][] events, int endTime){\\n\\n        int n = events.length;\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(end >= start){\\n\\n            int mid = start  + (end - start) / 2;\\n\\n            if(events[mid][0] <= endTime){\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return start;\\n    }\\n\\n    int helper(int[][] events, int index, int k){\\n\\n        int n = events.length;\\n\\n        if(k <= 0) return 0;\\n\\n        if(index >= n) return 0;\\n\\n        if(memo[index][k] != null) return memo[index][k];\\n\\n        int maxValue = 0;\\n\\n        maxValue = Math.max(maxValue, helper(events, index + 1, k));\\n\\n        int currEndTime = events[index][1];\\n        int currValue = events[index][2];\\n\\n        int nextEventIndex = helperBinarySearch(events, currEndTime);\\n\\n        maxValue = Math.max(maxValue, currValue + helper(events, nextEventIndex, k - 1));\\n\\n        return memo[index][k] = maxValue;\\n    }\\n\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\\n        memo = new Integer[n + 1][3];\\n        return helper(events, 0, 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    Integer[][] memo;\\n\\n    int helperBinarySearch(int[][] events, int endTime){\\n\\n        int n = events.length;\\n        int start = 0;\\n        int end = n - 1;\\n\\n        while(end >= start){\\n\\n            int mid = start  + (end - start) / 2;\\n\\n            if(events[mid][0] <= endTime){\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return start;\\n    }\\n\\n    int helper(int[][] events, int index, int k){\\n\\n        int n = events.length;\\n\\n        if(k <= 0) return 0;\\n\\n        if(index >= n) return 0;\\n\\n        if(memo[index][k] != null) return memo[index][k];\\n\\n        int maxValue = 0;\\n\\n        maxValue = Math.max(maxValue, helper(events, index + 1, k));\\n\\n        int currEndTime = events[index][1];\\n        int currValue = events[index][2];\\n\\n        int nextEventIndex = helperBinarySearch(events, currEndTime);\\n\\n        maxValue = Math.max(maxValue, currValue + helper(events, nextEventIndex, k - 1));\\n\\n        return memo[index][k] = maxValue;\\n    }\\n\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\\n        memo = new Integer[n + 1][3];\\n        return helper(events, 0, 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767931,
                "title": "python3-bottom-up-and-top-down-with-binary-search-simple-to-understand-beginner-friendly",
                "content": "BOTTOM-UP :\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        starts=[s for s,e,v in events]\\n        n=len(events)\\n        dp=[[-1]*3 for _ in range(n)]\\n        def dfs(i,left):\\n            if i>=n or left==0:\\n                return 0\\n            if dp[i][left]!=-1:\\n                return dp[i][left]\\n            idx=bisect_left(starts,events[i][1]+1)\\n            #take\\n            take=events[i][2]+dfs(idx,left-1)\\n            #notTake\\n            notTake=dfs(i+1,left)\\n            dp[i][left]= max(take,notTake)\\n            return dp[i][left]\\n        return dfs(0,2)\\n```\\n\\n\\nTOP-DOWN :\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        starts=[s for s,e,v in events]\\n        n=len(events)\\n        dp=[[0]*3 for _ in range(n+1)]\\n        for i in range(n-1,-1,-1):\\n            for left in range(2,-1,-1):\\n                idx=bisect_left(starts,events[i][1]+1)\\n                #take\\n                take=events[i][2]+dp[idx][left-1]  if left-1>=0 else 0\\n                #notTake\\n                notTake=dp[i+1][left]\\n                dp[i][left]= max(take,notTake)\\n        return dp[0][2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        starts=[s for s,e,v in events]\\n        n=len(events)\\n        dp=[[-1]*3 for _ in range(n)]\\n        def dfs(i,left):\\n            if i>=n or left==0:\\n                return 0\\n            if dp[i][left]!=-1:\\n                return dp[i][left]\\n            idx=bisect_left(starts,events[i][1]+1)\\n            #take\\n            take=events[i][2]+dfs(idx,left-1)\\n            #notTake\\n            notTake=dfs(i+1,left)\\n            dp[i][left]= max(take,notTake)\\n            return dp[i][left]\\n        return dfs(0,2)\\n```\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        starts=[s for s,e,v in events]\\n        n=len(events)\\n        dp=[[0]*3 for _ in range(n+1)]\\n        for i in range(n-1,-1,-1):\\n            for left in range(2,-1,-1):\\n                idx=bisect_left(starts,events[i][1]+1)\\n                #take\\n                take=events[i][2]+dp[idx][left-1]  if left-1>=0 else 0\\n                #notTake\\n                notTake=dp[i+1][left]\\n                dp[i][left]= max(take,notTake)\\n        return dp[0][2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766874,
                "title": "heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn the worst case all events are pushed into the heap\\nInserting an element in a heap of size N, takes O(logN) time. \\nSince N elements are inserted, so TC becomes O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace is occupied by heap\\nAt worst all N elements are inserted in heap\\nSo space complexity becomes O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        // intialize the variables\\n        int maxVal = 0;\\n        int ans = 0;\\n\\n        // sort the data based on start times\\n        sort(events.begin(), events.end());\\n\\n        // we will store the end time and value for each data point\\n        // we want the data to be sorted in ascending order of end times\\n        // hence we will negate the end times while pushing in heap\\n        // since pq is max heap\\n        // alternatively we can directly use a min heap here\\n        // like priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>\\n\\n        priority_queue<pair<int, int>> pq;\\n\\n        // iterate through the events\\n        // for each event find all events which end before it\\n        // find the max value of sum (this event + one more previous event)\\n        // after finding  maxVal for current event, update the global (final ans)\\n        for(auto e: events)\\n        {\\n            while(!pq.empty() and -pq.top().first < e[0])\\n            {\\n                maxVal = max(maxVal, pq.top().second);\\n                pq.pop();\\n            }\\n\\n            ans = max(ans, maxVal+e[2]);\\n            pq.push({-e[1], e[2]});\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        \\n        // intialize the variables\\n        int maxVal = 0;\\n        int ans = 0;\\n\\n        // sort the data based on start times\\n        sort(events.begin(), events.end());\\n\\n        // we will store the end time and value for each data point\\n        // we want the data to be sorted in ascending order of end times\\n        // hence we will negate the end times while pushing in heap\\n        // since pq is max heap\\n        // alternatively we can directly use a min heap here\\n        // like priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>\\n\\n        priority_queue<pair<int, int>> pq;\\n\\n        // iterate through the events\\n        // for each event find all events which end before it\\n        // find the max value of sum (this event + one more previous event)\\n        // after finding  maxVal for current event, update the global (final ans)\\n        for(auto e: events)\\n        {\\n            while(!pq.empty() and -pq.top().first < e[0])\\n            {\\n                maxVal = max(maxVal, pq.top().second);\\n                pq.pop();\\n            }\\n\\n            ans = max(ans, maxVal+e[2]);\\n            pq.push({-e[1], e[2]});\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739447,
                "title": "python-solution-binary-search-help-with-postfix-max-array",
                "content": "# Intuition\\nsort events by start time \\nbinary search find if there are remaing events(candicates)\\nchoose max value from candicates\\nbut how can we find max-value in O(1) time?\\nwith max-postfix array! eg. if values=[1,1,4,5,3]\\nmax-postfix array=[5,5,5,5,3]\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort events by start time\\n2. bulid max-postfix array with value from last to first.\\n3. foreach event(from minum to maxium) use binary search find if there is valid event can be come with(events start after finished tine), if tehre are use max-postfix array find max-value, if not, just use event-value compare with current max-value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime:O(N*lgN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace:O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxTwoEvents(self, events):\\n        \"\"\"\\n        :type events: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        events=sorted(events,key=lambda x:x[0])\\n        maxposts=[events[-1][-1]]*len(events)\\n        for i in range(len(events)-2,-1,-1):maxposts[i]=max(maxposts[i+1],events[i][-1])\\n        ffs,ans=[e[0] for e in events],0\\n        for i in range(len(events)):\\n            finishTime,sc1=events[i][1],events[i][-1]\\n            p=bisect.bisect_right(ffs,finishTime)\\n            if p==len(events):ans=max(ans,sc1)\\n            else:ans=max(ans,sc1+maxposts[p])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxTwoEvents(self, events):\\n        \"\"\"\\n        :type events: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        events=sorted(events,key=lambda x:x[0])\\n        maxposts=[events[-1][-1]]*len(events)\\n        for i in range(len(events)-2,-1,-1):maxposts[i]=max(maxposts[i+1],events[i][-1])\\n        ffs,ans=[e[0] for e in events],0\\n        for i in range(len(events)):\\n            finishTime,sc1=events[i][1],events[i][-1]\\n            p=bisect.bisect_right(ffs,finishTime)\\n            if p==len(events):ans=max(ans,sc1)\\n            else:ans=max(ans,sc1+maxposts[p])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640316,
                "title": "easy-tc-o-nlogn-sc-o-n-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& a) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        int mx[n+1];\\n        mx[n] = 0;\\n        for(int i=n-1; i>=0; i--){\\n            int value = a[i][2];\\n            mx[i] = max(mx[i+1], value);\\n        }\\n        vector<int> ind(n);\\n        int ans = 0;\\n        for(int i=n-1; i>=0; i--){\\n            int startTime = a[i][0], endTime = a[i][1], value = a[i][2];\\n            vector<int> tempVec = {endTime, INT_MAX, INT_MAX};\\n            int x = upper_bound(a.begin(), a.end(), tempVec) - a.begin();\\n            ans = max(ans, value + mx[x]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& a) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        int mx[n+1];\\n        mx[n] = 0;\\n        for(int i=n-1; i>=0; i--){\\n            int value = a[i][2];\\n            mx[i] = max(mx[i+1], value);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3634937,
                "title": "memoization-and-using-upper-bound-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i, vector<vector<int>> &events, int count,int n,vector<int> &needs,vector<vector<int>> &dp){\\n        if(i>=n or count==0){\\n            return 0;\\n        }\\n        if(dp[i][count]!=-1){\\n            return dp[i][count];\\n        }\\n        int notake=find(i+1,events,count,n,needs,dp);\\n        int it=upper_bound(needs.begin(),needs.end(),events[i][1])-needs.begin();\\n        notake=max(notake,events[i][2]+find(it,events,count-1,n,needs,dp));\\n        return dp[i][count]=notake;\\n\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<int> needs(n,0);\\n        for(int i=0;i<n;i++){\\n            //cout<<events[i][0]<<\" \"<<events[i][1]<<\" \"<<events[i][2]<<endl;\\n            needs[i]=events[i][0];\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>(3,-1));\\n        \\n        return find(0,events,2,n,needs,dp);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i, vector<vector<int>> &events, int count,int n,vector<int> &needs,vector<vector<int>> &dp){\\n        if(i>=n or count==0){\\n            return 0;\\n        }\\n        if(dp[i][count]!=-1){\\n            return dp[i][count];\\n        }\\n        int notake=find(i+1,events,count,n,needs,dp);\\n        int it=upper_bound(needs.begin(),needs.end(),events[i][1])-needs.begin();\\n        notake=max(notake,events[i][2]+find(it,events,count-1,n,needs,dp));\\n        return dp[i][count]=notake;\\n\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<int> needs(n,0);\\n        for(int i=0;i<n;i++){\\n            //cout<<events[i][0]<<\" \"<<events[i][1]<<\" \"<<events[i][2]<<endl;\\n            needs[i]=events[i][0];\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>(3,-1));\\n        \\n        return find(0,events,2,n,needs,dp);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3620074,
                "title": "i-solved-using-binary-search-range-minimum-query-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n static class SegmentTree {\\n\\n    Node[] tree;\\n\\n    static class Node {\\n\\n      int max;\\n    }\\n\\n    void init(int nodeVal, int start, int end, int[][] event) {\\n      if (start == end) {\\n        tree[nodeVal] = new Node();\\n        tree[nodeVal].max=event[start][2];\\n        return;\\n      }\\n      int mid = (start + end) / 2;\\n      init(2 * nodeVal, start, mid, event);\\n      init(2 * nodeVal + 1, mid + 1, end, event);\\n      tree[nodeVal] = new Node();\\n\\n      tree[nodeVal].max = Math.max(tree[2 * nodeVal].max, tree[2 * nodeVal + 1].max);\\n    }\\n\\n    int query(int nodeVal, int start, int end, int q, int r, int[][] event) {\\n      if (end == r && start == q) {\\n        return tree[nodeVal].max;\\n      }\\n      int mid = (start + end) / 2;\\n      if (r <= mid) {\\n        return query(2 * nodeVal, start, mid, q, r, event);\\n      } else if (q > mid) {\\n        return query(2 * nodeVal + 1, mid + 1, end, q, r, event);\\n      }\\n      int right = query(2 * nodeVal, start, mid, q, mid, event);\\n      int left = query(2 * nodeVal + 1, mid + 1, end, mid + 1, r, event);\\n      return Math.max(right, left);\\n    }\\n\\n    public SegmentTree() {\\n      this.tree = new Node[400005];\\n    }\\n  }\\n  public int maxTwoEvents(int[][] events) {\\n    Arrays.sort(events,(a,b)->a[0]-b[0]);\\n    int maxVal=-1;\\n    SegmentTree segmentTree = new SegmentTree();\\n    segmentTree.init(1,0,events.length-1,events);\\n    for(int i=0;i<events.length;i++){\\n      int x=events[i][1];\\n      int start=i+1,end=events.length-1,mid,ans=-1;\\n      while(start<=end){\\n        mid=(start+end)/2;\\n        if(events[mid][0]<=x){\\n          start=mid+1;\\n        }else{\\n          end=mid-1;\\n          ans=mid;\\n        }\\n      }\\n      if(ans!=-1){\\n        maxVal=Math.max(maxVal,events[i][2]+ segmentTree.query(1,0,events.length-1,ans,events.length-1,events));\\n      }else{\\n          maxVal=Math.max(maxVal,events[i][2]);\\n      }\\n    }\\n    return maxVal;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n static class SegmentTree {\\n\\n    Node[] tree;\\n\\n    static class Node {\\n\\n      int max;\\n    }\\n\\n    void init(int nodeVal, int start, int end, int[][] event) {\\n      if (start == end) {\\n        tree[nodeVal] = new Node();\\n        tree[nodeVal].max=event[start][2];\\n        return;\\n      }\\n      int mid = (start + end) / 2;\\n      init(2 * nodeVal, start, mid, event);\\n      init(2 * nodeVal + 1, mid + 1, end, event);\\n      tree[nodeVal] = new Node();\\n\\n      tree[nodeVal].max = Math.max(tree[2 * nodeVal].max, tree[2 * nodeVal + 1].max);\\n    }\\n\\n    int query(int nodeVal, int start, int end, int q, int r, int[][] event) {\\n      if (end == r && start == q) {\\n        return tree[nodeVal].max;\\n      }\\n      int mid = (start + end) / 2;\\n      if (r <= mid) {\\n        return query(2 * nodeVal, start, mid, q, r, event);\\n      } else if (q > mid) {\\n        return query(2 * nodeVal + 1, mid + 1, end, q, r, event);\\n      }\\n      int right = query(2 * nodeVal, start, mid, q, mid, event);\\n      int left = query(2 * nodeVal + 1, mid + 1, end, mid + 1, r, event);\\n      return Math.max(right, left);\\n    }\\n\\n    public SegmentTree() {\\n      this.tree = new Node[400005];\\n    }\\n  }\\n  public int maxTwoEvents(int[][] events) {\\n    Arrays.sort(events,(a,b)->a[0]-b[0]);\\n    int maxVal=-1;\\n    SegmentTree segmentTree = new SegmentTree();\\n    segmentTree.init(1,0,events.length-1,events);\\n    for(int i=0;i<events.length;i++){\\n      int x=events[i][1];\\n      int start=i+1,end=events.length-1,mid,ans=-1;\\n      while(start<=end){\\n        mid=(start+end)/2;\\n        if(events[mid][0]<=x){\\n          start=mid+1;\\n        }else{\\n          end=mid-1;\\n          ans=mid;\\n        }\\n      }\\n      if(ans!=-1){\\n        maxVal=Math.max(maxVal,events[i][2]+ segmentTree.query(1,0,events.length-1,ans,events.length-1,events));\\n      }else{\\n          maxVal=Math.max(maxVal,events[i][2]);\\n      }\\n    }\\n    return maxVal;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597627,
                "title": "knapsack-binary-search-classical-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int get_next_index(vector<vector<int>> &events , int start , int current_job_end)\\n    {\\n        int ans = -1;\\n        int e = events.size()-1;\\n        while(start <= e)\\n        {\\n            int mid = e + (start-e)/2;\\n            if(events[mid][0] > current_job_end)\\n            {\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else start = mid+1;\\n        }\\n        return ans;\\n    }\\n    int solve(vector<vector<int>> &events , int index , int two , vector<vector<int>> &dp)\\n    {\\n        if(index >= events.size()) return 0;\\n        if(two==0) return 0;\\n        if(dp[index][two]!=-1) return dp[index][two];\\n        int next = get_next_index(events,index+1,events[index][1]);\\n        int take = events[index][2] + solve(events,next,two-1,dp);\\n        int ntake = solve(events,index+1,two,dp);\\n        return dp[index][two] =  max(take,ntake);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        vector<vector<int>> dp(events.size()+1 , vector<int> (3,-1));\\n        sort(events.begin() , events.end());\\n        return solve(events,0,2,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int get_next_index(vector<vector<int>> &events , int start , int current_job_end)\\n    {\\n        int ans = -1;\\n        int e = events.size()-1;\\n        while(start <= e)\\n        {\\n            int mid = e + (start-e)/2;\\n            if(events[mid][0] > current_job_end)\\n            {\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else start = mid+1;\\n        }\\n        return ans;\\n    }\\n    int solve(vector<vector<int>> &events , int index , int two , vector<vector<int>> &dp)\\n    {\\n        if(index >= events.size()) return 0;\\n        if(two==0) return 0;\\n        if(dp[index][two]!=-1) return dp[index][two];\\n        int next = get_next_index(events,index+1,events[index][1]);\\n        int take = events[index][2] + solve(events,next,two-1,dp);\\n        int ntake = solve(events,index+1,two,dp);\\n        return dp[index][two] =  max(take,ntake);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        vector<vector<int>> dp(events.size()+1 , vector<int> (3,-1));\\n        sort(events.begin() , events.end());\\n        return solve(events,0,2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586734,
                "title": "knapsack-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int f(vector<vector<int>>&events,int i,int k){\\n        if(i>=events.size())return 0;\\n        if(k<=0)return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n\\n        vector<int>ans={events[i][1],INT_MAX,INT_MAX};\\n        int idx=upper_bound(events.begin(),events.end(),ans)-events.begin();\\n        int notpick=f(events,i+1,k);\\n        int pick=events[i][2]+f(events,idx,k-1);\\n        return dp[i][k]=max(pick,notpick);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        memset(dp,-1,sizeof(dp));\\n        return f(events,0,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int f(vector<vector<int>>&events,int i,int k){\\n        if(i>=events.size())return 0;\\n        if(k<=0)return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n\\n        vector<int>ans={events[i][1],INT_MAX,INT_MAX};\\n        int idx=upper_bound(events.begin(),events.end(),ans)-events.begin();\\n        int notpick=f(events,i+1,k);\\n        int pick=events[i][2]+f(events,idx,k-1);\\n        return dp[i][k]=max(pick,notpick);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        memset(dp,-1,sizeof(dp));\\n        return f(events,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584904,
                "title": "without-dp-c-soln-priority-queue-min-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the array and\\nmaintain min heap which will contain end of all the events\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck if minimum end of any event is smaller than current start\\nif end is smaller then pop untill we get end smaller than current event start and maintain variable which will check if value of event to be popped is greater than any previous popped element\\nWe will discard all the popped events and only take event with maximum value as only this event will contribute to the maximum because the array is sorted and all the next event to come have the start value greater than the end of the popped elements so they will always be non overlapping and as they have value less than the maximum value so their sum with the current event will always be less than the sum with maximum value\\nand hence we will keep only the maximum value among all the events that is popped\\nAt last single event may also have value greater than combined 2 events and we have not considered single event so popping it from heap and considering it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        //priority queue will check if end of any event is\\n// smaller than the start of current event\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int ans=0;\\n        pq.push({events[0][1],events[0][2]});\\n        for(int i=1;i<events.size();i++){\\n            if(pq.top().first<events[i][0]){//checking if end \\n//of smallest event is smaller that start of current \\n            //if end is smaller that means it is not \\n//overlapping and hence we can consider it in sum\\n                int x,y=0;\\n                //taking all the elements whose end is smaller \\n//than start of current element as we can take them all in sum\\n                while(!pq.empty() && pq.top().first<events[i][0]){\\n                    int a=pq.top().first;\\n                    int b=pq.top().second;\\n                    pq.pop();\\n                    if(b>y){//taking the end which has \\n//maximum value among all\\n                        y=b;\\n                        x=a;\\n                    }\\n                }\\n                ans = max(ans,y+events[i][2]);//taking max \\n//value sum with current event value\\n                pq.push({x,y});//pushing only maximum value in\\n// heap and discarding all rest as all values of events[i][0]\\n// for rest of i are bigger than the current value of events[i]\\n//[0] as we sorted array\\n                //so all discarded values have \\n//end<events[i][0] for all upcoming events[i][0]\\n                //and hence we discarded all and took only maximum as no sense of keeping the smaller values as they dont contribute to max sum\\n            }\\n            pq.push({events[i][1],events[i][2]});\\n//push current iteration value in min heap\\n        }\\n        \\n        //to check if any single element is greater \\n//than sum of 2\\n        while(!pq.empty()){\\n            ans = max(ans,pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        //priority queue will check if end of any event is\\n// smaller than the start of current event\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int ans=0;\\n        pq.push({events[0][1],events[0][2]});\\n        for(int i=1;i<events.size();i++){\\n            if(pq.top().first<events[i][0]){//checking if end \\n//of smallest event is smaller that start of current \\n            //if end is smaller that means it is not \\n//overlapping and hence we can consider it in sum\\n                int x,y=0;\\n                //taking all the elements whose end is smaller \\n//than start of current element as we can take them all in sum\\n                while(!pq.empty() && pq.top().first<events[i][0]){\\n                    int a=pq.top().first;\\n                    int b=pq.top().second;\\n                    pq.pop();\\n                    if(b>y){//taking the end which has \\n//maximum value among all\\n                        y=b;\\n                        x=a;\\n                    }\\n                }\\n                ans = max(ans,y+events[i][2]);//taking max \\n//value sum with current event value\\n                pq.push({x,y});//pushing only maximum value in\\n// heap and discarding all rest as all values of events[i][0]\\n// for rest of i are bigger than the current value of events[i]\\n//[0] as we sorted array\\n                //so all discarded values have \\n//end<events[i][0] for all upcoming events[i][0]\\n                //and hence we discarded all and took only maximum as no sense of keeping the smaller values as they dont contribute to max sum\\n            }\\n            pq.push({events[i][1],events[i][2]});\\n//push current iteration value in min heap\\n        }\\n        \\n        //to check if any single element is greater \\n//than sum of 2\\n        while(!pq.empty()){\\n            ans = max(ans,pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549617,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nComments mentioned in code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass Solution {\\n\\n    public int maxTwoEvents(int[][] events) {\\n        if(events == null || events.length < 1) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Sort the event array based on the starting time\\n        Arrays.sort(events, (a, b) -> a[0] == b[0] ? b[2] - a[2] : a[0] - b[0]);\\n        \\n\\t\\t// Use an array to record the maximum value\\n        int[] maxArr = new int[events.length];\\n        \\n        maxArr[events.length - 1] = events[events.length - 1][2];\\n        for(int i = events.length - 2; i >= 0; i--) {\\n            maxArr[i] = Math.max(maxArr[i + 1], events[i][2]);\\n        }\\n        \\n\\t\\t// The current maximum value is the last event\\n        int ans = events[events.length - 1][2];\\n        \\n        for(int i = 0; i < events.length - 1; i++) {\\n            int index = find(events, events[i][1], i + 1);\\n            \\n            if(index == -1) {\\n\\t\\t\\t// If we cannot find a non-overlapping event, the maximum so far is the current event value\\n                ans = Math.max(ans, events[i][2]);\\n            } else {\\n\\t\\t\\t// The maximum is the current event value plus the nonoverlapping event value\\n                ans = Math.max(ans, events[i][2] + maxArr[index]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int find(int[][] events, int target, int left) {\\n\\t// Binary search to find the first nonoverlapping event\\n        int right = events.length - 1;\\n        \\n        while(left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(events[mid][0] <= target) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        if(events[left][0] > target) {\\n            return left;\\n        }\\n        \\n        if(events[right][0] > target) {\\n            return right;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n\\n    public int maxTwoEvents(int[][] events) {\\n        if(events == null || events.length < 1) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// Sort the event array based on the starting time\\n        Arrays.sort(events, (a, b) -> a[0] == b[0] ? b[2] - a[2] : a[0] - b[0]);\\n        \\n\\t\\t// Use an array to record the maximum value\\n        int[] maxArr = new int[events.length];\\n        \\n        maxArr[events.length - 1] = events[events.length - 1][2];\\n        for(int i = events.length - 2; i >= 0; i--) {\\n            maxArr[i] = Math.max(maxArr[i + 1], events[i][2]);\\n        }\\n        \\n\\t\\t// The current maximum value is the last event\\n        int ans = events[events.length - 1][2];\\n        \\n        for(int i = 0; i < events.length - 1; i++) {\\n            int index = find(events, events[i][1], i + 1);\\n            \\n            if(index == -1) {\\n\\t\\t\\t// If we cannot find a non-overlapping event, the maximum so far is the current event value\\n                ans = Math.max(ans, events[i][2]);\\n            } else {\\n\\t\\t\\t// The maximum is the current event value plus the nonoverlapping event value\\n                ans = Math.max(ans, events[i][2] + maxArr[index]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int find(int[][] events, int target, int left) {\\n\\t// Binary search to find the first nonoverlapping event\\n        int right = events.length - 1;\\n        \\n        while(left + 1 < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(events[mid][0] <= target) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        if(events[left][0] > target) {\\n            return left;\\n        }\\n        \\n        if(events[right][0] > target) {\\n            return right;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514257,
                "title": "coordinate-compression-and-suffix-maximum",
                "content": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        n = len(events)\\n        mp = {}\\n        for a, b, c in events:\\n            mp[a] = mp[b] = 0\\n        for i, el in enumerate(sorted(mp)):\\n            mp[el] = i\\n        events.sort()\\n        maxscore = [0] * (len(mp) + 1)\\n        j = n - 1\\n        maxyet = 0\\n        for i in range(len(mp), -1, -1):\\n            while j >= 0 and mp[events[j][0]] >= i:\\n                maxyet = max(maxyet, events[j][2])\\n                j -= 1\\n            maxscore[i] = maxyet\\n        res = 0\\n        for a, b, c in events:\\n            res = max(res, c + maxscore[mp[b] + 1])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        n = len(events)\\n        mp = {}\\n        for a, b, c in events:\\n            mp[a] = mp[b] = 0\\n        for i, el in enumerate(sorted(mp)):\\n            mp[el] = i\\n        events.sort()\\n        maxscore = [0] * (len(mp) + 1)\\n        j = n - 1\\n        maxyet = 0\\n        for i in range(len(mp), -1, -1):\\n            while j >= 0 and mp[events[j][0]] >= i:\\n                maxyet = max(maxyet, events[j][2])\\n                j -= 1\\n            maxscore[i] = maxyet\\n        res = 0\\n        for a, b, c in events:\\n            res = max(res, c + maxscore[mp[b] + 1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500281,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts a simple dp + binary search problem. We just implement the recursion call for picking and not picking the particular interval;\\nWe use the dp for storing the maximum profit at a particular time and particlar picks.\\nit reduces its time compleity form n*n*logn --> nlogn.\\n we also use binary search in order to find the index of valid pick in logn time instead of making call for all the invalid picks between current index and valid pick index. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-- Sort the array in ascending order corresponding to the start time.\\n-- Make a 2D dp in prder to keep track of the max. profit at a particular index with no. of picks.\\n-- make call for pick and not pick.\\n-- for picking event store the current event(index) value + recursion call to the next valid Index(find by the binary search).\\n-- for not picking just make a call for the alternate(next) index.\\n-- at last return the maximum between pick and not pick.\\nthis will be the optimal(max) value for the current index with particular events.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n            O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n            O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] arr) {\\n        int n = arr.length;\\n        int dp[][] = new int[n][3];\\n        for(int d[]: dp) Arrays.fill(d, -1);\\n        Arrays.sort(arr, (a, b) -> a[0] - b[0]);\\n        return solver(arr, 0, dp, 0);\\n    }\\n    int solver(int arr[][], int ind, int dp[][], int events) {\\n        if(ind == arr.length || events == 2) return 0;\\n        if(dp[ind][events] != -1) return dp[ind][events];\\n        int max = 0;\\n        int nextInd = findNext(arr, ind);\\n        int pick = arr[ind][2] + solver(arr, nextInd, dp, events + 1);\\n        int notPick = solver(arr, ind + 1, dp, events);\\n        return dp[ind][events] = Math.max(pick, notPick);\\n    }\\n    int findNext(int arr[][], int ind) {\\n        int ans = arr.length, i = ind + 1, j = arr.length - 1;\\n        while(i <= j) {\\n            int mid = (i + j) / 2;\\n            if(arr[mid][0] > arr[ind][1]) {\\n                ans = mid;\\n                j = mid - 1;\\n            }\\n            else i = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] arr) {\\n        int n = arr.length;\\n        int dp[][] = new int[n][3];\\n        for(int d[]: dp) Arrays.fill(d, -1);\\n        Arrays.sort(arr, (a, b) -> a[0] - b[0]);\\n        return solver(arr, 0, dp, 0);\\n    }\\n    int solver(int arr[][], int ind, int dp[][], int events) {\\n        if(ind == arr.length || events == 2) return 0;\\n        if(dp[ind][events] != -1) return dp[ind][events];\\n        int max = 0;\\n        int nextInd = findNext(arr, ind);\\n        int pick = arr[ind][2] + solver(arr, nextInd, dp, events + 1);\\n        int notPick = solver(arr, ind + 1, dp, events);\\n        return dp[ind][events] = Math.max(pick, notPick);\\n    }\\n    int findNext(int arr[][], int ind) {\\n        int ans = arr.length, i = ind + 1, j = arr.length - 1;\\n        while(i <= j) {\\n            int mid = (i + j) / 2;\\n            if(arr[mid][0] > arr[ind][1]) {\\n                ans = mid;\\n                j = mid - 1;\\n            }\\n            else i = mid + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470851,
                "title": "c-dp-bin-search-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<pair<int,int>> dp(n);\\n        dp[n-1].first=events.back()[2];\\n        dp[n-1].second=events.back()[2];\\n        for(int i=n-2;i>=0;i--){\\n            pair<int,int> res=dp[i+1];\\n            int x=lower_bound(events.begin(),events.end(),vector<int>({events[i][1]+1,0,0}))-events.begin();\\n            res.second=max(res.second,events[i][2]+((x<n)?dp[x].first:0));\\n            res.first=max(res.first,events[i][2]);\\n            dp[i]=res;\\n        }\\n        return dp[0].second; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<pair<int,int>> dp(n);\\n        dp[n-1].first=events.back()[2];\\n        dp[n-1].second=events.back()[2];\\n        for(int i=n-2;i>=0;i--){\\n            pair<int,int> res=dp[i+1];\\n            int x=lower_bound(events.begin(),events.end(),vector<int>({events[i][1]+1,0,0}))-events.begin();\\n            res.second=max(res.second,events[i][2]+((x<n)?dp[x].first:0));\\n            res.first=max(res.first,events[i][2]);\\n            dp[i]=res;\\n        }\\n        return dp[0].second; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457370,
                "title": "2-solutions-minheap-and-sweep-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) : sort\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        res, prevLargest, minHeap = 0, 0, []\\n        for start, end, val in sorted(events): # sort to avoid duplicate\\n            heappush(minHeap, (end, val))\\n            while minHeap and minHeap[0][0] < start: # find another event\\n                e, v = heappop(minHeap) # pop the first event\\n                prevLargest = max(prevLargest, v) # prev largest val\\n            res = max(res, prevLargest + val) # final largest val\\n        return res \\n\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        event, prevLargest, res = [], 0, 0\\n        for start, end, val in events:\\n            event.append((start, -1, val)) # solve start = end case, start should be arranged first if they are equal\\n            event.append((end, 1, val))\\n        event.sort()\\n\\n        for line, sign, val in event:\\n            if sign == -1: # sweep one start point, it can have a prevLargest or 0\\n                res = max(res, prevLargest + val)\\n            else: # sweep one end point, get the prev largest value\\n                prevLargest = max(prevLargest, val)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        res, prevLargest, minHeap = 0, 0, []\\n        for start, end, val in sorted(events): # sort to avoid duplicate\\n            heappush(minHeap, (end, val))\\n            while minHeap and minHeap[0][0] < start: # find another event\\n                e, v = heappop(minHeap) # pop the first event\\n                prevLargest = max(prevLargest, v) # prev largest val\\n            res = max(res, prevLargest + val) # final largest val\\n        return res \\n\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        event, prevLargest, res = [], 0, 0\\n        for start, end, val in events:\\n            event.append((start, -1, val)) # solve start = end case, start should be arranged first if they are equal\\n            event.append((end, 1, val))\\n        event.sort()\\n\\n        for line, sign, val in event:\\n            if sign == -1: # sweep one start point, it can have a prevLargest or 0\\n                res = max(res, prevLargest + val)\\n            else: # sweep one end point, get the prev largest value\\n                prevLargest = max(prevLargest, val)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415178,
                "title": "memo-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int search(vector<vector<int>>&events,int i)\\n    {\\n        int val = events[i][1];\\n        int low = i+1,high = events.size()-1,mid,ans=events.size();\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(events[mid][0]>val)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n    int find(int ind,int c,vector<vector<int>>&events)\\n    {\\n        if(c==0) return 0;\\n        if(ind == events.size()) return -1e8;\\n        if(dp[ind][c]!=-1) return dp[ind][c];\\n        int a = 0;\\n        int i = search(events,ind);\\n        a=events[ind][2]+find(i,c-1,events);\\n        a=max(a,find(ind+1,c,events));\\n        return dp[ind][c]=a;\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(begin(events),end(events));\\n        int ans = find(0,2,events);\\n        for(auto &it:events)\\n        ans=max(ans,it[2]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int search(vector<vector<int>>&events,int i)\\n    {\\n        int val = events[i][1];\\n        int low = i+1,high = events.size()-1,mid,ans=events.size();\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(events[mid][0]>val)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n    int find(int ind,int c,vector<vector<int>>&events)\\n    {\\n        if(c==0) return 0;\\n        if(ind == events.size()) return -1e8;\\n        if(dp[ind][c]!=-1) return dp[ind][c];\\n        int a = 0;\\n        int i = search(events,ind);\\n        a=events[ind][2]+find(i,c-1,events);\\n        a=max(a,find(ind+1,c,events));\\n        return dp[ind][c]=a;\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(begin(events),end(events));\\n        int ans = find(0,2,events);\\n        for(auto &it:events)\\n        ans=max(ans,it[2]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335802,
                "title": "easy-approach-c-priority-queue-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n     \\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        priority_queue<pair<int, pair<int,int>>> pq; // <end, <start, value>>\\n//         we are using Max heap pbut to work it as a min heap we just negate the elemetns -ve to make it as min heap hehe\\n        int maxi = 0, ans = 0;\\n        for(int i=0; i<n; i++){\\n            \\n            int stcur = events[i][0];\\n            int endcur = events[i][1];\\n            int valcur = events[i][2];\\n            // maxi = max(maxi,valcur);\\n            \\n            while(!pq.empty() && (-1* pq.top().first) < stcur){\\n                auto it = pq.top();\\n                int val = it.second.second;\\n                maxi = max(maxi, val );\\n                pq.pop();\\n                \\n            }\\n            ans = max(ans, maxi+valcur);\\n            pq.push({ -1*endcur, {stcur, valcur}});\\n            \\n        }\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n     \\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        priority_queue<pair<int, pair<int,int>>> pq; // <end, <start, value>>\\n//         we are using Max heap pbut to work it as a min heap we just negate the elemetns -ve to make it as min heap hehe\\n        int maxi = 0, ans = 0;\\n        for(int i=0; i<n; i++){\\n            \\n            int stcur = events[i][0];\\n            int endcur = events[i][1];\\n            int valcur = events[i][2];\\n            // maxi = max(maxi,valcur);\\n            \\n            while(!pq.empty() && (-1* pq.top().first) < stcur){\\n                auto it = pq.top();\\n                int val = it.second.second;\\n                maxi = max(maxi, val );\\n                pq.pop();\\n                \\n            }\\n            ans = max(ans, maxi+valcur);\\n            pq.push({ -1*endcur, {stcur, valcur}});\\n            \\n        }\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321010,
                "title": "priority-queue-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events){\\n      priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n      int maxval=0;\\n      int maxsum = 0;\\n      int n = events.size();\\n      bool flag = true;\\n      sort(events.begin(),events.end());\\n      \\n      \\n      \\n      for(int i = 0 ; i<n ; i++){\\n        if(pq.empty()==true && flag==true){\\n          int endtime = events[i][1];\\n          int profit = events[i][2];\\n          maxsum = max(profit,maxsum);\\n          flag = false;\\n          pq.push({endtime,profit});\\n          continue;\\n        }\\n        int start = events[i][0];\\n        int end = events[i][1];\\n        int profit = events[i][2];\\n        maxsum = max(profit,maxsum);\\n        while(!pq.empty() && pq.top().first<start){\\n          maxval = max(maxval,pq.top().second);\\n          pq.pop();\\n        }\\n        int currsum = profit+maxval;\\n        maxsum = max(maxsum,currsum);\\n        pq.push({end,profit});\\n        \\n      }\\n      \\n      return maxsum;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events){\\n      priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n      int maxval=0;\\n      int maxsum = 0;\\n      int n = events.size();\\n      bool flag = true;\\n      sort(events.begin(),events.end());\\n      \\n      \\n      \\n      for(int i = 0 ; i<n ; i++){\\n        if(pq.empty()==true && flag==true){\\n          int endtime = events[i][1];\\n          int profit = events[i][2];\\n          maxsum = max(profit,maxsum);\\n          flag = false;\\n          pq.push({endtime,profit});\\n          continue;\\n        }\\n        int start = events[i][0];\\n        int end = events[i][1];\\n        int profit = events[i][2];\\n        maxsum = max(profit,maxsum);\\n        while(!pq.empty() && pq.top().first<start){\\n          maxval = max(maxval,pq.top().second);\\n          pq.pop();\\n        }\\n        int currsum = profit+maxval;\\n        maxsum = max(maxsum,currsum);\\n        pq.push({end,profit});\\n        \\n      }\\n      \\n      return maxsum;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304484,
                "title": "python-sorting-binary-search-with-intuition",
                "content": "Intuition - \\n\\nIf we pick the current event[i] = [start, end, value] then we should only look for the best value we could get starting for time (end + 1). Hence, we are maintaining a suffix maximum array of the values where suffix_max[i] denotes the maximum value we can get from index i till the last index. This is the basic intuition behind my approach. Please go through the code once. Hope it will help you in understanding the solution.\\n\\n\\'\\'\\'\\n\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        n = len(events)\\n        events.sort()    # Sort w.r.t to start time\\n        start = [s for s, e, v in events]\\n        end = [e for s, e, v in events]\\n        values = [v for s, e, v in events]\\n        \\n        suffix_max = [-1]*n\\n        suffix_max[-1] = values[-1]\\n        \\n        for i in range(n-2, -1, -1):\\n            suffix_max[i] = max(suffix_max[i+1], values[i])\\n        \\n        res = max(values)\\n        \\n        for i in range(n):\\n            idx = bisect.bisect_right(start, end[i])\\n            \\n            if idx == n:\\n                continue\\n            \\n            res = max(res, values[i] + suffix_max[idx])\\n        \\n        return res\\n\\'\\'\\'\\n\\nTime complexity - O(nlogn)\\nSpace complexity - O(n)",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "Intuition - \\n\\nIf we pick the current event[i] = [start, end, value] then we should only look for the best value we could get starting for time (end + 1). Hence, we are maintaining a suffix maximum array of the values where suffix_max[i] denotes the maximum value we can get from index i till the last index. This is the basic intuition behind my approach. Please go through the code once. Hope it will help you in understanding the solution.\\n\\n\\'\\'\\'\\n\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        n = len(events)\\n        events.sort()    # Sort w.r.t to start time\\n        start = [s for s, e, v in events]\\n        end = [e for s, e, v in events]\\n        values = [v for s, e, v in events]\\n        \\n        suffix_max = [-1]*n\\n        suffix_max[-1] = values[-1]\\n        \\n        for i in range(n-2, -1, -1):\\n            suffix_max[i] = max(suffix_max[i+1], values[i])\\n        \\n        res = max(values)\\n        \\n        for i in range(n):\\n            idx = bisect.bisect_right(start, end[i])\\n            \\n            if idx == n:\\n                continue\\n            \\n            res = max(res, values[i] + suffix_max[idx])\\n        \\n        return res\\n\\'\\'\\'\\n\\nTime complexity - O(nlogn)\\nSpace complexity - O(n)",
                "codeTag": "Python3"
            },
            {
                "id": 3301093,
                "title": "dp-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int fun(int idx,int count,int n,int k,vector<int>&arr,vector<vector<int>>&dp,vector<vector<int>>&events){\\n        if(count==k){\\n            return 0;\\n        }\\n        if(idx==n){\\n            return 0;\\n        }\\n        if(dp[idx][count]!=-1){\\n            return dp[idx][count];\\n        }\\n        int i=upper_bound(arr.begin(),arr.end(),events[idx][1])-arr.begin();\\n        int take=events[idx][2]+fun(i,count+1,n,k,arr,dp,events);\\n        int nottake=fun(idx+1,count,n,k,arr,dp,events);\\n        return dp[idx][count]=max(nottake,take);\\n    }\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int k=2;\\n        int n=events.size();\\n        vector<int>arr;\\n        for(auto it:events){\\n            arr.push_back(it[0]);\\n        }\\n        vector<vector<int>>dp(events.size(),vector<int>(k+1,-1));\\n        return fun(0,0,n,2,arr,dp,events);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int fun(int idx,int count,int n,int k,vector<int>&arr,vector<vector<int>>&dp,vector<vector<int>>&events){\\n        if(count==k){\\n            return 0;\\n        }\\n        if(idx==n){\\n            return 0;\\n        }\\n        if(dp[idx][count]!=-1){\\n            return dp[idx][count];\\n        }\\n        int i=upper_bound(arr.begin(),arr.end(),events[idx][1])-arr.begin();\\n        int take=events[idx][2]+fun(i,count+1,n,k,arr,dp,events);\\n        int nottake=fun(idx+1,count,n,k,arr,dp,events);\\n        return dp[idx][count]=max(nottake,take);\\n    }\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int k=2;\\n        int n=events.size();\\n        vector<int>arr;\\n        for(auto it:events){\\n            arr.push_back(it[0]);\\n        }\\n        vector<vector<int>>dp(events.size(),vector<int>(k+1,-1));\\n        return fun(0,0,n,2,arr,dp,events);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263181,
                "title": "recursion-memoization-binary-search-dp-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[100005][3];\\n    int f(int i, int count, vector<vector<int>>& events)\\n    {\\n        if(count==2) return 0;\\n        if(i==events.size()) return 0;\\n\\n        if(dp[i][count]!=-1) return dp[i][count];\\n\\n        vector<int>ans={events[i][1],INT_MAX,INT_MAX};\\n        int nextindex=upper_bound(begin(events),end(events),ans)-begin(events);\\n        \\n        return dp[i][count]=max(events[i][2]+f(nextindex,count+1,events),f(i+1,count,events));\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        sort(events.begin(),events.end());\\n        return f(0,0,events);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[100005][3];\\n    int f(int i, int count, vector<vector<int>>& events)\\n    {\\n        if(count==2) return 0;\\n        if(i==events.size()) return 0;\\n\\n        if(dp[i][count]!=-1) return dp[i][count];\\n\\n        vector<int>ans={events[i][1],INT_MAX,INT_MAX};\\n        int nextindex=upper_bound(begin(events),end(events),ans)-begin(events);\\n        \\n        return dp[i][count]=max(events[i][2]+f(nextindex,count+1,events),f(i+1,count,events));\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        sort(events.begin(),events.end());\\n        return f(0,0,events);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243934,
                "title": "javascript-sorted-seen",
                "content": "```\\nconst maxTwoEvents = (e) => {\\n  e.sort((a, b) => b[2] - a[2]);\\n  let max = e[0][2];\\n  let seen = {};\\n\\n  for (let i = 0; i < e.length - 1; i++) {\\n    if (seen[e[i]]) continue;\\n    else seen[e[i]] = true;\\n\\n    for (let j = i + 1; j < e.length; j++) {\\n      let [s1, e1, val1] = e[i];\\n      let [s2, e2, val2] = e[j];\\n\\n      if (val1 + val2 <= max) break;\\n      if (s1 > e2 || e1 < s2) max = Math.max(max, val1 + val2);\\n    }\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxTwoEvents = (e) => {\\n  e.sort((a, b) => b[2] - a[2]);\\n  let max = e[0][2];\\n  let seen = {};\\n\\n  for (let i = 0; i < e.length - 1; i++) {\\n    if (seen[e[i]]) continue;\\n    else seen[e[i]] = true;\\n\\n    for (let j = i + 1; j < e.length; j++) {\\n      let [s1, e1, val1] = e[i];\\n      let [s2, e2, val2] = e[j];\\n\\n      if (val1 + val2 <= max) break;\\n      if (s1 > e2 || e1 < s2) max = Math.max(max, val1 + val2);\\n    }\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230508,
                "title": "c-sort-suffixmax-binarysearch",
                "content": "# Intuition\\n1 Sort array by startTime\\n2 Find max value for all suffix of array and save in another array\\n3 For all events find another leftmost event such that secondEvent.startTime > firstEvent.endTime and update result  \\n\\n# Approach\\nBinary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int BinarySearch(int[][] events, int endTime)\\n    {\\n        int l = 0;\\n        int r = events.Length;\\n        \\n        while (r - l > 1)\\n        {\\n            int m = l + (r - l) / 2;\\n            \\n            if (events[m][0] > endTime)\\n            {\\n                r = m;\\n            }\\n            else\\n            {\\n                l = m;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int MaxTwoEvents(int[][] events) {\\n        int n = events.Length;\\n        Array.Sort(events, (int[] a, int[] b) => a[0].CompareTo(b[0]));\\n        \\n        int[] suffixMax = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            suffixMax[i] = Math.Max(suffixMax[i + 1], events[i][2]);\\n        }\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int index = BinarySearch(events, events[i][1]);\\n            result = Math.Max(result, events[i][2] + suffixMax[index]);    \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int BinarySearch(int[][] events, int endTime)\\n    {\\n        int l = 0;\\n        int r = events.Length;\\n        \\n        while (r - l > 1)\\n        {\\n            int m = l + (r - l) / 2;\\n            \\n            if (events[m][0] > endTime)\\n            {\\n                r = m;\\n            }\\n            else\\n            {\\n                l = m;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int MaxTwoEvents(int[][] events) {\\n        int n = events.Length;\\n        Array.Sort(events, (int[] a, int[] b) => a[0].CompareTo(b[0]));\\n        \\n        int[] suffixMax = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            suffixMax[i] = Math.Max(suffixMax[i + 1], events[i][2]);\\n        }\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int index = BinarySearch(events, events[i][1]);\\n            result = Math.Max(result, events[i][2] + suffixMax[index]);    \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224988,
                "title": "python-heap-with-sentinel",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\cdot log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        ans = l = 0\\n        h = [(inf, None)]\\n        events.sort()\\n        for [a, z, r] in events:\\n            while h[0][0] < a:\\n                l = max(l, heappop(h)[1])\\n            heappush(h, (z, r))\\n            ans = max(ans, l+r)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        ans = l = 0\\n        h = [(inf, None)]\\n        events.sort()\\n        for [a, z, r] in events:\\n            while h[0][0] < a:\\n                l = max(l, heappop(h)[1])\\n            heappush(h, (z, r))\\n            ans = max(ans, l+r)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204265,
                "title": "c",
                "content": "```\\nclass Solution {\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1] ;\\n    }\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size() ;\\n        sort(events.begin(), events.end(), cmp) ;\\n        vector<int>PrefixMax(n) ;\\n        int m =  0 ;\\n        for(int i = 0; i < n; i++){\\n            m = max(m, events[i][2]) ;\\n            PrefixMax[i] = m ;\\n        }\\n        vector<int>endTimes ;\\n        int ret = 0 ;\\n        for(int i = 0; i < n; i++){\\n            int start = events[i][0] - 1 ;\\n            int end = events[i][1] ;\\n            int val = events[i][2] ;\\n            ret = max(ret, val) ;\\n            auto iter = upper_bound(endTimes.begin(), endTimes.end(), start) ;\\n            if(iter != endTimes.begin())\\n            {\\n                iter = prev(iter) ;\\n                int idx = iter - endTimes.begin() ;\\n                ret = max(ret, PrefixMax[idx] + val) ;\\n            }\\n            endTimes.push_back(end) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        return a[1] < b[1] ;\\n    }\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size() ;\\n        sort(events.begin(), events.end(), cmp) ;\\n        vector<int>PrefixMax(n) ;\\n        int m =  0 ;\\n        for(int i = 0; i < n; i++){\\n            m = max(m, events[i][2]) ;\\n            PrefixMax[i] = m ;\\n        }\\n        vector<int>endTimes ;\\n        int ret = 0 ;\\n        for(int i = 0; i < n; i++){\\n            int start = events[i][0] - 1 ;\\n            int end = events[i][1] ;\\n            int val = events[i][2] ;\\n            ret = max(ret, val) ;\\n            auto iter = upper_bound(endTimes.begin(), endTimes.end(), start) ;\\n            if(iter != endTimes.begin())\\n            {\\n                iter = prev(iter) ;\\n                int idx = iter - endTimes.begin() ;\\n                ret = max(ret, PrefixMax[idx] + val) ;\\n            }\\n            endTimes.push_back(end) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152762,
                "title": "memoization-tabulation-c",
                "content": "# Memization\\n```\\nclass Solution {\\n    int dfs(int i, int cnt, vector<vector<int>> &events, vector<vector<int>> &dp, int n) {\\n        if(i == n) return 0;\\n        if(dp[i][cnt] != -1) return dp[i][cnt];\\n\\n        int notPick = dfs(i + 1, cnt, events, dp, n), pick = 0;\\n        if(cnt) {\\n            vector<int> x = {events[i][1], INT_MAX, INT_MAX};\\n            auto pos = upper_bound(events.begin() + i, events.end(), x) - events.begin();\\n            pick = events[i][2] + dfs(pos, cnt - 1, events, dp, n);\\n        }\\n\\n        return dp[i][cnt] = max(pick, notPick);\\n    }\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n\\n        return dfs(0, 2, events, dp, n);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n + 1, vector<int>(3));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int cnt=1; cnt<=2; cnt++) {\\n                int notPick = dp[i + 1][cnt];\\n                vector<int> x = {events[i][1], INT_MAX, INT_MAX};\\n                auto pos = upper_bound(events.begin() + i, events.end(), x) - events.begin();\\n                int pick = events[i][2] + dp[pos][cnt - 1];\\n\\n                dp[i][cnt] = max(pick, notPick);\\n            }\\n        }\\n        return dp[0][2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int cnt, vector<vector<int>> &events, vector<vector<int>> &dp, int n) {\\n        if(i == n) return 0;\\n        if(dp[i][cnt] != -1) return dp[i][cnt];\\n\\n        int notPick = dfs(i + 1, cnt, events, dp, n), pick = 0;\\n        if(cnt) {\\n            vector<int> x = {events[i][1], INT_MAX, INT_MAX};\\n            auto pos = upper_bound(events.begin() + i, events.end(), x) - events.begin();\\n            pick = events[i][2] + dfs(pos, cnt - 1, events, dp, n);\\n        }\\n\\n        return dp[i][cnt] = max(pick, notPick);\\n    }\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n, vector<int>(3, -1));\\n\\n        return dfs(0, 2, events, dp, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n + 1, vector<int>(3));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int cnt=1; cnt<=2; cnt++) {\\n                int notPick = dp[i + 1][cnt];\\n                vector<int> x = {events[i][1], INT_MAX, INT_MAX};\\n                auto pos = upper_bound(events.begin() + i, events.end(), x) - events.begin();\\n                int pick = events[i][2] + dp[pos][cnt - 1];\\n\\n                dp[i][cnt] = max(pick, notPick);\\n            }\\n        }\\n        return dp[0][2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134292,
                "title": "javascript-beats-100-binary-search",
                "content": "\\n# Approach\\n1. Sort the events array by startTime. \\n2. Iterate events, for each index i, use binary search to find the first element whose startTime is bigger than i\\'s endTime, say it\\'s index j.\\n3. Find the max value from index j to the end of events - mValue.\\n4. The answer would be Max(valuei + mValue) for each i.\\n\\nFor step 3, we can use suffix array to record the max value from j to the end of events.\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} events\\n * @return {number}\\n */\\nvar maxTwoEvents = function(events) {\\n    events.sort((a, b) => a[0]-b[0]);\\n    let res = 0, suffix = new Array(events.length);\\n    let max = 0;\\n    for(let i = events.length-1; i >= 0; i--){\\n        max = Math.max(max, events[i][2]);\\n        suffix[i] = max;\\n    }\\n    for(let i = 0; i < events.length; i++){\\n        res = Math.max(res, events[i][2]);\\n        let l = i+1, e = events.length-1;\\n        while(l < e){\\n            let mid = (l+e) >> 1;\\n            if(events[mid][0] > events[i][1]){\\n                e = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        if(events[e][0] > events[i][1]){\\n            res = Math.max(res, events[i][2] + suffix[e]);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} events\\n * @return {number}\\n */\\nvar maxTwoEvents = function(events) {\\n    events.sort((a, b) => a[0]-b[0]);\\n    let res = 0, suffix = new Array(events.length);\\n    let max = 0;\\n    for(let i = events.length-1; i >= 0; i--){\\n        max = Math.max(max, events[i][2]);\\n        suffix[i] = max;\\n    }\\n    for(let i = 0; i < events.length; i++){\\n        res = Math.max(res, events[i][2]);\\n        let l = i+1, e = events.length-1;\\n        while(l < e){\\n            let mid = (l+e) >> 1;\\n            if(events[mid][0] > events[i][1]){\\n                e = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        if(events[e][0] > events[i][1]){\\n            res = Math.max(res, events[i][2] + suffix[e]);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129929,
                "title": "golang-solution",
                "content": "# Intuition\\n\\nConsider each event ordered by start time while keeping track of the largest already completed event in a copy of the events sorted by end time.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$ for sorting.\\n\\n- Space complexity: $$O(n)$$ for a copy of the events.\\n\\n# Code\\n```\\nfunc maxTwoEvents(es [][]int) int {\\n    // sort events by start time\\n\\tsort.Slice(es, func(p, q int) bool { return es[p][0] < es[q][0] })\\n\\n    // copy of events sorted by end time\\n\\tee := append([][]int(nil), es...)\\n\\tsort.Slice(ee, func(p, q int) bool { return ee[p][1] < ee[q][1] })\\n\\n    // resulting maximum value\\n\\tr := 0\\n    // index into ee for the events that have been completed\\n\\tj := -1\\n    // the maximum value of events that have been completed\\n\\tmcv := 0\\n\\n    // consider each event\\n\\tfor _, e := range es {\\n\\n        // update index and maximum value of completed events\\n\\t\\tfor ee[j+1][1] < e[0] {\\n\\t\\t\\tj++\\n\\t\\t\\tif ee[j][2] > mcv {\\n\\t\\t\\t\\tmcv = ee[j][2]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        // value of the current event + the maximum completed event\\n\\t\\tv := e[2] + mcv\\n\\n\\t\\tif v > r {\\n\\t\\t\\tr = v\\n\\t\\t}\\n\\t}\\n\\n\\treturn r\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxTwoEvents(es [][]int) int {\\n    // sort events by start time\\n\\tsort.Slice(es, func(p, q int) bool { return es[p][0] < es[q][0] })\\n\\n    // copy of events sorted by end time\\n\\tee := append([][]int(nil), es...)\\n\\tsort.Slice(ee, func(p, q int) bool { return ee[p][1] < ee[q][1] })\\n\\n    // resulting maximum value\\n\\tr := 0\\n    // index into ee for the events that have been completed\\n\\tj := -1\\n    // the maximum value of events that have been completed\\n\\tmcv := 0\\n\\n    // consider each event\\n\\tfor _, e := range es {\\n\\n        // update index and maximum value of completed events\\n\\t\\tfor ee[j+1][1] < e[0] {\\n\\t\\t\\tj++\\n\\t\\t\\tif ee[j][2] > mcv {\\n\\t\\t\\t\\tmcv = ee[j][2]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n        // value of the current event + the maximum completed event\\n\\t\\tv := e[2] + mcv\\n\\n\\t\\tif v > r {\\n\\t\\t\\tr = v\\n\\t\\t}\\n\\t}\\n\\n\\treturn r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128911,
                "title": "0-1-knapsack-easy-memoization-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n         dp.resize(events.size(),vector<int>(3,-1));\\n         //first of all we will sort the array with respect to the start time \\n         sort(events.begin(),events.end());\\n\\n         //to iterate on the array\\n         int idx = 0;\\n        \\n         return fun(idx,2,events);\\n    }\\n    int fun(int idx,int k,vector<vector<int>>&events)\\n    {\\n         if(idx >= events.size())\\n         return 0;\\n\\n         if(k == 0)\\n         return 0;\\n\\n         if(dp[idx][k]!=-1)\\n         return dp[idx][k];\\n         \\n        //we have the choise to get entered into the curr event or not\\n        int choise1 = 0;\\n        int choise2 = 0;\\n        \\n        int nextpos = getnextpos(idx,events[idx][1],events);\\n        \\n        choise1 = events[idx][2] + fun(nextpos,k-1,events);\\n        choise2 = 0 + fun(idx+1,k,events);\\n\\n        return dp[idx][k] = max(choise1,choise2);\\n    }\\n    int getnextpos(int idx,int endtime,vector<vector<int>>&events)\\n    {\\n        //the event vector is already sorted\\n        int start = idx+1;\\n        int end = events.size()-1;\\n\\n        int ans = events.size();\\n\\n        //we are searching for the first\\n        while(start <= end)\\n        {\\n            int mid = (start+end)/2;\\n            \\n            if(events[mid][0] < endtime) // if the starttime of this bracket is less than the endtime we are looking for then move\\n            {\\n                start = mid+1;\\n            }\\n            else if(events[mid][0] == endtime)\\n            {\\n                start = mid+1;\\n            }\\n           else if(events[mid][0] > endtime)\\n           {\\n               ans = min(ans,mid);\\n               end = mid-1;\\n           }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n         dp.resize(events.size(),vector<int>(3,-1));\\n         //first of all we will sort the array with respect to the start time \\n         sort(events.begin(),events.end());\\n\\n         //to iterate on the array\\n         int idx = 0;\\n        \\n         return fun(idx,2,events);\\n    }\\n    int fun(int idx,int k,vector<vector<int>>&events)\\n    {\\n         if(idx >= events.size())\\n         return 0;\\n\\n         if(k == 0)\\n         return 0;\\n\\n         if(dp[idx][k]!=-1)\\n         return dp[idx][k];\\n         \\n        //we have the choise to get entered into the curr event or not\\n        int choise1 = 0;\\n        int choise2 = 0;\\n        \\n        int nextpos = getnextpos(idx,events[idx][1],events);\\n        \\n        choise1 = events[idx][2] + fun(nextpos,k-1,events);\\n        choise2 = 0 + fun(idx+1,k,events);\\n\\n        return dp[idx][k] = max(choise1,choise2);\\n    }\\n    int getnextpos(int idx,int endtime,vector<vector<int>>&events)\\n    {\\n        //the event vector is already sorted\\n        int start = idx+1;\\n        int end = events.size()-1;\\n\\n        int ans = events.size();\\n\\n        //we are searching for the first\\n        while(start <= end)\\n        {\\n            int mid = (start+end)/2;\\n            \\n            if(events[mid][0] < endtime) // if the starttime of this bracket is less than the endtime we are looking for then move\\n            {\\n                start = mid+1;\\n            }\\n            else if(events[mid][0] == endtime)\\n            {\\n                start = mid+1;\\n            }\\n           else if(events[mid][0] > endtime)\\n           {\\n               ans = min(ans,mid);\\n               end = mid-1;\\n           }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118288,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events):\\n        ans = sorted(events)\\n        starts, ends, profits = zip(*ans)\\n        n = len(events)\\n        \\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if i >= n or k == 0:\\n                return 0\\n\\n            return max(dfs(i+1,k),profits[i] + dfs(bisect.bisect_right(starts,ends[i]),k-1))\\n\\n        return dfs(0,2)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events):\\n        ans = sorted(events)\\n        starts, ends, profits = zip(*ans)\\n        n = len(events)\\n        \\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if i >= n or k == 0:\\n                return 0\\n\\n            return max(dfs(i+1,k),profits[i] + dfs(bisect.bisect_right(starts,ends[i]),k-1))\\n\\n        return dfs(0,2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112685,
                "title": "best-go-solution",
                "content": "# Complexity\\n- Time: O(N*logN)\\n\\n- Space: O(N)\\n\\n# Code\\n```\\nfunc maxTwoEvents(events [][]int) int {\\n    if len(events) == 0 {\\n        return 0\\n    }\\n    \\n    typed := make([][]int, 2*len(events))\\n    for i := 0; i < len(events); i++ {\\n        typed[2*i] = []int{events[i][0], 1, events[i][2]}\\n        typed[2*i+1] = []int{events[i][1]+1, -1, events[i][2]}\\n    }\\n    sort.Sort(mySort(typed))\\n    \\n    currOptimal, best := 0, 0\\n    for i := 0; i < len(typed); i++  {\\n        switch typed[i][1] {\\n        case 1:\\n            best = max(best, currOptimal + typed[i][2])\\n        case -1:\\n            currOptimal = max(currOptimal, typed[i][2])\\n        }\\n    }\\n    return best\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\ntype mySort [][]int\\n\\nfunc (b mySort) Len() int {\\n    return len(b)\\n}\\n\\nfunc (b mySort) Swap(i, j int) {\\n    b[i], b[j] = b[j], b[i]\\n}\\n\\nfunc (b mySort) Less(i, j int) bool {\\n    if b[i][0] == b[j][0] {\\n        if b[i][1] == b[j][1] {\\n            return b[i][2]<b[j][2]\\n        }\\n        return b[i][1]<b[j][1]\\n    }\\n    return b[i][0]<b[j][0]\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxTwoEvents(events [][]int) int {\\n    if len(events) == 0 {\\n        return 0\\n    }\\n    \\n    typed := make([][]int, 2*len(events))\\n    for i := 0; i < len(events); i++ {\\n        typed[2*i] = []int{events[i][0], 1, events[i][2]}\\n        typed[2*i+1] = []int{events[i][1]+1, -1, events[i][2]}\\n    }\\n    sort.Sort(mySort(typed))\\n    \\n    currOptimal, best := 0, 0\\n    for i := 0; i < len(typed); i++  {\\n        switch typed[i][1] {\\n        case 1:\\n            best = max(best, currOptimal + typed[i][2])\\n        case -1:\\n            currOptimal = max(currOptimal, typed[i][2])\\n        }\\n    }\\n    return best\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\ntype mySort [][]int\\n\\nfunc (b mySort) Len() int {\\n    return len(b)\\n}\\n\\nfunc (b mySort) Swap(i, j int) {\\n    b[i], b[j] = b[j], b[i]\\n}\\n\\nfunc (b mySort) Less(i, j int) bool {\\n    if b[i][0] == b[j][0] {\\n        if b[i][1] == b[j][1] {\\n            return b[i][2]<b[j][2]\\n        }\\n        return b[i][1]<b[j][1]\\n    }\\n    return b[i][0]<b[j][0]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075706,
                "title": "c-binary-search-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int n = events.size();\\n        vector<int> tmp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = events[i][2];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            events[i][2] = max(events[i+1][2],events[i][2]);\\n        }\\n        int mans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = tmp[i];\\n            int end = events[i][1];\\n            int tmpans=0;\\n            int l=i+1,r=n-1;\\n            while(l<=r)\\n            {\\n                int mid = (l+r)/2;\\n                int st = events[mid][0];\\n                int val = events[mid][2];\\n                if(st>end)\\n                {\\n                    tmpans = max(tmpans,val);\\n                    r = mid-1;\\n                }\\n                else\\n                l = mid+1;\\n            }\\n            ans+=tmpans;\\n            mans = max(mans,ans);\\n        }\\n        return mans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end());\\n        int n = events.size();\\n        vector<int> tmp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = events[i][2];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            events[i][2] = max(events[i+1][2],events[i][2]);\\n        }\\n        int mans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ans = tmp[i];\\n            int end = events[i][1];\\n            int tmpans=0;\\n            int l=i+1,r=n-1;\\n            while(l<=r)\\n            {\\n                int mid = (l+r)/2;\\n                int st = events[mid][0];\\n                int val = events[mid][2];\\n                if(st>end)\\n                {\\n                    tmpans = max(tmpans,val);\\n                    r = mid-1;\\n                }\\n                else\\n                l = mid+1;\\n            }\\n            ans+=tmpans;\\n            mans = max(mans,ans);\\n        }\\n        return mans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062623,
                "title": "python-one-pass-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        end_events = []\\n        L, R = 1, 0\\n        for s,e,p in events:\\n            end_events.append((s-1,L,p))\\n            end_events.append((e,R,p))\\n        end_events.sort()\\n        last = 0\\n        res = 0\\n        for e,D,p in end_events:\\n            if D == R:\\n                last = max(last, p)\\n            else:\\n                res = max(res, last + p)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        end_events = []\\n        L, R = 1, 0\\n        for s,e,p in events:\\n            end_events.append((s-1,L,p))\\n            end_events.append((e,R,p))\\n        end_events.sort()\\n        last = 0\\n        res = 0\\n        for e,D,p in end_events:\\n            if D == R:\\n                last = max(last, p)\\n            else:\\n                res = max(res, last + p)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060831,
                "title": "sorting-and-using-priorityqueue-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sorting Array by start and then end\\n2. Build a priorityQueue to keep end time and value of previuos events\\n3. Loop in array and Dequeue from queue while end of queue is less than start of current event\\n4. Find The max value\\n5. Add max value to the current value and update the result\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot 2023-01-16 at 12.48.05 PM.png](https://assets.leetcode.com/users/images/717b1055-0080-4778-a0c3-be9a04346184_1673902107.933055.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxTwoEvents(int[][] events) {\\n        int result=0,max=0;\\n        events=events.OrderBy(p=>p[0]).ThenBy(p=>p[1]).ToArray();\\n        var queue=new PriorityQueue<int[],int>();\\n        queue.Enqueue(new[]{events[0][2],events[0][1]}, events[0][1]);\\n        result=events[0][2];\\n        for(int i=1;i<events.Length;i++){\\n            while(queue.Count>0 && queue.Peek()[1]<events[i][0]){\\n                max=Math.Max(max,queue.Dequeue()[0]);\\n            }\\n            result=Math.Max(result,events[i][2]+max);\\n            queue.Enqueue(new[]{events[i][2],events[i][1]}, events[i][1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxTwoEvents(int[][] events) {\\n        int result=0,max=0;\\n        events=events.OrderBy(p=>p[0]).ThenBy(p=>p[1]).ToArray();\\n        var queue=new PriorityQueue<int[],int>();\\n        queue.Enqueue(new[]{events[0][2],events[0][1]}, events[0][1]);\\n        result=events[0][2];\\n        for(int i=1;i<events.Length;i++){\\n            while(queue.Count>0 && queue.Peek()[1]<events[i][0]){\\n                max=Math.Max(max,queue.Dequeue()[0]);\\n            }\\n            result=Math.Max(result,events[i][2]+max);\\n            queue.Enqueue(new[]{events[i][2],events[i][1]}, events[i][1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047129,
                "title": "simple-java-solution-using-sort-max-heap-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] a) {\\n        Arrays.sort(a,(x,y)->x[1]-y[1]);\\n        PriorityQueue<pair> pq= new PriorityQueue<>((x,y)->y.val-x.val);\\n        for(int x[]:a)pq.add(new pair(x[0],x[2]));\\n        int ans=0;\\n        for(int x[]:a){\\n            while(pq.size()!=0 && pq.peek().s<=x[1])pq.poll();\\n            int top=0;\\n            if(pq.size()!=0)top+=pq.peek().val;\\n            ans=Math.max(ans,top+x[2]);\\n        }\\n        return ans;\\n    }\\n}\\nclass pair{\\n    int s,val;\\n    pair(int s,int val){\\n        this.s=s;\\n        this.val=val;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] a) {\\n        Arrays.sort(a,(x,y)->x[1]-y[1]);\\n        PriorityQueue<pair> pq= new PriorityQueue<>((x,y)->y.val-x.val);\\n        for(int x[]:a)pq.add(new pair(x[0],x[2]));\\n        int ans=0;\\n        for(int x[]:a){\\n            while(pq.size()!=0 && pq.peek().s<=x[1])pq.poll();\\n            int top=0;\\n            if(pq.size()!=0)top+=pq.peek().val;\\n            ans=Math.max(ans,top+x[2]);\\n        }\\n        return ans;\\n    }\\n}\\nclass pair{\\n    int s,val;\\n    pair(int s,int val){\\n        this.s=s;\\n        this.val=val;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044792,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn max_two_events(mut events: Vec<Vec<i32>>) -> i32 {\\n    let mut set = HashSet::new();\\n    for arr in &events {\\n      set.insert(arr[0]);\\n      set.insert(arr[1]+1);\\n    }\\n\\n    let mut arr = set.into_iter().collect::<Vec<i32>>();\\n    arr.sort();\\n    let mut dict = HashMap::new();\\n    for i in 0..arr.len() {\\n      dict.insert(arr[i], i);\\n    }\\n    dict.insert(arr[arr.len()-1], arr.len()-1);\\n\\n    let n = dict.keys().len();\\n    let m = events.len();\\n    let mut memo = vec![0;n];\\n    events.sort_by(|a,b| a[0].cmp(&b[0]));\\n    for i in 0..m {\\n      let from = *dict.get(&events[i][0]).unwrap();\\n      memo[from] = memo[from].max(events[i][2]);\\n    }\\n    for i in (0..n-1).rev() {\\n      memo[i] = memo[i].max(memo[i+1]);\\n    }\\n\\n    events.sort_by(|a,b| a[1].cmp(&b[1]));\\n    let mut max = 0;    \\n    for i in 0..m {\\n      let to = *dict.get(&(events[i][1]+1)).unwrap();\\n      let v = events[i][2];\\n      max = max.max(v+memo[to]);\\n    }\\n\\n    max\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn max_two_events(mut events: Vec<Vec<i32>>) -> i32 {\\n    let mut set = HashSet::new();\\n    for arr in &events {\\n      set.insert(arr[0]);\\n      set.insert(arr[1]+1);\\n    }\\n\\n    let mut arr = set.into_iter().collect::<Vec<i32>>();\\n    arr.sort();\\n    let mut dict = HashMap::new();\\n    for i in 0..arr.len() {\\n      dict.insert(arr[i], i);\\n    }\\n    dict.insert(arr[arr.len()-1], arr.len()-1);\\n\\n    let n = dict.keys().len();\\n    let m = events.len();\\n    let mut memo = vec![0;n];\\n    events.sort_by(|a,b| a[0].cmp(&b[0]));\\n    for i in 0..m {\\n      let from = *dict.get(&events[i][0]).unwrap();\\n      memo[from] = memo[from].max(events[i][2]);\\n    }\\n    for i in (0..n-1).rev() {\\n      memo[i] = memo[i].max(memo[i+1]);\\n    }\\n\\n    events.sort_by(|a,b| a[1].cmp(&b[1]));\\n    let mut max = 0;    \\n    for i in 0..m {\\n      let to = *dict.get(&(events[i][1]+1)).unwrap();\\n      let v = events[i][2];\\n      max = max.max(v+memo[to]);\\n    }\\n\\n    max\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2888318,
                "title": "easy-and-clean-3-ways-using-dp-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        //Way 1\\n        Arrays.sort(events, (x,y) -> Integer.compare(x[0], y[0]));\\n        int [][] dp = new int[events.length][2];\\n        for(int i=0;i<events.length;i++)\\n            Arrays.fill(dp[i], -1);\\n        return GetMaxTwoEvents(0, 1, events, dp);\\n\\n        //Way 2\\n        Sort by start time and storing the max so far at each junction\\n        Arrays.sort(events, (x,y) -> Integer.compare(x[0], y[0]));\\n        int n = events.length;\\n        int [] max = new int[n];\\n        max[n-1] = events[n-1][2];\\n        for(int i = n-2; i>=0; i--)\\n        max[i] = Math.max(max[i+1], events[i][2]);\\n\\n        int maxEvents = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int nextIdx = n;\\n            int low = i+1;\\n            int high = n - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(events[mid][0] > events[i][1])\\n                {\\n                    nextIdx = mid;\\n                    high = mid - 1;\\n                }\\n                else\\n                low = mid + 1;\\n            }\\n            if(nextIdx == n)\\n            maxEvents = Math.max(maxEvents, events[i][2]);\\n            else\\n            maxEvents = Math.max(maxEvents, events[i][2] + max[nextIdx]);\\n        }\\n        return maxEvents;\\n\\n        //Sort by end time and storing the max so far at each junction\\n        Arrays.sort(events, (x,y) -> Integer.compare(x[1], y[1]));\\n        int n = events.length;\\n        int [] max = new int[n];\\n        max[0] = events[0][2];\\n        for(int i = 1; i<n; i++)\\n        max[i] = Math.max(max[i-1], events[i][2]);\\n\\n        int maxEvents = 0;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int nextIdx = n;\\n            int low = 0;\\n            int high = i - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(events[mid][1] < events[i][0])\\n                {\\n                    nextIdx = mid;\\n                    low = mid + 1;\\n                }\\n                else\\n                high = mid - 1;\\n            }\\n            if(nextIdx == n)\\n            maxEvents = Math.max(maxEvents, events[i][2]);\\n            else\\n            maxEvents = Math.max(maxEvents, events[i][2] + max[nextIdx]);\\n        }\\n        return maxEvents;\\n    }\\n\\n    public int GetMaxTwoEvents(int i, int count, int [][] events, int [][] dp)\\n    {\\n        if(count == -1 || i == events.length)\\n        return 0;\\n\\n        if(dp[i][count] != -1)\\n        return dp[i][count];\\n\\n        //int nextIdx = If doing iteratively gives TLE as it takes O(N). So total becomes O(N*2)\\n        //Lets Bring BS\\n        int nextIdx = events.length;\\n        int low = i+1;\\n        int high = events.length - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(events[mid][0] > events[i][1])\\n            {\\n                nextIdx = mid;\\n                high = mid - 1;\\n            }\\n            else\\n            low = mid + 1;\\n        }\\n        int take = 0;\\n        take = events[i][2] + GetMaxTwoEvents(nextIdx, count - 1, events, dp);\\n        int notTake = GetMaxTwoEvents(i+1, count, events, dp);\\n        return dp[i][count] = Math.max(take, notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        //Way 1\\n        Arrays.sort(events, (x,y) -> Integer.compare(x[0], y[0]));\\n        int [][] dp = new int[events.length][2];\\n        for(int i=0;i<events.length;i++)\\n            Arrays.fill(dp[i], -1);\\n        return GetMaxTwoEvents(0, 1, events, dp);\\n\\n        //Way 2\\n        Sort by start time and storing the max so far at each junction\\n        Arrays.sort(events, (x,y) -> Integer.compare(x[0], y[0]));\\n        int n = events.length;\\n        int [] max = new int[n];\\n        max[n-1] = events[n-1][2];\\n        for(int i = n-2; i>=0; i--)\\n        max[i] = Math.max(max[i+1], events[i][2]);\\n\\n        int maxEvents = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int nextIdx = n;\\n            int low = i+1;\\n            int high = n - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(events[mid][0] > events[i][1])\\n                {\\n                    nextIdx = mid;\\n                    high = mid - 1;\\n                }\\n                else\\n                low = mid + 1;\\n            }\\n            if(nextIdx == n)\\n            maxEvents = Math.max(maxEvents, events[i][2]);\\n            else\\n            maxEvents = Math.max(maxEvents, events[i][2] + max[nextIdx]);\\n        }\\n        return maxEvents;\\n\\n        //Sort by end time and storing the max so far at each junction\\n        Arrays.sort(events, (x,y) -> Integer.compare(x[1], y[1]));\\n        int n = events.length;\\n        int [] max = new int[n];\\n        max[0] = events[0][2];\\n        for(int i = 1; i<n; i++)\\n        max[i] = Math.max(max[i-1], events[i][2]);\\n\\n        int maxEvents = 0;\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            int nextIdx = n;\\n            int low = 0;\\n            int high = i - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(events[mid][1] < events[i][0])\\n                {\\n                    nextIdx = mid;\\n                    low = mid + 1;\\n                }\\n                else\\n                high = mid - 1;\\n            }\\n            if(nextIdx == n)\\n            maxEvents = Math.max(maxEvents, events[i][2]);\\n            else\\n            maxEvents = Math.max(maxEvents, events[i][2] + max[nextIdx]);\\n        }\\n        return maxEvents;\\n    }\\n\\n    public int GetMaxTwoEvents(int i, int count, int [][] events, int [][] dp)\\n    {\\n        if(count == -1 || i == events.length)\\n        return 0;\\n\\n        if(dp[i][count] != -1)\\n        return dp[i][count];\\n\\n        //int nextIdx = If doing iteratively gives TLE as it takes O(N). So total becomes O(N*2)\\n        //Lets Bring BS\\n        int nextIdx = events.length;\\n        int low = i+1;\\n        int high = events.length - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(events[mid][0] > events[i][1])\\n            {\\n                nextIdx = mid;\\n                high = mid - 1;\\n            }\\n            else\\n            low = mid + 1;\\n        }\\n        int take = 0;\\n        take = events[i][2] + GetMaxTwoEvents(nextIdx, count - 1, events, dp);\\n        int notTake = GetMaxTwoEvents(i+1, count, events, dp);\\n        return dp[i][count] = Math.max(take, notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886230,
                "title": "c-sorting-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n        int ans=0,max_val=0;\\n        priority_queue<pair<int,int>> pq;\\n        sort(events.begin(),events.end());\\n        for(auto &e:events)\\n        {\\n            while(!pq.empty()&&-pq.top().first<e[0])\\n            {\\n                max_val=max(max_val,pq.top().second);\\n                pq.pop();\\n            }\\n            ans=max(ans,max_val+e[2]);\\n            pq.push({-e[1],e[2]});\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n        int ans=0,max_val=0;\\n        priority_queue<pair<int,int>> pq;\\n        sort(events.begin(),events.end());\\n        for(auto &e:events)\\n        {\\n            while(!pq.empty()&&-pq.top().first<e[0])\\n            {\\n                max_val=max(max_val,pq.top().second);\\n                pq.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2885464,
                "title": "java-sorting-dp-binarysearch-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int len = events.length;\\n        \\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int[] maxValue = new int[len];\\n        \\n        for(int i = len - 1; i >= 0; i--){\\n            maxValue[i] = i == len - 1 ? events[i][2] : Math.max(maxValue[i + 1], events[i][2]);\\n        }\\n        \\n        int[] dp = new int[len];\\n        \\n        for(int i = len - 1; i >= 0; i--){\\n            if(i == len - 1){\\n                dp[i] = events[i][2];\\n            }\\n            else{\\n                int curr = events[i][2];\\n                int prev = dp[i + 1];\\n                int combo = curr + binarySearch(events, i, maxValue);\\n                dp[i] = Math.max(combo, Math.max(curr, prev));\\n            }\\n        }\\n        \\n        \\n        return dp[0];\\n    }\\n    public int binarySearch(int[][] events, int i, int[] maxValue){\\n        int ei = events[i][1];\\n        int low = i + 1, high = events.length - 1, ans = -1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(ei < events[mid][0]){\\n                ans = mid;\\n                high = mid - 1;        \\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans == -1 ? 0 : maxValue[ans];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        int len = events.length;\\n        \\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int[] maxValue = new int[len];\\n        \\n        for(int i = len - 1; i >= 0; i--){\\n            maxValue[i] = i == len - 1 ? events[i][2] : Math.max(maxValue[i + 1], events[i][2]);\\n        }\\n        \\n        int[] dp = new int[len];\\n        \\n        for(int i = len - 1; i >= 0; i--){\\n            if(i == len - 1){\\n                dp[i] = events[i][2];\\n            }\\n            else{\\n                int curr = events[i][2];\\n                int prev = dp[i + 1];\\n                int combo = curr + binarySearch(events, i, maxValue);\\n                dp[i] = Math.max(combo, Math.max(curr, prev));\\n            }\\n        }\\n        \\n        \\n        return dp[0];\\n    }\\n    public int binarySearch(int[][] events, int i, int[] maxValue){\\n        int ei = events[i][1];\\n        int low = i + 1, high = events.length - 1, ans = -1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(ei < events[mid][0]){\\n                ans = mid;\\n                high = mid - 1;        \\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans == -1 ? 0 : maxValue[ans];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858622,
                "title": "java-priorityqueue",
                "content": "Using Sorting and PriorityQueue + MinHeap to solve this problem.\\n\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(events.length, (a, b) -> Integer.compare(a[0], b[0]));\\n        int maxV = 0;\\n        int singleMax = 0;\\n        for(int i = 0; i < events.length; i++){\\n            int s = events[i][0], e = events[i][1], v = events[i][2];\\n            maxV = Math.max(maxV, v);\\n            while(!pq.isEmpty() && s > pq.peek()[0]){\\n                singleMax = Math.max(singleMax, pq.peek()[1]);\\n                pq.poll();\\n            }\\n            maxV = Math.max(maxV, singleMax + v);\\n            pq.add(new int[]{e, v});\\n        }\\n        return maxV;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(events.length, (a, b) -> Integer.compare(a[0], b[0]));\\n        int maxV = 0;\\n        int singleMax = 0;\\n        for(int i = 0; i < events.length; i++){\\n            int s = events[i][0], e = events[i][1], v = events[i][2];\\n            maxV = Math.max(maxV, v);\\n            while(!pq.isEmpty() && s > pq.peek()[0]){\\n                singleMax = Math.max(singleMax, pq.peek()[1]);\\n                pq.poll();\\n            }\\n            maxV = Math.max(maxV, singleMax + v);\\n            pq.add(new int[]{e, v});\\n        }\\n        return maxV;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851429,
                "title": "binary-search-my-thought-process-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo events are truly independent if the end of an event is smaller than start of some other event. In case of an event wrapping around smaller ones, the answer is always the value of the overlapping one.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort event according to start time. To compute, maximum within a range in constant time, store max till point i in maxes array. \\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int getLowerBound(int element, int[][] events) {\\n        int n = events.length;\\n        int low = 0, high = n - 1;\\n\\n        int answer = n;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int start = events[mid][0];\\n\\n            if(element < start) {\\n                answer = mid;\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        int[] maxes = new int[n];\\n        maxes[n - 1] = events[n - 1][2];\\n\\n        for(int i = n - 2; i >= 0; --i) {\\n            maxes[i] = Math.max(events[i][2], maxes[i + 1]);\\n        }\\n\\n        int answer = 0;\\n        for(int i = 0; i < n; ++i) {\\n            answer = Math.max(answer, events[i][2]);\\n\\n            int lowerBound = getLowerBound(events[i][1], events);\\n            if(lowerBound < n) {\\n                answer = Math.max(answer, events[i][2] + maxes[lowerBound]);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int getLowerBound(int element, int[][] events) {\\n        int n = events.length;\\n        int low = 0, high = n - 1;\\n\\n        int answer = n;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int start = events[mid][0];\\n\\n            if(element < start) {\\n                answer = mid;\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    public int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        int[] maxes = new int[n];\\n        maxes[n - 1] = events[n - 1][2];\\n\\n        for(int i = n - 2; i >= 0; --i) {\\n            maxes[i] = Math.max(events[i][2], maxes[i + 1]);\\n        }\\n\\n        int answer = 0;\\n        for(int i = 0; i < n; ++i) {\\n            answer = Math.max(answer, events[i][2]);\\n\\n            int lowerBound = getLowerBound(events[i][1], events);\\n            if(lowerBound < n) {\\n                answer = Math.max(answer, events[i][2] + maxes[lowerBound]);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850337,
                "title": "c-min-heap-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        // priority queue minheap --> to store endtime and values of the events\\n        sort(events.begin(),events.end()); // sort according to start time\\n        \\n        int result = 0;\\n        int maxval = 0; // maxvalue stores the maximum value of the values encountered so far and \\n        // whose ending time is less than the start time of the current event\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n            {\\n                maxval = max(maxval,pq.top().second);\\n                pq.pop();\\n            }\\n            result = max(result, maxval + events[i][2]);\\n            pq.push({events[i][1],events[i][2]});\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        // priority queue minheap --> to store endtime and values of the events\\n        sort(events.begin(),events.end()); // sort according to start time\\n        \\n        int result = 0;\\n        int maxval = 0; // maxvalue stores the maximum value of the values encountered so far and \\n        // whose ending time is less than the start time of the current event\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n            {\\n                maxval = max(maxval,pq.top().second);\\n                pq.pop();\\n            }\\n            result = max(result, maxval + events[i][2]);\\n            pq.push({events[i][1],events[i][2]});\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849242,
                "title": "c-sort-binary-search",
                "content": "* Sort the events by start-time.\\n* while iterating from last event upto first event  , maintain a array \\'prefix\\' (kind of prefix - sum array) , whose i-th index denote the maximum value amongst the events between i-th index upto end.\\n* iterate over each event from start and for each event find the next valid-event\\'s index (whose start time is Strictly greater than current event\\'s end time) using binary search .\\n*  Maximize the value (current event value + prefix[next_valid_index]).\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin() , events.end());\\n        vector<int> prefix(events.size() , -1);\\n        prefix[n-1] = events[n-1][2];\\n        for(int i = n-2 ; i >= 0 ;i--){\\n            int mx = max(events[i][2] , prefix[i+1]);\\n            prefix[i] = mx;\\n        }\\n        \\n        int maxVal = -1;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int next_indx = n;\\n            int st = i+1;\\n            int en = n-1;\\n            while(st <= en){\\n                int mid = (st + en)/2;\\n                if(events[mid][0] > events[i][1])\\n                {\\n                    next_indx = mid;\\n                    en = mid-1;\\n                }\\n                else st = mid+1;\\n            }\\n            int u = events[i][2] + (next_indx < n ? prefix[next_indx] : 0); //if we can\\'t find the next valid index => there is no event whose start time > current-end-time . In this case , account only 1 event.\\n            maxVal = max(maxVal , u);\\n        }\\n        return maxVal;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int n = events.size();\\n        sort(events.begin() , events.end());\\n        vector<int> prefix(events.size() , -1);\\n        prefix[n-1] = events[n-1][2];\\n        for(int i = n-2 ; i >= 0 ;i--){\\n            int mx = max(events[i][2] , prefix[i+1]);\\n            prefix[i] = mx;\\n        }\\n        \\n        int maxVal = -1;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int next_indx = n;\\n            int st = i+1;\\n            int en = n-1;\\n            while(st <= en){\\n                int mid = (st + en)/2;\\n                if(events[mid][0] > events[i][1])\\n                {\\n                    next_indx = mid;\\n                    en = mid-1;\\n                }\\n                else st = mid+1;\\n            }\\n            int u = events[i][2] + (next_indx < n ? prefix[next_indx] : 0); //if we can\\'t find the next valid index => there is no event whose start time > current-end-time . In this case , account only 1 event.\\n            maxVal = max(maxVal , u);\\n        }\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849203,
                "title": "python-sort-and-binary-search",
                "content": "```python\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n\\n        events.sort(key=lambda x: x[1])\\n        res, prevs = 0, [(0, 0)]\\n        \\n        for s, e, v in events:\\n            i = bisect_right(prevs, s-1, key=lambda x: x[0])\\n            res = max(res, prevs[i-1][1] + v)\\n            nv = max(prevs[-1][1], v)\\n            prevs.append((e, nv))\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n\\n        events.sort(key=lambda x: x[1])\\n        res, prevs = 0, [(0, 0)]\\n        \\n        for s, e, v in events:\\n            i = bisect_right(prevs, s-1, key=lambda x: x[0])\\n            res = max(res, prevs[i-1][1] + v)\\n            nv = max(prevs[-1][1], v)\\n            prevs.append((e, nv))\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818746,
                "title": "java-o-nlog-n",
                "content": "# O(3nlog(n) + n) -> O(nlog(n))\\nEach element gets pushed and popped at most one time into the while loop.\\n```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, Comparator.comparingInt(i -> i[0]));\\n        \\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(i -> i[0]));\\n        \\n        int bestSeen = 0;\\n        int result = 0;\\n        for (int[] event : events){\\n            // The value of an interval gets unpacked by the first non-overlapping following interval.\\n            // Each interval after this non-overlapping one is also a non-overlapping one with this\\n            // unpacked interval, why do you think is this the case ?\\n            while (!pq.isEmpty() && pq.peek()[0] < event[0]) bestSeen = Math.max(bestSeen, pq.poll()[1]);\\n            result = Math.max(result, bestSeen + event[2]);\\n            pq.offer(new int[]{event[1], event[2]});\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, Comparator.comparingInt(i -> i[0]));\\n        \\n        final PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(i -> i[0]));\\n        \\n        int bestSeen = 0;\\n        int result = 0;\\n        for (int[] event : events){\\n            // The value of an interval gets unpacked by the first non-overlapping following interval.\\n            // Each interval after this non-overlapping one is also a non-overlapping one with this\\n            // unpacked interval, why do you think is this the case ?\\n            while (!pq.isEmpty() && pq.peek()[0] < event[0]) bestSeen = Math.max(bestSeen, pq.poll()[1]);\\n            result = Math.max(result, bestSeen + event[2]);\\n            pq.offer(new int[]{event[1], event[2]});\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803834,
                "title": "java-o-nlogn-100-33ms-binary-search-brute-force",
                "content": "## **1. Brute Force**\\n```\\nclass Solution {\\n\\tpublic int maxTwoEvents(int[][] events) {\\n\\t\\tint n = events.length;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ans < events[i][2]) {\\n\\t\\t\\t\\tans = events[i][2];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tif (events[i][0] <= events[j][1] && events[j][0] <= events[i][1]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint s = events[i][2] + events[j][2];\\n\\t\\t\\t\\tif (ans < s) {\\n\\t\\t\\t\\t\\tans = s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n### **Time Complexity : TLE**\\n### **Space Complexity : O(1)**\\n\\n=============================================================================\\n\\n## **2. Brute Force Optimized**\\n```\\nclass Solution {\\n\\tpublic int maxTwoEvents(int[][] events) {\\n\\t\\tint n = events.length;\\n\\t\\tint[][] start = new int[n][];\\n\\t\\tint[][] end = new int[n][];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstart[i] = new int[]{events[i][0], events[i][2]};\\n\\t\\t\\tend[i] = new int[]{events[i][1], events[i][2]};\\n\\t\\t}\\n\\n\\t\\tComparator<int[]> cp = new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tArrays.sort(start, cp);\\n\\t\\tArrays.sort(end, cp);\\n\\n\\t\\tint ans = 0;\\n\\t\\tint j = 0;\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (j < n && end[j][0] < start[i][0]) {\\n\\t\\t\\t\\tif (max < end[j][1]) {\\n\\t\\t\\t\\t\\tmax = end[j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint s = start[i][1] + max;\\n\\t\\t\\tif (ans < s) {\\n\\t\\t\\t\\tans = s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n### **Time Complexity : O(NlogN)**\\n### **Space Complexity : O(N)**\\n![image](https://assets.leetcode.com/users/images/409d7fe3-3409-4253-83ef-f79c5c0e4e5a_1668177666.461362.png)\\n\\n=============================================================================\\n\\n## **3. Binary Search**\\n```\\nclass Solution {\\n\\tint[][] E;\\n\\tint n;\\n\\tpublic int maxTwoEvents(int[][] events) {\\n\\t\\tn = events.length;\\n\\t\\tint ans = 0;\\n\\t\\tArrays.sort(events, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tE = events;\\n\\t\\tint[] max = new int[n];\\n\\t\\tmax[n - 1] = events[n - 1][2];\\n\\t\\tfor (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tmax[i] = Math.max(max[i + 1], events[i][2]);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint idx = bsEvent(i, events[i][1]);\\n\\t\\t\\tif (idx == n) {\\n\\t\\t\\t\\tif (ans < events[i][2]) {\\n\\t\\t\\t\\t\\tans = events[i][2];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint s = events[i][2] + max[idx];\\n\\t\\t\\t\\tif (ans < s) {\\n\\t\\t\\t\\t\\tans = s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int bsEvent(int idx, int end) {\\n\\t\\tint l = idx + 1;\\n\\t\\tint r = n - 1;\\n\\t\\tint mid = 0;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tmid = l + ((r - l) >> 1);\\n\\t\\t\\tif (E[mid][0] <= end) {\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn l;\\n\\t}\\n}\\n```\\n### **Time Complexity : O(NlogN)**\\n### **Space Complexity : O(N)**\\n![image](https://assets.leetcode.com/users/images/aa6bf2c6-3854-4705-91ae-fe07af0b5d65_1668178230.752366.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int maxTwoEvents(int[][] events) {\\n\\t\\tint n = events.length;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ans < events[i][2]) {\\n\\t\\t\\t\\tans = events[i][2];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\t\\tif (events[i][0] <= events[j][1] && events[j][0] <= events[i][1]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint s = events[i][2] + events[j][2];\\n\\t\\t\\t\\tif (ans < s) {\\n\\t\\t\\t\\t\\tans = s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int maxTwoEvents(int[][] events) {\\n\\t\\tint n = events.length;\\n\\t\\tint[][] start = new int[n][];\\n\\t\\tint[][] end = new int[n][];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstart[i] = new int[]{events[i][0], events[i][2]};\\n\\t\\t\\tend[i] = new int[]{events[i][1], events[i][2]};\\n\\t\\t}\\n\\n\\t\\tComparator<int[]> cp = new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tArrays.sort(start, cp);\\n\\t\\tArrays.sort(end, cp);\\n\\n\\t\\tint ans = 0;\\n\\t\\tint j = 0;\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (j < n && end[j][0] < start[i][0]) {\\n\\t\\t\\t\\tif (max < end[j][1]) {\\n\\t\\t\\t\\t\\tmax = end[j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint s = start[i][1] + max;\\n\\t\\t\\tif (ans < s) {\\n\\t\\t\\t\\tans = s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\tint[][] E;\\n\\tint n;\\n\\tpublic int maxTwoEvents(int[][] events) {\\n\\t\\tn = events.length;\\n\\t\\tint ans = 0;\\n\\t\\tArrays.sort(events, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0] - o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tE = events;\\n\\t\\tint[] max = new int[n];\\n\\t\\tmax[n - 1] = events[n - 1][2];\\n\\t\\tfor (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tmax[i] = Math.max(max[i + 1], events[i][2]);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint idx = bsEvent(i, events[i][1]);\\n\\t\\t\\tif (idx == n) {\\n\\t\\t\\t\\tif (ans < events[i][2]) {\\n\\t\\t\\t\\t\\tans = events[i][2];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint s = events[i][2] + max[idx];\\n\\t\\t\\t\\tif (ans < s) {\\n\\t\\t\\t\\t\\tans = s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int bsEvent(int idx, int end) {\\n\\t\\tint l = idx + 1;\\n\\t\\tint r = n - 1;\\n\\t\\tint mid = 0;\\n\\t\\twhile (l <= r) {\\n\\t\\t\\tmid = l + ((r - l) >> 1);\\n\\t\\t\\tif (E[mid][0] <= end) {\\n\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tr = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn l;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785530,
                "title": "python-simple-and-clean-solution",
                "content": "```\\nfrom bisect import bisect_left\\nfrom functools import partial\\nfrom itertools import accumulate\\nfrom operator import itemgetter\\n\\nEND_KEY = itemgetter(1)\\n\\n\\nclass Solution:\\n    def maxTwoEvents(self, E: list[list[int]]) -> int:\\n        E.sort(key=END_KEY)\\n\\n        cum_mx_value = self.cumulative_max_value(E)  # note that first value is \"0\"\\n\\n        bl = partial(bisect_left, E, key=END_KEY)  # bl(s) = largest index \"i\" such that, for all x in E[:i], x[1] < s\\n\\n        return max(cum_mx_value[bl(s)] + v for s, _, v in E)\\n\\n    @staticmethod\\n    def cumulative_max_value(E: list[list[int]]) -> list[int]:\\n        return list(accumulate((e[2] for e in E), func=max, initial=0))\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nfrom functools import partial\\nfrom itertools import accumulate\\nfrom operator import itemgetter\\n\\nEND_KEY = itemgetter(1)\\n\\n\\nclass Solution:\\n    def maxTwoEvents(self, E: list[list[int]]) -> int:\\n        E.sort(key=END_KEY)\\n\\n        cum_mx_value = self.cumulative_max_value(E)  # note that first value is \"0\"\\n\\n        bl = partial(bisect_left, E, key=END_KEY)  # bl(s) = largest index \"i\" such that, for all x in E[:i], x[1] < s\\n\\n        return max(cum_mx_value[bl(s)] + v for s, _, v in E)\\n\\n    @staticmethod\\n    def cumulative_max_value(E: list[list[int]]) -> list[int]:\\n        return list(accumulate((e[2] for e in E), func=max, initial=0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742815,
                "title": "solution-using-priority-queue-and-sorting-no-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        int n = e.size();\\n        int res = 0;\\n        int val = 0;\\n        sort(e.begin(),e.end());\\n        priority_queue<pair<int,int>> pq;\\n        for(int i =0;i<n;i++)\\n        {\\n            while(!pq.empty() and -pq.top().first < e[i][0])\\n            {\\n                val = max(val,pq.top().second);\\n                pq.pop();\\n            }\\n            res = max(res,val + e[i][2]);\\n            pq.push({-e[i][1] , e[i][2]});\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        int n = e.size();\\n        int res = 0;\\n        int val = 0;\\n        sort(e.begin(),e.end());\\n        priority_queue<pair<int,int>> pq;\\n        for(int i =0;i<n;i++)\\n        {\\n            while(!pq.empty() and -pq.top().first < e[i][0])\\n            {\\n                val = max(val,pq.top().second);\\n                pq.pop();\\n            }\\n            res = max(res,val + e[i][2]);\\n            pq.push({-e[i][1] , e[i][2]});\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724930,
                "title": "python-sort-maxsofararray-binary-search",
                "content": "```\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        sumArray = [events[-1][2]]\\n        for i in range(len(events) - 2, -1, -1):\\n            sumArray.append(max(events[i][2], sumArray[-1]))\\n        \\n        sumArray = sumArray[::-1]\\n        \\n        res = float(\\'-inf\\')\\n        for s, e, v in events:\\n            res = max(res, v)\\n            index = bisect.bisect_right(events, [e+1])\\n            if index != len(events):\\n                res = max(res, v + sumArray[index])\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        events.sort()\\n        sumArray = [events[-1][2]]\\n        for i in range(len(events) - 2, -1, -1):\\n            sumArray.append(max(events[i][2], sumArray[-1]))\\n        \\n        sumArray = sumArray[::-1]\\n        \\n        res = float(\\'-inf\\')\\n        for s, e, v in events:\\n            res = max(res, v)\\n            index = bisect.bisect_right(events, [e+1])\\n            if index != len(events):\\n                res = max(res, v + sumArray[index])\\n        \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2721272,
                "title": "c-sorting-beats-99-61-simple-greedy-without-heap",
                "content": "If for a particular event i with endTime(i), there exist 2 events j1 and j2 both having startTime>endTime(i) and startTime(j1)<startTime(j2) and value(j1)<value(j2), then it is always optimal to choose j2 for pairing with event i.\\n\\n```\\n#define pii pair<int,int>\\n\\nclass Solution {\\npublic:\\n    \\n    int upper_bound_custom (vector<pii>& listing, int start, int end, int k) {\\n        int ans = end+1;\\n        while (start<=end) {\\n            int mid = (start+end)/2;\\n            if (listing[mid].first<=k) start=mid+1;\\n            else ans=mid, end=mid-1;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        //When checking an event i, find the next event j whose starttime(j)>=endtime(i)+1\\n        //And has the highest priority\\n        //Final list will have elements arranged in decreasing order of priority\\n        //pair<int,int> list(m); \\n        //for all j>i, list[j].first>list[i].first and list[j].second<list[i].second\\n        //Iterate in the events array and upper_bound \\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<pii> listing;\\n        for (int i=n-1; i>=0; i--) {\\n            if (!listing.empty() && listing.back().second>=events[i][2]) continue;\\n            listing.push_back({events[i][0], events[i][2]});\\n        }\\n        reverse(listing.begin(), listing.end());\\n        int maxi = 0, m = listing.size();\\n        for (int i=0; i<n; i++) {\\n            int end = events[i][1];\\n            int idx = upper_bound_custom(listing, 0, m-1, end);\\n            if (idx==m) maxi = max(maxi, events[i][2]);\\n            else maxi = max(maxi, events[i][2]+listing[idx].second);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int,int>\\n\\nclass Solution {\\npublic:\\n    \\n    int upper_bound_custom (vector<pii>& listing, int start, int end, int k) {\\n        int ans = end+1;\\n        while (start<=end) {\\n            int mid = (start+end)/2;\\n            if (listing[mid].first<=k) start=mid+1;\\n            else ans=mid, end=mid-1;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        //When checking an event i, find the next event j whose starttime(j)>=endtime(i)+1\\n        //And has the highest priority\\n        //Final list will have elements arranged in decreasing order of priority\\n        //pair<int,int> list(m); \\n        //for all j>i, list[j].first>list[i].first and list[j].second<list[i].second\\n        //Iterate in the events array and upper_bound \\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<pii> listing;\\n        for (int i=n-1; i>=0; i--) {\\n            if (!listing.empty() && listing.back().second>=events[i][2]) continue;\\n            listing.push_back({events[i][0], events[i][2]});\\n        }\\n        reverse(listing.begin(), listing.end());\\n        int maxi = 0, m = listing.size();\\n        for (int i=0; i<n; i++) {\\n            int end = events[i][1];\\n            int idx = upper_bound_custom(listing, 0, m-1, end);\\n            if (idx==m) maxi = max(maxi, events[i][2]);\\n            else maxi = max(maxi, events[i][2]+listing[idx].second);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694131,
                "title": "o-nlogn-time-o-n-space-5-lines",
                "content": "convert each event to 2 events:  for each (start, end, val):\\n1. (isEnd = 0, time = start, value = val)\\n2. (isEnd = 1, time = end, value = val)\\nsort them by primary key = time, secondary = isEnd.\\nNow iterate in this list backwards,\\n\\n* each time u see start event update bestStart = max(bestStart, value of this event)\\n* each time u see end event update res = max(res,  value of this event + bestStart)\\n\\n\\n```\\nclass Solution(object):\\n    def maxTwoEvents(self, events):\\n        \"\"\"\\n        :type events: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res, bestStart = 0, 0\\n        for x in reversed(sorted([(0, event[0], event[2]) for event in events] + [(1, event[1], event[2]) for event in events], key = lambda x : (x[1], x[0]))):\\n            bestStart = max(bestStart, x[2]) if x[0] == 0 else bestStart\\n            res = max(res, x[2] + bestStart) if x[0] == 1 else res\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxTwoEvents(self, events):\\n        \"\"\"\\n        :type events: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res, bestStart = 0, 0\\n        for x in reversed(sorted([(0, event[0], event[2]) for event in events] + [(1, event[1], event[2]) for event in events], key = lambda x : (x[1], x[0]))):\\n            bestStart = max(bestStart, x[2]) if x[0] == 0 else bestStart\\n            res = max(res, x[2] + bestStart) if x[0] == 1 else res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689819,
                "title": "c-beats-90-lambdas-are-your-friend",
                "content": "For every interval, we just want to know the max value of an interval that starts ahead of it. This can be accomplished with a prefix array and binary search in O(n log n) time. Sort the intervals by start time and binary search for the first interval that starts at end+1 or greater. \\n\\n```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int ans = 0;\\n        sort(events.begin(), events.end(), [](const vector<int>& a, const vector<int>&b){return a[0] < b[0];});\\n        auto pref = events;\\n        for(int i = pref.size()-2; i >=0 ; i--) pref[i][2] = max(pref[i][2], pref[i+1][2]); // best interval ahead\\n        for(int i = 0; i < events.size(); i++){\\n            int right = events[i][1];\\n            auto it = lower_bound(pref.begin(), pref.end(), right+1,\\n            [](const vector<int>& a, const int &b){return a[0] < b;});\\n            if(it != pref.end()) ans = max(ans, events[i][2] + (*it)[2]);\\n            else ans = max(ans, events[i][2]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int ans = 0;\\n        sort(events.begin(), events.end(), [](const vector<int>& a, const vector<int>&b){return a[0] < b[0];}",
                "codeTag": "Java"
            },
            {
                "id": 2643618,
                "title": "two-pointers-like-approach-o-n-log-n",
                "content": "We create two versions of original events array. Sort one by endTime and another by startTime. Loop over the first one while keeping a state of all the events which *ended* before (and which one is the *most-profitable* from those).\\n\\nStating the obvious but we try to leverage the fact that while looping through the array sorted by startTime if an event(E) has ended before ith element than we can assume that such event E has definitely ended before subsequent items of the loop i.e. i+1, i+2.. and so on.\\n\\n```\\npublic int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        int[][] events_sortedByEnd = events.clone();\\n        int[][] events_sortedByStart = events.clone();\\n        \\n        Arrays.sort(events_sortedByEnd, (int[] e1, int[] e2) -> e1[1] - e2[1]); // ascending endTimes\\n        int biggestOpened = 0;\\n        int maxSum = 0;\\n        \\n        Arrays.sort(events_sortedByStart, (int[] e1, int[] e2) -> e1[0] - e2[0]); // ascending startTimes\\n        int j=0; // aka events_sortedByEnd_cursor\\n        \\n        for (int i=0; i<events_sortedByStart.length; i++) {\\n            int[] currEvent = events_sortedByStart[i];\\n            \\n            while (j < n && events_sortedByEnd[j][1] < currEvent[0]) {\\n                // potential candidates\\n                biggestOpened = Math.max(biggestOpened, events_sortedByEnd[j][2]);\\n                j++;\\n            }\\n            \\n            maxSum = Math.max(maxSum, currEvent[2] + biggestOpened);\\n        }\\n        \\n        return maxSum;\\n    }\\n```\\n\\nTime Complexity: O(nlogn) // 2 times sorting + 2 clone",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxTwoEvents(int[][] events) {\\n        int n = events.length;\\n        int[][] events_sortedByEnd = events.clone();\\n        int[][] events_sortedByStart = events.clone();\\n        \\n        Arrays.sort(events_sortedByEnd, (int[] e1, int[] e2) -> e1[1] - e2[1]); // ascending endTimes\\n        int biggestOpened = 0;\\n        int maxSum = 0;\\n        \\n        Arrays.sort(events_sortedByStart, (int[] e1, int[] e2) -> e1[0] - e2[0]); // ascending startTimes\\n        int j=0; // aka events_sortedByEnd_cursor\\n        \\n        for (int i=0; i<events_sortedByStart.length; i++) {\\n            int[] currEvent = events_sortedByStart[i];\\n            \\n            while (j < n && events_sortedByEnd[j][1] < currEvent[0]) {\\n                // potential candidates\\n                biggestOpened = Math.max(biggestOpened, events_sortedByEnd[j][2]);\\n                j++;\\n            }\\n            \\n            maxSum = Math.max(maxSum, currEvent[2] + biggestOpened);\\n        }\\n        \\n        return maxSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620340,
                "title": "easy-to-understand-solutuion-using-binary-search",
                "content": "```\\nclass Solution \\n{\\n    private int bs(int limit, int[][] e)\\n    {\\n        int left = 0;\\n        int right = e.length - 1;\\n        int index = -1;\\n        while (left <= right)\\n        {\\n            int mid = (left + right) / 2;\\n            if (e[mid][0] > limit)\\n            {\\n                index = mid;\\n                right = mid - 1;\\n            }\\n            else\\n                left = mid + 1;\\n        }\\n        return index;\\n    }\\n    \\n    public int maxTwoEvents(int[][] events) \\n    {\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int n = events.length;\\n        int[] sufMax = new int[n];\\n        sufMax[n - 1] = events[n - 1][2];\\n        for (int i = n - 2; i >= 0; i--)\\n            sufMax[i] = Math.max(sufMax[i + 1], events[i][2]);\\n        int answer = sufMax[0]; // we can attend one event, so answer stores the maximum of values\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = bs(events[i][1], events);\\n\\t\\t\\t// what we find using binary search is the left most index whose starting time is greater than events[i][1]\\n\\t\\t\\t// then we use the suffix max array to find the max value in the range of (x, n - 1), both inclusive\\n            if (x == -1)\\n                continue;\\n            answer = Math.max(answer, events[i][2] + sufMax[x]);\\n        }\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    private int bs(int limit, int[][] e)\\n    {\\n        int left = 0;\\n        int right = e.length - 1;\\n        int index = -1;\\n        while (left <= right)\\n        {\\n            int mid = (left + right) / 2;\\n            if (e[mid][0] > limit)\\n            {\\n                index = mid;\\n                right = mid - 1;\\n            }\\n            else\\n                left = mid + 1;\\n        }\\n        return index;\\n    }\\n    \\n    public int maxTwoEvents(int[][] events) \\n    {\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int n = events.length;\\n        int[] sufMax = new int[n];\\n        sufMax[n - 1] = events[n - 1][2];\\n        for (int i = n - 2; i >= 0; i--)\\n            sufMax[i] = Math.max(sufMax[i + 1], events[i][2]);\\n        int answer = sufMax[0]; // we can attend one event, so answer stores the maximum of values\\n        for (int i = 0; i < n; i++)\\n        {\\n            int x = bs(events[i][1], events);\\n\\t\\t\\t// what we find using binary search is the left most index whose starting time is greater than events[i][1]\\n\\t\\t\\t// then we use the suffix max array to find the max value in the range of (x, n - 1), both inclusive\\n            if (x == -1)\\n                continue;\\n            answer = Math.max(answer, events[i][2] + sufMax[x]);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607372,
                "title": "java-sort-min-heap-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a,b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]) ;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]) ;\\n        \\n        int n = events.length ;\\n        int maxValue = 0, result = 0 ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!pq.isEmpty() && pq.peek()[0] < events[i][0]) {\\n                maxValue = Math.max(maxValue, pq.peek()[1]) ;\\n                pq.remove() ;\\n            }\\n            result = Math.max(result, maxValue + events[i][2]) ;\\n            pq.add(new int[]{events[i][1], events[i][2]}) ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTwoEvents(int[][] events) {\\n        Arrays.sort(events, (a,b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]) ;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]) ;\\n        \\n        int n = events.length ;\\n        int maxValue = 0, result = 0 ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!pq.isEmpty() && pq.peek()[0] < events[i][0]) {\\n                maxValue = Math.max(maxValue, pq.peek()[1]) ;\\n                pq.remove() ;\\n            }\\n            result = Math.max(result, maxValue + events[i][2]) ;\\n            pq.add(new int[]{events[i][1], events[i][2]}) ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606496,
                "title": "dp-binarysearch-heap-simple-greedy-python",
                "content": "```\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        #keep track of max value of finished event so far, that means u can add its value to curr_event\\n        proc = []\\n        ans = m = 0  # m represents max value of finished event so far\\n        for s,e,v in events:\\n            proc.append( (s, True, v) )     # time, is_start, val\\n            proc.append( (e+1, False, v) )  # use e+1 (inclusive)\\n        proc.sort()  # sort by time\\n        \\n        for time, is_start, val in proc:\\n            if is_start:\\n                ans = max(ans, m+val)\\n            else:\\n                m = max(m, val)\\n        return ans\\n    \\n        #heap solution: use heap to keep track of max finished event so far, same as prev approach\\n        events.sort()\\n        max_prev_val, res = 0, 0\\n        int_heap = []\\n        for s, e, v in events:\\n            heapq.heappush(int_heap, (e, v))\\n            while int_heap and int_heap[0][0] < s:\\n                _, val = heapq.heappop(int_heap)\\n                max_prev_val = max(max_prev_val, val)\\n            res = max(res, v + max_prev_val)\\n        return res\\n    \\n    \\n        #dp approach with binary search\\n        events.sort(key=lambda x: x[1])#sorting by end day\\n        n = len(events)\\n        \\n        dp = [0]*n\\n        c_max = 0\\n        for i in range(n):\\n            c_max = max(c_max, events[i][2])\\n            dp[i] = c_max\\n        \\n        ans = 0\\n        for i in range(n-1, -1, -1):\\n            startDay = events[i][0]\\n            \\n            ans = max(ans, events[i][2])\\n            \\n            L = 0; R = i\\n            while L < R:\\n                M = (L+R+1)//2\\n                \\n                if events[M][1] >= startDay:\\n                    R = M-1\\n                else:\\n                    L = M\\n            \\n            if events[L][1] < startDay:\\n                ans = max(ans, dp[L] + events[i][2])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        #keep track of max value of finished event so far, that means u can add its value to curr_event\\n        proc = []\\n        ans = m = 0  # m represents max value of finished event so far\\n        for s,e,v in events:\\n            proc.append( (s, True, v) )     # time, is_start, val\\n            proc.append( (e+1, False, v) )  # use e+1 (inclusive)\\n        proc.sort()  # sort by time\\n        \\n        for time, is_start, val in proc:\\n            if is_start:\\n                ans = max(ans, m+val)\\n            else:\\n                m = max(m, val)\\n        return ans\\n    \\n        #heap solution: use heap to keep track of max finished event so far, same as prev approach\\n        events.sort()\\n        max_prev_val, res = 0, 0\\n        int_heap = []\\n        for s, e, v in events:\\n            heapq.heappush(int_heap, (e, v))\\n            while int_heap and int_heap[0][0] < s:\\n                _, val = heapq.heappop(int_heap)\\n                max_prev_val = max(max_prev_val, val)\\n            res = max(res, v + max_prev_val)\\n        return res\\n    \\n    \\n        #dp approach with binary search\\n        events.sort(key=lambda x: x[1])#sorting by end day\\n        n = len(events)\\n        \\n        dp = [0]*n\\n        c_max = 0\\n        for i in range(n):\\n            c_max = max(c_max, events[i][2])\\n            dp[i] = c_max\\n        \\n        ans = 0\\n        for i in range(n-1, -1, -1):\\n            startDay = events[i][0]\\n            \\n            ans = max(ans, events[i][2])\\n            \\n            L = 0; R = i\\n            while L < R:\\n                M = (L+R+1)//2\\n                \\n                if events[M][1] >= startDay:\\n                    R = M-1\\n                else:\\n                    L = M\\n            \\n            if events[L][1] < startDay:\\n                ans = max(ans, dp[L] + events[i][2])\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2604506,
                "title": "python-sorting-minheap-solution",
                "content": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        heap = []; events.sort()\\n        result, maxVal = 0, 0\\n        for i in range(len(events)):\\n            while heap and heap[0][0] < events[i][0]:\\n                maxVal = max(maxVal, heappop(heap)[1])\\n            result = max(result, maxVal + events[i][2])\\n            heappush(heap, (events[i][1], events[i][2]))\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        heap = []; events.sort()\\n        result, maxVal = 0, 0\\n        for i in range(len(events)):\\n            while heap and heap[0][0] < events[i][0]:\\n                maxVal = max(maxVal, heappop(heap)[1])\\n            result = max(result, maxVal + events[i][2])\\n            heappush(heap, (events[i][1], events[i][2]))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576558,
                "title": "c-easy-to-understand-minheap-implementation",
                "content": "```\\n\\n#define ipair pair<int,int>\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n\\t\\n        //sort based on smaller start time\\n       sort(events.begin(), events.end());\\n        \\n        int mx = 0, ans = 0, n = events.size();\\n        priority_queue<ipair, vector<ipair>, greater<>> pq;\\n        // pq conatins {event_endtime , even_value}\\n        // for every event check the max-value of earlier events whose \\n        // deadline is less than start time of curr event\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n                mx = max(mx, pq.top().second), pq.pop();\\n            \\n            ans = max(ans, mx+events[i][2]);\\n            pq.push({events[i][1], events[i][2]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n#define ipair pair<int,int>\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n\\t\\n        //sort based on smaller start time\\n       sort(events.begin(), events.end());\\n        \\n        int mx = 0, ans = 0, n = events.size();\\n        priority_queue<ipair, vector<ipair>, greater<>> pq;\\n        // pq conatins {event_endtime , even_value}\\n        // for every event check the max-value of earlier events whose \\n        // deadline is less than start time of curr event\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n                mx = max(mx, pq.top().second), pq.pop();\\n            \\n            ans = max(ans, mx+events[i][2]);\\n            pq.push({events[i][1], events[i][2]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567351,
                "title": "bug",
                "content": "Why the expected is 85 and not 93?:\\n![image](https://assets.leetcode.com/users/images/25939090-4ed5-48df-8b4e-757993ff5d0e_1662998708.9219844.png)\\n",
                "solutionTags": [],
                "code": "Why the expected is 85 and not 93?:\\n![image](https://assets.leetcode.com/users/images/25939090-4ed5-48df-8b4e-757993ff5d0e_1662998708.9219844.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2527189,
                "title": "python-heap-o-nlog-n",
                "content": "```\\nclass Solution(object):\\n    def maxTwoEvents(self, events):\\n        events.sort()\\n        heap=[]\\n        heappush(heap,events[0][1:3])\\n        maximum,ans=0,0\\n        \\n        for event in events:\\n            ans=max(ans, event[2])\\n                \\n        for event in events[1:]:           \\n            while heap and heap[0][0]<event[0]:\\n                maximum=max(maximum, heap[0][1])\\n                heappop(heap)            \\n            ans=max(ans,maximum+event[2])                \\n            heappush(heap,event[1:3])                       \\n        return ans\\n                \\n                \\n                \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxTwoEvents(self, events):\\n        events.sort()\\n        heap=[]\\n        heappush(heap,events[0][1:3])\\n        maximum,ans=0,0\\n        \\n        for event in events:\\n            ans=max(ans, event[2])\\n                \\n        for event in events[1:]:           \\n            while heap and heap[0][0]<event[0]:\\n                maximum=max(maximum, heap[0][1])\\n                heappop(heap)            \\n            ans=max(ans,maximum+event[2])                \\n            heappush(heap,event[1:3])                       \\n        return ans\\n                \\n                \\n                \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459497,
                "title": "c-simillar-to-maximum-no-of-events-that-he-can-attend",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>>dp;\\n    int pos(vector<vector<int>>&nums,int s,int val)\\n    {\\n        int l=s;\\n        int h=nums.size()-1;\\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(nums[mid][0]>val)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n        \\n        }\\n    static bool comp(vector<int>&a,vector<int>&b)\\n    {\\n        if(a[0]==b[0])\\n            return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int solve(vector<vector<int>>&nums,int i,int n,int k )\\n    {\\n        if(i==-1)\\n            return 0;\\n        if(i>=n||k<=0)\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int j=pos(nums,i+1,nums[i][1]);\\n        int op1=solve(nums,i+1,n,k);\\n        int op2=nums[i][2]+solve(nums,j,n,k-1);\\n        return dp[i][k]= max(op1,op2);\\n    }\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        sort(events.begin(),events.end(),comp);\\n        int n=events.size();\\n        dp.assign(n+1,vector<int>(3,-1));\\n        return solve(events,0,n,2);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>>dp;\\n    int pos(vector<vector<int>>&nums,int s,int val)\\n    {\\n        int l=s;\\n        int h=nums.size()-1;\\n        int ans=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            if(nums[mid][0]>val)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2434731,
                "title": "c-as-clean-as-it-gets",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, int> p;\\n    int maxTwoEvents(vector<vector<int>> &events)\\n    {\\n\\n        sort(events.begin(), events.end());\\n\\n        events.push_back(vector<int>{INT_MAX, INT_MAX, 0});\\n\\n        priority_queue<p, vector<p>, greater<p>> conflicts;\\n\\n        multiset<int, greater<int>> maxinterval;\\n\\n        for (auto &e : events)\\n            maxinterval.insert(e[2]);\\n\\n        int maxres = 0;\\n\\n        for (auto &event : events)\\n        {\\n            int s = event[0];\\n            int e = event[1];\\n            int val = event[2];\\n\\n            while (conflicts.size() && s > conflicts.top().first)\\n            {\\n                maxres = max(maxres, conflicts.top().second + *maxinterval.begin());\\n                conflicts.pop();\\n            }\\n\\n            conflicts.emplace(e, val);\\n\\n            maxinterval.erase(maxinterval.find(val));\\n        }\\n\\n        return maxres;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef pair<int, int> p;\\n    int maxTwoEvents(vector<vector<int>> &events)\\n    {\\n\\n        sort(events.begin(), events.end());\\n\\n        events.push_back(vector<int>{INT_MAX, INT_MAX, 0});\\n\\n        priority_queue<p, vector<p>, greater<p>> conflicts;\\n\\n        multiset<int, greater<int>> maxinterval;\\n\\n        for (auto &e : events)\\n            maxinterval.insert(e[2]);\\n\\n        int maxres = 0;\\n\\n        for (auto &event : events)\\n        {\\n            int s = event[0];\\n            int e = event[1];\\n            int val = event[2];\\n\\n            while (conflicts.size() && s > conflicts.top().first)\\n            {\\n                maxres = max(maxres, conflicts.top().second + *maxinterval.begin());\\n                conflicts.pop();\\n            }\\n\\n            conflicts.emplace(e, val);\\n\\n            maxinterval.erase(maxinterval.find(val));\\n        }\\n\\n        return maxres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432582,
                "title": "accepted-c-solution-sort-binary-search-tc-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int mx_val = 0 , n = events.size();\\n        sort(events.begin() , events.end());\\n        \\n        vector<int> mx_till_idx(n);\\n        int temp_mx = INT_MIN;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            temp_mx = max(temp_mx , events[i][2]);\\n            mx_till_idx[i] = temp_mx;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int end_i = events[i][1] , val_i = events[i][2];\\n            int left = 0 , right = n - 1;\\n            \\n            int stp_idx = -1;\\n            \\n            while(left <= right){\\n                int mid = left + (right - left)/2;\\n                \\n                if(events[mid][0] > end_i){\\n                    stp_idx = mid;\\n                    right = mid - 1;\\n                }else\\n                    left = mid + 1;\\n            }\\n            \\n            if(stp_idx != -1)\\n                val_i += mx_till_idx[stp_idx];\\n          \\n            mx_val = max(mx_val , val_i);\\n        }\\n        \\n        return mx_val;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n        int mx_val = 0 , n = events.size();\\n        sort(events.begin() , events.end());\\n        \\n        vector<int> mx_till_idx(n);\\n        int temp_mx = INT_MIN;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            temp_mx = max(temp_mx , events[i][2]);\\n            mx_till_idx[i] = temp_mx;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2425013,
                "title": "c-solution",
                "content": "using System.CodeDom.Compiler;\\nusing System.Collections.Generic;\\nusing System.Collections;\\nusing System.ComponentModel;\\nusing System.Diagnostics.CodeAnalysis;\\nusing System.Globalization;\\nusing System.IO;\\nusing System.Linq;\\nusing System.Reflection;\\nusing System.Runtime.Serialization;\\nusing System.Text.RegularExpressions;\\nusing System.Text;\\nusing System;\\nusing System.ComponentModel.DataAnnotations;\\nusing System.Net.Http;\\nusing System.Threading.Tasks;\\n\\nclass Event\\n{\\n    public int eventId;\\n    public int startTime;\\n    public int endTime;\\n    public int value;\\n}\\nclass Solution\\n{\\n    public static bool IsOverlap(Event a,Event b)\\n    {\\n        if (a.startTime == b.startTime) return true;\\n        if (a.endTime == b.startTime) return true;\\n        if (a.startTime == b.endTime) return true;\\n        if (a.startTime > b.startTime && a.startTime < b.endTime) return true;\\n        if (b.startTime > a.startTime && b.startTime < a.endTime) return true;\\n        return false;\\n    }\\n    public static int SumTwoEventsvalue(Event a,Event b)\\n    {\\n        return a.value + b.value;\\n    }\\n    public static int MaxTwoEvents(int[][] events)\\n    {\\n        List<Event> listEvents = new();\\n        List<Event> max_Value = new();\\n        for (int i = 0; i < events.GetLength(0); i++)\\n        {\\n            listEvents.Add(new Event() { eventId = i,startTime = events[i][0], endTime = events[i][1], value = events[i][2] });\\n        }\\n\\n        listEvents = listEvents.OrderBy(a => a.startTime).ToList();\\n\\n        //Lets imagine max value event \\n        int maxValueEvent = listEvents.Max(a => a.value);\\n\\n        //Now we need to check if any non - over lapping event can swap this\\n        for (int i = 0; i < listEvents.Count; i++)\\n        {\\n            for (int j = 0; j < listEvents.Count; j++)\\n            {\\n                if(listEvents[i] != listEvents[j])\\n                {\\n                    if (!IsOverlap(listEvents[i], listEvents[j]) && SumTwoEventsvalue(listEvents[i],listEvents[j]) > maxValueEvent)\\n                    {\\n                        maxValueEvent = SumTwoEventsvalue(listEvents[i], listEvents[j]);\\n                    }\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n        return maxValueEvent;\\n    }\\n    public static void Main(string[] args)\\n    {\\n        int[][] vs = new int[3][];\\n\\n        vs[0] = new int[3] { 1, 5, 3 };\\n        vs[1] = new int[3] { 1, 5, 1 };\\n        vs[2] = new int[3] { 6, 6, 5 };\\n        Console.WriteLine(MaxTwoEvents(vs));\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public static bool IsOverlap(Event a,Event b)\\n    {\\n        if (a.startTime == b.startTime) return true;\\n        if (a.endTime == b.startTime) return true;\\n        if (a.startTime == b.endTime) return true;\\n        if (a.startTime > b.startTime && a.startTime < b.endTime) return true;\\n        if (b.startTime > a.startTime && b.startTime < a.endTime) return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2384089,
                "title": "c-recursion-dp-binary-search-sorting-great-concept-building",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n     \\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(events.size(), vector<int> (2, -1));\\n        return helper(events, 0, dp, 0);\\n    }\\n    \\n    int helper(vector<vector<int>> &events, int i, vector<vector<int>> &dp, int cnt)\\n    {\\n        if(i >= events.size() || cnt == 2)\\n            return 0;\\n        \\n        if(dp[i][cnt] != -1)\\n            return dp[i][cnt];\\n        \\n        // Not Including Currrent Interval\\n        int ans = helper(events, i + 1, dp, cnt);\\n        \\n        // Including Current Interval\\n        int n = events.size(), si = i + 1, ei = n - 1, j = n;\\n        while(si <= ei)\\n        {\\n            int mid = si + (ei - si) / 2;\\n            \\n            if(events[mid][0] > events[i][1]) \\n                j = mid, ei = mid - 1;\\n            else\\n                si = mid + 1;\\n        }\\n        \\n        ans = max(ans, events[i][2] + helper(events, j, dp, cnt + 1));\\n        return dp[i][cnt] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) {\\n     \\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(events.size(), vector<int> (2, -1));\\n        return helper(events, 0, dp, 0);\\n    }\\n    \\n    int helper(vector<vector<int>> &events, int i, vector<vector<int>> &dp, int cnt)\\n    {\\n        if(i >= events.size() || cnt == 2)\\n            return 0;\\n        \\n        if(dp[i][cnt] != -1)\\n            return dp[i][cnt];\\n        \\n        // Not Including Currrent Interval\\n        int ans = helper(events, i + 1, dp, cnt);\\n        \\n        // Including Current Interval\\n        int n = events.size(), si = i + 1, ei = n - 1, j = n;\\n        while(si <= ei)\\n        {\\n            int mid = si + (ei - si) / 2;\\n            \\n            if(events[mid][0] > events[i][1]) \\n                j = mid, ei = mid - 1;\\n            else\\n                si = mid + 1;\\n        }\\n        \\n        ans = max(ans, events[i][2] + helper(events, j, dp, cnt + 1));\\n        return dp[i][cnt] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314834,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        int n = e.size();\\n        map<int, pair<int, int>> mp;\\n        \\n        for(auto itr: e)\\n        {\\n            if((mp.find(itr[0])==mp.end()) || mp[itr[0]].second < itr[2])\\n                mp[itr[0]] = {itr[1], itr[2]};\\n        }\\n        \\n        int mx = 0;\\n        for (auto it = mp.rbegin(); it != mp.rend(); it++) \\n        {\\n            mx = max(mx, (*it).second.second);\\n            (*it).second.second = mx;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = max(ans, e[i][2]);\\n            int en = e[i][1];\\n            auto itr = mp.upper_bound(en);\\n            if(itr!=mp.end())\\n                ans = max(ans, e[i][2]+(*itr).second.second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& e) {\\n        int n = e.size();\\n        map<int, pair<int, int>> mp;\\n        \\n        for(auto itr: e)\\n        {\\n            if((mp.find(itr[0])==mp.end()) || mp[itr[0]].second < itr[2])\\n                mp[itr[0]] = {itr[1], itr[2]};\\n        }\\n        \\n        int mx = 0;\\n        for (auto it = mp.rbegin(); it != mp.rend(); it++) \\n        {\\n            mx = max(mx, (*it).second.second);\\n            (*it).second.second = mx;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = max(ans, e[i][2]);\\n            int en = e[i][1];\\n            auto itr = mp.upper_bound(en);\\n            if(itr!=mp.end())\\n                ans = max(ans, e[i][2]+(*itr).second.second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313717,
                "title": "c-binary-search-suffix-sum",
                "content": "\\tstatic bool comp(vector<int> &x, vector<int> &y)\\n    {\\n        return x[0] < y[0];\\n    }\\n\\tclass Solution {\\n\\tpublic:\\n    int maxTwoEvents(vector<vector<int>>& a) \\n    {\\n        sort(a.begin(), a.end(), comp);\\n        \\n        vector<int> et;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            et.push_back(a[i][0]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        int n = a.size();\\n        \\n        int maxr[n];\\n        \\n        int maxm = 0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            maxm = max(maxm, a[i][2]);\\n            \\n            maxr[i] = maxm;\\n        }\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            int c = 0;\\n            \\n            c += a[i][2];\\n            \\n            int v = a[i][1];\\n            \\n            auto it = upper_bound(et.begin(), et.end(), v);\\n            \\n            int count = 1;\\n            \\n            if(it != et.end())\\n            while(true)\\n            {\\n                count++;\\n                \\n                int idx = it - et.begin();\\n                \\n                int maxi = maxr[idx];\\n                \\n                c += maxi;\\n    \\n                if(count == 2) break;\\n            }\\n            \\n            ans = max(ans, c);\\n        }\\n        \\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int maxTwoEvents(vector<vector<int>>& a) \\n    {\\n        sort(a.begin(), a.end(), comp);\\n        \\n        vector<int> et;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            et.push_back(a[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2239517,
                "title": "c-priority-queue-min-heap-easy-explanation-with-comments",
                "content": "```\\n#define ipair pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n        /*we have to take only 2 events so we can take one and the other one which we are taking \\n\\t\\tmust satisfy the following that its start must be greater than another\\'s deadline. if we search \\n\\t\\ttowards end then there\\'s a problem bcs we havent traversed all the elements in array after it, \\n\\t\\tso it is better if we find first element from the beginnnign part of array and second element as \\n\\t\\tcur element in array */\\n        \\n        /*now two conditions must satisfy one is that start of first must be smaller than start of cur \\n\\t\\twhich can be done by sorting the array by start time and edeadline of first must be smaller \\n\\t\\tthan start of cur, the only oness which satisfy this condition maximum must be taken of them \\n\\t\\tonly, so since deadline wise array is not sorted, a large deadline may appear before a lesser \\n\\t\\tdeadline but we need to consider the lesser one, so we can make a min heap that gives us \\n\\t\\tminimum such deadline of all the deadline we have traversed so far and if this is less than cur \\n\\t\\tstart then we can maximise the profit from it else if it is not lesser than cur start then let it be in \\n\\t\\theap so when cur grows it becomes suitable */\\n        \\n        sort(events.begin(), events.end());\\n        int mx = 0, ans = 0, n = events.size();\\n        \\n        priority_queue<ipair, vector<ipair>, greater<>> pq;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n                mx = max(mx, pq.top().second), pq.pop();\\n            \\n            ans = max(ans, mx+events[i][2]);\\n            pq.push({events[i][1], events[i][2]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ipair pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int maxTwoEvents(vector<vector<int>>& events) \\n    {\\n        /*we have to take only 2 events so we can take one and the other one which we are taking \\n\\t\\tmust satisfy the following that its start must be greater than another\\'s deadline. if we search \\n\\t\\ttowards end then there\\'s a problem bcs we havent traversed all the elements in array after it, \\n\\t\\tso it is better if we find first element from the beginnnign part of array and second element as \\n\\t\\tcur element in array */\\n        \\n        /*now two conditions must satisfy one is that start of first must be smaller than start of cur \\n\\t\\twhich can be done by sorting the array by start time and edeadline of first must be smaller \\n\\t\\tthan start of cur, the only oness which satisfy this condition maximum must be taken of them \\n\\t\\tonly, so since deadline wise array is not sorted, a large deadline may appear before a lesser \\n\\t\\tdeadline but we need to consider the lesser one, so we can make a min heap that gives us \\n\\t\\tminimum such deadline of all the deadline we have traversed so far and if this is less than cur \\n\\t\\tstart then we can maximise the profit from it else if it is not lesser than cur start then let it be in \\n\\t\\theap so when cur grows it becomes suitable */\\n        \\n        sort(events.begin(), events.end());\\n        int mx = 0, ans = 0, n = events.size();\\n        \\n        priority_queue<ipair, vector<ipair>, greater<>> pq;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            while(!pq.empty() && pq.top().first < events[i][0])\\n                mx = max(mx, pq.top().second), pq.pop();\\n            \\n            ans = max(ans, mx+events[i][2]);\\n            pq.push({events[i][1], events[i][2]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575910,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "leetcode.com/problems/two-best-non-overlapping-events/discuss/1548982/Hardest-contest-I-met.......-anyone-else/1132821\\nContest start time: 8:00pm IST.\\n\\nSolved Q3 at 8:55 pm IST. Got AS.\\nSolved Q2 at 9:25 pm IST. Got TLE. (Corrected after contest)\\nSolved Q1 at 9:31 pm IST. Got AS.\\nIn between, spent 5 min reading Q4. Realized its kinda backtracking / dp approach so left.\\nContest end time: 9:30pm IST.\\nSo as per contest, I solved 1/4. But I would consider it as 3/4 considering from an interview perspective.\\n\\nFor Q2: I identified it is a BS problem similar to Job Scehduling. Had practised this pattern after bombing previous contest. But my bad. I sorted with respect to event[2]. Careless mistake! So I thought the approach was wrong and did a O(n\\xB2) solution and got TLE. Later, after contest, got it correct.\\n\\nFor Q3: I immediately identified the cache approach (related - Range sum problem. Popular segment tree problems but can be done more optimally using cache) but took time to get the logic of 3 auxillary arrays. O(Q + N) time and O(Q) space, Q = query.\\n\\nFor Q1: After some contests I always started doing Q1s last which actually made me think and solve it faster. Doing in the first will make me think a lot. But in the final few minutes, I get pressurised on time constraint. This brings out the best in me. So could think and code fast. Trying to do it in under 2 min (Right now taking 5 min).\\n\\nLC: 87, 229, 60, 376\\nLC prep: 1 year\\nMocks: 2 months\\nContests: 1 month\\nYOE: 3.3 year, SDE Java"
                    },
                    {
                        "username": "dleyba042",
                        "content": "THIS PROBLEM IS HAAAAAAAARRRRDDDDDDDD"
                    },
                    {
                        "username": "autf",
                        "content": "#ICantRead\n> **at most two** non-overlapping events"
                    }
                ]
            },
            {
                "id": 1974856,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "leetcode.com/problems/two-best-non-overlapping-events/discuss/1548982/Hardest-contest-I-met.......-anyone-else/1132821\\nContest start time: 8:00pm IST.\\n\\nSolved Q3 at 8:55 pm IST. Got AS.\\nSolved Q2 at 9:25 pm IST. Got TLE. (Corrected after contest)\\nSolved Q1 at 9:31 pm IST. Got AS.\\nIn between, spent 5 min reading Q4. Realized its kinda backtracking / dp approach so left.\\nContest end time: 9:30pm IST.\\nSo as per contest, I solved 1/4. But I would consider it as 3/4 considering from an interview perspective.\\n\\nFor Q2: I identified it is a BS problem similar to Job Scehduling. Had practised this pattern after bombing previous contest. But my bad. I sorted with respect to event[2]. Careless mistake! So I thought the approach was wrong and did a O(n\\xB2) solution and got TLE. Later, after contest, got it correct.\\n\\nFor Q3: I immediately identified the cache approach (related - Range sum problem. Popular segment tree problems but can be done more optimally using cache) but took time to get the logic of 3 auxillary arrays. O(Q + N) time and O(Q) space, Q = query.\\n\\nFor Q1: After some contests I always started doing Q1s last which actually made me think and solve it faster. Doing in the first will make me think a lot. But in the final few minutes, I get pressurised on time constraint. This brings out the best in me. So could think and code fast. Trying to do it in under 2 min (Right now taking 5 min).\\n\\nLC: 87, 229, 60, 376\\nLC prep: 1 year\\nMocks: 2 months\\nContests: 1 month\\nYOE: 3.3 year, SDE Java"
                    },
                    {
                        "username": "dleyba042",
                        "content": "THIS PROBLEM IS HAAAAAAAARRRRDDDDDDDD"
                    },
                    {
                        "username": "autf",
                        "content": "#ICantRead\n> **at most two** non-overlapping events"
                    }
                ]
            },
            {
                "id": 1813141,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "leetcode.com/problems/two-best-non-overlapping-events/discuss/1548982/Hardest-contest-I-met.......-anyone-else/1132821\\nContest start time: 8:00pm IST.\\n\\nSolved Q3 at 8:55 pm IST. Got AS.\\nSolved Q2 at 9:25 pm IST. Got TLE. (Corrected after contest)\\nSolved Q1 at 9:31 pm IST. Got AS.\\nIn between, spent 5 min reading Q4. Realized its kinda backtracking / dp approach so left.\\nContest end time: 9:30pm IST.\\nSo as per contest, I solved 1/4. But I would consider it as 3/4 considering from an interview perspective.\\n\\nFor Q2: I identified it is a BS problem similar to Job Scehduling. Had practised this pattern after bombing previous contest. But my bad. I sorted with respect to event[2]. Careless mistake! So I thought the approach was wrong and did a O(n\\xB2) solution and got TLE. Later, after contest, got it correct.\\n\\nFor Q3: I immediately identified the cache approach (related - Range sum problem. Popular segment tree problems but can be done more optimally using cache) but took time to get the logic of 3 auxillary arrays. O(Q + N) time and O(Q) space, Q = query.\\n\\nFor Q1: After some contests I always started doing Q1s last which actually made me think and solve it faster. Doing in the first will make me think a lot. But in the final few minutes, I get pressurised on time constraint. This brings out the best in me. So could think and code fast. Trying to do it in under 2 min (Right now taking 5 min).\\n\\nLC: 87, 229, 60, 376\\nLC prep: 1 year\\nMocks: 2 months\\nContests: 1 month\\nYOE: 3.3 year, SDE Java"
                    },
                    {
                        "username": "dleyba042",
                        "content": "THIS PROBLEM IS HAAAAAAAARRRRDDDDDDDD"
                    },
                    {
                        "username": "autf",
                        "content": "#ICantRead\n> **at most two** non-overlapping events"
                    }
                ]
            }
        ]
    }
]